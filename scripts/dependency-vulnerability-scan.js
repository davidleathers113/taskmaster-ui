/**
 * Enhanced Dependency Vulnerability Scanner for 2025
 * 
 * Implements multi-source vulnerability scanning:
 * - npm audit (built-in)
 * - Snyk API integration
 * - OWASP Dependency Check patterns
 * - RetireJS for frontend libraries
 * - OSV (Open Source Vulnerabilities) database
 */

const { exec } = require('child_process');
const fs = require('fs').promises;
const path = require('path');
const https = require('https');
const { promisify } = require('util');
const execAsync = promisify(exec);

// Configuration
const CONFIG = {
  outputDir: path.join(__dirname, '../test-results/security'),
  vulnerabilityThresholds: {
    critical: 0,
    high: 3,      // Allow up to 3 high vulnerabilities
    medium: 10,   // Allow up to 10 medium vulnerabilities
    low: -1       // No limit on low vulnerabilities
  },
  scanners: {
    npm: true,
    snyk: process.env.SNYK_TOKEN ? true : false,
    osv: true,
    retirejs: true
  }
};

class DependencyVulnerabilityScanner {
  constructor() {
    this.results = {
      npm: null,
      snyk: null,
      osv: null,
      retirejs: null,
      summary: {
        total: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      }
    };
    this.startTime = Date.now();
  }

  async run() {
    console.log('üîç Starting Enhanced Dependency Vulnerability Scan...\n');
    
    try {
      // Ensure output directory exists
      await this.ensureOutputDirectory();
      
      // Run all scanners in parallel
      const scanPromises = [];
      
      if (CONFIG.scanners.npm) {
        scanPromises.push(this.runNpmAudit());
      }
      
      if (CONFIG.scanners.snyk) {
        scanPromises.push(this.runSnykTest());
      }
      
      if (CONFIG.scanners.osv) {
        scanPromises.push(this.runOSVScan());
      }
      
      if (CONFIG.scanners.retirejs) {
        scanPromises.push(this.runRetireJS());
      }
      
      // Wait for all scans to complete
      await Promise.all(scanPromises);
      
      // Aggregate results
      this.aggregateResults();
      
      // Generate reports
      await this.generateReports();
      
      // Check against thresholds
      const passed = this.checkThresholds();
      
      // Print summary
      this.printSummary();
      
      return passed;
    } catch (error) {
      console.error('‚ùå Vulnerability scan failed:', error.message);
      process.exit(1);
    }
  }

  async ensureOutputDirectory() {
    await fs.mkdir(CONFIG.outputDir, { recursive: true });
  }

  /**
   * Run npm audit
   */
  async runNpmAudit() {
    console.log('üì¶ Running npm audit...');
    
    try {
      const { stdout } = await execAsync('npm audit --json', {
        maxBuffer: 10 * 1024 * 1024 // 10MB buffer
      });
      
      const auditResult = JSON.parse(stdout);
      this.results.npm = this.parseNpmAudit(auditResult);
      
      console.log('‚úÖ npm audit completed');
    } catch (error) {
      // npm audit returns non-zero exit code if vulnerabilities found
      if (error.stdout) {
        try {
          const auditResult = JSON.parse(error.stdout);
          this.results.npm = this.parseNpmAudit(auditResult);
          console.log('‚úÖ npm audit completed (vulnerabilities found)');
        } catch (parseError) {
          console.error('‚ùå npm audit failed:', parseError.message);
        }
      } else {
        console.error('‚ùå npm audit failed:', error.message);
      }
    }
  }

  parseNpmAudit(auditResult) {
    const vulnerabilities = [];
    
    if (auditResult.vulnerabilities) {
      Object.entries(auditResult.vulnerabilities).forEach(([pkg, data]) => {
        data.via.forEach(via => {
          if (typeof via === 'object') {
            vulnerabilities.push({
              package: pkg,
              severity: via.severity,
              title: via.title,
              cve: via.cve,
              url: via.url,
              range: data.range,
              fixAvailable: data.fixAvailable
            });
          }
        });
      });
    }
    
    return {
      metadata: auditResult.metadata || {},
      vulnerabilities
    };
  }

  /**
   * Run Snyk test (requires SNYK_TOKEN environment variable)
   */
  async runSnykTest() {
    console.log('üîí Running Snyk test...');
    
    if (!process.env.SNYK_TOKEN) {
      console.log('‚ö†Ô∏è  Snyk test skipped (SNYK_TOKEN not set)');
      return;
    }
    
    try {
      const { stdout } = await execAsync('npx snyk test --json', {
        maxBuffer: 10 * 1024 * 1024,
        env: { ...process.env }
      });
      
      const snykResult = JSON.parse(stdout);
      this.results.snyk = this.parseSnykResults(snykResult);
      
      console.log('‚úÖ Snyk test completed');
    } catch (error) {
      if (error.stdout) {
        try {
          const snykResult = JSON.parse(error.stdout);
          this.results.snyk = this.parseSnykResults(snykResult);
          console.log('‚úÖ Snyk test completed (vulnerabilities found)');
        } catch (parseError) {
          console.error('‚ùå Snyk test failed:', parseError.message);
        }
      } else {
        console.error('‚ùå Snyk test failed:', error.message);
      }
    }
  }

  parseSnykResults(snykResult) {
    const vulnerabilities = [];
    
    if (snykResult.vulnerabilities) {
      snykResult.vulnerabilities.forEach(vuln => {
        vulnerabilities.push({
          package: vuln.packageName,
          version: vuln.version,
          severity: vuln.severity.toLowerCase(),
          title: vuln.title,
          cve: vuln.identifiers?.CVE?.[0],
          cvssScore: vuln.cvssScore,
          exploitMaturity: vuln.exploit,
          fixedIn: vuln.fixedIn,
          isUpgradable: vuln.isUpgradable,
          isPatchable: vuln.isPatchable
        });
      });
    }
    
    return {
      vulnerabilities,
      summary: snykResult.summary || {}
    };
  }

  /**
   * Run OSV (Open Source Vulnerabilities) scan
   */
  async runOSVScan() {
    console.log('üåê Running OSV scan...');
    
    try {
      // Read package-lock.json
      const packageLockPath = path.join(process.cwd(), 'package-lock.json');
      const packageLock = JSON.parse(await fs.readFile(packageLockPath, 'utf8'));
      
      // Extract all dependencies
      const packages = this.extractPackagesFromLock(packageLock);
      
      // Query OSV API in batches
      const osvResults = await this.queryOSVDatabase(packages);
      
      this.results.osv = {
        vulnerabilities: osvResults,
        scannedPackages: packages.length
      };
      
      console.log('‚úÖ OSV scan completed');
    } catch (error) {
      console.error('‚ùå OSV scan failed:', error.message);
    }
  }

  extractPackagesFromLock(packageLock) {
    const packages = [];
    
    const extractDeps = (deps) => {
      Object.entries(deps || {}).forEach(([name, data]) => {
        if (data.version) {
          packages.push({
            name,
            version: data.version,
            ecosystem: 'npm'
          });
        }
        if (data.dependencies) {
          extractDeps(data.dependencies);
        }
      });
    };
    
    extractDeps(packageLock.dependencies);
    return packages;
  }

  async queryOSVDatabase(packages) {
    const vulnerabilities = [];
    const batchSize = 100;
    
    for (let i = 0; i < packages.length; i += batchSize) {
      const batch = packages.slice(i, i + batchSize);
      
      try {
        const response = await this.makeOSVRequest(batch);
        if (response.vulns) {
          response.vulns.forEach(vuln => {
            vulnerabilities.push({
              package: vuln.package.name,
              version: vuln.package.version,
              id: vuln.vulns[0].id,
              summary: vuln.vulns[0].summary,
              severity: this.mapOSVSeverity(vuln.vulns[0].database_specific),
              aliases: vuln.vulns[0].aliases
            });
          });
        }
      } catch (error) {
        console.error(`OSV batch query failed: ${error.message}`);
      }
    }
    
    return vulnerabilities;
  }

  makeOSVRequest(packages) {
    return new Promise((resolve, reject) => {
      const data = JSON.stringify({
        packages: packages
      });
      
      const options = {
        hostname: 'api.osv.dev',
        path: '/v1/querybatch',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': data.length
        }
      };
      
      const req = https.request(options, (res) => {
        let body = '';
        res.on('data', (chunk) => { body += chunk; });
        res.on('end', () => {
          try {
            resolve(JSON.parse(body));
          } catch (error) {
            reject(error);
          }
        });
      });
      
      req.on('error', reject);
      req.write(data);
      req.end();
    });
  }

  mapOSVSeverity(databaseSpecific) {
    // Map CVSS scores to severity levels
    const cvss = databaseSpecific?.cvss_v3?.base_score || 0;
    if (cvss >= 9.0) return 'critical';
    if (cvss >= 7.0) return 'high';
    if (cvss >= 4.0) return 'medium';
    return 'low';
  }

  /**
   * Run RetireJS for frontend library scanning
   */
  async runRetireJS() {
    console.log('üåê Running RetireJS scan...');
    
    try {
      const { stdout } = await execAsync('npx retire --outputformat json', {
        maxBuffer: 10 * 1024 * 1024
      });
      
      const retireResults = JSON.parse(stdout || '[]');
      this.results.retirejs = this.parseRetireJSResults(retireResults);
      
      console.log('‚úÖ RetireJS scan completed');
    } catch (error) {
      console.error('‚ùå RetireJS scan failed:', error.message);
      this.results.retirejs = { vulnerabilities: [] };
    }
  }

  parseRetireJSResults(results) {
    const vulnerabilities = [];
    
    results.forEach(result => {
      if (result.vulnerabilities) {
        result.vulnerabilities.forEach(vuln => {
          vulnerabilities.push({
            file: result.file,
            component: result.results?.[0]?.component,
            version: result.results?.[0]?.version,
            severity: vuln.severity || 'medium',
            summary: vuln.summary,
            cve: vuln.identifiers?.cve?.[0]
          });
        });
      }
    });
    
    return { vulnerabilities };
  }

  /**
   * Aggregate results from all scanners
   */
  aggregateResults() {
    // Reset summary
    this.results.summary = {
      total: 0,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    };
    
    // Aggregate vulnerabilities from all sources
    const allVulnerabilities = [];
    
    ['npm', 'snyk', 'osv', 'retirejs'].forEach(scanner => {
      if (this.results[scanner]?.vulnerabilities) {
        this.results[scanner].vulnerabilities.forEach(vuln => {
          const severity = vuln.severity?.toLowerCase() || 'unknown';
          if (this.results.summary[severity] !== undefined) {
            this.results.summary[severity]++;
            this.results.summary.total++;
          }
          
          allVulnerabilities.push({
            ...vuln,
            source: scanner
          });
        });
      }
    });
    
    // Deduplicate vulnerabilities
    this.results.aggregated = this.deduplicateVulnerabilities(allVulnerabilities);
  }

  deduplicateVulnerabilities(vulnerabilities) {
    const seen = new Map();
    
    vulnerabilities.forEach(vuln => {
      const key = `${vuln.package}-${vuln.cve || vuln.title}`;
      if (!seen.has(key) || this.getSeverityScore(vuln.severity) > this.getSeverityScore(seen.get(key).severity)) {
        seen.set(key, vuln);
      }
    });
    
    return Array.from(seen.values());
  }

  getSeverityScore(severity) {
    const scores = { critical: 4, high: 3, medium: 2, low: 1, unknown: 0 };
    return scores[severity?.toLowerCase()] || 0;
  }

  /**
   * Generate comprehensive reports
   */
  async generateReports() {
    // Save JSON report
    const jsonPath = path.join(CONFIG.outputDir, 'dependency-vulnerabilities.json');
    await fs.writeFile(jsonPath, JSON.stringify(this.results, null, 2));
    
    // Generate HTML report
    const htmlPath = path.join(CONFIG.outputDir, 'dependency-vulnerabilities.html');
    const htmlContent = this.generateHTMLReport();
    await fs.writeFile(htmlPath, htmlContent);
    
    // Generate SBOM (Software Bill of Materials)
    await this.generateSBOM();
    
    console.log(`\nüìÑ Reports generated:`);
    console.log(`   - JSON: ${jsonPath}`);
    console.log(`   - HTML: ${htmlPath}`);
    console.log(`   - SBOM: ${path.join(CONFIG.outputDir, 'sbom.json')}`);
  }

  generateHTMLReport() {
    const { summary, aggregated } = this.results;
    
    return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dependency Vulnerability Report</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .header {
      background: #1e3a8a;
      color: white;
      padding: 30px;
      border-radius: 8px;
      margin-bottom: 30px;
    }
    .summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }
    .metric {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .metric-value {
      font-size: 36px;
      font-weight: bold;
      margin: 10px 0;
    }
    .metric-label {
      color: #666;
      text-transform: uppercase;
      font-size: 14px;
    }
    .critical { color: #dc2626; }
    .high { color: #ea580c; }
    .medium { color: #f59e0b; }
    .low { color: #3b82f6; }
    .vulnerability {
      background: white;
      padding: 20px;
      margin-bottom: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-left: 4px solid;
    }
    .vulnerability.critical { border-left-color: #dc2626; }
    .vulnerability.high { border-left-color: #ea580c; }
    .vulnerability.medium { border-left-color: #f59e0b; }
    .vulnerability.low { border-left-color: #3b82f6; }
    .vuln-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .vuln-title {
      font-weight: bold;
      font-size: 18px;
    }
    .vuln-details {
      color: #666;
      margin: 10px 0;
    }
    .fix-available {
      background: #10b981;
      color: white;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
    .sources {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .source-badge {
      background: #e5e7eb;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üîç Dependency Vulnerability Report</h1>
    <p>Generated on ${new Date().toLocaleString()}</p>
    <p>Scan duration: ${((Date.now() - this.startTime) / 1000).toFixed(2)}s</p>
  </div>

  <div class="summary">
    <div class="metric">
      <div class="metric-label">Total Vulnerabilities</div>
      <div class="metric-value">${summary.total}</div>
    </div>
    <div class="metric">
      <div class="metric-label">Critical</div>
      <div class="metric-value critical">${summary.critical}</div>
    </div>
    <div class="metric">
      <div class="metric-label">High</div>
      <div class="metric-value high">${summary.high}</div>
    </div>
    <div class="metric">
      <div class="metric-label">Medium</div>
      <div class="metric-value medium">${summary.medium}</div>
    </div>
    <div class="metric">
      <div class="metric-label">Low</div>
      <div class="metric-value low">${summary.low}</div>
    </div>
  </div>

  <h2>Vulnerability Details</h2>
  ${this.generateVulnerabilityListHTML(aggregated)}

  <div class="footer" style="margin-top: 50px; text-align: center; color: #666;">
    <p>Scanned with: npm audit, ${this.results.snyk ? 'Snyk, ' : ''}OSV Database, RetireJS</p>
  </div>
</body>
</html>
    `;
  }

  generateVulnerabilityListHTML(vulnerabilities) {
    if (!vulnerabilities || vulnerabilities.length === 0) {
      return '<p>No vulnerabilities found!</p>';
    }
    
    // Sort by severity
    const sorted = vulnerabilities.sort((a, b) => 
      this.getSeverityScore(b.severity) - this.getSeverityScore(a.severity)
    );
    
    return sorted.map(vuln => `
      <div class="vulnerability ${vuln.severity}">
        <div class="vuln-header">
          <div class="vuln-title">${vuln.package}${vuln.version ? `@${vuln.version}` : ''}</div>
          <div>
            <span class="${vuln.severity}">${vuln.severity.toUpperCase()}</span>
            ${vuln.fixAvailable ? '<span class="fix-available">Fix Available</span>' : ''}
          </div>
        </div>
        <div class="vuln-details">
          <div>${vuln.title || vuln.summary || 'No description available'}</div>
          ${vuln.cve ? `<div>CVE: ${vuln.cve}</div>` : ''}
          ${vuln.cvssScore ? `<div>CVSS Score: ${vuln.cvssScore}</div>` : ''}
        </div>
        <div class="sources">
          <span class="source-badge">Source: ${vuln.source}</span>
        </div>
      </div>
    `).join('');
  }

  /**
   * Generate SBOM (Software Bill of Materials)
   */
  async generateSBOM() {
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    const packageLockPath = path.join(process.cwd(), 'package-lock.json');
    
    const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf8'));
    const packageLock = JSON.parse(await fs.readFile(packageLockPath, 'utf8'));
    
    const sbom = {
      bomFormat: 'CycloneDX',
      specVersion: '1.4',
      version: 1,
      metadata: {
        timestamp: new Date().toISOString(),
        tools: [
          { name: 'dependency-vulnerability-scan', version: '1.0.0' }
        ],
        component: {
          type: 'application',
          name: packageJson.name,
          version: packageJson.version
        }
      },
      components: this.extractComponentsForSBOM(packageLock),
      vulnerabilities: this.results.aggregated?.map(vuln => ({
        id: vuln.cve || vuln.id || vuln.title,
        source: {
          name: vuln.source,
          url: vuln.url
        },
        ratings: [{
          severity: vuln.severity,
          score: vuln.cvssScore
        }],
        affects: [{
          ref: `pkg:npm/${vuln.package}@${vuln.version}`
        }]
      })) || []
    };
    
    const sbomPath = path.join(CONFIG.outputDir, 'sbom.json');
    await fs.writeFile(sbomPath, JSON.stringify(sbom, null, 2));
  }

  extractComponentsForSBOM(packageLock) {
    const components = [];
    
    const extractDeps = (deps, scope = 'required') => {
      Object.entries(deps || {}).forEach(([name, data]) => {
        components.push({
          type: 'library',
          'bom-ref': `pkg:npm/${name}@${data.version}`,
          name,
          version: data.version,
          scope,
          purl: `pkg:npm/${name}@${data.version}`,
          properties: [
            { name: 'resolved', value: data.resolved }
          ]
        });
        
        if (data.dependencies) {
          extractDeps(data.dependencies, scope);
        }
      });
    };
    
    extractDeps(packageLock.dependencies, 'required');
    extractDeps(packageLock.devDependencies, 'optional');
    
    return components;
  }

  /**
   * Check against configured thresholds
   */
  checkThresholds() {
    const { summary } = this.results;
    let passed = true;
    
    console.log('\nüéØ Checking vulnerability thresholds:');
    
    for (const [severity, count] of Object.entries(summary)) {
      if (severity === 'total') continue;
      
      const threshold = CONFIG.vulnerabilityThresholds[severity];
      if (threshold !== undefined && threshold !== -1) {
        const status = count <= threshold ? '‚úÖ' : '‚ùå';
        console.log(`   ${status} ${severity.toUpperCase()}: ${count} found (threshold: ${threshold})`);
        
        if (count > threshold) {
          passed = false;
        }
      }
    }
    
    return passed;
  }

  /**
   * Print summary to console
   */
  printSummary() {
    const { summary } = this.results;
    
    console.log('\nüìä Dependency Vulnerability Summary:');
    console.log('‚îÅ'.repeat(50));
    console.log(`   Total Vulnerabilities: ${summary.total}`);
    console.log(`   Critical: ${summary.critical}`);
    console.log(`   High: ${summary.high}`);
    console.log(`   Medium: ${summary.medium}`);
    console.log(`   Low: ${summary.low}`);
    console.log('‚îÅ'.repeat(50));
    
    // Show scanners used
    console.log('\nüîç Scanners used:');
    ['npm', 'snyk', 'osv', 'retirejs'].forEach(scanner => {
      if (this.results[scanner]) {
        const vulnCount = this.results[scanner].vulnerabilities?.length || 0;
        console.log(`   - ${scanner}: ${vulnCount} vulnerabilities found`);
      }
    });
  }
}

// Main execution
async function main() {
  const scanner = new DependencyVulnerabilityScanner();
  const passed = await scanner.run();
  
  if (!passed) {
    console.log('\n‚ùå Dependency vulnerability scan failed! Fix the issues above before proceeding.');
    process.exit(1);
  } else {
    console.log('\n‚úÖ Dependency vulnerability scan passed!');
    process.exit(0);
  }
}

// Run if called directly
if (require.main === module) {
  main().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

module.exports = { DependencyVulnerabilityScanner, CONFIG };